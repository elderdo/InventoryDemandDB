#!/usr/bin/ksh
#   $Author:   zf297a  $
# $Revision:   1.13.1.1.1.2  $
#     $Date:   04 Feb 2009 15:14:32  $
# $Workfile:   main_amd_loader.ksh  $
#
USAGE="usage: ${0##*/} [-m] [-d] [-g] [-h] [-l logHomedir] [-s srcHomedir] [-b binHomedir]
[-i libHome ] [-c commandFile]  [-n] [-x] [-t 999] [-a REPLICATE] [-w REPLICATE_WESM]
[-e AMDLOAD1] [-f AMDLOAD2] [-u] [-o] [-q] [-v] [-r] [-k] [startStep endStep ]\n\n
\twhere\n
\t-m will enable a selection menu\n
\t-c commandFile allows for a file of step names to be processed.\n
\t-d enables debug\n
\t-n signals not to use the tee command\n
\t-x show runEnqueue debug errors\n
\t-t 999\tset the SPARE_PARTS_NEW_DATA_THRESHOLD for data\n
\t\twhere 999 is the min # or rows for tmp_amd_spare_parts.\n
\t\tThe default is 99999\n
\t-a REPLICATE where REPLICATE is the file containing\n
\t\tthe sql for the ReplicateGold step\n
\t-w REPLICATE_WESM where REPLICATE_WESM is the file containing\n
\t\tthe sql for the ReplicateWesm step\n
\t-e AMDLOAD1\twhere AMDLOAD1 is the file for step AmdLoad1\n
\t-f AMDLOAD2\twhere AMDLOAD2 is the file for step AmdLoad2\n
\t-g set DO_SQLLDR_FOR_SPO to N\n
\t-h for step sendPartInfo send all parts\n
\t-j abort job for all errors or warnings\n
\t-u\tdo not report updateSpo errors\n
\t-o\tturn off notification via email\n
\t-q\tquit sending all email and pager notifications\n
\t-v\tSend notification that the Bssm Flat Files have been created\n
\t\tdefault is to NOT send notification\n
\t-r\tsend remsh output to stdout via a tee\n
\t\tdefault is to send stdout for remsh to a log file\n
\t-k\tdo not send data to spo via sqlldr
\tstartStep can be from 1 to 27\n
\t\tdefault is 1\n
\tendStep must be >= startStep & <= 27\n
\t\tdefault is 27"

if [[ "$#" -gt "0" && "$1" = "?" ]] ; then
	print $USAGE
	exit 0
fi

# import common definitions
. $UNVAR/apps/CRON/AMD/lib/amdconfig.ksh

while getopts :kghjrqouvxnmdl:s:b:i:c:t:a:e:f:w: arguments
do
	case $arguments in
	  a) REPLICATE=${OPTARG};;
	  w) REPLICATE_WESM=${OPTARG};;
	  e) AMDLOAD1=${OPTARG};;
	  f) AMDLOAD2=${OPTARG};;
	  g) export DO_SQLLDR_FOR_SPO=N;;
	  h) export SEND_ALL_PARTS=Y;;
	  j) export ABORT_FOR_WARNINGS=Y;;
	  t) SPARE_PARTS_NEW_DATA_THRESHOLD=${OPTARG};;
	  l) LOG_HOME=${OPTARG};;
	  s) SRC_HOME=${OPTARG};;
	  b) BIN_HOME=${OPTARG};;
	  i) LIB_HOME=${OPTARG};;
	  c) COMMAND_FILE=${OPTARG};;
	  m) AMD_USE_MENU=Y;;
	  k) export DO_SQLLDR_FOR_SPO=N;;
	  n) NO_TEE=Y;;
	  x) showRunEnqueueDebug=Y;;
	  o) AMD_ERROR_NOTIFICATION=N
	     AMD_NOTIFY=N;;
	  q) AMD_NOTIFY=N;;
	  v) AMD_BSSMFLATFILE_NOTIFY=Y;;
	  u) updateSpoCheckForErrors=N;;
	  r) REMOTE_TEE=Y ;;
	  w) ESCM_HOME=${OPTARG} ;;
	  d) debug=Y
	     set -x ;;
	  *) print -u2 "$USAGE"
	     exit 4;;
	esac
done
# OPTIND now contains a numnber representing the identity of the first
# nonswitch argument on the command line.  For example, if the first
# nonswitch argume on the command line is positional parameter $<F5>,
# OPTIND hold the number 5.
((positions_occupied_by_switches = OPTIND - 1))
# Use a shift statement to eliminate all switches and switch arguments
# from the set of positional parameters.
shift $positions_occupied_by_switches
# After the shift, the set of positional parameter contains all
# remaining nonswitch arguments.

export TimeStamp=`date $DateStr | sed "s/:/_/g"`

export AMD_CUR_STEP=1
export AMD_LOADER_LOG=$LOG_HOME/${TimeStamp}_99_amd_loader.log

hostname=`uname -n`

abort() {
	errmsg="AMD Load Failed"
	print "$errmsg $1"
	print -u2 "$errmsg $1"
	if [[ "${AMD_ERROR_NOTIFICATION:-Y}" = "Y" ]] ; then
		$LIB_HOME/notify.ksh -s "$errmsg on $hostname" \
			-m " $errmsg on $hostname. $1" 
		$LIB_HOME/sendPage.ksh  "$errmsg $1"		
	fi
	exit 4
}

function execSteps {

		typeset -Z3 array
		cnt=0
		for x in `echo $* | awk -f $BIN_HOME/awkNumInput.txt`
		do
			let cnt=cnt+1
			array[$cnt]=$x
		done

		# set $* to the data in the work array
		set -s ${array[*]}

		# empty work array
		i=1
		while (( $i <= $cnt ))
		do
			array[$i]=
			let i=i+1
		done

		for x in $*
		do
			((x=x)) # make sure x is a number with no leading zerso
			AMD_CUR_STEP=`printf "%02d" $x`
			if [[ "${steps[$x]}" != "exit" ]] ; then
				print "${steps[$x]} started at `date`"
			fi
			if [[ "${steps[$x]}" = "amd2spo" || "${steps[$x]}" = "trimmedPostProcessing" ]] ; then
				${steps[$x]} &
			else
				${steps[$x]} 
			fi
			print "${steps[$x]} ended at `date`"
		done

}

function mainMenu {
	PS3="select n or n-n (range) ..... for multiple steps [hit return to re-display menu]? "
	select item in ${steps[*]}
	do
		set  $REPLY
		execSteps $*
	done
}

function main
{
		
	echo "main started at `date`" 
	let curStep=${1:-1}
	let endStep=${2:-${#steps[*]}}
	if (( $curStep > $endStep ))
	then
		print -u2 "start step must be <= end step"
		exit 4
	fi
	execSteps ${curStep}-${endStep}
	echo "main ended at `date`" 
		
}


StartJob()
{
	$LIB_HOME/execSqlplus.ksh $0 2>> $AMD_LOADER_LOG
	if (($?!=0)) ; then
		abort "$0 error."	
	fi
}

cleanTraceTables()
{
	$LIB_HOME/execSqlplus.ksh $0 2>> $AMD_LOADER_LOG
	if (($?!=0)) ; then
		abort "$0 error."
	fi
}

replicateGold()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/replicateGold.ksh > $LOG_NAME 2>&1
	if (($?!=0)) ; then
		abort "$0 error."
	fi
}

replicateWesm()
{
   LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
   $LIB_HOME/replicateWesm.ksh > $LOG_NAME 2>&1
   if (($?!=0)) ; then
	abort "$0 error."	
   fi
}

processL67()
{
   LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
   $LIB_HOME/amd_LoadFtpFile.ksh L67 >$LOG_NAME 2>&1
   RC=$?
   $LIB_HOME/checkforerrors.ksh $LOG_NAME
   if (($?!=0 || $RC!=0)) ; then
	   print "Warning: $0 ended without a return code of zero"
   fi
}

processGDSS()
{
   LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
   $LIB_HOME/amd_LoadFtpFile.ksh GDSS >$LOG_NAME 2>&1
   RC=$?
   $LIB_HOME/checkforerrors.ksh $LOG_NAME
   if (($?!=0 || $RC!=0)) ; then
	   print "Warning: $0 ended without a return code of zero"
   fi
}


truncateAmd()
{
	$LIB_HOME/execSqlplus.ksh $0 2>> $AMD_LOADER_LOG
	if (($?!=0)) ; then
		abort "$0 error."
	fi
}

function loadDmndFrcstConsumables {
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	if [[ "$debug" = "Y" ]] ; then
		ksh -x $LIB_HOME/loadDmndFrcstConsumables.ksh >$LOG_NAME 2>&1
		RC=$?
	else
		$LIB_HOME/loadDmndFrcstConsumables.ksh >$LOG_NAME 2>&1
		RC=$?
	fi
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
   	if (($?!=0 || $RC!=0)) ; then
	   print "Warning: $0 ended without a return code of zero"
   	fi
}

function dmndFrcstConsumablesDiff {
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/${0}.ksh >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
   	if (($?!=0 || $RC!=0)) ; then
	   abort "$0 error."
   	fi
}

	
AmdLoad1()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/AmdLoad1.ksh > $LOG_NAME 2>&1
   	if (($?!=0)) ; then
	   abort "$0 error."
   	fi
}
		

plannersDiff()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/plannersDiff.ksh >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
   	if (($?!=0 || $RC!=0)) ; then
	   abort "$0 error."
   	fi
}

sparePartDiff()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"

	param="${SPARE_PARTS_NEW_DATA_THRESHOLD:+-s $SPARE_PARTS_NEW_DATA_THRESHOLD}"

	$LIB_HOME/sparePartDiff.ksh $param >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
   	if (($?!=0 || $RC!=0)) ; then
	   	abort "$0 error."
   	fi
}

AmdLoad2()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/AmdLoad2.ksh > $LOG_NAME 2>&1
	if (($?!=0)) ; then
	   	abort "$0 error."
	fi
}
			
invDiff()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/invDiff.ksh >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
	if (($?!=0 || $RC!=0)) ; then
	   	abort "$0 error."
	fi
}


partFactorsDiff()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/partFactorsDiff.ksh >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
	if (($?!=0 || $RC!=0)) ; then
	   abort "$0 error."
   	fi
}

partLocForecastsDiff()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/partLocForecastsDiff.ksh >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
	if (($?!=0 || $RC!=0)) ; then
	   abort "$0 error."
   	fi
}


locPartLeadtimeDiff()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/locPartLeadtimeDiff.ksh >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
	if (($?!=0 || $RC!=0)) ; then
	   abort "$0 error."
   	fi
}



function AmdLoad3
{
	$LIB_HOME/execSqlplus.ksh $0 2>> $AMD_LOADER_LOG
	if (($?!=0)) ; then
		abort "$0 error."
	fi
}

if [[ -a $DATA_HOME/dynam.ksh ]] ; then
	. $DATA_HOME/dynam.ksh
else
function DynamSql
{
	return
}
fi

if [[ -a $DATA_HOME/dynamPostProcess.ksh ]] ; then
	. $DATA_HOME/dynamPostProcess.ksh
else
function DynamSqlPostProcess
{
	return
}
fi

function sendPartInfo
{
	if [[ "${SEND_ALL_PARTS:-N}" = "Y" ]] ; then
		params="-a"
		print "sending all parts"
	fi

	if [[ "$REMOTE_TEE" = "N" ]] ; then
		params="$params -t"
	fi

	if [[ "$showRunEnqueueDebug" = "Y" ]] ; then
		params="$params -e"
	fi
	$LIB_HOME/sendPartInfo.ksh $params
	if (($?!=0)) ; then
		abort "$0 error."
	fi
}

function loadZeroTsls
{
	$LIB_HOME/execSqlplus.ksh $0 2>> $AMD_LOADER_LOG
	if (($?!=0)) ; then
		abort "$0 error."
	fi
}

function checkForDeletedSpoPrimeParts
{
	$LIB_HOME/execSqlplus.ksh $0 2>> $AMD_LOADER_LOG
	if (($?!=0)) ; then
		abort "$0 error."	
	fi
}

locPartOverrideDiff()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/locPartOverrideDiff.ksh >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
   	if (($?!=0 || $RC!=0)) ; then
	   abort "$0 error."
   	fi
	grep -c "rows with overriden quantities=" $LOG_NAME
	if (($?==0)) ; then
		hostname=`uname -n`
		MSG="AMD Load of LpOverride data on $hostname had quantities that were too big"
		$LIB_HOME/execSqlplus.ksh  sendWarningMsg \
	       	"$MSG for step $0${AMD_CUR_STEP:+ / AMD_STEP=$AMD_CUR_STEP} had quantities too large" 
	fi
}

loadRmads()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/amd_LoadRmads.ksh ${TimeStamp} >$LOG_NAME 2>&1
	RC=$?
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
   	if (($?!=0 || $RC!=0)) ; then
	   abort "$0 error."
   	fi
}

bssmFlatFiles()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/amd_bssmFlatFiles.ksh ${TimeStamp} >$LOG_NAME 2>&1
	$LIB_HOME/checkforerrors.ksh $LOG_NAME
   	if (($?!=0)) ; then
	   abort "$0 error."
   	fi
	if [ $AMD_BSSMFLATFILE_NOTIFY = Y ]
	then
		$LIB_HOME/notify.ksh -a bssmNotify.txt  -s "Bssm Flat Files have been created on $hostname" -m "$0 Bssm Flat Files have been created on $hostname." $LOG_NAME
	fi
}

amd2spo()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	if [[ "$REMOTE_TEE" = "N" ]] ; then
		$LIB_HOME/execRemoteShell.ksh amd2spo.ksh > $LOG_NAME 
		RC=$?
	else
		$LIB_HOME/execRemoteShell.ksh amd2spo.ksh | tee $LOG_NAME
		RC=$?
	fi
	if [[ "$showRunEnqueueDebug" = "Y" ]] ; then
		$LIB_HOME/checkforerrors.ksh $LOG_NAME
   		if (($?!=0 || $RC!=0)) ; then
		   abort "$0 error 1."
   		fi
	else
		# filter out debug errors from amd2spo
		sed '/ESCMC17V2/d' $LOG_NAME > /tmp/amd2spo.log
		$LIB_HOME/checkforerrors.ksh /tmp/amd2spo.log
   		if (($?!=0 || $RC!=0)) ; then
		   abort "$0 error 2."
   		fi
	fi
	grep "enqueued successfully" $LOG_NAME  # make sure that at least 1 file was sent
   	if (($?!=0)) ; then
		print -u2  "AMD Loader Failed \@ $TimeStamp"		
		if [ $AMD_ERROR_NOTIFICATION = Y ]
		then
			$LIB_HOME/sendPage.ksh  "AMD Loader Failed \@ $TimeStamp"		
			# notify.ksh uses data/addresses.txt for the list of email recipients
			# -s is the subject
			# -m is for the message body
			$LIB_HOME/notify.ksh -s "AMD Load Failed on $hostname" -m "$0 Failed for step amd2spo on $hostname. No records enqueued" $LOG_NAME
		fi
		exit 4
	fi
	amdspoCounts
}

archive() 
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"
	$LIB_HOME/archive.ksh >> $LOG_NAME 2>&1
	if (($?!=0)) ; then
		abort "$0 error."
	fi
	if [[ ! -s $LOG_NAME ]] ; then
		rm -f $LOG_NAME
	fi
}

EndJob()
{
	$LIB_HOME/execSqlplus.ksh $0 2>> $AMD_LOADER_LOG
	if (($?!=0)) ; then
		abort "$0 error."
	fi
	if [[ "$AMD_NOTIFY" = "Y" ]] ; then
		awk 'sub("$", "\r")' $AMD_LOADER_LOG > /tmp/${TimeStamp}_${AMD_CUR_STEP}_amd_loader.log 
		$LIB_HOME/sendWarnings.ksh -a endJobNotify.txt
		WRC=$?
		RC=`$LIB_HOME/oraCheck.ksh "select count(*) from amd_load_warnings where last_update_dt > amd_batch_pkg.getLastStartTime"`
		if [[ $RC = 0 || $WRC != 0 ]] ; then 
			$LIB_HOME/notify.ksh -a endJobNotify.txt \
			-s "AMD Load Finished on $hostname" \
			-m "$0 finished on $hostname." \
			/tmp/${TimeStamp}_${AMD_CUR_STEP}_amd_loader.log 
		fi
	else
		print "AMD Load Finished on $hostname"
	fi
}

amdspoCounts()
{
	$LIB_HOME/execSqlplus.ksh $0 2>> $AMD_LOADER_LOG
	if (($?!=0)) ; then
		abort "$0 error."
	fi
}


updateSpo()
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${0}.log"

	if [[ "$REMOTE_TEE" = "N" ]] ; then
		$LIB_HOME/execRemoteShell.ksh updateSpo.ksh 2>&1 $LOG_NAME
		RC=$?
	else
		$LIB_HOME/execRemoteShell.ksh updateSpo.ksh | tee $LOG_NAME
		RC=$?
	fi

	if (($RC!=0)) ; then
		abort "$0 error"
	fi

	if [[ "${updateSpoCheckForErrors:-Y}" = "Y" ]] ; then
		$LIB_HOME/checkforerrors.ksh $LOG_NAME
		if (($?!=0)) ; then
		   abort "$0 error."
		fi
	fi
}

header()
{
	echo "********************************************************"; 
	echo "* Start Date & Time: `date`";
	echo "********************************************************";
	echo "Log time in ALL filenames will be: ${TimeStamp}.";
	
}



footer()
{
	echo "";
	echo "********************************************************";
	echo "* End Date & Time: `date`";
	echo "********************************************************"
}

function checkStepName {
	cnt=1
	while (( $cnt <= ${#steps[*]} ))
	do
		if [[ "${steps[$cnt]}" = "$1" ]] ; then
			return
		fi
		let cnt=cnt+1
	done
	# it is ok to execute external scripts via command file
	if [[ -x $1 ]] ; then
		print  "executing script $1"
	else
		print -u2 "$1 is an invalid step"
	fi
   	abort "$0 error."
}

function sendXmlTran
{
	LOG_NAME="$LOG_HOME/${TimeStamp}_${AMD_CUR_STEP}_${1}.log"

	if [[ "$REMOTE_TEE" = "N" ]] ; then
		$LIB_HOME/execRemoteShell.ksh send${1}.ksh >> $LOG_NAME
		RC=$?
	else
		$LIB_HOME/execRemoteShell.ksh send${1}.ksh | tee -a $LOG_NAME
		RC=$?
	fi

	if [[ "$showRunEnqueueDebug" = "Y" ]] ; then
		$LIB_HOME/checkforerrors.ksh $LOG_NAME
   		if (($?!=0 || $RC!=0)) ; then
		   abort "$0 error."
   		fi
	else
		# filter out debug errors from send${1}
		sed '/ESCMC17V2/d' $LOG_NAME > /tmp/send${1}.log
		$LIB_HOME/checkforerrors.ksh /tmp/send${1}.log
   		if (($?!=0 || $RC!=0)) ; then
		   abort "$0 error."
   		fi
	fi

	grep "enqueued successfully" $LOG_NAME  
	if  (($? != 0 )) 
	then
		if [[ "${ABORT_FOR_WARNINGS:-N}" = "Y" ]] ; then
			MSG_TYPE="Failed"
		else
			MSG_TYPE="Warning"
		fi
		print "AMD Loader $MSG_TYPE \@ $TimeStamp"		
		if [ "$AMD_ERROR_NOTIFICATION" = "Y" ]
		then
			if [[ "${ABORT_FOR_WARNINGS:-N}" = "Y" ]] ; then # only send a page when aborting
				$LIB_HOME/sendPage.ksh  "AMD Loader $MSG_TYPE \@ $TimeStamp"		
			fi
			$LIB_HOME/execSqlplus.ksh sendWarningMsg \
		       	  "$0 $MSG_TYPE for step send${1} on $hostname. No records enqueued" 
		fi
		if [[ "${ABORT_FOR_WARNINGS:-N}" = "Y" ]] ; then 
			exit 4
		fi
	fi
}

sendSpoUser() {
	sendXmlTran SpoUser
}

sendSiteAsset() {
	sendXmlTran SiteAsset
}

trimmedPostProcessing()
{
	$LIB_HOME/trimTactics.ksh -f complete -o run -t run
	if (($?!=0)) ; then
		abort "trimTactics.ksh failed for $0"
	fi 
}



# load step array
steps[1]=header
steps[2]=StartJob
steps[3]=cleanTraceTables
steps[4]=replicateGold
steps[5]=replicateWesm
steps[6]=processL67
# no longer needed - 12/05/2006 DSE steps[5]=processGDSS
steps[7]=truncateAmd
steps[8]=loadDmndFrcstConsumables
steps[9]=dmndFrcstConsumablesDiff
steps[10]=loadRmads
steps[11]=AmdLoad1
steps[12]=plannersDiff
steps[13]=sendSpoUser
steps[14]=sendSiteAsset
steps[15]=sparePartDiff
steps[16]=AmdLoad2
steps[17]=sendPartInfo
steps[18]=invDiff
steps[19]=partFactorsDiff
steps[20]=partLocForecastsDiff
steps[21]=locPartLeadtimeDiff
steps[22]=AmdLoad3
steps[23]=locPartOverrideDiff
steps[24]=checkForDeletedSpoPrimeParts
steps[25]=DynamSql
steps[26]=amd2spo
steps[27]=DynamSqlPostProcess
steps[28]=trimmedPostProcessing
steps[29]=EndJob
steps[30]=bssmFlatFiles
steps[31]=archive
steps[32]=footer
steps[33]=exit

showRunEnqueueDebug=${showRunEnqueueDebug:-N}
REMOTE_TEE=${REMOTE_TEE:-N}

if [[ "$REMOTE_TEE" = "N" ]] ; then
	remoteLog="2>&1"
else
	remoteLog="| tee"
fi

export AMD_NOTIFY=${AMD_NOTIFY:-Y}
export AMD_BSSMFLATFILE_NOTIFY=${AMD_BSSMFLATFILE_NOTIFY:-N}
if [ $AMD_NOTIFY = N ]
then
	AMD_ERROR_NOTIFICATION=N
fi

export AMD_ERROR_NOTIFICATION=${AMD_ERROR_NOTIFICATION:-Y}

if [[ "$AMD_USE_MENU" = "Y" ]] ; then
	header
	if [[ "$NO_TEE" = "Y" ]] ; then
		mainMenu >> "$AMD_LOADER_LOG"

	else
		mainMenu | tee -a "$AMD_LOADER_LOG"
	fi
else
	if [[ -n $COMMAND_FILE && -f $COMMAND_FILE ]] ; then
		# remove all lines beginning with a #
		sed '/^\#/d' $COMMAND_FILE | while read step
		do
			checkStepName $step
			if [[ "${step}" != "exit" ]] ; then
				print "${steps} started at `date`"
			fi
			if [[ "$step" = "amd2spo" ]] ; then
				$step &
			else
				$step | tee -a "$AMD_LOADER_LOG"
			fi
			print "$step ended at  `date`"
		done 
	else
		if (( $# > 0 ))
		then
			if [[ "$NO_TEE" = "Y" || "$LOGNAME" = "amduser" ]] ; then
				execSteps $* >> "$AMD_LOADER_LOG"
			else
				execSteps $* | tee -a "$AMD_LOADER_LOG"
			fi
		else
			if [[ "$NO_TEE" = "Y" || "$LOGNAME" = "amduser" ]] ; then
				main $@ >> "$AMD_LOADER_LOG"
			else
				main $@ | tee -a "$AMD_LOADER_LOG"
			fi
		fi
	fi
fi


return 0
