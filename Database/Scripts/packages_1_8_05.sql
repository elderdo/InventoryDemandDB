-- "Set define off" turns off substitution variables. 
Set define off; 

CREATE OR REPLACE PACKAGE Amd_Utils AS
/*
       $Author:   zf297a  $
     $Revision:   1.27  $
         $Date:   Sep 25 2006 15:16:06  $
     $Workfile:   amd_utils.pks  $
	 $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_utils.pks-arc  $
   
      Rev 1.27   Sep 25 2006 15:16:06   zf297a
   added interface for isDiff with date parameters
   
      Rev 1.26   Sep 18 2006 13:14:18   zf297a
   added overloaded boolean functions isDiff
   
      Rev 1.25   Sep 12 2006 10:56:32   zf297a
   added interface for isNumber and isNumberYorN
   
      Rev 1.24   Aug 23 2006 09:43:48   zf297a
   Defined interface for boolean function isPartRepairable and
   the interface for varchar2 function isPartRepairableYorN.
   
      Rev 1.23   Jul 13 2006 12:12:42   zf297a
   Added interface for getSpoPrimePartNo.

      Rev 1.22   Jun 09 2006 11:27:30   zf297a
   added version interface

      Rev 1.21   Jun 01 2006 10:55:58   zf297a
   Added writeMsg

      Rev 1.19   Nov 09 2005 11:25:46   zf297a
   Added interface for isPrimePartYorN.

      Rev 1.18   Sep 09 2005 00:20:36   zf297a
   Changed splitString and joinString to use a single character delimiter.

      Rev 1.17   Sep 07 2005 09:44:42   zf297a
   Added the arrayOfWords 'type' and interfaces splitString and joinString.

      Rev 1.16   Sep 02 2005 15:05:32   zf297a
   Added interfaces for getLocType,  isPrimePart, getPrimePart, getEquivalentParts, equivalentParts

      Rev 1.17   Aug 19 2005 12:41:06   zf297a
   Added functions bizDays2CalendarDays, months2CalendarDays, and getSiteLocation.

      Rev 1.16   Aug 19 2005 11:35:16   c378632
   add GetNsiSidFromPartNo

      Rev 1.15   07 Jun 2005 22:13:08   c378632
   add GetLocationInfo, GetSpoLocation, GetPartNo

      Rev 1.14   May 17 2005 10:03:58   c970183
   Removed redundant version of InsertErrorMessage

      Rev 1.13   May 13 2005 14:19:00   c970183
   For the insertErrorMsg procedure all parameters are now optional.  The load_no will still get set, the key5 variable will get set if it is null to the sysdate, and the comments column will get set to sqlcode and sqlerrm.

      Rev 1.12   May 02 2005 13:35:34   c970183
   Removed the global mDebug - each package should have their own mDebug flag which determines if the debug code is executed.

      Rev 1.11   Apr 21 2005 08:17:08   c970183
   Created debugMsg which can be controlled via mDebug and mDebugThreshold.  Both params can be controlled by the package user or the amd_param_changes table.  The data from amd_param_changes is loaded at package initialization, therefore the settings given by the package user have a higher priority since they can be overriden at any time during the session.

      Rev 1.9   05 Sep 2002 10:16:34   c970183
   Added $Log$ keyword and changed variable name from sendorAddress to senderAddress

	--
	-- SCCSID: %M%  %I%  Modified: %G% %U%
	--
	-- Date     By     History
	-- -------- -----  ---------------------------------------------------
	-- 10/14/01 FF     Initial implementation
	-- 10/17/01 DSE		Added GetNsiSid functions
	-- 10/24/01 ks		added GetLocSid
	-- 10/28/01 ks		added GetLocType, GetLocId
	-- 10/30/01 dse		added a variation of InsertErrorMsg with all
						the fields for amd_load_details
	-- 09/05/02 dse		added sendMail procedure
	-- 9/3/04 dse		added stronger data typing for GetLoadNo and InsertErrorMsg
	-- 06/07/05 ks		add GetLocationInfo, GetSpoLocation, GetPartNo
	-- 06/09/05 ks		add GetNsiSidFromPartNo
	   					(signatures often equivalent for other GetNsiSid -
						received too many functions match this call)
*/

type equivalent_parts is ref cursor return amd_spare_parts%rowtype ;
type parts is table of amd_spare_parts%Rowtype ;
type arrayOfWords is varray(50) of varchar2(512) ;

mDebugThreshold NUMBER := 1000 ; -- this can be controlled by the user of the package
				                 -- or by amd_param_changes / debugUtilsThreshold

-- when this routine has been executed pDebugThreshold times, it will not create any more
-- output
PROCEDURE debugMsg(pMsg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE,
			  pPackage IN AMD_LOAD_DETAILS.KEY_1%TYPE := 'amd_utils',
			  pLocation IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE := 999,
			  pMsg2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
			  pMsg3 IN AMD_LOAD_DETAILS.key_3%TYPE := '',
			  pMsg4 IN AMD_LOAD_DETAILS.key_4%TYPE := '') ;


FUNCTION GetLoadNo(
							pSourceName AMD_LOAD_STATUS.SOURCE%TYPE,
							pTableName AMD_LOAD_STATUS.TABLE_NAME%TYPE) RETURN NUMBER ;

FUNCTION FormatNsn(
							pNsn VARCHAR2,
							pType VARCHAR2 DEFAULT 'AMD') RETURN VARCHAR2;

PROCEDURE InsertErrorMsg (
							pLoad_no IN AMD_LOAD_DETAILS.load_no%TYPE := NULL,
							pData_line_no IN AMD_LOAD_DETAILS.data_line_no%TYPE := NULL,
							pData_line IN AMD_LOAD_DETAILS.data_line%TYPE := NULL,
							pKey_1 IN AMD_LOAD_DETAILS.key_1%TYPE := NULL,
							pKey_2 IN AMD_LOAD_DETAILS.key_2%TYPE := NULL,
							pKey_3 IN AMD_LOAD_DETAILS.key_3%TYPE := NULL,
							pKey_4 IN AMD_LOAD_DETAILS.key_4%TYPE := NULL,
							pKey_5 IN AMD_LOAD_DETAILS.key_5%TYPE := NULL,
							pComments IN AMD_LOAD_DETAILS.comments%TYPE := NULL ) ;

	-- source is amd_nsns
	FUNCTION GetNsiSid(pNsn IN AMD_NSNS.nsn%TYPE) RETURN AMD_NSNS.nsi_sid%TYPE ;
	PRAGMA RESTRICT_REFERENCES(GetNsiSid,WNDS) ;


	-- source is amd_nsi_parts
	FUNCTION GetNsiSid(pPart_no IN AMD_NSI_PARTS.part_no%TYPE) RETURN AMD_NSI_PARTS.nsi_sid%TYPE ;
	PRAGMA RESTRICT_REFERENCES(GetNsiSid,WNDS) ;

	FUNCTION GetLocSid(pLocId AMD_SPARE_NETWORKS.loc_id%TYPE) RETURN AMD_SPARE_NETWORKS.loc_sid%TYPE;
	FUNCTION GetLocType(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_type%TYPE;
	FUNCTION GetLocId(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_id%TYPE;
	PROCEDURE sendMail(senderAddress   VARCHAR2, receiverAddress VARCHAR2, subject VARCHAR2, mesg VARCHAR2) ;

	-- added 06/07/05
	-- GetPartNo only return active parts
	FUNCTION GetPartNo(pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE)	RETURN AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE ;
	FUNCTION GetSpoLocation(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) 	RETURN AMD_SPARE_NETWORKS.spo_location%TYPE ;
	PRAGMA RESTRICT_REFERENCES (GetPartNo, WNDS) ;
	PRAGMA RESTRICT_REFERENCES (GetSpoLocation, WNDS) ;
	FUNCTION GetLocationInfo(pLocSid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN	AMD_SPARE_NETWORKS%ROWTYPE ;

	-- added 06/09/05
	FUNCTION GetNsiSidFromPartNo(pPart AMD_NSI_PARTS.part_no%TYPE) RETURN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE ;

	-- added 08/19/05
	FUNCTION bizDays2CalendarDays(bizDays IN INTEGER) RETURN INTEGER ;
	FUNCTION months2CalendarDays(months IN DECIMAL) RETURN NUMBER ;
	FUNCTION getSiteLocation(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_id%TYPE ;

	-- added 9/1/2005
	FUNCTION getLocType(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_type%TYPE ;

	FUNCTION isPrimePart(part_no AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN ;
	-- added 11/9/2005
	function isPrimePartYorN(part_no amd_spare_parts.part_no%type) return varchar2 ;
	-- for any part number return the prime part - if the input is the prime it will return itself
	function getPrimePart(part_no amd_nsi_parts.part_no%type) return amd_national_stock_items.prime_part_no%type ;

	-- for any part number, return a cursor with all the equivalent parts (could return 0 rows)
	function getEquivalentParts(part_no amd_spare_parts.part_no%type) return equivalent_parts ;

	function equivalentParts(part_no amd_spare_parts.part_no%type) return parts PIPELINED ;

	-- added 9/7/2005
	function splitString(text in varchar2, delim in varchar2 := ',') return arrayOfWords ;
	function joinString(words in arrayOfWords, delim in varchar2 := ',') return varchar2 ;

	-- added 10/7/2005 by DSE
	function getCageCode(part_no in varchar2) return varchar2 ;

	-- added 10/12/2005 by DSE
	function getUnitCostDefaulted(part_no in varchar2) return amd_spare_parts.unit_cost_defaulted%type ;

	-- added 03/03/2006 by DSE
	function boolean2Varchar2(theValue in boolean, YorN in boolean := false) return varchar2 ;

	-- added 6/1/2006 by DSE
	-- record a note in amd_load_details
	procedure writeMsg(
		pSourceName in varchar2,
		pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
		pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
		pKey1 IN VARCHAR2 := '',
		pKey2 IN VARCHAR2 := '',
		pKey3 IN VARCHAR2 := '',
		pKey4 in varchar2 := '',
		pData IN VARCHAR2 := '',
		pComments IN VARCHAR2 := '')  ;

	-- added 6/9/2006 by DSE
	procedure version ;

	-- added 7/13/2006 by DSE
	FUNCTION getSpoPrimePartNo(part_no AMD_SENT_TO_A2A.part_no%TYPE) RETURN AMD_SENT_TO_A2A.SPO_PRIME_PART_NO%TYPE ;
	
	-- add 8/22/2006 by DSE
	function isPartRepairable(part_no amd_spare_parts.part_no%type) return boolean ;
	function isPartRepairableYorN(part_no amd_spare_parts.part_no%type) return varchar2 ;

	-- added 9/12/2006 by DSE
	function isNumber( p_string in varchar2 ) return boolean ;
	-- added 9/12/2006 by DSE
	function isNumberYorN( p_string in varchar2) return varchar2 ;

	
	-- added 9/18/2006 by DSE
	function isDiff(oldText in varchar2, newText in varchar2) return boolean ;
	-- added 9/18/2006 by DSE
	function isDiff(oldNum in number, newNum in number) return boolean ;
	-- added 9/25/2006 by DSE
	function isDiff(oldDate in date, newDate in Date) return boolean ;
	
END Amd_Utils;
/

show errors

CREATE OR REPLACE PACKAGE Amd_Spare_Parts_Pkg AS
    /*
       $Author:   zf297a  $
     $Revision:   1.37  $
         $Date:   Jun 09 2006 12:29:34  $
     $Workfile:   AMD_SPARE_PARTS_PKG.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_spare_parts_pkg.pks-arc  $
   
      Rev 1.37   Jun 09 2006 12:29:34   zf297a
   added interface version
   
      Rev 1.36   Mar 08 2006 09:26:18   zf297a
   Added mtbdr_computed.

      Rev 1.35   Jun 16 2005 15:53:18   c970183
   Changed errorMsg to be the same as the errorMsg in the a2a_pkg: this uses a unique pError_location number to pinpoint the block of code that has the exception.  Also, added some user defined exception instead of return codes.

      Rev 1.34   Jun 03 2005 12:50:10   c970183
   Added the procedure loadCurrentBackOrder for amd_national_stock_items.current_backorder

      Rev 1.33   May 16 2005 11:59:52   c970183
   Moved time_to_repair_off_base and cost_to_repair_off_base from amd_part_locs to amd_national_stock_items.  Created "changed indicators" for both of these fields.

      Rev 1.32   May 02 2005 12:53:12   c970183
   Added error code for 'deleteRow'

      Rev 1.30   Apr 22 2005 08:09:26   c970183
   added addtional debug code

      Rev 1.29   Apr 18 2005 10:54:44   c970183
   Added new parameters to insertRow and updateRow.  Leveraged the old routines by just defining the new parameters as global member variables and invoking the old insertRow and updateRow methods.   Change the insert and update of amd_national_stock_items to use the new global member variables.

      Rev 1.28   Mar 24 2005 14:37:06   c970183
   added ver 1.40 - 1.45 changes.  Plus fixed a2a trans

      Rev 1.27   Mar 24 2005 09:36:22   c970183
   Added qpei_weighted, order_lead_time_cleaned, unit_cost_cleaned, planner_code_cleaned, smr_code_cleaned, cost_to_repair_off_base_cleand to InsertRow and UpdateRow

      Rev 1.23   30 Aug 2002 11:46:26   c970183
   Fixed updating of the prime_part_no.   When a prime_part_no and its equivalent parts got deleted and reinserted,  the logic caused the amd_national_stock_items.prime_part_no column to get set to a null value.  To accomodate this condition code has been added to the equivalent part section that checks for an existing amd_nsi_parts.part_no with its prime_ind set to 'Y'.  If found it makes sure that the same part_no appears in amd_national_stock_items.prime_part_no.

      Rev 1.22   07 Aug 2002 08:58:24   c970183
   Set unassignment_date to sysdate for deleted parts.

      Rev 1.21   11 Apr 2002 09:26:18   c970183
   Put SCCS keywords back into the file

      Rev 1.20   08 Apr 2002 12:14:48   c970183
   Added acquisition_advice_code

      Rev 1.19   05 Apr 2002 09:30:28   c970183
   Added return code: unable to chg nsn_type and constants for amd_nsns.nsn_type

      Rev 1.18   04 Apr 2002 13:25:28   c970183
   Added mic_code_lowest to the InsertRow and UpdateRow routines.

      Rev 1.17   28 Mar 2002 12:41:58   c970183
   added comment and log regarding sleep/insert exception handler

	  SCCSID:	%M%	%I%	Modified: %G%  %U%
      10/02/01 Douglas Elder   Initial implementation
	  03/21/02 Douglas Elder	Added Sleep(5) to insure
	  							a unique key for amd_nsi_parts
	  03/28/02 Douglas Elder	Added insertagain_err code - since the sleep
	  		   		   			is now only executed for insert exceptions
	  04/04/02 Douglas Elder	Added Mic Code to insert and update
	  04/05/02 Douglas Elder    Added return code: unable to chg nsn_type
	  		   		   			and constants for amd_nsns.nsn_type
     */
	-- return values from InsertRow, UpdateRow, and DeleteRow

	SUCCESS							CONSTANT NUMBER := 0 ;
	FAILURE							CONSTANT NUMBER := 4 ;

	-- amd_nsns.nsn_type values

	TEMPORARY_NSN 		 	   		CONSTANT VARCHAR2(1) := 'T' ;
	CURRENT_NSN	  		   			CONSTANT VARCHAR2(1) := 'C' ;

	/* NOTE: Most of these return values should not occur, but
		if they do occur there is probably a coding error that
		needs to be corrected.  The return value should help
		to isolate the section of code that caused the problem.
		The return value and associated data are recorded in the
		amd_load_details table
		*/

	PART_NOT_PRIME					CONSTANT NUMBER := 8 ;
	UNABLE_TO_PRIME_INFO			CONSTANT NUMBER := 12 ;
	UNABLE_TO_INSERT_SPARE_PART		CONSTANT NUMBER := 16 ;
	UNABLE_TO_INSERT_AMD_NSNS		CONSTANT NUMBER := 20 ;
	UNABLE_TO_INSERT_AMD_NSI_PARTS	CONSTANT NUMBER := 24 ;
	CANNOT_UPDT_NSN_NAT_STCK_ITEMS	CONSTANT NUMBER := 28 ;
	cannotGetNsiSid					exception ;
	CANNOT_UPDATE_SPARE_PARTS_NSN	CONSTANT NUMBER := 36 ;
	CANNOT_UPADATE_NAT_STCK_ITEMS 	CONSTANT NUMBER := 40 ;
	CANNOT_UPDATE_AMD_NSNS			CONSTANT NUMBER := 44 ;
	CANNOT_GET_UNIT_COST_CLEANED	CONSTANT NUMBER := 48 ;
	CHK_NSN_AND_PRIME_ERR			CONSTANT NUMBER := 52 ;
	UNABLE_TO_DELT_PART_NOT_FOUND 	CONSTANT NUMBER := 56 ;
	UNABLE_TO_DLET_NAT_STK_ITEM		CONSTANT NUMBER := 60 ;
	UNABLE_TO_RESET_NAT_STK_ITEM	CONSTANT NUMBER := 64 ;
	INSERT_PRIMEPART_ERR			CONSTANT NUMBER := 68 ;
	INS_PRIME_PART_ERR				CONSTANT NUMBER := 72 ;
	UPDATE_NATSTK_ERR				CONSTANT NUMBER := 76 ;
	INS_EQUIV_PART_ERR				CONSTANT NUMBER := 80 ;
	INS_AMD_NSI_PARTS_ERR			CONSTANT NUMBER := 84 ;
	UPD_AMD_SPARE_PARTS_NSN			CONSTANT NUMBER := 88 ;
	LOGICAL_INSERT_FAILED			CONSTANT NUMBER := 92 ;
	partAlreadyExists				exception ;
	INSERTROW_FAILED				CONSTANT NUMBER := 100 ;
	UNASSIGN_PRIME_PART_ERR			CONSTANT NUMBER := 104 ;
	UNASSIGN_OLD_PRIME_PART_ERR		CONSTANT NUMBER := 108 ;
	UPD_NSI_PARTS_ERR				CONSTANT NUMBER := 116 ;
	ASSIGN_NEW_PRIME_PART_ERR		CONSTANT NUMBER := 120 ;
	UPDATE_ERR						CONSTANT NUMBER := 124 ;
	UNABLE_TO_GET_PRIME_PART		CONSTANT NUMBER := 128 ;
	UPDT_PRIME_PART_ERR				CONSTANT NUMBER := 132 ;
	MAKE_NEW_PRIME_PART_ERR			CONSTANT NUMBER := 136 ;
	UNASSIGN_EQUIV_PART_ERR			CONSTANT NUMBER := 140 ;
	UPD_NSN_SPARE_PARTS_ERR			CONSTANT NUMBER := 144 ;
	ASSIGN_PRIME_TO_EQUIV_ERR		CONSTANT NUMBER := 148 ;
	UPD_PRIME_PART_ERR				CONSTANT NUMBER := 152 ;
	UNABLE_TO_GET_NSI_SID			CONSTANT NUMBER := 156 ;
	UNABLE_TO_PREP_DATA				CONSTANT NUMBER := 160 ;
	UNABLE_TO_GET_NUM_ACTIVE_PARTS	CONSTANT NUMBER := 164 ;
	UNABLE_TO_PROC_INS_OR_DLET		CONSTANT NUMBER := 170 ;
	UNABLE_TO_SET_TACTICAL_IND		CONSTANT NUMBER := 174 ;
	UNABLE_TO_SET_SMR_CODE			CONSTANT NUMBER := 178 ;
	UNABLE_TO_SET_UNIT_COST			CONSTANT NUMBER := 182 ;
	ADD_PLANNER_CODE_ERR			CONSTANT NUMBER := 186 ;
	ADD_UOM_CODE_ERR				CONSTANT NUMBER := 190 ;
	UPDT_ERR_NATIONAL_STK_ITEMS		CONSTANT NUMBER := 194 ;
	ASSIGN_NEW_EQUIV_PART_ERR		CONSTANT NUMBER := 198 ;
	UPDT_NULL_PRIME_COLS_ERR		CONSTANT NUMBER := 202 ;
	INSERT_NEW_NSN_ERR				CONSTANT NUMBER := 206 ;
	UPDT_NSN_PRIME_ERR				CONSTANT NUMBER := 210 ;
	CREATE_NATSTKITEM_ERR			CONSTANT NUMBER := 214 ;
	PREP_DATA_FOR_UPDT_ERR			CONSTANT NUMBER := 218 ;
	UPDT_SPAREPART_ERR				CONSTANT NUMBER := 222 ;
	UPDT_PRIMEPART_ERR				CONSTANT NUMBER := 226 ;
	UPDT_NATSTKITEM_ERR				CONSTANT NUMBER := 230 ;
	NEW_NSN_ERR						CONSTANT NUMBER := 234 ;
	GET_NSISID_BY_PART_ERR			CONSTANT NUMBER := 238 ;
	NEW_NSN_ERROR					CONSTANT NUMBER := 242 ;
	CHK_NSN_AND_PRIME_ERR2			CONSTANT NUMBER := 246 ;
	INSERTAGAIN_ERR					CONSTANT NUMBER := 248 ;
	UNABLE_TO_CHG_NSN_TYPE			CONSTANT NUMBER := 252 ;
	UNABLE_TO_UNASSIGN_PART			CONSTANT NUMBER := 256 ;
	UNABLE_TO_GET_PRIME_PART		CONSTANT NUMBER := 260 ;
	UPDT_NULL_PRIME_COLS_ERR2		CONSTANT NUMBER := 264 ;
	CANNOT_UPDATE_ORDER_LEAD_TIME   CONSTANT NUMBER := 268 ;
	UPDT_ERRX						CONSTANT NUMBER := 270 ;
	CANNOT_UPDATE_PART_PRICING		CONSTANT NUMBER := 274 ;
	DELETE_ERR						CONSTANT NUMBER := 278 ;

	mDebug boolean := false ; -- allow debugging to be turned on or off at the package level


	FUNCTION InsertRow
                (pPart_no IN VARCHAR2,
                pMfgr IN VARCHAR2,
                pDate_icp IN DATE,
                pDisposal_cost IN NUMBER,
                pErc IN VARCHAR2,
                pIcp_ind IN VARCHAR2,
                pNomenclature IN VARCHAR2,
                pOrder_lead_time IN NUMBER,
				pOrder_quantity IN NUMBER,
                pOrder_uom IN VARCHAR2,
				pPrime_ind IN VARCHAR2,
                pScrap_value IN NUMBER,
                pSerial_flag IN VARCHAR2,
                pShelf_life IN NUMBER,
                pUnit_cost IN NUMBER,
                pUnit_volume IN NUMBER,
                pNsn IN VARCHAR2,
				pNsn_type IN VARCHAR2,
                pItem_type IN VARCHAR2,
                pSmr_code IN VARCHAR2,
                pPlanner_code IN VARCHAR2,
				pMic_code_lowest IN VARCHAR2,
				pAcquisition_advice_code IN VARCHAR2,
				pMmac IN VARCHAR2,
				pUnitOfIssue IN VARCHAR2,
				pMtbdr in number,
				pMtbdr_computed in number,
  				pQpeiWeighted in number,
  				pCondemnAvgCleaned in number,
  				pCriticalityCleaned in number,
  				pMtbdrCleaned in number,
  				pNrtsAvgCleaned in number,
  				pCosToRepairOffBaseCleand in number,
  				pTimeToRepairOffBaseCleand in  number,
  				pOrderLeadTimeCleaned in number,
  				pPlannerCodeCleaned in amd_national_stock_items.planner_code_cleaned%type,
  				pRtsAvgCleaned in number,
  				pSmrCodeCleaned in amd_national_stock_items.smr_code_cleaned%type,
  				pUnitCostCleaned in number,
  				pCondemnAvg in number,
  				pCriticality in number,
  				pNrtsAvg in number,
  				pRtsAvg in number,
				pCostToRepairOffBase in number,
				pTimeToRepairOffBase in number) return number ;



	FUNCTION UpdateRow
                (pPart_no IN VARCHAR2,
                pMfgr IN VARCHAR2,
                pDate_icp IN DATE,
                pDisposal_cost IN NUMBER,
                pErc IN VARCHAR2,
                pIcp_ind IN VARCHAR2,
                pNomenclature IN VARCHAR2,
                pOrder_lead_time IN NUMBER,
				pOrder_quantity IN NUMBER,
                pOrder_uom IN VARCHAR2,
				pPrime_ind IN VARCHAR2,
                pScrap_value IN NUMBER,
                pSerial_flag IN VARCHAR2,
                pShelf_life IN NUMBER,
                pUnit_cost IN NUMBER,
                pUnit_volume IN NUMBER,
                pNsn IN VARCHAR2,
				pNsn_type IN VARCHAR2,
                pItem_type IN VARCHAR2,
                pSmr_code IN VARCHAR2,
                pPlanner_code IN VARCHAR2,
				pMic_code_lowest IN VARCHAR2,
				pAcquisition_advice_code IN VARCHAR2,
				pMmac IN VARCHAR2,
				pUnitOfIssue IN VARCHAR2,
				pMtbdr in number,
				pMtbdr_computed in number,
  				pQpeiWeighted in number,
  				pCondemnAvgCleaned in number,
  				pCriticalityCleaned in number,
  				pMtbdrCleaned in number,
  				pNrtsAvgCleaned in number,
  				pCosToRepairOffBaseCleand in number,
  				pTimeToRepairOffBaseCleand in  number,
  				pOrderLeadTimeCleaned in number,
  				pPlannerCodeCleaned in amd_national_stock_items.planner_code_cleaned%type,
  				pRtsAvgCleaned in number,
  				pSmrCodeCleaned in amd_national_stock_items.smr_code_cleaned%type,
  				pUnitCostCleaned in number,
  				pCondemnAvg in number,
  				pCriticality in number,
  				pNrtsAvg in number,
  				pRtsAvg in number,
				pCostToRepairOffBase in number,
				pTimeToRepairOffBase in number) return number ;


	function DeleteRow(
							pPart_no in varchar2,
							pNomenclature in varchar2,
							pMfgr in varchar2 ) return number ;

	procedure loadCurrentBackOrder(debug in boolean := False) ;
	
	-- added 6/9/2006 by dse
	procedure version ;

END Amd_Spare_Parts_Pkg ;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_batch_pkg AS
	/*7
      $Author:   zf297a  $
    $Revision:   1.5  $
	    $Date:   Jun 09 2006 11:34:36  $
    $Workfile:   AMD_BATCH_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_BATCH_PKG.pks.-arc  $
/*   
/*      Rev 1.5   Jun 09 2006 11:34:36   zf297a
/*   added interface version
/*   
/*      Rev 1.4   Mar 23 2006 08:19:14   zf297a
/*   Added procedure truncateIfOld
/*   
/*      Rev 1.3   Mar 19 2006 01:48:46   zf297a
/*   Added interface for isStepComplete function
/*   
/*      Rev 1.2   Mar 16 2006 14:24:42   zf297a
/*   Added step procedures and functions
/*   
/*      Rev 1.1   Mar 03 2006 12:32:56   zf297a
/*   Added three functions:
/*   getLastStartTime
/*   getLastEndTime
/*   isJobComplete.
/*   
/*      Rev 1.0   Nov 22 2005 08:02:18   zf297a
/*   Initial revision.
*/
  	   ASSET_MANAGEMENT_DESKTOP constant varchar2(3) := 'AMD' ;
	   
	   procedure start_job(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP, description in amd_batch_jobs.description%type := null) ;
	   procedure abort_job(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) ;
	   procedure end_job(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) ;
	   function getActiveJob(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_jobs.batch_job_number%type ;
  	   function isJobActive(batch_job_number in amd_batch_jobs.batch_job_number%type := null,
  		   system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean ;
	   function getLastCompleteJob(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_jobs.batch_job_number%type ;
	   function getLastStartTime(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP)  
	   			return amd_batch_jobs.START_TIME%type ;
				
  	   function getLastEndTime(batch_job_number in amd_batch_jobs.batch_job_number%type := null,system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) 
	   			return amd_batch_jobs.END_TIME%type ;
				
  	   function isJobComplete(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type := null, 
	   			system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean ;
  	   function isJob(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type, 
	   			system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean ;
	   
	   procedure start_step(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null, 
	   			 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
				 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null, 
				 description in amd_batch_job_steps.DESCRIPTION%type := null, 
				 package_name in amd_batch_job_steps.PACKAGE_NAME%type := null, 
				 procedure_name in amd_batch_job_steps.PROCEDURE_NAME%type := null,
				 function_name in amd_batch_job_steps.FUNCTION_NAME%type := null) ;
				 
	   procedure abort_step(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			 system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
				 batch_step_number in amd_batch_job_steps.batch_step_number%type := null) ;
				 
				 
	   procedure end_step(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null, 
				 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
	 			 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null) ;
				 
	
	   function getActiveStep(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
	   function getLastCompleteStep(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.batch_step_number%type ;
	   function getLastStepStartTime(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.start_time%type ;
	   function getLastStepEndTime(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.start_time%type;
	   procedure deleteJob(batch_job_number in amd_batch_jobs.batch_job_number%type := null,
	   			 system_id in amd_batch_jobs.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP) ;    
  	   function isStepComplete(batch_job_number in amd_batch_job_steps.batch_job_number%type,
  		   system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		   batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type) return boolean ;
       function isStepComplete(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
  		   system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		   description in amd_batch_job_steps.description%type) return boolean ;
		   
  	   function didStepStart(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null, 
  		 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
		 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null, 
		 description in amd_batch_job_steps.DESCRIPTION%type := null, 
		 package_name in amd_batch_job_steps.PACKAGE_NAME%type := null, 
		 procedure_name in amd_batch_job_steps.PROCEDURE_NAME%type := null,
		 function_name in amd_batch_job_steps.FUNCTION_NAME%type := null) return boolean ;
		 
  	  procedure truncateIfOld(tablename in varchar2, system_id in amd_batch_jobs.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP) ;
	  
	  -- added 6/9/2006 by DSE
	  procedure version ;
	  
END amd_batch_pkg;
/

show errors

CREATE OR REPLACE PACKAGE A2a_Pkg AS
 --
 -- SCCSID:   %M%   %I%   Modified: %G%  %U%
 --
 /*
      $Author:   zf297a  $
    $Revision:   1.48  $
     $Date:   Aug 31 2006 11:36:36  $
    $Workfile:   A2A_PKG.PKS  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\A2A_PKG.PKS-arc  $
/*   
/*      Rev 1.48   Aug 31 2006 11:36:36   zf297a
/*   Added interface for initA2ADemands
/*   
/*      Rev 1.47   Aug 18 2006 15:36:46   zf297a
/*   Added interface for processExtForecast and added 2 interfaces for initA2AExtForecasts.  Defined extForecastCur type.
/*   
/*      Rev 1.46   Aug 10 2006 14:29:32   zf297a
/*   Added an optional param that will display the reason a part is not valid if the param is set to true or Y for the boolean function isPartValid and the varchar2 function, isPartValidYorN, that returns Y or N
/*   
/*      Rev 1.45   Aug 04 2006 12:55:38   zf297a
/*   Added interface getDueDate and changed the interface includeOrder by adding part_no as an argument
/*   
/*      Rev 1.44   Aug 04 2006 11:08:46   zf297a
/*   Made the boolean function includeOrder public
/*   
/*      Rev 1.43   Jul 11 2006 14:33:28   c402417
/*   Modified TYPE inTransitsCur from AMD_IN_TRANSITS to AMD_IN_TRANSITS_SUM.
/*   
/*      Rev 1.42   Jun 07 2006 20:59:10   zf297a
/*   added version procedure
/*   
/*      Rev 1.41   May 12 2006 13:57:14   zf297a
/*   Removed deletesOk from the wasPartSent interface.  Now using a global variable mblnSendAllData, which has its own getter and setter.
/*   Changed all init routines to include DELETED action codes and to use all part_no's contained in amd_sent_to_a2a that also have a spo_prime_part_no.
/*   
/*      Rev 1.40   May 12 2006 10:23:10   zf297a
/*   Allowed for A2A part delete transactions to be sent again
/*   
/*      Rev 1.39   Apr 27 2006 14:51:40   zf297a
/*   Changed interface for loadAll by adding an optional system_id
/*   
/*      Rev 1.38   Mar 03 2006 14:42:46   zf297a
/*   added loadAll procedure - this sends all the a2a data
/*   
/*      Rev 1.37   Feb 15 2006 13:39:06   zf297a
/*   Added cur ref's for all init and byDate routines + a common process routine to make sure everything is done the same no matter what selection criteria is used.
/*   
/*      Rev 1.36   Jan 04 2006 09:01:44   zf297a
/*   Added two overloaded procedures initA2ABackorderInfo which can accept a list of parts or a range of dates like the othe initA2A procedures.
/*   
/*      Rev 1.35   Jan 03 2006 12:44:14   zf297a
/*   Added date range to procedures 
/*   initA2AInvInfo
/*   initA2ARepairInvInfo
/*   initA2AInTransits
/*   initA2ARepairInfo
/*   initA2AOrderInfo
/*   initA2APartInfo
/*   initA2ABomDetail
/*   
/*   
/*      Rev 1.34   Dec 30 2005 01:32:08   zf297a
/*   added initA2ABomDetail by date
/*   
/*      Rev 1.33   Dec 29 2005 16:37:54   zf297a
/*   added initA2A by date procedures for PartInfo, OrderInfo, InvInfo, RepairInfo, InTransits, and RepairInvInfo
/*   
/*      Rev 1.32   Nov 30 2005 10:52:02   zf297a
/*   Added interface for BomDetail
/*
/*      Rev 1.31   Nov 10 2005 10:12:18   zf297a
/*   Added interface deleteInvalidParts
/*
/*      Rev 1.30   Nov 09 2005 11:09:56   zf297a
/*   Added interfaces:  wasPartSentYorN, isPartValidYorN, isPlannerCodeAssign2UserIdYorN, and isNslYorN.
/*
/*      Rev 1.29   Oct 27 2005 15:46:38   c402417
/*   Added expected_completion_date in fucntion InsertRepairInfo.
/*
/*      Rev 1.28   Oct 27 2005 10:21:38   zf297a
/*   Added interfaces deletePartInfo, which can be used to generate deletes for all parts or a set of test parts.  Added interface getTimeToRepair, so this previously private function is now a public function and so it can be tested using Toad's debugger.
/*
/*      Rev 1.27   Oct 19 2005 10:21:34   zf297a
/*   removed interface for insertTmpA2AOrderInfoLine and changed the interface for insertTmpA2AOrderInfo.   insertTmpA2AOrderInfo will now insert both the tmp_a2a_order_info and tmp_a2a_order_info_line.
/*
/*      Rev 1.26   Oct 10 2005 09:32:16   zf297a
/*   Added price to insertPartInfo and updatePartInfo
/*
/*      Rev 1.25   Oct 07 2005 12:18:22   zf297a
/*   Added cage_code to tmp_a2a_order_info and tmp_a2a_part_lead_time.  Created a separate procedure to init tmp_a2a_part_lead_time.
/*
/*      Rev 1.24   Sep 09 2005 11:11:22   zf297a
/*   Changed insertInvInfo to use spo_location, which comes from amd_spare_networks.spo_location.  However, the a2a transactions still refers to it as site_location so that name is left along for the tmp_a2a_inv_info table.
/*
/*      Rev 1.24   Aug 19 2005 12:36:10   zf297a
/*   removed functions bizDays2CalendarDays, months2CalendarDays, and getSiteLocation and put them in amd_utils
/*
/*      Rev 1.23   Aug 16 2005 14:28:56   zf297a
/*   Made getSiteLocation public
/*
/*      Rev 1.22   Aug 15 2005 14:46:22   zf297a
/*   added initA2ASpoUsers
/*
/*      Rev 1.20   Aug 10 2005 09:59:10   zf297a
/*   Added functions convertCleanedOrderLeadTime and convertOrderLeadTime.
/*
/*      Rev 1.19   Aug 04 2005 14:40:36   zf297a
/*   Added interface for insertTmpA2ASpoUsers.
/*
/*      Rev 1.18   Jul 20 2005 07:46:18   zf297a
/*   using only bems_id for a2a for spo users
/*
/*      Rev 1.17   Jul 19 2005 14:18:02   zf297a
/*   added spoUser procedure to create the a2a transactions for the spo_user
/*
/*      Rev 1.16   Jul 11 2005 12:38:40   zf297a
/*   added function initA2AInvInfo
/*
/*      Rev 1.15   Jul 11 2005 12:29:04   zf297a
/*   fixed name of initA2AInTransits
/*
/*      Rev 1.14   Jul 11 2005 12:26:22   zf297a
/*   added function initA2AInTransits
/*
/*      Rev 1.13   Jul 11 2005 12:14:54   zf297a
/*   added function initA2ARepairInfo
/*
/*      Rev 1.12   Jul 11 2005 11:47:48   zf297a
/*   added procedure insertTmpA2AInTransits
/*
/*      Rev 1.11   Jul 11 2005 11:16:52   zf297a
/*   Made wasPartSent and isPartValid public functions
/*
/*      Rev 1.9   Jul 11 2005 10:37:38   zf297a
/*   added procedure to insertTmpA2AOrderInfo and insertTmpA2AOrderInfoLine
/*
/*      Rev 1.8   Jun 22 2005 15:03:32   c970183
/*   Made the interface for the inita2aPartInfo more flexible.
/*
/*      Rev 1.7   Jun 10 2005 11:20:04   c970183
/*   Streamlined insertSiteRespAssetMgr, insertInvInfo, and insertRepairInfo.
/*
/*      Rev 1.6   May 18 2005 08:57:04   c970183
/*   Added getIndenture public method.  Modified inita2a to use getIndenture.
/*
/*      Rev 1.5   May 13 2005 14:39:32   c970183
/*   For a given part_no create an update transaction in tmp_a2a_part_info.  action_code may be overridden too.
/*
/*      Rev 1.4   Apr 22 2005 08:05:10   c970183
/*   Added debug code.  Added mArgs: a global variable containing the list of arguments to any public function or procedure.
/*
/*      Rev 1.2   27 Aug 2004 14:33:06   c970183
/*   Added constants 'NEW BUY', 'REPAIR', and 'ORDER'.
/*
/*      Rev 1.1   12 Aug 2004 14:30:48   c970183
/*   added insert, update, and delete functions for a2a tables.  implemented insert functions for part data.
/*
/*      Rev 1.0   Jul 19 2004 14:10:48   c970183
/*   Initial revision.
    */
	 SUCCESS CONSTANT NUMBER := 0 ;
	 FAILURE CONSTANT NUMBER := 4 ;
	 NEW_BUY CONSTANT CHAR(7) := 'NEW-BUY' ;
	 REPAIR  CONSTANT CHAR(6) := 'REPAIR' ;
	 AN_ORDER CONSTANT CHAR(5) := 'ORDER' ;
	 OPEN_STATUS CONSTANT CHAR(1) := 'O' ;
	 THIRD_PARTY_FLAG CONSTANT CHAR(1) := '?' ;
	 APPLICATION_ERROR EXCEPTION ;
	
	 mDebug BOOLEAN := FALSE ; -- allow debugging to be turned on or off at the package level
	 
	  TYPE partInfoRec IS RECORD (
	 	  mfgr 		  AMD_SPARE_PARTS.mfgr%TYPE, 
	      part_no	  AMD_SPARE_PARTS.part_no%TYPE,
	      NOMENCLATURE AMD_SPARE_PARTS.nomenclature%TYPE,
	      nsn		   AMD_SPARE_PARTS.nsn%TYPE,
	      order_lead_time AMD_SPARE_PARTS.order_lead_time%TYPE,
	      order_lead_time_defaulted AMD_SPARE_PARTS.order_lead_time_defaulted%TYPE,
	      unit_cost					AMD_SPARE_PARTS.unit_cost%TYPE,
	      unit_cost_defaulted		AMD_SPARE_PARTS.unit_cost_defaulted%TYPE,
	      unit_of_issue				AMD_SPARE_PARTS.unit_of_issue%TYPE,
	      unit_cost_cleaned			AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE,
	      order_lead_time_cleaned	AMD_NATIONAL_STOCK_ITEMS.order_lead_time_cleaned%TYPE,
	      planner_code				AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE,
	      planner_code_cleaned		AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE,
	      mtbdr						AMD_NATIONAL_STOCK_ITEMS.mtbdr%TYPE,
	      mtbdr_cleaned				AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE,
	      smr_code					AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE,
	      smr_code_cleaned			AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE,
	      smr_code_defaulted		AMD_NATIONAL_STOCK_ITEMS.smr_code_defaulted%TYPE,
	      nsi_sid					AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE,
	      TIME_TO_REPAIR_OFF_BASE_CLEAND AMD_NATIONAL_STOCK_ITEMS.TIME_TO_REPAIR_OFF_BASE_CLEAND%TYPE,
		  last_update_dt			AMD_SPARE_PARTS.last_update_dt%TYPE,
		  action_code				AMD_SPARE_PARTS.action_code%TYPE
	) ;
	
	TYPE part2Delete IS RECORD (
	 	  part_no AMD_SPARE_PARTS.part_no%TYPE,
		  nomenclature AMD_SPARE_PARTS.nomenclature%TYPE
	) ;
	
	
	 TYPE partCur IS REF CURSOR RETURN partInfoRec ;
	 TYPE onHandInvSumCur IS REF CURSOR RETURN AMD_ON_HAND_INVS_SUM%ROWTYPE ;
	 TYPE repairInvInfoCur IS REF CURSOR RETURN AMD_REPAIR_INVS_SUM%ROWTYPE ;
	 TYPE inTransitsCur IS REF CURSOR RETURN AMD_IN_TRANSITS_SUM%ROWTYPE ;
	 TYPE inRepairCur IS REF CURSOR RETURN AMD_IN_REPAIR%ROWTYPE ;
	 TYPE onOrderCur IS REF CURSOR RETURN AMD_ON_ORDER%ROWTYPE ;
	 TYPE part2DeleteCur IS REF CURSOR RETURN part2Delete ;
	 TYPE bomDetailCur IS REF CURSOR RETURN AMD_SENT_TO_A2A%ROWTYPE ;
	 TYPE backOrderCur IS REF CURSOR RETURN AMD_BACKORDER_SUM%ROWTYPE ;
	 type extForecastCur is ref cursor return amd_part_loc_forecasts%rowtype ;
	 
	 PROCEDURE processParts(parts IN partCur) ;
	 PROCEDURE processPartLeadTimes(parts IN partCur) ;
	 PROCEDURE processOnHandInvSum(onHandInvSum IN onHandInvSumCur) ;
	 PROCEDURE processRepairInvInfo(repairInvInfo IN repairInvInfoCur) ;
	 PROCEDURE processInTransits(inTransits IN inTransitsCur) ;
	 PROCEDURE processInRepair(inRepair IN inRepairCur) ;
	 PROCEDURE processOnOrder(onOrder IN onOrderCur) ;
	 PROCEDURE deletePartInfo(partInfo IN part2DeleteCur) ;
	 PROCEDURE processBomDetail(bomDetail IN bomDetailCur) ;
	 PROCEDURE processBackOrder(backOrder IN backOrderCur) ;
	 PROCEDURE processExtForecast(extForecast IN extForecastCur) ;
	
	
	
	
	 FUNCTION getIndenture(smr_code_preferred IN AMD_NATIONAL_STOCK_ITEMS.SMR_CODE%TYPE) RETURN TMP_A2A_PART_INFO.indenture%TYPE ;
	
	 FUNCTION getAssignedPlannerCode(part_no IN TMP_A2A_PART_INFO.part_no%TYPE,
	 		  planner_code IN AMD_PLANNERS.planner_code%TYPE) RETURN AMD_PLANNERS.planner_code%TYPE  ;
	
	 FUNCTION createPartInfo(part_no IN VARCHAR2,
	        action_code IN VARCHAR2 := Amd_Defaults.UPDATE_ACTION) RETURN NUMBER ;
	
	 FUNCTION InsertPartInfo(
	        mfgr IN VARCHAR2,
	       part_no IN VARCHAR2,
	       unit_issue IN VARCHAR2,
	       nomenclature IN VARCHAR2,
	       smr_code IN VARCHAR2,
	       nsn IN VARCHAR2,
	       planner_code IN VARCHAR2,
	       third_party_flag IN VARCHAR2,
	       mtbdr      IN NUMBER,
	       indenture IN VARCHAR2,
		   price IN NUMBER) RETURN NUMBER;
	
	 FUNCTION UpdatePartInfo(
	       mfgr IN VARCHAR2,
	       part_no IN VARCHAR2,
	       unit_issue IN VARCHAR2,
	       nomenclature IN VARCHAR2,
	       smr_code IN VARCHAR2,
	       nsn IN VARCHAR2,
	       planner_code IN VARCHAR2,
	       third_party_flag IN VARCHAR2,
	       mtbdr      IN NUMBER,
	       indenture IN VARCHAR2,
		   price IN NUMBER) RETURN NUMBER;
	
	 FUNCTION DeletePartInfo(
	       part_no IN VARCHAR2, nomenclature IN VARCHAR2) RETURN NUMBER ;
	
	 FUNCTION InsertPartLeadTime(
	        part_no IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       lead_time IN NUMBER) RETURN NUMBER;
	
	 FUNCTION UpdatePartLeadTime(
	        part_no IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       lead_time IN NUMBER) RETURN NUMBER;
	
	 FUNCTION DeletePartLeadTime(
	        part_no IN VARCHAR2) RETURN NUMBER;
	
	 FUNCTION InsertPartPricing(
	        part_no IN VARCHAR2,
	       price_type IN VARCHAR2,
	       unit_cost IN NUMBER) RETURN NUMBER;
	
	 FUNCTION UpdatePartPricing(
	        part_no IN VARCHAR2,
	       price_type IN VARCHAR2,
	       unit_cost IN NUMBER) RETURN NUMBER;
	
	 FUNCTION DeletePartPricing(
	        part_no IN VARCHAR2) RETURN NUMBER ;
	
	
	 FUNCTION InsertLocPartLeadTime(
	        part_no IN VARCHAR2,
	       loc_sid IN NUMBER,
	       location_name IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       time_to_repair IN NUMBER) RETURN NUMBER;
	
	 FUNCTION UpdateLocPartLeadTime(
	        part_no IN VARCHAR2,
	       loc_sid IN NUMBER,
	       location_name IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       time_to_repair IN NUMBER) RETURN NUMBER;
	
	 FUNCTION DeleteLocPartLeadTime(
	        part_no IN VARCHAR2,
	       loc_sid IN NUMBER,
	       location_name IN NUMBER) RETURN NUMBER;
	
	 PROCEDURE insertSiteRespAssetMgr(
	        assetMgr IN TMP_A2A_SITE_RESP_ASSET_MGR.SITE_RESP_ASSET_MGR%TYPE,
	       logonId  IN TMP_A2A_SITE_RESP_ASSET_MGR.TOOL_LOGON_ID%TYPE,
	       action_code IN TMP_A2A_SITE_RESP_ASSET_MGR.action_code%TYPE,
		   data_source in tmp_a2a_site_resp_asset_mgr.DATA_SOURCE%type) ;
		   
	    PROCEDURE deleteAllSiteRespAssetMgr  ;
	 PROCEDURE initSiteRespAssetMgr ;
	
	 procedure initA2ADemands ;
	
	 PROCEDURE initA2ASpoUsers ;
	
	
	 FUNCTION initA2APartInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
	
	 FUNCTION initA2AOrderInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
	
	 FUNCTION initA2ARepairInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
	
	 FUNCTION initA2AInTransits(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
	
	 FUNCTION initA2AInvInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
	
	 FUNCTION initA2ARepairInvInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
	 
	
	  PROCEDURE insertRepairInvInfo(part_no IN TMP_A2A_REPAIR_INV_INFO.part_no%TYPE,
	    site_location IN TMP_A2A_REPAIR_INV_INFO.site_location%TYPE,
	    inv_qty IN TMP_A2A_REPAIR_INV_INFO.QTY_ON_HAND%TYPE,
	    action_code IN TMP_A2A_REPAIR_INV_INFO.action_code%TYPE)  ;
	
	 PROCEDURE insertInvInfo(part_no IN TMP_A2A_INV_INFO.part_no%TYPE,
	    spo_location IN TMP_A2A_INV_INFO.site_location%TYPE ,
	    qty_on_hand IN TMP_A2A_INV_INFO.QTY_ON_HAND%TYPE,
	    action_code IN TMP_A2A_INV_INFO.action_code%TYPE)  ;
	
	 PROCEDURE insertRepairInfo(part_no IN TMP_A2A_REPAIR_INFO.part_no%TYPE,
	    loc_sid IN NUMBER,
	    doc_no IN TMP_A2A_REPAIR_INFO.doc_no%TYPE, -- order_sid
	    repair_date IN TMP_A2A_REPAIR_INFO.repair_date%TYPE,
	    status IN TMP_A2A_REPAIR_INFO.status%TYPE,
	    quantity IN TMP_A2A_REPAIR_INFO.quantity%TYPE /* repair_qty */,
		expected_completion_date IN TMP_A2A_REPAIR_INFO.expected_completion_date%TYPE,
	    action_code IN TMP_A2A_REPAIR_INFO.action_code%TYPE) ;
	
	 PROCEDURE insertTmpA2AOrderInfo(gold_order_number IN AMD_ON_ORDER.GOLD_ORDER_NUMBER%TYPE,
	     loc_sid IN AMD_ON_ORDER.LOC_SID%TYPE,
	     order_date IN AMD_ON_ORDER.ORDER_DATE%TYPE,
	     part_no IN AMD_ON_ORDER.PART_NO%TYPE,
	     order_qty IN AMD_ON_ORDER.ORDER_QTY%TYPE,
		 sched_receipt_date IN AMD_ON_ORDER.SCHED_RECEIPT_DATE%TYPE,
	     action_code IN TMP_A2A_ORDER_INFO.action_code%TYPE) ;
	
	
	  PROCEDURE insertTmpA2AInTransits(part_no IN AMD_IN_TRANSITS_SUM.part_no%TYPE,
	       site_location    IN AMD_IN_TRANSITS_SUM.site_location%TYPE,
	       quantity      IN AMD_IN_TRANSITS_SUM.quantity%TYPE,
	       serviceable_flag  IN AMD_IN_TRANSITS_SUM.serviceable_flag%TYPE,
	       action_code   IN TMP_A2A_IN_TRANSITS.action_code%TYPE) ;
	
	  FUNCTION wasPartSent(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN ;
	  FUNCTION wasPartSentYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 ;
	  FUNCTION isPartValid (partNo IN AMD_SPARE_PARTS.part_no%TYPE, showReason in boolean := false) RETURN BOOLEAN ;
	  FUNCTION isPartValidYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE, showReason in varchar2 := 'N') RETURN VARCHAR2 ;
	  FUNCTION isPlannerCodeAssigned2UserId(plannerCode IN VARCHAR2) RETURN BOOLEAN ;
	  FUNCTION isPlannerCodeAssign2UserIdYorN(plannerCode IN VARCHAR2) RETURN VARCHAR2 ;
	  FUNCTION isNsl(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN ;
	  FUNCTION isNslYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 ;
	
	   PROCEDURE spoUser(bems_id IN TMP_A2A_SPO_USERS.BEMS_ID%TYPE,
	  action_code IN TMP_A2A_SPO_USERS.ACTION_CODE%TYPE) ;
	
	PROCEDURE insertTmpA2ASpoUsers(bems_id IN TMP_A2A_SPO_USERS.bems_id%TYPE,
	       stable_email     IN TMP_A2A_SPO_USERS.EMAIL%TYPE,
	       last_name      IN VARCHAR2,
	       first_name  IN VARCHAR2,
	       action_code   IN TMP_A2A_IN_TRANSITS.action_code%TYPE) ;
	
	 PROCEDURE initA2APartLeadTime(useTestParts IN BOOLEAN := FALSE) ;
	 
	 PROCEDURE initA2ABomDetail(useTestParts IN BOOLEAN := FALSE) ;
	
	 PROCEDURE deletePartInfo(useTestParts IN BOOLEAN := FALSE) ;
	
	 FUNCTION getTimeToRepair(loc_sid  IN AMD_IN_REPAIR.loc_sid%TYPE,
	 		  part_no IN VARCHAR2) RETURN AMD_PART_LOCS.time_to_repair%TYPE ;
	
	 PROCEDURE deleteInvalidParts (testOnly IN BOOLEAN := FALSE) ;
	
	PROCEDURE populateBomDetail(part_no IN TMP_A2A_BOM_DETAIL.part_no%TYPE,
			  included_part IN TMP_A2A_BOM_DETAIL.INCLUDED_PART%TYPE,
			  action_code IN TMP_A2A_BOM_DETAIL.action_code%TYPE,
			  quantity IN TMP_A2A_BOM_DETAIL.QUANTITY%TYPE := Amd_Defaults.BOM_QUANTITY,
			  bom IN TMP_A2A_BOM_DETAIL.BOM%TYPE := Amd_Defaults.BOM,
			  begin_date IN TMP_A2A_BOM_DETAIL.BEGIN_DATE%TYPE := NULL,
			  end_date IN TMP_A2A_BOM_DETAIL.end_date%TYPE := NULL) ;
			  
	 start_dt DATE := TO_DATE('01/01/1990','MM/DD/YYYY') ;
	 
	 PROCEDURE initA2AInvInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
	 PROCEDURE initA2ARepairInvInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
	 PROCEDURE initA2AInTransits(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
	 PROCEDURE initA2ARepairInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
	 PROCEDURE initA2AOrderInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
	 PROCEDURE initA2APartInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
	 PROCEDURE initA2ABomDetail(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE ) ;
	 
	 PROCEDURE initA2ABackorderInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE ) ;
	 PROCEDURE initA2ABackorderInfo(useTestParts IN BOOLEAN := FALSE ) ;
	 
	 PROCEDURE initA2AExtForecast(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
	 PROCEDURE initA2AExtForecast(useTestParts IN BOOLEAN := FALSE ) ;
	
	 PROCEDURE loadAll(startStep IN NUMBER := 1, endStep IN NUMBER := 15, debugIt IN BOOLEAN := FALSE, system_id IN AMD_BATCH_JOBS.SYSTEM_ID%TYPE := 'LOAD_ALL_A2A') ;
	 FUNCTION getSendAllData RETURN BOOLEAN ;
	 PROCEDURE setSendAllData(theIndicator IN BOOLEAN) ;
	 PROCEDURE version ;
	 
	 FUNCTION includeOrder(gold_order_number IN AMD_ON_ORDER.gold_order_number%TYPE, 
	 		  			  order_date IN AMD_ON_ORDER.order_date%TYPE,
						  part_no in amd_on_order.part_no%type) RETURN BOOLEAN ;
						  
	 FUNCTION getDueDate(part_no in AMD_ON_ORDER.PART_NO%TYPE, order_date in AMD_ON_ORDER.ORDER_DATE%TYPE)  RETURN DATE ;

END A2a_Pkg ;
/

show errors

CREATE OR REPLACE PACKAGE AMD_PART_LOC_FORECASTS_PKG AS
 /*
      $Author:   zf297a  $
	$Revision:   1.8  $
        $Date:   Aug 18 2006 15:44:40  $
    $Workfile:   AMD_PART_LOC_FORECASTS_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PART_LOC_FORECASTS_PKG.pks.-arc  $
/*   
/*      Rev 1.8   Aug 18 2006 15:44:40   zf297a
/*   Added interface doExtforecast and made insertTmpA2A_EF_AllPeriods public.
/*   
/*      Rev 1.7   Jul 26 2006 10:10:42   zf297a
/*   Made getLatestRblRunBssm public.  Made getCurrentPeriod, setCurrentPeriod, getLatestRblRunAmd, and setLatestRblRunAmd public.
/*   
/*      Rev 1.6   Jul 26 2006 09:43:34   zf297a
/*   Made getCurrentPeriod a public routine.
/*   
/*      Rev 1.5   Jun 09 2006 12:16:58   zf297a
/*   added interface version
/*   
/*      Rev 1.4   May 12 2006 14:38:56   zf297a
/*   added action_code to type partLocForecastsRec.
/*   
/*      Rev 1.3   Feb 15 2006 21:52:10   zf297a
/*   Added a ref cursor, a type, and a common process routine.
/*   
/*      Rev 1.1   Jan 03 2006 07:56:40   zf297a
/*   Added procedure loadA2AByDate
/*   
/*      Rev 1.0   Dec 01 2005 09:44:12   zf297a
/*   Initial revision.
*/
	PARAMS_LATEST_RBL_RUN_DATE VARCHAR2(50) := 'ext_forecast_last_rbl_run_date' ;
	PARAMS_CURRENT_PERIOD_DATE VARCHAR2(50) := 'ext_forecast_current_period' ;
	ROLLING_PERIOD_MONTHS CONSTANT NUMBER := 60 ;
	PARAM_USER VARCHAR2(50) := 'bsrm_loader' ;
	DEMAND_FORECAST_TYPE VARCHAR2(10) := 'External' ;
	-- decimal precision for forecast_qty --
	DP CONSTANT NUMBER := 4 ;
	
	SUCCESS							CONSTANT NUMBER := 0 ;
	FAILURE							CONSTANT NUMBER := 4 ;
	type partLocForecastsRec is record (
		 part_no amd_part_loc_forecasts.PART_NO%type, 
		 spo_location amd_spare_networks.SPO_LOCATION%type, 
		 forecast_qty amd_part_loc_forecasts.FORECAST_QTY%type,
		 action_code amd_part_loc_forecasts.action_code%type
	) ;
	type partLocForecastsCur is ref cursor return partLocForecastsRec ;
	procedure processPartLocForecasts(partLocForecasts in partLocForecastsCur) ;
	
	FUNCTION getLatestRblRunBssm(lockName in bssm_locks.NAME%type) RETURN DATE ;
	
	FUNCTION getLatestRblRunAmd RETURN DATE ;
	PROCEDURE setLatestRblRunAmd(pRblRunDate DATE) ;
	
	FUNCTION getCurrentPeriod RETURN DATE ;
	PROCEDURE setCurrentPeriod(pCurrentPeriodDate DATE) ;
	
	FUNCTION GetFirstDateOfMonth(pDate DATE) RETURN DATE ;
	pragma restrict_references(GetFirstDateOfMonth, WNDS) ;
	
	/*
	 returns 1 if not empty, 0 if empty, -1 if any problem e.g.table not oracle table
	*/
	-- FUNCTION IsTableEmpty(pTableName VARCHAR2) RETURN NUMBER  ;
	
	FUNCTION InsertRow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE )
			return NUMBER ;
	
	FUNCTION Updaterow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE )
			RETURN NUMBER ;
	
	
	FUNCTION DeleteRow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE )
			RETURN NUMBER ;
	
	PROCEDURE LoadAllA2A ;
	PROCEDURE LoadInitial ;
	
	PROCEDURE LoadLatestRblRun ;
	PROCEDURE LoadTmpAmdPartLocForecasts_Add ;
	procedure loadA2AByDate(from_dt in date := a2a_pkg.start_dt, to_dt in date := sysdate) ;
	-- added 8/17/2006
	procedure doExtForecast ;
	-- added 8/18/2006
	PROCEDURE InsertTmpA2A_EF_AllPeriods(pPartNo VARCHAR2, pLocation VARCHAR2, pStartPeriod DATE, pQty NUMBER, pActionCode VARCHAR2, pLastUpdateDt DATE ) ;
	
	-- added 6/9/2006 by dse
	procedure version ;

END AMD_PART_LOC_FORECASTS_PKG ;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_PART_LOCS_LOAD_PKG
AS
    /*

       $Author:   zf297a  $
     $Revision:   1.7  $
         $Date:   Jun 09 2006 12:12:08  $
     $Workfile:   amd_part_locs_load_pkg.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_part_locs_load_pkg.pks-arc  $
   
      Rev 1.7   Jun 09 2006 12:12:08   zf297a
   added interface version

      Rev 1.6   Jun 13 2005 09:19:04   c970183
   Added PVCS keywords

*/

  	   	-------------------------------------------------------------------
		--
		-- SCCSID: amd_part_locs_load_pkg.sql  1.1  Modified: 08/14/02 17:11:22
		--
	   	--  Date	  	  By			History
	   	--  ----		  --			-------
	   	--  10/10/01	  	  ks		initial implementation
	   	--  12/11/01	  	  dse		Added named param for amd_preferred_pkg.GetUnitCost(.....
	   	--  8/14/02		  ks            change fsl query to be more efficient.
		--  6/01/05		  ks		changes to support AMD 1.7.1 - change to RSP_ON_HAND, RSP_OBJECTIVE
		--					change rampData_rec to be whole record,
		--					mod to queries for bssm, eg. lock_sid use '0' instead of 0
		-------------------------------------------------------------------


		-- added ROR to previous part_locations, since table now combines old amd_repair_levels
	   	-- too, which had MOB, FSL, ROR. also adding each part to warehouse as part/loc list since
	   	-- child table amd_part_loc_time_periods may provide ROP/ROQ info for warehouse, especially
	   	-- for consumables.
  OFFBASE_LOCID constant varchar2(30) := 'OFFBASE';
  COMMIT_AFTER constant number := 10000;
  -- data fields match cursor and database field names
  -- wrm relates to rsp
  /*
  type rampData_rec is record (
  	   date_processed date,
	   avg_repair_cycle_time number,
	   percent_base_condem number,
	   percent_base_repair number,
	   wrm_level number,
	   wrm_balance number );
  function GetRampData(pNsn ramp.nsn%type, pLocId amd_spare_networks.loc_id%type) return rampData_rec;
  function GetRampData(pNsn ramp.nsn%type, pLocSid amd_spare_networks.loc_sid%type) return rampData_rec;
  */

  function GetRampData(pNsn ramp.nsn%type, pLocId amd_spare_networks.loc_id%type) return ramp%ROWTYPE ;
  function GetRampData(pNsn ramp.nsn%type, pLocSid amd_spare_networks.loc_sid%type) return ramp%ROWTYPE ;
  procedure LoadAmdPartLocations;
  
  -- added 6/9/2006 by dse
  procedure version ;
  
END AMD_PART_LOCS_LOAD_PKG;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_PART_FACTORS_PKG AS

 /*
      $Author:   zf297a  $
	$Revision:   1.3  $
        $Date:   Jun 09 2006 12:02:52  $
    $Workfile:   AMD_PART_FACTORS_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PART_FACTORS_PKG.pks.-arc  $
/*   
/*      Rev 1.3   Jun 09 2006 12:02:52   zf297a
/*   added interface version
/*   
/*      Rev 1.2   Jan 03 2006 13:03:18   zf297a
/*   Added date range to procedure loadA2AByDate
/*   
/*      Rev 1.1   Jan 03 2006 08:07:42   zf297a
/*   Added procedure loadA2AByDate
/*
/*      Rev 1.0   Oct 31 2005 08:04:54   zf297a
/*   Initial revision.
*/

	DEFAULT_WHSE_COND CONSTANT NUMBER := .005 ;
	CRITICALITY_REPAIRABLE_DEFAULT	CONSTANT amd_national_stock_items.criticality%TYPE := .5 ;
		--  consumable not defined yet, placeholder for when defined
	CRITICALITY_CONSUMABLE_DEFAULT	CONSTANT amd_national_stock_items.criticality%TYPE :=  0 ;
	
		-- calcs done to 4 decimal places
	DP CONSTANT NUMBER := 4 ;
	COMMITAFTER CONSTANT NUMBER := 100000 ;
	SUCCESS		CONSTANT NUMBER := 0 ;
	FAILURE		CONSTANT NUMBER := 4 ;
	
	
	
	
	PROCEDURE LoadTmpAmdPartFactors ;
	PROCEDURE ProcessA2AVirtualLocs ;
	PROCEDURE ProcessA2AVirtualLocs( pDoAllA2A boolean, pVirtSpoLocation amd_spare_networks.LOC_ID%TYPE ) ;
	PROCEDURE LoadInitial ;
	PROCEDURE LoadAllA2A ;
	procedure loadA2AByDate(from_dt in date := a2a_pkg.start_dt, to_dt in date := sysdate) ;
	
	
	
	
	/* current spec says to send a auto default nrts, rts, cond to vub, vcd, basc,
	   others - mob, fsl, ctlatl, uk will use #'s from best spares.
	   Below function will have to be maintained at this point for which
	   locations are autodefaulted and which are not */
	FUNCTION IsAutoDefaulted(pLocRow amd_spare_networks%ROWTYPE ) RETURN boolean ;
	
	FUNCTION InsertRow(
			pPartNo                      amd_part_factors.part_no%TYPE,
			pLocSid                      amd_part_factors.loc_sid%TYPE,
			pPassUpRate					 amd_part_factors.pass_up_rate%TYPE ,
			pRts						 amd_part_factors.rts%TYPE ,
			pCmdmdRate					 amd_part_factors.cmdmd_rate%TYPE ,
			pCriticality				 amd_national_stock_items.criticality%TYPE,
			pCriticalityChanged			 amd_national_stock_items.criticality_changed%TYPE,
			pCriticalityCleaned			 amd_national_stock_items.criticality_cleaned%TYPE )
			return NUMBER ;
	
	FUNCTION UpdateRow(
			pPartNo                      amd_part_factors.part_no%TYPE,
			pLocSid                      amd_part_factors.loc_sid%TYPE,
			pPassUpRate					 amd_part_factors.pass_up_rate%TYPE ,
			pRts						 amd_part_factors.rts%TYPE ,
			pCmdmdRate					 amd_part_factors.cmdmd_rate%TYPE ,
			pCriticality				 amd_national_stock_items.criticality%TYPE,
			pCriticalityChanged			 amd_national_stock_items.criticality_changed%TYPE,
			pCriticalityCleaned			 amd_national_stock_items.criticality_cleaned%TYPE )							RETURN NUMBER ;
	
	
	FUNCTION DeleteRow(
			pPartNo                      amd_part_factors.part_no%TYPE,
			pLocSid                      amd_part_factors.loc_sid%TYPE,
			pPassUpRate					 amd_part_factors.pass_up_rate%TYPE ,
			pRts						 amd_part_factors.rts%TYPE ,
			pCmdmdRate					 amd_part_factors.cmdmd_rate%TYPE ,
			pCriticality				 amd_national_stock_items.criticality%TYPE,
			pCriticalityChanged			 amd_national_stock_items.criticality_changed%TYPE,
			pCriticalityCleaned			 amd_national_stock_items.criticality_cleaned%TYPE )		RETURN NUMBER ;
	
	FUNCTION GetRepairIndicator(pNsn bssm_base_parts.nsn%TYPE, pSran bssm_base_parts.sran%TYPE, pLockSid bssm_locks.LOCK_SID%TYPE) RETURN VARCHAR2 ;
	pragma restrict_references(GetRepairIndicator, WNDS) ;
	
	-- added 6/9/2006 by dse
	procedure version ;



END AMD_PART_FACTORS_PKG ;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_PARTPRIME_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
     $Date:   Jun 09 2006 12:07:00  $
    $Workfile:   AMD_PARTPRIME_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PARTPRIME_PKG.pks.-arc  $
/*   
/*      Rev 1.1   Jun 09 2006 12:07:00   zf297a
/*   added interface version
/*   
/*      Rev 1.0   Dec 01 2005 09:41:48   zf297a
/*   Initial revision.
*/
   	  /* The following "getSuperPrime" functions
	  	 first checks for a super relationship in bssm_rbl_pairs.
		 if super relationship not available or super relationship part does not meet
		 minimum a2a requirement (i.e. exists in AMD_SENT_TO_A2A with action_code != 'D')
		 it will use the prime in amd_national_stock_items - however at this point
		 it does not check if the prime in amd_national_stock_items meets minimum a2a requirement */
	   FUNCTION getSuperPrimePart(pPart VARCHAR2) RETURN VARCHAR2 ;
   	   FUNCTION getSuperPrimePartByNsiSid(pNsiSid NUMBER) RETURN VARCHAR2 ;
	   FUNCTION getSuperPrimeNsiSid(pPart VARCHAR2) RETURN NUMBER ;
	   FUNCTION getSuperPrimeNsiSidByNsn(pNsn VARCHAR2) RETURN NUMBER ;
   	   FUNCTION getSuperPrimeNsiSidByNsiSid(pNsiSid NUMBER) RETURN NUMBER ;


	   -- The following takes into account if returned value also meets minimum a2a requirments
	   FUNCTION getSuperPrimeNsiSidByNsn_A2A(pNsn VARCHAR2) RETURN NUMBER ;

	   PROCEDURE DiffPartToPrime ;
	   -- added 11/11/05 dse
	   FUNCTION getPrimePartAMD(pNsn VARCHAR2)
		 RETURN VARCHAR2 ;

	   FUNCTION getNsn(pPart VARCHAR2)
		 RETURN VARCHAR2 ;

		 -- added 6/9/2006 by dse
		 procedure version ;


END amd_partprime_pkg ;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_org_deployment_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.2  $
     $Date:   Jun 09 2006 12:38:10  $
    $Workfile:   amd_org_deployment_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_org_deployment_pkg.pks-arc  $
/*   
/*      Rev 1.2   Jun 09 2006 12:38:10   zf297a
/*   added interface version
/*   
/*      Rev 1.1   Dec 01 2005 09:39:04   zf297a
/*   added pvcs keywords
*/
  PROCEDURE load_org_deployment;
  
  -- added 6/9/2006 by dse
  procedure version ;
  
END amd_org_deployment_pkg;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_on_order_date_filters_pkg AS
/******************************************************************************
       $Author:   zf297a  $
     $Revision:   1.4  $
         $Date:   Jun 09 2006 12:34:00  $
     $Workfile:   AMD_ON_ORDER_DATE_FILTERS_PKG.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_ON_ORDER_DATE_FILTERS_PKG.pks.-arc  $
/*   
/*      Rev 1.4   Jun 09 2006 12:34:00   zf297a
/*   added interface version
/*   
/*      Rev 1.3   May 17 2006 14:58:36   zf297a
/*   removed start_date - not needed
/*
/*      Rev 1.2   May 17 2006 14:21:24   zf297a
/*   Added setScheduledReceiptDateCalDays and
/*   getScheduledReceiptDateCalDays
/*
/*      Rev 1.1   May 17 2006 13:25:08   zf297a
/*   Implemented procedures and functions using amd_on_order_date_filters table.
/*
/*      Rev 1.0   May 17 2006 12:24:26   zf297a
/*   Initial revision.
******************************************************************************/

	sched_receipt_date_exception EXCEPTION ;

	FUNCTION getOrderCreateDate(filter_name in amd_on_order_date_filters.FILTER_NAME%type, voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE ;
	PROCEDURE setOrderCreateDate(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  					voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
								orderCreateDate IN amd_on_order_date_filters.ORDER_CREATE_DATE%type) ;

	FUNCTION getScheduledReceiptDateFrom(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			 				voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE ;

	FUNCTION getScheduledReceiptDateTo(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			 				voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE ;

	PROCEDURE setScheduledReceiptDates(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										fromDate IN DATE, toDate DATE) ;

	procedure getScheduledReceiptDateCalDays(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										calendar_days out amd_on_order_date_filters.CALENDAR_DAYS%type ) ;

	PROCEDURE setScheduledReceiptDateCalDays(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										calendar_days IN NUMBER) ;

	PROCEDURE getOnOrderDateFilters(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
			  orderCreateDate 		  OUT amd_on_order_date_filters.ORDER_CREATE_DATE%type,
			  schedReceiptDateFrom 	  OUT amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_FROM%type,
			  schedReceiptDateTo 	  OUT amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_TO%type,
			  schedReceiptCalDays 	  OUT amd_on_order_date_filters.CALENDAR_DAYS%type) ;

	PROCEDURE setOnOrderDateFilters(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
			  orderCreateDate 		  in amd_on_order_date_filters.ORDER_CREATE_DATE%type,
			  schedReceiptDateFrom 	  in amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_FROM%type,
			  schedReceiptDateTo 	  in amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_TO%type,
			  schedReceiptCalDays 	  in amd_on_order_date_filters.CALENDAR_DAYS%type) ;

	FUNCTION isVoucher(voucher IN VARCHAR2) RETURN BOOLEAN ;
	PROCEDURE clearOnOrderParams(filter_name in amd_on_order_date_filters.FILTER_NAME%type) ;
	FUNCTION numberOfOnOrderParams(filter_name in amd_on_order_date_filters.FILTER_NAME%type) RETURN NUMBER ;
	TYPE ref_cursor IS REF CURSOR ;
	FUNCTION getVouchers RETURN ref_cursor ;
	
	-- added 6/9/2006 by dse
	procedure version ;

END amd_on_order_date_filters_pkg;
/

show errors

CREATE OR REPLACE PACKAGE Amd_Location_Part_Override_Pkg AS
 /*
      $Author:   zf297a  $
	$Revision:   1.10  $
        $Date:   Aug 24 2006 10:33:28  $
    $Workfile:   AMD_LOCATION_PART_OVERRIDE_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_LOCATION_PART_OVERRIDE_PKG.pks.-arc  $
/*   
/*      Rev 1.10   Aug 24 2006 10:33:28   zf297a
/*   Added a constant for the loc_sid warehouse value
/*   
/*      Rev 1.9   Jun 09 2006 11:55:42   zf297a
/*   added interface version
/*   
/*      Rev 1.8   Apr 28 2006 13:15:54   zf297a
/*   Added the interface for loadRspZeroTslA2A
/*   
/*      Rev 1.7   Apr 21 2006 13:50:40   zf297a
/*   Added isInTmpA2A, isInTmpA2AYorN, loadZeroTslByDate, and InsertTmpA2ALPO
/*   
/*      Rev 1.6   Feb 24 2006 15:08:32   zf297a
/*   Modified the interfaces for some TSL procedures and load procedures.
/*   
/*      Rev 1.5   Feb 15 2006 21:22:54   zf297a
/*   Added ref cursor's, type's and common process routines.
/*   
/*      Rev 1.4   Jan 03 2006 12:56:26   zf297a
/*   Added date range to procedures loadZeroTslA2AByDate and loadA2AByDate
/*   
/*      Rev 1.3   Jan 03 2006 09:13:06   zf297a
/*   Changed name from loadByDate to loadA2AByDate
/*   
/*      Rev 1.2   Dec 30 2005 01:20:08   zf297a
/*   add loadByDate
/*
/*      Rev 1.1   Nov 10 2005 11:10:46   zf297a
/*   Added interfaces getInsertCnt, getDeleteCnt, and getUpdateCnt.  Changed the interface for LoadAllA2A to have an optional boolean argument that can control the use of "test data".
/*
/*      Rev 1.0   Oct 18 2005 19:12:48   c394547
/*   Initial revision.
		 */

	OVERRIDE_TYPE CONSTANT VARCHAR2(32) := 'TSL Fixed' ;
	OVERRIDE_REASON CONSTANT VARCHAR2(64) := 'Fixed TSL Load' ;
	THE_WAREHOUSE CONSTANT VARCHAR2(6) := 'FD2090' ;
	THE_WAREHOUSE_LOC_SID NUMBER := 256 ;
	
	BULKLIMIT CONSTANT NUMBER := 100000 ;
	COMMITAFTER CONSTANT NUMBER := 100000 ;
	SUCCESS							CONSTANT NUMBER := 0 ;
	FAILURE							CONSTANT NUMBER := 4 ;
	
	
	TYPE locPartOverrideRec IS RECORD (
		 part_no AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
		 site_location AMD_SPARE_NETWORKS.SPO_LOCATION%TYPE,
		 override_type VARCHAR2(32),
	     override_quantity AMD_LOCATION_PART_OVERRIDE.TSL_OVERRIDE_QTY%TYPE,
		 override_reason VARCHAR2(64),
		 tsl_override_user AMD_LOCATION_PART_OVERRIDE.TSL_OVERRIDE_USER%TYPE,
		 begin_date DATE,
		 end_date DATE,
		 action_code AMD_LOCATION_PART_OVERRIDE.ACTION_CODE%TYPE,
		 last_update_dt AMD_LOCATION_PART_OVERRIDE.LAST_UPDATE_DT%TYPE
	) ;
	
	TYPE tslRec IS RECORD (
		 spo_prime_part_no AMD_SENT_TO_A2A.SPO_PRIME_PART_NO%TYPE,
		 action_code AMD_SENT_TO_A2A.ACTION_CODE%TYPE,
		 transaction_date AMD_SENT_TO_A2A.TRANSACTION_DATE%TYPE,
		 spo_location AMD_SPARE_NETWORKS.SPO_LOCATION%TYPE,
		 nsn AMD_NATIONAL_STOCK_ITEMS.nsn%TYPE,
		 nsi_sid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE,
		 override_quantity AMD_LOCATION_PART_OVERRIDE.TSL_OVERRIDE_QTY%TYPE
	) ;
	
	TYPE locPartOverrideCur IS REF CURSOR RETURN locPartOverrideRec ;
	TYPE tslCur IS REF CURSOR RETURN tslRec ;
	
	PROCEDURE processLocPartOverride(locPartOverride IN locPartOverrideCur) ;
	PROCEDURE processTsl(tsl IN tslCur, pDoAllA2A IN BOOLEAN) ;
	
	PROCEDURE LoadInitial ;
	PROCEDURE loadA2AByDate( from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE) ;
	PROCEDURE LoadAllA2A (useTestData IN BOOLEAN := FALSE, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE) ;
	PROCEDURE LoadZeroTslA2A(doAllA2A IN BOOLEAN := FALSE, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE) ;
	PROCEDURE LoadTmpAmdLocPartOverride ;
	PROCEDURE LoadZeroTslA2A(pDoAllA2A BOOLEAN, pSpoLocation VARCHAR2, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE)   ;
	
	
	FUNCTION InsertRow(
			pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			pTslOverrideQty				 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
			pTslOverrideUser			 AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
			RETURN NUMBER ;
	
	FUNCTION Updaterow(
			pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			pTslOverrideQty				 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
			pTslOverrideUser			 AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
			RETURN NUMBER ;
	
	
	
	FUNCTION DeleteRow(
			pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			pTslOverrideQty				 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
			pTslOverrideUser			 AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
			RETURN NUMBER ;
	
			-- return Y or N
	FUNCTION IsNumeric(pString VARCHAR2) RETURN VARCHAR2 ;
	PRAGMA RESTRICT_REFERENCES(IsNumeric, WNDS) ;
	
	-- testing
	FUNCTION GetFirstLogonIdForPart(pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE) RETURN AMD_PLANNER_LOGONS.logon_id%TYPE ;
	-- added 11/7/05 dse
	FUNCTION getInsertCnt RETURN NUMBER ;
	FUNCTION getUpdateCnt RETURN NUMBER ;
	FUNCTION getDeleteCnt RETURN NUMBER ;
	
	-- added 02/23/2006 dse
	-- these functions allow  stand alone SQL to use the package constants
	FUNCTION getOVERRIDE_TYPE RETURN VARCHAR2 ;
	FUNCTION getOVERRIDE_REASON RETURN VARCHAR2 ;
	FUNCTION getBULKLIMIT RETURN NUMBER ;
	FUNCTION getCOMMITAFTER RETURN NUMBER ;
	FUNCTION getSUCCESS RETURN NUMBER ;
	FUNCTION getFAILURE RETURN NUMBER ;
	FUNCTION getTHE_WAREHOUSE RETURN VARCHAR2 ;
	FUNCTION isInTmpA2AYorN(part_no IN TMP_A2A_LOC_PART_OVERRIDE.part_no%TYPE, site_location IN TMP_A2A_LOC_PART_OVERRIDE.SITE_LOCATION%TYPE) RETURN VARCHAR2 ;
	FUNCTION isInTmpA2A(part_no IN TMP_A2A_LOC_PART_OVERRIDE.part_no%TYPE, site_location IN TMP_A2A_LOC_PART_OVERRIDE.SITE_LOCATION%TYPE) RETURN BOOLEAN ;
	 
	PROCEDURE loadZeroTslA2APartsWithNoTsls(doAllA2A IN BOOLEAN := FALSE, useTestData IN BOOLEAN := FALSE ) ;
	PROCEDURE loadRspZeroTslA2A(doAllA2A IN BOOLEAN := FALSE, useTestData in boolean := false) ;
	PROCEDURE loadZeroTslA2A4DelSpoPrimParts(doAllA2A IN BOOLEAN := FALSE, useTestData IN BOOLEAN := FALSE) ;
	PROCEDURE loadTslA2AWarehouseParts(doAllA2A IN BOOLEAN := FALSE, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE) ;
	
	PROCEDURE loadZeroTslA2AByDate(pDoAllA2A IN BOOLEAN, 
			  from_dt IN DATE, to_dt IN DATE, pSpolocation IN VARCHAR2) ;
	
	FUNCTION insertedTmpA2ALPO (
				  pPartNo			TMP_A2A_LOC_PART_OVERRIDE.part_no%TYPE,
				  pBaseName			TMP_A2A_LOC_PART_OVERRIDE.site_location%TYPE,
				  pOverrideType		TMP_A2A_LOC_PART_OVERRIDE.override_type%TYPE,
				  pTslOverrideQty	TMP_A2A_LOC_PART_OVERRIDE.override_quantity%TYPE,
				  pOverrideReason	TMP_A2A_LOC_PART_OVERRIDE.override_reason%TYPE,
				  pTslOverrideUser	TMP_A2A_LOC_PART_OVERRIDE.override_user%TYPE,
				  pBeginDate		TMP_A2A_LOC_PART_OVERRIDE.begin_date%TYPE,
				  pActionCode		TMP_A2A_LOC_PART_OVERRIDE.action_code%TYPE,
				  pLastUpdateDt		TMP_A2A_LOC_PART_OVERRIDE.last_update_dt%TYPE
				  ) RETURN BOOLEAN ;
	
	-- added 6/9/2006 by dse
	procedure version ;
	
	-- added 9/1/2006 by dse		
	procedure LoadOverrideUsers ;
		
END Amd_Location_Part_Override_Pkg ;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.7  $
	    $Date:   Jun 12 2006 13:22:08  $
    $Workfile:   AMD_LOCATION_PART_LEADTIME_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_LOCATION_PART_LEADTIME_PKG.pks.-arc  $
/*   
/*      Rev 1.7   Jun 12 2006 13:22:08   zf297a
/*   added symbolic constants for UK_LOCATION and BASC_LOCATION.
/*   
/*      Rev 1.6   Jun 09 2006 11:50:52   zf297a
/*   added interface version
/*   
/*      Rev 1.5   Mar 03 2006 12:18:56   zf297a
/*   Removed IsLatestRun and GetBatchRunStart.  GetBatchRunStart is being replaced by amd_batch_pkg.getLastStartTime since it will always return the last start time of the last job that has been run even if it has already completed.  That way if data has changed since the start of the last batch job, then it should be sent in an a2a transaction.  This may cause the same data to be sent again but that is not a problem.
/*   
/*      Rev 1.4   Feb 15 2006 14:00:46   zf297a
/*   Added cur ref, record type and a common process routine so that the data gets loaded the same no matter what selection criteria is used.
/*   
/*      Rev 1.3   Jan 04 2006 10:07:38   zf297a
/*   Made loadAllA2A and loadA2AByDate conform to the a2a_pkg.initA2A procedures.
/*   
/*      Rev 1.2   Jan 03 2006 12:45:50   zf297a
/*   Added date range to procedure loadA2AByDate
/*   
/*      Rev 1.1   Dec 29 2005 16:29:58   zf297a
/*   Added loadA2AByDate procedure
/*   
/*      Rev 1.0   Nov 30 2005 12:40:00   zf297a
/*   Initial revision.
/*   
/*      Rev 1.0   Nov 30 2005 12:31:04   zf297a
/*   Initial revision.
*/	

	VIRTUAL_COD_SPO_LOCATION CONSTANT VARCHAR2(15) := 'VIRTUAL COD' ;
	VIRTUAL_UAB_SPO_LOCATION CONSTANT VARCHAR2(15) := 'VIRTUAL UAB' ;
	UK_LOCATION 			 CONSTANT varchar2(6)  := 'EY8780' ;
	BASC_LOCATION			 CONSTANT varchar2(6)  := 'EY1746' ;
	
	LEADTIMETYPE 			 CONSTANT VARCHAR2(6) := 'REPAIR' ;
	
	BULKLIMIT 	 		  			CONSTANT NUMBER := 100000 ;
	SUCCESS							CONSTANT NUMBER := 0 ;
	FAILURE							CONSTANT NUMBER := 4 ;
	
	type locationPartLeadTimeRec is record  (
		part_no amd_location_part_leadtime.part_no%type,
		lead_time_type varchar2(6),
		time_to_repair amd_location_part_leadtime.TIME_TO_REPAIR%type,
		action_code amd_location_part_leadtime.action_code%type,
		last_update_dt date,
		site_location tmp_a2a_loc_part_lead_time.site_location%type
	) ;
	
	type locPartLeadTimeCur is ref cursor return locationPartLeadTimeRec ;
	procedure processLocPartLeadtime(locPartLeadTime in locPartLeadTimeCur) ;
	
	FUNCTION IsPartRepairable(pNsiSid amd_national_stock_items.nsi_sid%TYPE ) RETURN VARCHAR2 ;
	FUNCTION IsPartRepairable(pPartNo amd_spare_parts.part_no%TYPE ) RETURN VARCHAR2 ;
	-- pragma restrict_references (IsPartRepairable, WNDS) ;
	FUNCTION IsPartDeleted(pPartNo amd_sent_to_a2a.part_no%TYPE) RETURN BOOLEAN ;
	FUNCTION GetAvgRepairCycleTime(pNsn amd_nsns.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) RETURN ramp.avg_repair_cycle_time%TYPE ;
	FUNCTION GetRampData(pNsn amd_nsns.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) RETURN ramp%ROWTYPE ;
	pragma restrict_references (GetRampData, WNDS) ;
	pragma restrict_references (GetAvgRepairCycleTime, WNDS) ;
	
	
	-- load procedure will truncate tmp_amd_location_part_leadtime prior to loading
	
	FUNCTION InsertRow(
			pPartNo                      amd_location_part_leadtime.part_no%TYPE,
			pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
			pTimeToRepair				 amd_location_part_leadtime.time_to_repair%TYPE)
			return NUMBER ;
	
	FUNCTION Updaterow(
			pPartNo                      amd_location_part_leadtime.part_no%TYPE,
			pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
			pTimeToRepair				 amd_location_part_leadtime.time_to_repair%TYPE)
			RETURN NUMBER ;
	
	
	FUNCTION DeleteRow(
			pPartNo                      amd_location_part_leadtime.part_no%TYPE,
			pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
			pTimeToRepair				 amd_location_part_leadtime.time_to_repair%TYPE)
			RETURN NUMBER ;
	
	
	
	PROCEDURE LoadTmpAmdLocPartLeadtime ;
	PROCEDURE LoadAmdLocPartLeadtime ;
	PROCEDURE LoadAllA2A(useTestParts in boolean := false) ;
	procedure loadA2AByDate (from_dt in date := a2a_pkg.start_dt, to_dt in date := sysdate) ;
	PROCEDURE LoadInitial ;

	-- added 6/9/2006 by dse
	procedure version ;

END AMD_LOCATION_PART_LEADTIME_PKG ;
/

show errors

CREATE OR REPLACE PACKAGE amd_load as
    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.15  $
         $Date:   Jun 09 2006 11:44:42  $
     $Workfile:   amd_load.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_load.pks-arc  $
   
      Rev 1.15   Jun 09 2006 11:44:42   zf297a
   added interface version

      Rev 1.14   Mar 20 2006 08:57:00   zf297a
   Added  "Future use" comments

      Rev 1.13   Mar 16 2006 15:07:46   zf297a
   Added exception no_active_job

      Rev 1.12   Mar 16 2006 10:36:08   zf297a
   Exposed functions and procedures to allow for easy unit testing.

      Rev 1.11   Mar 05 2006 21:19:14   zf297a
   Added interfaces for loadGoldPsmsMain, preProcess, postProcess, postDiffProcess, prepAmdDatabase, disableAmdConstraints, truncateAmdTables, and enableAmdConstraints to simplify the amd_loader.ksh script.

      Rev 1.10   Aug 16 2005 14:12:30   zf297a
   removed loadCurrentBackorder

      Rev 1.9   Aug 04 2005 13:34:44   zf297a
   Added interfaces for Users diff.

      Rev 1.8   Aug 04 2005 07:06:14   zf297a
   Made functions 	GetOffBaseRepairCost and GetOffBaseTurnAround public.

      Rev 1.7   Jul 26 2005 12:31:44   zf297a
   added function getBemsId.  This function will return a bems_id for an employee_no as defined in amd_use1.  The function will remove any semi colon or trailing alpha character.  If the the employee_no is the 'clock number' it will retrieve the bems_id via the emp_id of the amd_people_all_v.

      Rev 1.6   Jul 19 2005 14:22:50   zf297a
   added procedure loadUsers - populates the amd_users table and sends inserts, updates, and deletes via the a2a_pgk.spoUser procedure.

      Rev 1.5   Jun 09 2005 14:58:58   c970183
   Added insert, update, and delete routines for the amd_planners diff and the amd_planner_logons diff.

      Rev 1.4   May 17 2005 10:20:14   c970183
   Added PVCS keywords
*/
	--
	-- SCCSID: amd_load.sql  1.21  Modified: 10/25/04 10:35:34
	--
	-- Date     By     History
	-- -------- -----  ---------------------------------------------------
	-- 09/28/01 FF     Initial implementation
	-- 10/22/01 FF     Removed references to venc, venn from LoadGold().
	-- 10/23/01 FF     Changed exception in LoadTempNsns() and passed GOLD
	--                 smr_code if nothing else.
	-- 10/30/01 FF     Fixed getPrime() to look at all records for a '17P','17B'
	--                 match.
	-- 11/02/01 FF     Fixed logic in LoadTempNsns() to include GetPrime() and
	--                 associate logic.
	-- 11/12/01 FF     Fixed LoadGold() to use the part as prime for ANY NSL
	--                 that gets an nsn from BSSM other than of the form NSL#.
	-- 11/15/01 FF     Mod LoadGold() and LoadMain() to let equiv parts get
	--                 values from prime for item_type,order_quantity,
	--                 planner_code and smr_code.
	-- 11/19/01 FF     Mod LoadTempNsns to ignore the last 2 char's of the nsn
	--                 if they are not numeric.
	-- 11/21/01 FF     Removed references to gold_mfgr_cage.
	-- 11/29/01 FF     Fixed LoadTempNsns() and added lock_sid=0 condition
	--                 to cursor in LoadTempNsns().
	-- 12/10/01 FF     Fixed cursor in LoadTempNsns() to link with
	--                 amd_spare_parts.
	-- 12/21/01 FF     Added acquisition_advice_code.
	-- 01/28/02 FF     Added "FROM" column as temp nsns to LoadTempNsns().
	-- 02/19/02 FF     Added logic for manuf_cage to GetPrime().
	-- 02/25/02 FF     Fixed GetPrime() priority logic.
	-- 03/05/02 FF     Added logic to unit_cost code to look at po's with 9
	--                 characters only.
	-- 03/18/02 FF     The noun field is no longer truncated.
	-- 04/03/02 FF     Populated mic in tmp_amd_spare_parts.
	-- 06/04/02 FF     Removed debug record limiter.
	-- 06/14/02 FF     Changed references to PSMS to use synonyms.
	-- 07/05/02 FF     Changed references to PSMV to use synonyms.
	-- 10/14/02 FF     Mod'ed loadGold() to blindly assign the part as a prime
	--                 only if sequenceTheNsl() returned an nsn of type NSL.
	-- 11/05/02 FF     Get unit_cost from gold.prc1 instead of tmp_main. This
	--                 is now done in loadGold() instead of loadMain().
	-- 02/21/03 FF     Added performLogicalDelete() to allow NSL's to get
	--                 their own sid.
	-- 09/22/04 TP	   Changed how we pull SMR Code from PSMS to GOLD .
	--

	-- expose the following functions and procedures to allow for easy routine validation and unit testing
	no_active_job exception ;

	FUNCTION  IsValidSmr(pSmrCode VARCHAR2) RETURN BOOLEAN;
	FUNCTION  GetSmr(pPsmsInst VARCHAR2, pPart VARCHAR2, pCage VARCHAR2) RETURN VARCHAR2;
	FUNCTION  GetPrime(pNsn CHAR) RETURN VARCHAR2;
	FUNCTION  getMic(pNsn VARCHAR2) RETURN VARCHAR2;
	FUNCTION  getUnitCost(pPartNo VARCHAR2) RETURN NUMBER;
	FUNCTION  GetPsmsInstance (pPart VARCHAR2, pCage VARCHAR2) RETURN VARCHAR2;
	FUNCTION  GetItemType(pSmrCode VARCHAR2) RETURN VARCHAR2;
	FUNCTION  getMmac(pNsn VARCHAR2) RETURN VARCHAR2;
	FUNCTION  onNsl(pPartNo VARCHAR2) RETURN BOOLEAN;

	procedure getOriginalBssmData(nsn in amd_nsns.nsn%type,
		 part_no in bssm_owner.bssm_parts.PART_NO%type,
		 condemn_avg out amd_national_stock_items.condemn_avg%type,
		 criticality out amd_national_stock_items.criticality%type,
		 mtbdr_computed out amd_national_stock_items.mtbdr_computed%type,
		 nrts_avg out amd_national_stock_items.nrts_avg%type,
		 rts_avg out amd_national_stock_items.rts_avg%type) ;

	procedure getCleanedBssmData(nsn in amd_nsns.nsn%type,
		part_no 				in bssm_owner.bssm_parts.part_no%type,
		condemn_avg_cleaned 	out amd_national_stock_items.condemn_avg_cleaned%type,
		criticality_cleaned 	out amd_national_stock_items.criticality_cleaned%type,
		mtbdr_cleaned 			out amd_national_stock_items.mtbdr_cleaned%type,
		nrts_avg_cleaned 		out amd_national_stock_items.nrts_avg_cleaned%type,
		rts_avg_cleaned 		out amd_national_stock_items.rts_avg_cleaned%type,
		order_lead_time_cleaned out amd_national_stock_items.order_lead_time_cleaned%type,
		planner_code_cleaned 	out amd_national_stock_items.planner_code_cleaned%type,
		smr_code_cleaned 		out amd_national_stock_items.smr_code_cleaned%type,
		unit_cost_cleaned 		out amd_national_stock_items.unit_cost_cleaned%type,
		cost_to_repair_off_base_cleand out amd_national_stock_items.cost_to_repair_off_base_cleand%type,
		time_to_repair_off_base_cleand out amd_national_stock_items.time_to_repair_off_base_cleand%type) ;

	PROCEDURE getRmadsData (part_no in amd_rmads_source_tmp.part_no%type, qpei_weighted out amd_rmads_source_tmp.QPEI_WEIGHTED%type,
		mtbdr out amd_rmads_source_tmp.MTBDR%type) ;

	PROCEDURE GetPsmsData(pPartNo VARCHAR2, pCage VARCHAR2, pPsmsInst VARCHAR2,
			  pSlifeDay OUT NUMBER, pUnitVol  OUT NUMBER, pSmrCode  OUT VARCHAR2);


	procedure LoadGold;
	procedure LoadPsms;
	procedure LoadMain;
	procedure LoadTempNsns;
	procedure loadUsers ;

	-- For future use
	-- The following procedures: loadGoldPsmsMain, preProcess, postProcess, & postDiffProcess,
	-- may be used to replace the bulky sql scripts currently used by amd_loader.ksh
	procedure loadGoldPsmsMain(startStep in number := 1, endStep in number := 3) ;
	procedure preProcess(startStep in number := 1, endStep in number := 3) ;
	procedure postProcess(startStep in number := 1, endStep in number := 18) ;
	procedure postDiffProcess(startStep in number := 1, endStep in number := 3) ;
	-- For future use
	-- The following procedures: prepAmdDatabase, disableAmdConstraints, truncateAmdTables, &
	-- enableAmdConstraints can be be used in conjunction with the above procedures
	procedure prepAmdDatabase ;
	procedure disableAmdConstraints ;
	procedure truncateAmdTables ;
	procedure enableAmdConstraints ;


	SUCCESS constant number := 0 ;
	FAILURE constant number := 4 ;

	-- for amd_planners diff
	function insertRow(planner_code in varchar2) return number ;
	function updateRow(planner_code in varchar2) return number ;
	function deleteRow(planner_code in varchar2) return number ;

	-- for amd_planner_logons diff
	function insertplannerlogons(planner_code in varchar2, logon_id in varchar2, data_source in varchar2) return number ;
	function updatePlannerLogons(planner_code in varchar2, logon_id in varchar2, data_source in varchar2) return number ;
	function deletePlannerLogons(planner_code in varchar2, logon_id in varchar2, data_source in varchar2) return number ;

	function getBemsId(employeeNo in amd_use1.EMPLOYEE_NO%type) return amd_users.BEMS_ID%type ;

	function GetOffBaseRepairCost(pPartNo char) return amd_part_locs.cost_to_repair%type ;
	function GetOffBaseTurnAround (pPartno char) return amd_part_locs.time_to_repair%type ;

	type resultSetCursor is REF cursor ;
	function getNewUsers return resultSetCursor ;
	function insertUsersRow(bems_id in varchar2, stable_email in varchar2, last_name in varchar2, first_name in varchar2) return number ;
	function updateUsersRow(bems_id in varchar2, stable_email in varchar2, last_name in varchar2, first_name in varchar2) return number ;
	function deleteUsersRow(bems_id in varchar2) return number ;
	
	-- added 6/9/2006 by DSE
	procedure version ;

end amd_load;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.Amd_Inventory AS
	--
	-- SCCSID: %M%  %I%  Modified: %G% %U%
	--
	-- Date     By     History
	-- -------- -----  ---------------------------------------------------
	-- 10/14/01 FF     Initial implementation
	-- 11/01/01 FF     Changed LoadGoldInventory() to accept parameter as
	--                 char to match item.prime char datatype.
	-- 11/07/01 FF     Implemented WWA mod. Removed GetLocSid().
	-- 11/21/01 FF     Removed references to gold_mfgr_cage.
	-- 11/26/01 FF     Changed action_code to use defaults package.
	-- 01/04/02 FF     Removed "tactical" check from select criteria.
	-- 01/23/02 FF     Added "distinct" keyword to partCur cursor.
	-- 02/20/02 FF     Modified load to be by part not roll up to prime.
	-- 03/05/02 FF     Fixed conditions for insert and rtrim()ed the join
	--                 to the ord1 table.
	-- 09/25/02 FF     Qualified all amd_spare_parts refereneces with
	--                 action_code != 'D'
	-- 10/23/02 FF     Added translation of loc_type='TMP' srans to its MOB val.
	-- 11/18/02 FF     Added exception handler to rampCur.
	-- 06/13/03 TP     Changed order_no prefixes from ord1 table.
	-- 04/05/04 TP	   Removed 'TC' as a valid order prefix for including a
	--                 cap order in inventory.
	-- 05/13/04 TP	   Changed LoadGoldInventory() in On Hand and in Repair .
	-- 06/16/04 TP	   Added conditions in the OnHand and Repair types.
	--
	-- 07/26/04 TL    Added constant numbers for debugging purposes.
   --                Added implementations for insertRow, updateRow, and deleteRow on amd_on_order table
    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.28  $
         $Date:   Jun 09 2006 11:39:14  $
     $Workfile:   amd_inventory.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_inventory.pks-arc  $
   
      Rev 1.28   Jun 09 2006 11:39:14   zf297a
   added interface version
   
      Rev 1.27   Apr 28 2006 12:37:32   c402417
   Added amd_rsp diff function.
   
      Rev 1.26   Dec 06 2005 12:28:20   zf297a
   Changed deleteRow interface for amd_on_order - passed in additional parameters: part_no, loc_sid, and order_date (gold_order_number was the only parameter previously).

      Rev 1.25   Nov 03 2005 09:35:54   c402417
   Have Procedure UpdateSpoTotalInventory execute after all the Procedure load amd tables .

      Rev 1.24   Oct 13 2005 11:04:52   c402417
   Added fucntion doRepairInvsSumDiff.

      Rev 1.23   Sep 13 2005 12:43:04   zf297a
   added interface for the isVoucher boolean function

      Rev 1.22   Sep 12 2005 11:36:18   zf297a
   added interfaces for one get and one set procedure for all the on order date parameters for a given voucher.

      Rev 1.21   Sep 09 2005 10:56:34   zf297a
   For amd_on_hand_inv_sums changed the site_location column to be the spo_location column.  The spo_location comes from amd_spare_networks.spo_location.

      Rev 1.20   Sep 07 2005 21:00:00   zf297a
   added sched_receipt_date_exception when the from date is 42; than the to date.

      Rev 1.19   Sep 02 2005 15:49:34   zf297a
   Added interfaces for getOrderCreateDate, setOrderCreateDate, getScdeduledReceiptDateFrom, getScdeduledReceiptDateTo, setScheduledReceiptDate, and setScheduledReceiptDateCalDays

      Rev 1.18   Aug 26 2005 12:15:38   zf297a
   Added interfaces for doOnHandInvsSumDiff, loadOnHandInvs, and loadInRepair.

      Rev 1.17   Aug 04 2005 08:04:46   zf297a
   Made insertRow and updateRow for amd_on_order unique for the jdbc interface.

      Rev 1.15   Jul 11 2005 09:30:34   zf297a
   made the loading of tmp_amd_in_transits a separate procedure

      Rev 1.14   Jul 11 2005 09:17:40   zf297a
   made the loading of tmp_amd_on_order a separate procedure

      Rev 1.13   Jul 06 2005 09:30:44   zf297a
   Changed deleteRow for in_repair to have a unique name.

      Rev 1.12   20 Sep 2004 10:17:40   c970183
   Fixed site_location for insertRow of in_transits - it must be varchar(20)

      Rev 1.11   06 Aug 2004 14:09:56   c970183
   removed repair_type

      Rev 1.8   Aug 02 2004 08:08:36   c970183
   Removed inv_date from insertRow, updateRow, and deleteRow for amd_on_hand_invs since diff is done on the summarized qty.  Also, changed parameter names so they would not conflict with the column names.

      Rev 1.7   Jul 30 2004 12:04:56   c970183
   added pvcs comments with keywords
	 */

	 -- added 9/7/2005
	sched_receipt_date_exception EXCEPTION ;

	SUCCESS                   CONSTANT NUMBER :=  0;
	FAILURE                   CONSTANT NUMBER :=  4;

	PROCEDURE LoadGoldInventory;

	PROCEDURE loadOnOrder ;

	PROCEDURE loadInTransits ;
	
	PROCEDURE loadRsp ;
	

	/* amd_on_order diff functions */
	FUNCTION InsertOnOrderRow(
							PART_NO             IN VARCHAR2,
  							LOC_SID             IN NUMBER,
							ORDER_DATE			IN DATE,
  							ORDER_QTY           IN NUMBER,
  							GOLD_ORDER_NUMBER   IN VARCHAR2,
							SCHED_RECEIPT_DATE IN  DATE) RETURN NUMBER ;

	FUNCTION UpdateOnOrderRow(
							PART_NO             IN VARCHAR2,
  							LOC_SID             IN NUMBER,
							ORDER_DATE  		IN DATE,
  							ORDER_QTY           IN NUMBER,
  							GOLD_ORDER_NUMBER   IN VARCHAR2,
							SCHED_RECEIPT_DATE IN  DATE) RETURN NUMBER ;

	FUNCTION deleterow(part_no IN VARCHAR2, 
			 loc_sid IN NUMBER, 
			 gold_order_number IN VARCHAR2, 
			 order_date IN DATE) RETURN NUMBER ;

	/* amd_on_hand_invs diff functions */
	FUNCTION doOnHandInvsSumDiff(
			 part_no IN VARCHAR2,
			 spo_location VARCHAR2,
			 qty_on_hand IN NUMBER,
			 action_code IN VARCHAR2) RETURN NUMBER ;

	FUNCTION InsertRow(
			 		   		 part_no         IN VARCHAR2,
  							 loc_sid         IN NUMBER,
  							 inv_qty         IN NUMBER) RETURN NUMBER ;
	FUNCTION UpdateRow(
			 		   		 part_no         IN VARCHAR2,
  							 loc_sid         IN NUMBER,
  							 inv_qty         IN NUMBER) RETURN NUMBER ;
	FUNCTION DeleteRow(
			 		   		 part_no         IN VARCHAR2,
  							 loc_sid         IN NUMBER) RETURN NUMBER;
							 
							 
	/* amd_rsp diff functions */
	FUNCTION doRspSumDiff(
			 part_no 	IN VARCHAR2,
			 rsp_location  VARCHAR2,
			 qty_on_hand		IN NUMBER,
			 rsp_level			   IN NUMBER,
			 action_code IN VARCHAR2) RETURN NUMBER;  
			 
	FUNCTION RspInsertRow(
			 		   PART_NO IN VARCHAR2,
					   LOC_SID IN NUMBER,
					   RSP_INV IN NUMBER,
					   RSP_LEVEL IN NUMBER) RETURN NUMBER;
					   
	FUNCTION RspUpdateRow(
			 		   PART_NO IN VARCHAR2,
					   LOC_SID IN NUMBER,
					   RSP_INV IN NUMBER,
					   RSP_LEVEL IN NUMBER) RETURN NUMBER;
					 
	FUNCTION RspDeleteRow(
			 			  PART_NO	IN VARCHAR2,
						  LOC_SID  IN NUMBER)RETURN NUMBER; 
						  

    /* amd_in_repair diff functions */
	FUNCTION doRepairInvsSumDiff(
			 part_no IN VARCHAR2,
			 site_location IN VARCHAR2,
			 qty_on_hand IN NUMBER,
			 action_code IN VARCHAR2) RETURN NUMBER ;

	FUNCTION InsertRow(
			 		   PART_NO         IN VARCHAR2,
  					   LOC_SID         IN NUMBER,
  					   REPAIR_DATE     IN DATE,
  					   REPAIR_QTY      IN NUMBER,
  					   ORDER_NO       IN VARCHAR2,
					   REPAIR_NEED_DATE	 IN DATE) RETURN NUMBER ;
	FUNCTION UpdateRow(
			 		   PART_NO         IN VARCHAR2,
  					   LOC_SID         IN NUMBER,
  					   REPAIR_DATE     IN DATE,
  					   REPAIR_QTY      IN NUMBER,
  					   ORDER_NO       IN VARCHAR2,
					   REPAIR_NEED_DATE IN DATE) RETURN NUMBER ;
	FUNCTION inRepairDeleteRow(
			 		   PART_NO         IN VARCHAR2,
  					   LOC_SID         IN NUMBER,
  					   ORDER_NO		   IN VARCHAR2) RETURN NUMBER ;


	/* amd_in_transits diff functions */
	FUNCTION InsertRow(
				 	   TO_LOC_SID	  		IN NUMBER,
					   QUANTITY				IN NUMBER,
					   DOCUMENT_ID			IN VARCHAR2,
					   PART_NO				IN VARCHAR2,
					   FROM_LOCATION		IN VARCHAR2,
					   IN_TRANSIT_DATE		IN DATE,
					   SERVICEABLE_FLAG		IN VARCHAR2) RETURN NUMBER ;
	FUNCTION UpdateRow(
				 	   TO_LOC_SID			IN NUMBER,
					   QUANTITY				IN NUMBER,
					   DOCUMENT_ID			IN VARCHAR2,
					   PART_NO				IN VARCHAR2,
					   FROM_LOCATION		IN VARCHAR2,
					   IN_TRANSIT_DATE		IN DATE,
					   SERVICEABLE_FLAG		IN VARCHAR2) RETURN NUMBER ;
	FUNCTION DeleteRow(
				 	   DOCUMENT_ID			IN VARCHAR2,
					   PART_NO				IN VARCHAR2,
					   TO_LOC_SID			IN NUMBER) RETURN NUMBER ;


	/* amd_in_transits_sum diff function */
	FUNCTION InsertRow(
				 	   PART_NO			   	IN VARCHAR2,
					   SITE_LOCATION			IN VARCHAR2,
					   QUANTITY				IN NUMBER,
					   SERVICEABLE_FLAG		IN VARCHAR2) RETURN NUMBER ;

	FUNCTION UpdateRow(
				 	   PART_NO				IN VARCHAR2,
					   SITE_LOCATION			IN VARCHAR2,
					   QUANTITY				IN NUMBER,
					   SERVICEABLE_FLAG		IN VARCHAR2) RETURN NUMBER ;

	FUNCTION DeleteRow(
				 	   PART_NO				IN VARCHAR2,
					   SITE_LOCATION			IN VARCHAR2,
					   SERVICEABLE_FLAG		IN VARCHAR2) RETURN NUMBER ;


	PROCEDURE loadOnHandInvs ;

	PROCEDURE loadInRepair ;

	PROCEDURE updateSpoTotalInventory;

	-- added 9/2/2005 by dse
	FUNCTION getOrderCreateDate(voucher IN VARCHAR2) RETURN DATE ;
	PROCEDURE setOrderCreateDate(voucher IN VARCHAR2, orderCreateDate IN DATE) ;
	FUNCTION getScdeduledReceiptDateFrom(voucher IN VARCHAR2) RETURN DATE ;
	FUNCTION getScdeduledReceiptDateTo(voucher IN VARCHAR2) RETURN DATE ;
	PROCEDURE setScheduledReceiptDate(voucher IN VARCHAR2, fromDate IN DATE, toDate DATE) ;
	PROCEDURE setScheduledReceiptDateCalDays(voucher IN VARCHAR2, days IN NUMBER) ;
	-- added 9/8/2005 by dse
	FUNCTION getScheduledReceiptDateCalDays(voucher IN VARCHAR2) RETURN NUMBER ;

	-- added 9/10/2005 by dse
	PROCEDURE getOnOrderParams(voucher IN VARCHAR2,
			  orderCreateDate 		  OUT DATE,
			  schedReceiptDateFrom 	  OUT DATE,
			  schedReceiptDateTo 	  OUT DATE,
			  schedReceiptCalDays 	  OUT NUMBER) ;
	PROCEDURE setOnOrderParams(voucher IN VARCHAR2,
			  orderCreateDate 		   IN DATE,
			  schedReceiptDateFrom 	   IN DATE,
			  schedReceiptDateTo 	   IN DATE,
			  schedReceiptCalDays 	   IN NUMBER) ;
	FUNCTION isVoucher(voucher IN VARCHAR2) RETURN BOOLEAN ;
	PROCEDURE clearOnOrderParams ;
	FUNCTION numberOfOnOrderParams RETURN NUMBER ;
	TYPE ref_cursor IS REF CURSOR ;
	FUNCTION getVouchers RETURN ref_cursor ;
	-- added 6/9/2006 by dse
	procedure version ;


END Amd_Inventory;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_FROM_BSSM_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.7  $
	    $Date:   Jun 09 2006 10:46:00  $
    $Workfile:   amd_from_bssm_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_from_bssm_pkg.pks-arc  $
   
      Rev 1.7   Jun 09 2006 10:46:00   zf297a
   Added interface for version
   
      Rev 1.6   Nov 30 2005 12:26:02   zf297a
   added pvcs keywords
*/	

   	   -------------------------------------------------------------------
	   --  Date	  		  By			History
	   --  ----			  --			-------
	   --  10/10/01		  ks			initial implementation
	   --  04/02/02		  ks			mic_code_lowest will not come from bssm anymore
	   -------------------------------------------------------------------


 	   	 -- those values where bssm is currently the only source
	   procedure LoadAmdPartFromBssmRaw;
	   procedure LoadAmdBaseFromBssmRaw;
	   procedure LoadAmdPartFromBssmRaw(pNsn bssm_parts.nsn%type);
   	   procedure LoadAmdBaseFromBssmRaw(pNsn bssm_base_parts.nsn%type,pSran bssm_base_parts.sran%type);
	   procedure LoadAmdPartLocTimePeriods;
	   procedure UpdateAmdNsi(pBssmPartsRec bssm_parts%rowtype);
	   procedure UpdateAmdPartLocs (pBssmBaseRec bssm_base_parts%rowtype);
	   function GetCurrentBssmNsn(pNsn bssm_parts.nsn%type) return bssm_parts.nsn%type;
       function ConvertCriticality(pCriticality bssm_parts.criticality%type) return varchar2;
	   function ConvertItemType(pItemType bssm_parts.item_type%type) return amd_national_stock_items.item_type%type;
	   function GetLocSid(pLocId amd_spare_networks.loc_id%type) return amd_spare_networks.loc_sid%type;
	   procedure version ;
	   AMD_WAREHOUSE_LOCID constant varchar2(30) := 'CTLATL';
	   BSSM_WAREHOUSE_SRAN constant varchar2(1) := 'W';
END AMD_FROM_BSSM_PKG;
/

show errors

CREATE OR REPLACE PACKAGE Amd_Reqs_Pkg AS
	/*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.5  $
         $Date:   Jun 28 2006 13:15:06  $
     $Workfile:   AMD_REQS_PKG.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_REQS_PKG.pks-arc  $
/*   
/*      Rev 1.5   Jun 28 2006 13:15:06   zf297a
/*   Added the interfaces for the amd_backorder_spo_sum diff
/*   
/*      Rev 1.4   Jun 09 2006 12:25:06   zf297a
/*   added interface version
/*   
/*      Rev 1.3   Apr 28 2006 13:51:00   zf297a
/*   updated package end statment: end amd_reqs_pkg ;
/*
/*      Rev 1.2   12 Aug 2005 10:48:46   c402417
/*   Added amd_reqs and amd_backorder_sum diff fucntions
/*
/*      Rev 1.1   May 06 2005 09:07:02   c970183
/*   fixed deleteRow and added PVCS keywords

*/
	   -------------------------------------------------------------------
	   -- SCCSID: amd_reqs_pkg.sql 1.2 Modified: 06/26/02 10:36:43
	   --
	   --  Date	  		  By			History
	   --  ----			  --			-------
	   --  12/10/01		  ks			initial implementation
	   --  06/26/02		  ks			modified action code from not Deleted to in
	   --  				  		add or change - performance issue
	   -------------------------------------------------------------------

	SUCCESS							CONSTANT  NUMBER := 0;
	FAILURE							   CONSTANT  NUMBER := 4;

	PROCEDURE LoadAmdReqs;
	 /* amd_reqs  diff  function */

	FUNCTION InsertRow(
			 		   		  	REQ_ID 			 		IN VARCHAR2,
								PART_NO					IN VARCHAR2,
								LOC_SID					IN NUMBER,
								QUANTITY_DUE			   IN NUMBER) RETURN NUMBER;

	FUNCTION UpdateRow(
			 		   			 REQ_ID					   	  IN VARCHAR2,
								 PART_NO					  IN VARCHAR2,
								 LOC_SID 					  IN NUMBER,
								 QUANTITY_DUE				  IN NUMBER) RETURN NUMBER;

	FUNCTION DeleteRow(
			 		   			 REQ_ID						   IN VARCHAR2,
								 PART_NO					   IN VARCHAR2,
								 LOC_SID					   IN NUMBER) RETURN NUMBER;


	/* amd_backorder_sum diff function */

	FUNCTION InsertRow(
			 		   	 PART_NO	   	 					   IN VARCHAR2,
						 LOC_SID							   IN NUMBER,
						 QTY								   IN NUMBER) RETURN NUMBER;

	FUNCTION UpdateRow(
			 		   	 PART_NO							   IN VARCHAR2,
						 LOC_SID							   IN NUMBER,
						 QTY								   IN NUMBER) RETURN NUMBER;


	FUNCTION DeleteRow(
			 		   	 PART_NO							   IN VARCHAR2,
						 LOC_SID							   IN NUMBER) RETURN NUMBER;
						 
	-- added 6/9/2006 by dse
	procedure version ;

	-- added 6/28/2006 by dse
	FUNCTION InsertRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type,
						 qty		IN amd_backorder_spo_sum.QTY%type) RETURN NUMBER ;
	FUNCTION UpdateRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type,
						 qty		IN amd_backorder_spo_sum.QTY%type) RETURN NUMBER ;
	FUNCTION DeleteRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type) RETURN NUMBER ;
	
END Amd_Reqs_Pkg;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_demand as
/*
      $Author:   zf297a  $
    $Revision:   1.11  $
        $Date:   Jun 09 2006 12:51:12  $
    $Workfile:   amd_demand.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_demand.pks-arc  $
   
      Rev 1.11   Jun 09 2006 12:51:12   zf297a
   added interface version

      Rev 1.10   Jul 27 2005 11:56:20   zf297a
   Modified by Dean Hoang for a2a transactions
*/

	--
	-- SCCSID: amd_demand.sql  1.9  Modified: 11/23/04 09:05:30
	--
	-- -------------------------------------------------------------------
	-- This program loads demand data into amd_af_reqs table.
	--
	-- Prior to execution of this procedure, we assume that the lcf data
	-- have been successfully loaded into tmp_lcf_raw table.
	--
	-- The temporary table amd_l67_tmp and tmp_lcf_icp should be truncated
	-- prior to the execution of the procedure.
	-- -------------------------------------------------------------------
	--
	-- Date     By     History
	-- 10/12/01 FF     Initial implementation
	-- 10/25/01 FF     Removed DedupL67() and moved into InsertL67TmpLcfIcp()
	-- 10/28/01 FF     Added LoadBascUkDemands().
	-- 11/21/01 FF     Removed use of mfgr, manuf_cage as part of key when
	--                 accessing data from amd_spare_parts
	-- 11/26/01 FF     Changed action_code to use defaults package.
	-- 12/13/01 FF     Added logic in Insertl67TmpLcfIcp() to handle 15-char
	--                 nsn's. MMC is added to NSN if numeric.
	-- 08/06/01 FF     Removed use of CalcReqDate(). Using trans_date instead.
	-- 10/23/02 FF     Added translation of loc_type='TMP' srans to its MOB val.
	-- 11/04/04 TP	   Added EY1213 to Request Id field.
	--

	procedure LoadAmdDemands;
	procedure LoadBascUkDemands;
	procedure amd_demand_a2a;
	procedure prime_part_change (old_part_no amd_national_stock_items.prime_part_no%TYPE,
                                new_part_no amd_national_stock_items.prime_part_no%TYPE);
								
	-- added 6/9/2006 by dse
	procedure version ;

end amd_demand;
/


CREATE OR REPLACE PACKAGE AMD_OWNER.amd_defaults as
    /*

     $Author:   zf297a  $
   $Revision:   1.19  $
       $Date:   Jun 09 2006 12:55:24  $
   $Workfile:   amd_defaults.pks  $
        $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_defaults.pks-arc  $
   
      Rev 1.19   Jun 09 2006 12:55:24   zf297a
   added interface version
   
      Rev 1.18   Nov 30 2005 10:56:18   zf297a
   added bom_quantity and bom

      Rev 1.17   Nov 01 2005 12:32:52   zf297a
   Added some more "getter" functions for other constants.

      Rev 1.16   Nov 01 2005 12:21:34   zf297a
   Simplified the name of the "getter's" to getCONSTANT where CONSTANT is the identifier for the associated constant.

      Rev 1.15   Nov 01 2005 11:50:32   zf297a
   Added "getter 's" (get functions) for some of the constant's so they can be used in ordinary SQL instead of only in PL/SQL code.

      Rev 1.14   Sep 13 2005 11:04:02   zf297a
   Added interfaces for isParamKey and addParamKey.

      Rev 1.13   Jul 08 2005 09:08:38   zf297a
   added the public function getLogonId

      Rev 1.12   Jul 08 2005 08:58:36   zf297a
   Added the public function getPlannerCode

      Rev 1.11   Jul 05 2005 13:54:12   zf297a
   added $Log$ PVCS keyword

     	10/02/01 Douglas Elder	Initial implementation
	 							Although variables that are CAPITALIZED
								are usually "constant's", these variables
								are quasi-constants, since they rarely change,
								but they are initialized from values stored
								in an Oracle table.  Some values are returned
								via functions, since they are dependent on
								the value of other variables.
		6/07/05	 KS				Add more constants and defaults
     */

	CONDEMN_AVG					amd_national_stock_items.condemn_avg%type := null ;
	CONSUMABLE					constant amd_national_stock_items.item_type%type := 'C' ;
	function getCONSUMABLE return varchar2 ;
	DELETE_ACTION				constant amd_spare_parts.action_code%type := 'D' ;
	function getDELETE_ACTION return varchar2 ;
	DISPOSAL_COST				amd_spare_parts.disposal_cost%type := null ;
	DISTRIB_UOM					amd_national_stock_items.distrib_uom%type := null ;
	INSERT_ACTION				constant amd_spare_parts.action_code%type := 'A' ;
	function getINSERT_ACTION return varchar2 ;
	NOT_PRIME_PART				constant amd_nsi_parts.prime_ind%type  := 'N' ;
	NRTS_AVG					amd_national_stock_items.nrts_avg%type := null ;

	OFF_BASE_TURN_AROUND		amd_part_locs.time_to_repair%type := null ;
	function GetOrderLeadTime(pItem_type in amd_national_stock_items.item_type%type) return  amd_spare_parts.order_lead_time_defaulted%type ;
	ORDER_QUANTITY				amd_national_stock_items.order_quantity%type := null ;

	ORDER_UOM					amd_spare_parts.order_uom%type := null ;
	PRIME_PART					constant amd_nsi_parts.prime_ind%type  := 'Y' ;

	QPEI_WEIGHTED				amd_national_stock_items.qpei_weighted%type := null ;
	REPAIRABLE					constant amd_national_stock_items.item_type%type := 'R' ;
	function getREPAIRABLE return varchar2 ;
	RTS_AVG						amd_national_stock_items.rts_avg%type := null ;
	SCRAP_VALUE					amd_spare_parts.scrap_value%type := null ;
    SHELF_LIFE					amd_spare_parts.shelf_life%type := null ;


	TIME_TO_REPAIR_ON_BASE_AVG	amd_national_stock_items.time_to_repair_on_base_avg_df%type := null ;
	
	BOM_QUANTITY				tmp_a2a_bom_detail.quantity%type := 1 ;
	BOM							tmp_a2a_bom_detail.bom%type := 'C17' ;

	function GetUnitCost(
		pNsn in amd_spare_parts.nsn%type,
		pPart_no in amd_spare_parts.part_no%type,
		pMfgr in amd_spare_parts.mfgr%type,
		pSmr_code in amd_national_stock_items.smr_code%type,
		pPlanner_code in amd_national_stock_items.planner_code%type) return amd_spare_parts.unit_cost_defaulted%type ;

	function getPlannerCode(nsn in varchar2) return varchar2 ;

	function getLogonId(nsn in varchar2) return varchar2 ;

	UNIT_VOLUME					amd_spare_parts.unit_volume%type := null ;
	UPDATE_ACTION				constant amd_spare_parts.action_code%type := 'C' ;
	function getUPDATE_ACTION return varchar2 ;
	USE_BSSM_TO_GET_NSLs		varchar2(1) := null ;

	COST_TO_REPAIR_ONBASE amd_part_locs.cost_to_repair%type := null;
	TIME_TO_REPAIR_ONBASE amd_part_locs.time_to_repair%type := null;
	TIME_TO_REPAIR_OFFBASE amd_part_locs.time_to_repair%type := null;
	UNIT_COST_FACTOR_OFFBASE number := 0;

		/* ks add 06/07/05
		-- expose GetParamValue
		-- constants
		*/
	function GetParamValue(key in varchar2) return amd_param_changes.param_value%type ;
	-- added 9/3/2005 dse
	procedure setParamValue(key in varchar2, value in varchar2) ;
	AMD_WAREHOUSE_LOCID CONSTANT amd_spare_networks.loc_id%TYPE := 'CTLATL';
	function getAMD_WAREHOUSE_LOCID return varchar2 ;
	BSSM_WAREHOUSE_SRAN CONSTANT bssm_bases.sran%TYPE := 'W';
	function getBSSM_WAREHOUSE_SRAN return varchar2 ;

	AMD_UK_LOC_ID 	CONSTANT amd_spare_networks.loc_id%TYPE := 'EY8780' ;
	function getAMD_UK_LOC_ID return varchar2 ;
	AMD_BASC_LOC_ID CONSTANT amd_spare_networks.loc_id%TYPE := 'EY1746' ;
	function getAMD_BASC_LOC_ID return varchar2 ;
	AMD_VUB_LOC_ID	CONSTANT amd_spare_networks.loc_id%TYPE := 'FB4490' ;
	function getAMD_VUB_LOC_ID return varchar2 ;
	--AMD_VCD_LOC_ID  CONSTANT amd_spare_networks.loc_id%TYPE :=	'?' ;

	NSN_PLANNER_CODE amd_planners.PLANNER_CODE%type := null ;
	NSN_LOGON_ID amd_planner_logons.LOGON_ID%type := null ;
	NSL_PLANNER_CODE amd_planners.PLANNER_CODE%type := null ;
	NSL_LOGON_ID amd_planner_logons.LOGON_ID%type := null ;

	function isParamKey(key in varchar2) return boolean ;
	procedure addParamKey(key in varchar2, description in varchar2) ;
	
	-- added 6/09/2006 by dse
	procedure version ;

end amd_defaults ;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_clean_data as
    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.5  $
         $Date:   Jun 09 2006 12:42:42  $
     $Workfile:   amd_clean_data.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_clean_data.pks-arc  $
   
      Rev 1.5   Jun 09 2006 12:42:42   zf297a
   added interface version

      Rev 1.5   Aug 23 2005 12:20:02   zf297a
   Added part_no to the interfaces of the cleaned data that is being retrived via the amd_load / diff process.  This will allow the routine to attempt to retrieve the cleaned_data via the part_no if it is not found via the nsn.

      Rev 1.4   May 06 2005 08:15:38   c970183
   changed dla_warehouse_stock and dla_warehouse_stock_cleaned to current_backorder and current_backorder_cleaned.  added pvcs keywords
   	  */

/*
 *	These routines will make it easy to retrieve cleaned data from BSSM
 *	Douglas S. Elder and Chung D. Lu  10/03/01  Initial implementation
 */
   	-- ks - base specific clean fields, not in pkg body yet
	function RemovalInd(pNsn in varchar2, pLocSid in number ) return varchar2;
	function RepairLevelCode(pNsn in varchar2, pLocSid in number) return varchar2;
	--
	function GetCondemnAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.condemn_avg_cleaned%type ;
	function GetNrtsAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.nrts_avg_cleaned%type ;
	function GetCriticality(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.criticality_cleaned%type ;
	function GetMtbdr(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.mtbdr_cleaned%type ;
	function GetRtsAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.rts_avg_cleaned%type ;
	function GetOrderLeadTime(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.order_lead_time_cleaned%type ;
	function GetPlannerCode(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.planner_code_cleaned%type ;
	function GetSmrCode(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.smr_code_cleaned%type ;
	function GetUnitCost(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.unit_cost_cleaned%type ;
	function GetCostToRepairOffBase(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.cost_to_repair_off_base_cleand%type ;
	function GetTimeToRepairOffBase(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.time_to_repair_off_base_cleand%type ;

	function GetAddIncrement(pNsn in varchar2) return amd_national_stock_items.add_increment_cleaned%type ;
	function GetAmcBaseStock(pNsn in varchar2) return amd_national_stock_items.amc_base_stock_cleaned%type ;
	function GetAmcDaysExperience(pNsn in varchar2) return amd_national_stock_items.amc_days_experience_cleaned%type ;
	function GetAmcDemand(pNsn in varchar2) return amd_national_stock_items.amc_demand_cleaned%type ;
	function GetCapabilityRequirement(pNsn in varchar2) return amd_national_stock_items.capability_requirement_cleaned%type ;
	function GetDlaDemand(pNsn in varchar2) return amd_national_stock_items.dla_demand_cleaned%type ;
	function GetCurrentBackorder(pNsn in varchar2) return amd_national_stock_items.current_backorder_cleaned%type ;
	function GetFedcCost(pNsn in varchar2) return amd_national_stock_items.fedc_cost_cleaned%type ;
	function GetItemType(pNsn in varchar2) return amd_national_stock_items.item_type_cleaned%type ;
	function GetMicCodeLowest(pNsn in varchar2) return amd_national_stock_items.mic_code_lowest_cleaned%type ;
	function GetNomenclature(pNsn in varchar2) return amd_national_stock_items.nomenclature_cleaned%type ;
	function GetOrderUom(pNsn in varchar2) return amd_national_stock_items.order_uom_cleaned%type ;
	function GetPrimeInd(pNsn in varchar2, pPart_no in varchar2, pMfgr in varchar2) return amd_nsi_parts.prime_ind_cleaned%type ;
	function GetRuInd(pNsn in varchar2) return amd_national_stock_items.ru_ind_cleaned%type ;
	function GetTimeToRepairOnBaseAvg(pNsn in varchar2) return amd_national_stock_items.time_to_repair_on_base_avg_cl%type ;
	
	-- added 6/9/2006 by dse
	procedure version ;
	
end amd_clean_data ;
/

show errors

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG
is
    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.8  $
         $Date:   Jun 09 2006 12:47:12  $
     $Workfile:   AMD_CLEANED_FROM_BSSM_PKG.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_cleaned_from_bssm_pkg.pks-arc  $
   
      Rev 1.8   Jun 09 2006 12:47:12   zf297a
   added interface version

      Rev 1.8   Aug 23 2005 12:27:14   zf297a
   Added funciont GetValuesX - it retireves bssm via the nsn or the part_no.  If the data is not found via the nsn, the routine attempts to find it via the part_no.

      Rev 1.7   May 17 2005 11:05:56   c970183
   added new cleaned fields.  added fields that are not part of amd, but could provide an easy way to get field from bssm

      Rev 1.6   May 17 2005 10:26:48   c970183
   Changed dla_wareshouse_stock to current_backorder

      Rev 1.5   May 06 2005 07:36:58   c970183
   changed dla_warehouse_stcok to current_backorder.  added pvcs keywords
		  */


  	   -- constant name is amd field name, value is corresponding bssm field name.
	   -- more of a visual reference.
	ACQUISITION_ADVICE_CODE		 constant varchar2(30) := 'ACQUISITION_ADVICE_CODE' ;
  	ADD_INCREMENT 		  		 constant varchar2(30) := 'ADD_INCREMENT';
	AMC_BASE_STOCK				 constant varchar2(30) := 'AMC_BASE_STOCK';
	AMC_DAYS_EXPERIENCE			 constant varchar2(30) := 'AMC_DAYS_EXPERIENCE';
	AMC_DEMAND					 constant varchar2(30) := 'AMC_DEMAND';
	CAPABILITY_REQUIREMENT		 constant varchar2(30) := 'CAPABILITY_REQUIREMENT';  -- CATEGORY
	CONDEMN_AVG					 constant varchar2(30) := 'CONDEMN';
	COST_TO_REPAIR_OFF_BASE		 constant varchar2(30) := 'OFF_BASE_REPAIR_COST';
	CRITICALITY					 constant varchar2(30) := 'CRITICALITY';
	DLA_DEMAND					 constant varchar2(30) := 'DLA_DEMAND';
	CURRENT_BACKORDER			 constant varchar2(30) := 'CURRENT_BACKORDER';
	FEDC_COST					 constant varchar2(30) := 'FEDC_COST';
	GOLD_MFGR_CAGE				 constant varchar2(30) := 'GOLD_MFGR_CAGE'; -- not an amd fiueld
	ITEM_TYPE					 constant varchar2(30) := 'ITEM_TYPE';
	MFGR						 constant varchar2(30) := 'MFGR' ; -- not cleaned in amd
	MIC_CODE_LOWEST				 constant varchar2(30) := 'MIC_CODE';
	MTBDR						 constant varchar2(30) := 'MTBDR';
	MIN_PURCHASE_QUANTITY		 constant varchar2(30) := 'MIN_PURCHASE_QUANTITY' ;
	MONTHLY_DEMAND_RATE			 constant varchar2(30) := 'MONTHLY_DEMAND_RATE' ;
	NOMENCLATURE 				 constant varchar2(30) := 'NOMENCLATURE';
	NRTS_AVG					 constant varchar2(30) := 'NRTS';
	ORDER_LEAD_TIME				 constant varchar2(30) := 'ORDER_LEAD_TIME';     -- TCONDEMN
	ORDER_UOM 					 constant varchar2(30) := 'ORDER_UOM'; /* UNITS */
	PLANNER_CODE				 constant varchar2(30) := 'PLANNER_CODE';
	RTS_AVG						 constant varchar2(30) := 'RTS';
	RU_IND						 constant varchar2(30) := 'RU_IND';
	SMR_CODE 					 constant varchar2(30) := 'SMR_CODE';
	TIME_TO_REPAIR_OFF_BASE		 constant varchar2(30) := 'OFF_BASE_TURNAROUND'; -- TDEPOT
	TIME_TO_REPAIR_ON_BASE_AVG	 constant varchar2(30) := 'ON_BASE_TURNAROUND';  -- TBASE
	UNIT_COST					 constant varchar2(30) := 'UNIT_COST';
	WUC							 constant varchar2(30) := 'WUC' ; -- not an amd field

		-- base specific cleanable fields
	REMOVAL_IND					 constant varchar2(30) := 'REPLACEMENT_INDICATOR';
	REPAIR_LEVEL_CODE			 constant varchar2(30) := 'REPAIR_INDICATOR';

	    -- if field needs to be converted, eg. item_type, criticality, from bssm to
		-- amd, any function in this package will return the converted value that
		-- amd needs.
	type partFields is record (
		 nsn					  amd_national_stock_items.nsn%type,
		 part_no				  amd_spare_parts.PART_NO%type,
		 add_increment 		   	  amd_national_stock_items.add_increment%type,
		 amc_base_stock			  amd_national_stock_items.amc_base_stock%type,
		 amc_days_experience 	  amd_national_stock_items.amc_days_experience%type,
		 amc_demand 		   	  amd_national_stock_items.amc_demand%type,
		 capability_requirement   amd_national_stock_items.capability_requirement%type,
		 condemn_avg 		   	  amd_national_stock_items.condemn_avg%type,
		 cost_to_repair_off_base  amd_national_stock_items.cost_to_repair_off_base_cleand%type,
		 criticality 		   	  amd_national_stock_items.criticality%type,
		 dla_demand 		   	  amd_national_stock_items.dla_demand%type,
		 current_backorder  	  amd_national_stock_items.current_backorder%type,
		 fedc_cost 		   	      amd_national_stock_items.fedc_cost%type,
		 item_type 		   	  	  amd_national_stock_items.item_type%type,
		 mic_code_lowest 	   	  amd_national_stock_items.mic_code_lowest%type,
		 mtbdr 		   	  		  amd_national_stock_items.mtbdr%type,
		 min_purchase_quantity	  amd_national_stock_items.min_purchase_quantity%type,
		 nomenclature 		   	  amd_national_stock_items.nomenclature_cleaned%type,
		 nrts_avg 		   	  	  amd_national_stock_items.nrts_avg%type,
		 order_lead_time 	  	  amd_national_stock_items.order_lead_time_cleaned%type,
		 acquisition_advice_code  bssm_owner.bssm_parts.ACQUISITION_ADVICE_CODE%type,
		 order_uom				  amd_national_stock_items.order_uom_cleaned%type,
		 planner_code			  amd_national_stock_items.planner_code%type,
		 rts_avg				  amd_national_stock_items.rts_avg%type,
		 ru_ind					  amd_national_stock_items.ru_ind%type,
		 smr_code				  amd_national_stock_items.smr_code%type,
 		 time_to_repair_off_base  amd_national_stock_items.time_to_repair_on_base_avg%type,
		 time_to_repair_on_base_avg	  amd_national_stock_items.time_to_repair_on_base_avg%type,
		 unit_cost				  amd_national_stock_items.unit_cost_cleaned%type,
		 mfgr					  amd_spare_parts.MFGR%type,
		 gold_mfgr_cage			  bssm_owner.bssm_parts.GOLD_MFGR_CAGE%type
		 );

	type partBaseFields is record (
		 nsn amd_national_stock_items.nsn%type,
		 loc_id amd_spare_networks.loc_id%type,
		 removal_ind amd_part_locs.removal_ind%type,
		 repair_level_code amd_part_locs.repair_level_code%type
	);

		 	 -- part specific

	function GetValues(pNsn bssm_parts.nsn%type) return partFields;
	function GetValuesX(pNsn bssm_parts.nsn%type, pPartNo bssm_parts.part_no%type) return partFields ;
	function GetValues(pNsn bssm_parts.nsn%type, pFieldName varchar2) return varchar2;

			 -- base specific
	function GetBaseValues(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type) return partBaseFields;
	function GetBaseValues(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type, pFieldName varchar2) return varchar2;


			-- update all cleaned by listing all in bssm_parts for lock_sid 2
	procedure UpdateAmdAllPartCleaned;
	procedure UpdateAmdAllBaseCleaned;
	procedure NullAmdAllCleanedFields;
			-- update used by trigger
	procedure UpdateAmdPartByTrigger(pLockSidTwo bssm_parts%rowtype);
	procedure UpdateAmdBaseByTrigger(pLockSidTwo bssm_base_parts%rowtype);
	procedure OnPartResetByTrigger(pLockSidTwo bssm_parts%rowtype);
	procedure OnBaseResetByTrigger(pLockSidTwo bssm_base_parts%rowtype);
	
	-- added 6/9/2006 by dse
	procedure version ;

end AMD_CLEANED_FROM_BSSM_PKG;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Batch_Pkg AS
	/*7
      $Author:   zf297a  $
    $Revision:   1.12  $
	    $Date:   Jun 09 2006 11:34:48  $
    $Workfile:   AMD_BATCH_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_BATCH_PKG.pkb.-arc  $
/*   
/*      Rev 1.12   Jun 09 2006 11:34:48   zf297a
/*   implemented version
/*   
/*      Rev 1.11   May 05 2006 09:24:34   zf297a
/*   Fixed invocation of getLastStartTime to used the named parameter notation for system_id since the batch_job_number is not available, otherwise Oracle will issue a
/*   "ORA-06502: PL/SQL: numeric or value error: character to number conversion error"  when the system_id is passed as the first positional parameter - i.e. it thinks it is the batch_job_number, but it is NOT, hence the number conversion error since system_id is always a VARCHAR2.
/*   
/*      Rev 1.10   May 01 2006 12:10:02   zf297a
/*   Fixed isJobComplete
/*   
/*      Rev 1.9   Apr 05 2006 14:09:42   zf297a
/*   Fixed getLastStartTime - will return null if there are no jobs in the system.
/*   
/*      Rev 1.8   Mar 23 2006 10:52:06   zf297a
/*   Added an exception handler to truncateIfOld and updated the error location numbers.
/*   
/*      Rev 1.7   Mar 23 2006 08:21:20   zf297a
/*   Implemented procedure truncateIfOld - this procedure will only truncate a table if there is no active batch job for the given system_id or if  there is an active job and the table has been updated since the job started.
/*   
/*      Rev 1.6   Mar 21 2006 08:38:12   zf297a
/*   Fixed getLastStartData
/*   
/*      Rev 1.5   Mar 19 2006 01:49:06   zf297a
/*   Implemented isStepComplete function
/*   
/*      Rev 1.3   Mar 16 2006 14:25:00   zf297a
/*   Implemented step functions and procedures
/*   
/*      Rev 1.2   Mar 03 2006 12:33:58   zf297a
/*   Implemented functions getLastStartTime, getLastEndTime, and isJobComplete.
/*   
/*      Rev 1.1   Nov 22 2005 08:09:22   zf297a
/*   Restored body using previous package dump.
*/

	procedure ErrorMsg(
					pSqlfunction in amd_load_status.SOURCE%type,
					pTableName in amd_load_status.TABLE_NAME%type := '',
					pError_location amd_load_details.DATA_LINE_NO%type,
					pKey_1 in amd_load_details.KEY_1%type := '',
			 		pKey_2 in amd_load_details.KEY_2%type := '',
					pKey_3 in amd_load_details.KEY_3%type := '',
					pKey_4 in amd_load_details.KEY_4%type := '',					
					pKeywordValuePairs in varchar2 := '') is
		key5 amd_load_details.KEY_5%type := pKeywordValuePairs ;
	begin
		rollback;
		if key5 = '' then
		   key5 := pSqlFunction || '/' || pTableName ;
		else
			key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
		end if ;
		-- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
		-- do not exceed the length of the column's that the data gets inserted into
		-- This is for debugging and logging, so efforts to make it not be the source of more
		-- errors is VERY important
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => substr(pSqlfunction,1,20),
						pTableName  => substr(pTableName,1,20)),
				pData_line_no => pError_location,
				pData_line    => 'amd_batch_pkg.',
				pKey_1 => substr(pKey_1,1,50),
				pKey_2 => substr(pKey_2,1,50),
				pKey_3 => substr(pKey_3,1,50),
				pKey_4 => substr(pKey_4,1,50),
				pKey_5 => to_char(sysdate,'MM/DD/YYYY HH:MM:SS') ||
						   ' ' || substr(key5,1,50),
				pComments => substr('sqlcode('||sqlcode||') sqlerrm('||sqlerrm||')',1,2000));
		commit;
	end ErrorMsg;

  procedure validateJob(batch_job_number in out amd_batch_jobs.BATCH_JOB_NUMBER%type, system_id in amd_batch_jobs.SYSTEM_ID%type) is
  			
  begin
  	   if batch_job_number is null then
	   	  batch_job_number := getActiveJob(system_id) ;
		  if batch_job_number is null then
		  	 batch_job_number := getLastCompleteJob(system_id) ;
		  end if ;
	   else
	   	   if not isJob(batch_job_number, system_id) then
		   	  	  RAISE_APPLICATION_ERROR(-20130,'Job ' || batch_job_number || ',' || system_id || ' is not a valid job.') ;
		   end if ;
	   end if ;
  end validateJob ;
  
  procedure validateActiveJob(batch_job_number in out amd_batch_jobs.BATCH_JOB_NUMBER%type, system_id in amd_batch_jobs.SYSTEM_ID%type ) is
  begin
  
  	   if batch_job_number is null then
	   	  batch_job_number := getActiveJob(system_id) ;
		  if batch_job_number is null then
		  	 RAISE_APPLICATION_ERROR(-20140,'There is no active job for system_id=' || system_id || '.') ;
		  end if ;
	  else
	   	   if isJob(batch_job_number, system_id) then
		   	  if not isJobActive(batch_job_number, system_id) then
		   	  	  RAISE_APPLICATION_ERROR(-20150,'Job ' || batch_job_number || ',' || system_id || ' is not an active job.') ;
			  end if ;
		   else		   
		   	  RAISE_APPLICATION_ERROR(-20160,'Job ' || batch_job_number || ',' || system_id || ' is not a valid job.') ;
		   end if ;		   
	  end if ;
	  
  end validateActiveJob ;
  
  procedure start_job(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP, description in amd_batch_jobs.description%type := null) is  			job_number NUMBER ;
  BEGIN
  	   SELECT MAX(batch_job_number) INTO job_number 
	   FROM AMD_BATCH_JOBS
	   WHERE start_time IS NOT NULL
	   AND end_time IS NOT NULL 
	   and system_id = start_job.system_id ;
	   IF job_number IS NULL THEN
	   	  job_number := 0 ;
	   ELSE
	   	   job_number := job_number + 1 ;
	   END IF ;
	   INSERT INTO AMD_BATCH_JOBS
	   (batch_job_number, system_id, description, start_time)
	   VALUES (job_number, start_job.system_id, start_job.description, SYSDATE) ;
  EXCEPTION
  		   WHEN standard.DUP_VAL_ON_INDEX THEN
		   	 RAISE_APPLICATION_ERROR(-20170,'Job ' || job_number || ',' || system_id || ' must be ended before another job can start') ;
  END start_job ;

  procedure abort_job(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) is
  			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := abort_job.batch_job_number ;
  begin
  	   validateActiveJob(theJob, system_id) ;
	   	   
	   <<abortActiveStep>>
	   begin
	   		abort_step(theJob, system_id) ;
	   exception when standard.no_data_found then
	   			 null ; -- no steps for job
	   end abortActiveStep ;
	   
	   -- can only abort an active job
	   update amd_batch_jobs
	   set end_time = sysdate,
	   job_aborted = 'Y'
	   where batch_job_number = theJob
	   and system_id = abort_job.system_id
	   and start_time is not null
	   and end_time is null
	   and job_aborted is null ;
	   
  exception 
  			when others then
			  	 ErrorMsg(pSqlfunction => 'update',
						pTableName => 'amd_batch_jobs',
						pError_location => 10, 
						pKey_1 => to_char(theJob),
						pKey_2 => system_id ) ;
				 raise ;
  end abort_job ;
  
  function isJob(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type, 
  			system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean is
			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type ;
  begin
  	   select batch_job_number into theJob 
	   from amd_batch_jobs
	   where batch_job_number = isJob.batch_job_number
	   and system_id = isJob.system_id ;
	   
	   return true ;
	   
  exception
  	   when standard.no_data_found then
	   		return false ;
	   when others then
	  	 ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_batch_jobs',
				pError_location => 20, 
				pKey_1 => to_char(batch_job_number),
				pKey_2 => system_id ) ;
		 raise ;
  end isJob ;

  function hasActiveSteps(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type, 
	   		system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean is 
			
			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := hasActiveSteps.batch_job_number ;
			numberOfSteps number := 0 ;
			
  begin
  	   validateActiveJob(theJob, system_id) ;
	   
	   SELECT COUNT(*) INTO numberOfSteps 
	   FROM AMD_BATCH_JOB_STEPS
	   WHERE batch_job_number = theJob
	   and system_id = hasActiveSteps.system_id
	   and start_time is not null 
	   AND end_time IS NULL
	   and step_aborted is null ;
	   
	   return numberOfSteps > 0 ; 
	   
  exception
  		   when standard.no_data_found then
		   		return false ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 30, 
					pKey_1 => to_char(theJob),
					pKey_2 => system_id ) ;
			 raise ;				
  end hasActiveSteps ;
  
  function isJobActive(batch_job_number in amd_batch_jobs.batch_job_number%type := null,
  		   system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean is
  begin
  	   return not isJobComplete(batch_job_number, system_id) ;
  end isJobActive ;

  function getLastCompleteJob(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_jobs.batch_job_number%type is
  		   theJob amd_batch_jobs.batch_job_number%type ;
  begin  	   
  	   select max(batch_job_number) into theJob 
	   from amd_batch_jobs 
	   where system_id = getLastCompleteJob.system_id
	   and start_time is not null
	   and end_time is not null
	   and job_aborted is null ;
	   return theJob ;
  exception
  			when standard.no_data_found then
				 return null ;
			when others then
			  	 ErrorMsg(pSqlfunction => 'select',
						pTableName => 'amd_batch_jobs',
						pError_location => 40, 
						pKey_1 => system_id) ;
				 raise ;
  end getLastCompleteJob ;
  
  function getActiveJob(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_jobs.batch_job_number%type is
  		   theJob amd_batch_jobs.BATCH_JOB_NUMBER%type ;
  begin
  	   -- any system is allowed only one active job
  	   select max(batch_job_number) into theJob
	   from   amd_batch_jobs
	   where  system_id = getActiveJob.system_id
	   and start_time is not null
	   and end_time is null
	   and job_aborted is null ;
	   
	   return theJob ;
  exception
     when standard.no_data_found then
	 	  return null ; -- no job active 
     when others then
	  	 ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_batch_jobs',
				pError_location => 50, 
				pKey_1 => system_id ) ;
		 raise ;
  end getActiveJob ;
  
  procedure end_job(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) is
  			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := end_job.batch_job_number ;
			active_steps NUMBER ;
  BEGIN
  	   validateActiveJob(theJob, system_id) ;
	   	   
	   IF hasActiveSteps(theJob, system_id) then
	   	   end_step(theJob, system_id) ;
	   end if ;
	   
	   UPDATE AMD_BATCH_JOBS
	   SET end_time = SYSDATE
	   WHERE batch_job_number = theJob
	   and system_id = end_job.system_id
	   and start_time is not null
	   and end_time is null
	   and job_aborted is null ;
	   
  exception
  	when others then
	  	 ErrorMsg(pSqlfunction => 'update',
				pTableName => 'amd_batch_jobs',
				pError_location => 60, 
				pKey_1 => to_char(theJob),
				pKey_2 => system_id ) ;
		 raise ;
  END end_job ;

  -- if there is no job in the system it will return a null value
  function getLastStartTime(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP)  
	   			return amd_batch_jobs.START_TIME%type is
				
				theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := getLastStartTime.batch_job_number ;
				theTime amd_batch_jobs.START_TIME%type := null ;
  begin
  	   validateJob(theJob, system_id) ;
	   if theJob is not null then
	  	   select start_time into theTime 
		   from amd_batch_jobs 
		   where batch_job_number = theJob 
		   and system_id = getLastStartTime.system_id
		   and start_time is not null
		   and job_aborted is  null ;
	   end if ;
	   return theTime ;
  exception 
  			when standard.NO_DATA_FOUND then
				 return null ;
			when others then
			  	 ErrorMsg(pSqlfunction => 'select',
						pTableName => 'amd_batch_jobs',
						pError_location => 70, 
						pKey_1 => to_char(theJob),
						pKey_2 => system_id ) ;
				 raise ;
  end getLastStartTime ;

  function getLastEndTime(batch_job_number in amd_batch_jobs.batch_job_number%type := null,system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) 
  			return amd_batch_jobs.END_TIME%type is
  			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := getLastEndTime.batch_job_number ;
			theTime amd_batch_jobs.END_TIME%type ;
  begin
  	   validateJob(theJob, system_id) ;
	   
  	   select end_time into theTime 
	   from amd_batch_jobs 
	   where batch_job_number = theJob 
	   and system_id = getLastEndTime.system_id
	   and start_time is not null
	   and end_time is not null
	   and job_aborted is null ;
	   
	   return theTime ;
	   
  exception 
  			when standard.NO_DATA_FOUND then
				 return null ;
			when others then
			  	 ErrorMsg(pSqlfunction => 'select',
						pTableName => 'amd_batch_jobs',
						pError_location => 80, 
						pKey_1 => to_char(theJob),
						pKey_2 => system_id ) ;
				 raise ;
  end getLastEndTime ;
  
  function isJobComplete(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type := null, 
	   			system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean is
		   theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := isJobComplete.batch_job_number ;
  		   isComplete boolean := false ;
		   completeJob amd_batch_jobs.BATCH_JOB_NUMBER%type ;
  begin
       validateJob(theJob, system_id) ;
	   
	   if theJob is null then
	   	  return true ;
	   else
	   	   if isJob(batch_job_number => theJob, system_id => system_id) then
		 	   select batch_job_number into completeJob
			   from amd_batch_jobs
			   where batch_job_number = theJob
			   and system_id = isJobComplete.system_id
			   and start_time is not null
			   and end_time is not null
			   and job_aborted is null ;
		   else
		   	  return true ;
		   end if ;
	  end if ;
	  			   
	  return true ;
	  
  exception
  		   when standard.no_data_found then
		   		return false ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_jobs',
					pError_location => 90, 
					pKey_1 => to_char(theJob),
					pKey_2 => system_id ) ;
			 raise ;
  end isJobComplete ;

  function didStepStart(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null, 
  		 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
		 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null, 
		 description in amd_batch_job_steps.DESCRIPTION%type := null, 
		 package_name in amd_batch_job_steps.PACKAGE_NAME%type := null, 
		 procedure_name in amd_batch_job_steps.PROCEDURE_NAME%type := null,
		 function_name in amd_batch_job_steps.FUNCTION_NAME%type := null) return boolean is
		 
		 theJob amd_batch_job_steps.BATCH_JOB_NUMBER%type := didStepStart.batch_job_number ;
		 theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type := didStepStart.batch_step_number ;
  begin
  	   validateActiveJob(theJob, system_id) ;
	   
  	   if description is not null then
	      -- only start the step if it has not yet completed	   	  
	   	  if isStepComplete(theJob, system_id, description) then
		  	 return false ;
		  else
		  	 start_step(batch_job_number => batch_job_number, system_id => system_id,
			   batch_step_number => batch_step_number, description => description,
			   package_name => package_name, procedure_name => procedure_name,
			   function_name => function_name) ;
		  end if ;
	   else
	  	 start_step(batch_job_number => batch_job_number, system_id => system_id,
		   batch_step_number => batch_step_number,
		   package_name => package_name, procedure_name => procedure_name,
		   function_name => function_name) ;
	   end if ;
  	   return true ;
  end didStepStart ;
  
  procedure start_step(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null, 
  		 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
		 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null, 
		 description in amd_batch_job_steps.DESCRIPTION%type := null, 
		 package_name in amd_batch_job_steps.PACKAGE_NAME%type := null, 
		 procedure_name in amd_batch_job_steps.PROCEDURE_NAME%type := null,
		 function_name in amd_batch_job_steps.FUNCTION_NAME%type := null) is
		 
		 theJob amd_batch_job_steps.BATCH_JOB_NUMBER%type := start_step.batch_job_number ;
		 theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type := start_step.batch_step_number ;
  begin
  	  validateActiveJob(theJob, system_id) ;
	  
	  if theStep is null then					   
		  <<getNextStep>>
		 begin
		 	 theStep := getActiveStep(theJob, system_id) ;
			 -- there was an activeStep that did not complete
			 -- show that it was aborted
			 if theStep is not null then
			 	abort_step(theJob, system_id, theStep) ;
			 end if ;
			 
		  	 select nvl(max(batch_step_number),0) into theStep
			 from amd_batch_job_steps
			 where batch_job_number = theJob
			 and system_id = start_step.system_id
			 and start_time is not null
			 and end_time is not null
			 and step_aborted is null ;
			 
			 theStep := theStep + 1 ;
	     exception
		 		  when standard.no_data_found then
				  	   theStep := 1 ;
				  when others then
				  	 ErrorMsg(pSqlfunction => 'select',
							pTableName => 'amd_batch_job_steps',
							pError_location => 100, 
							pKey_1 => to_char(theJob), 
							pKey_2 => system_id,
							pKey_3 => to_char(theStep) ) ;
					 raise ;
   		 end getNextStep ;
	  end if ;
	   
  	   insert into amd_batch_job_steps
	   (batch_job_number, system_id, batch_step_number, description, package_name, procedure_name, function_name, start_time)
	   values (theJob, start_step.system_id, theStep, start_step.description, start_step.package_name, start_step.procedure_name, start_step.function_name, sysdate) ;
	   
  exception
  		   when standard.DUP_VAL_ON_INDEX then
			  	 ErrorMsg(pSqlfunction => 'insert',
						pTableName => 'amd_batch_job_steps',
						pError_location => 110, 
						pKey_1 => to_char(theJob), 
						pKey_2 => system_id,
						pKey_3 => to_char(theStep) ) ;
				raise ;
			when others then
			  	 ErrorMsg(pSqlfunction => 'insert',
						pTableName => 'amd_batch_jobs',
						pError_location => 120, 
						pKey_1 => to_char(theJob), 
						pKey_2 => system_id) ;
				raise ;			
  end start_step ;
	 
  procedure abort_step(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
  			 system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		 batch_step_number in amd_batch_job_steps.batch_step_number%type := null) is
		 theJob amd_batch_job_steps.batch_job_number%type := abort_step.batch_job_number ;
		 theStep amd_batch_job_steps.batch_step_number%type := abort_step.batch_step_number ;
  begin
  	   validateActiveJob(theJob, system_id) ;
	   
	   if theStep is null then
  	   	  theStep := getActiveStep(batch_job_number, system_id) ;
		  if theStep is null then
		  	 return ; -- no step active
		  end if ;
	   end if ;
	   
	   update amd_batch_job_steps
	   set step_aborted = 'Y',
	   end_time = sysdate
	   where batch_job_number = theJob
	   and system_id = abort_step.system_id
	   and batch_step_number = theStep ;
	   
  exception
  		   when others then
			  	 ErrorMsg(pSqlfunction => 'update',
						pTableName => 'amd_batch_job_steps',
						pError_location => 130, 
						pKey_1 => to_char(theJob), 
						pKey_2 => system_id,
						pKey_3 => to_char(theStep) ) ;
				raise ;			
  end abort_step ;
  
  procedure end_step(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null, 
		 	 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
			 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null) is
			 
		theJob amd_batch_job_steps.batch_job_number%type := end_step.batch_job_number ;
		theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type := end_step.batch_step_number ;
  begin
  	   validateActiveJob(theJob, system_id) ;
	   
  	   if theStep is null then
	   	  theStep := getActiveStep(theJob, system_id) ;
		  if theStep is null then
		  	 return ;
		  end if ;
	   end if; 
  	   update amd_batch_job_steps
	   set end_time = sysdate
	   where batch_job_number = theJob
	   and system_id = end_step.system_id
	   and batch_step_number = theStep
	   and end_time is null ;
  exception 
    when standard.no_data_found then
		 return ; -- no step to end
  	when others then
	  	 ErrorMsg(pSqlfunction => 'update',
				pTableName => 'amd_batch_job_steps',
				pError_location => 140, 
				pKey_1 => batch_job_number, 
				pKey_2 => system_id) ;
		 raise ;			
		 
  end end_step ;
	 
  function getActiveStep(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.BATCH_STEP_NUMBER%type is
			
			theJob amd_batch_job_steps.batch_job_number%type := getActiveStep.batch_job_number ;
			theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
  begin
  	   validateActiveJob(theJob, system_id) ;
	   
	   select batch_step_number into theStep
	   from amd_batch_job_steps
	   where batch_job_number = theJob
	   and system_id = getActiveStep.system_id
	   and start_time is not null 
	   and end_time is null
	   and step_aborted is null ;
	   
  	   return theStep ;
	   
  exception
  		   when standard.no_data_found then
		   		return null ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 150, 
					pKey_1 => to_char(theJob), 
					pKey_2 => system_id,
					pKey_3 => to_char(theStep)) ;
			 raise ;			
  end getActiveStep ;
  
  function isStepComplete(batch_job_number in amd_batch_job_steps.batch_job_number%type,
  		   system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		   batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type) return boolean is

			theStep amd_batch_job_steps.batch_step_number%type ;
  begin
  	   select batch_step_number into theStep
	   from amd_batch_job_steps
	   where batch_job_number = isStepComplete.batch_job_number
	   and system_id = isStepComplete.system_id
	   and batch_step_number = isStepComplete.batch_step_number
	   and start_time is not null
	   and end_time is not null
	   and step_aborted is null ;
	   return true ;
  exception 
	   when no_data_found then
	   		return false ;
	   when others then
	  	 ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_batch_job_steps',
				pError_location => 160, 
				pKey_1 => to_char(batch_job_number), 
				pKey_2 => system_id,
				pKey_3 => to_char(batch_step_number)) ;
		 raise ;					   		
  end isStepComplete ;
  
  function isStepComplete(batch_job_number in amd_batch_job_steps.batch_job_number%type,
  		   system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		   description in amd_batch_job_steps.description%type) return boolean is
		   
	   theJob amd_batch_job_steps.BATCH_JOB_NUMBER%type := isStepComplete.batch_job_number ;
		   
	   cursor completedSteps  is
		   select batch_step_number
		   from amd_batch_job_steps
		   where batch_job_number = theJob
		   and system_id = isStepComplete.system_id
		   and description = isStepComplete.description
		   and start_time is not null
		   and end_time is not null
		   and step_aborted is null ;
		   
						
  begin
  	   if theJob is null then
	   	  -- assumption - there is an active job running
	   	  validateActiveJob(theJob, system_id) ;
	   end if ;
	   
	   -- assumption - description is unique per each step
	   -- step may have been run more than once
	   for rec in completedSteps loop
	   	   return true ;
	   end loop ;
	   return false ;
  exception 
	   when others then
	  	 ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_batch_job_steps',
				pError_location => 170, 
				pKey_1 => to_char(batch_job_number), 
				pKey_2 => system_id,
				pKey_3 => description) ;
		 raise ;					   		
  end isStepComplete ;

  function getLastCompleteStep(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
  			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.batch_step_number%type is
			
			theJob amd_batch_job_steps.batch_job_number%type := getLastCompleteStep.batch_job_number ;
			theStep amd_batch_job_steps.batch_step_number%type ;
  begin
  	   validateJob(theJob, system_id) ;
	   
  	   select max(batch_step_number) into theStep
	   from amd_batch_job_steps
	   where batch_job_number = theJob
	   and system_id = getLastCompleteStep.system_id
	   and start_time is not null
	   and end_time is not null 
	   and step_aborted is null ;
  exception
  		   when standard.no_data_found then
		   		return null ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 180, 
					pKey_1 => to_char(theJob), 
					pKey_2 => system_id) ;
			 raise ;			
  end getLastCompleteStep ;
  
  function getLastStepStartTime(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
  			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.start_time%type is

		theJob amd_batch_job_steps.batch_job_number%type := getLastStepStartTime.batch_job_number ;
		theStep amd_batch_job_steps.batch_step_number%type  ;
		theTime amd_batch_job_steps.START_TIME%type ;
  begin
  	   validateJob(theJob, system_id) ;

	   theStep := getActiveStep(theJob, system_id) ;
	   if theStep is null then
	   	  theStep := getLastCompleteStep(theJob, system_id) ;
		  if theStep is null then
		  	 return null ;
		  end if ;
	   end if ;
	   
  	   select start_time into theTime
	   from amd_batch_job_steps
	   where batch_job_number = theJob
	   and system_id = getLastStepStartTime.system_id
	   and batch_step_number = theStep
	   and start_time is not null
	   and step_aborted is null ;
	   return theTime ;
  exception
  		   when standard.no_data_found then
		   		return null ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 190, 
					pKey_1 => to_char(theJob), 
					pKey_2 => system_id,
					pKey_3 => to_char(theStep) ) ;
			 raise ;
  end getLastStepStartTime ;
  
  function getLastStepEndTime(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.start_time%type is
			
			theJob amd_batch_job_steps.batch_job_number%type := getLastStepEndTime.batch_job_number ;
			theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
			theTime amd_batch_job_steps.END_TIME%type ;
  begin
  	  validateJob(theJob, system_id) ;
	  
	  theStep := getActiveStep(theJob, system_id) ;
	  if theStep is null then
	  	 theStep := getLastCompleteStep(theJob, system_id) ;
		 if theStep is null then
		 	return null ; -- no steps for this job!
		 end if ;
	 end if ;
	 select end_time into theTime
	 from amd_batch_job_steps
	 where batch_job_number = theJob
	 and system_id = getLastStepEndTime.system_id
	 and batch_step_number = theStep
	 and start_time is not null
	 and end_time is not null
	 and step_aborted is null ;
	 return theTime ;
  exception
  		   when standard.no_data_found then
		   		return null ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 200, 
					pKey_1 => to_char(theJob), 
					pKey_2 => system_id,
					pKey_3 => to_char(theStep) ) ;
			 raise ;
  end getLastStepEndTime ;
      
  procedure deleteJob(batch_job_number in amd_batch_jobs.batch_job_number%type := null,
  			 system_id in amd_batch_jobs.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP) is
			 
		theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := deleteJob.batch_job_number ;
  begin
  	   validateJob(theJob, system_id) ;
	  
	  <<deleteSteps>>
	  begin
		  delete from amd_batch_job_steps 
		  where batch_job_number = theJob
		  and system_id = deleteJob.system_id ;
	  exception
	  		   when standard.no_data_found then
			   		return ;
			   when others then
			  	 ErrorMsg(pSqlfunction => 'delete',
						pTableName => 'amd_batch_job_steps',
						pError_location => 210, 
						pKey_1 => to_char(theJob), 
						pKey_2 => system_id ) ;
				 raise ;
	  end deleteSteps ;
	  
	  delete from  amd_batch_jobs
	  where batch_job_number = theJob
	  and system_id = deleteJob.system_id ;
  exception
			   when others then
			  	 ErrorMsg(pSqlfunction => 'delete',
						pTableName => 'amd_batch_jobs',
						pError_location => 220, 
						pKey_1 => to_char(theJob), 
						pKey_2 => system_id ) ;
				 raise ;
  end deleteJob ;    

  procedure truncateIfOld(tablename in varchar2, system_id in amd_batch_jobs.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP) is
  			type cv_type is ref cursor ;
			cv cv_type ;
			maxDate date ;
  begin
  	   if getActiveJob(system_id) is null then
	   	  	 Mta_Truncate_Table(tablename,'reuse storage');
	   else
	   	   open cv for
		   		'select max(last_update_dt) from ' || tablename ; 
		   fetch cv into maxDate ;
		   if maxDate is null or getLastStartTime(system_id => system_id) > maxDate then
		   	  Mta_Truncate_Table(tablename,'reuse storage');
		   end if ;
		   close cv ;
	   end if ;
  exception
			   when others then
			  	 ErrorMsg(pSqlfunction => 'fetch',
						pTableName => tablename,
						pError_location => 230, 
						pKey_1 => system_id ) ; 
				 raise ;
  end truncateIfOld ;

  procedure version is
  begin
		 amd_utils.writeMsg(pSourceName => 'amd_batch_pkg', pTableName => 'amd_batch_pkg', 
		 		pError_location => 240, pKey1 => 'amd_batch_pkg', pKey2 => '$Revision:   1.12  $') ;
  end version ;
 
END Amd_Batch_Pkg;
/

show errors

CREATE OR REPLACE PACKAGE BODY A2a_Pkg AS
 --
 -- SCCSID:   %M%   %I%   Modified: %G%  %U%
 --
 /*
      $Author:   zf297a  $
	$Revision:   1.138  $
     $Date:   Sep 12 2006 14:37:30  $
    $Workfile:   A2A_PKG.PKB  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\A2A_PKG.PKB-arc  $
/*   
/*      Rev 1.138   Sep 12 2006 14:37:30   zf297a
/*   For all initA2A routines use the action_code of the amd data source whenever it has a value of DELETE_ACTION, otherwise the action_code from the amd_sent_to_a2a is used.  If a part has been deleted from SPO the A2A should always be deleted too - that's why amd_sent_to_a2a.action_code is sent for all other cases.  For INSERT's or UPDATE's the A2A only sends an INSERT - if the data is already there the system will update it.
/*   
/*      Rev 1.137   Sep 12 2006 11:11:06   zf297a
/*   Added defaults for all arguments to the errorMsg procedure.  Enhanced the errorMsg procedure by enabling dbms_output when this procedure has an error.
/*   For the insertTmpA2AOrderInfo made sure the delete_action was used for any deleted order and the delete_action was used for any part that has been deleted from the SPO otherwise use whatever is in amd_on_order for this order number and part_no.
/*   
/*      Rev 1.136   Sep 05 2006 12:40:12   zf297a
/*   Renumbered pError_location's values
/*   
/*      Rev 1.135   Sep 05 2006 10:27:52   zf297a
/*   Make sure part lead time and part pricing get deleted at the right time
/*   
/*      Rev 1.134   Aug 31 2006 11:57:52   zf297a
/*   removed errorMsg function
/*   implemented interface for initA2ADemands
/*   fixed format for minutes: MI
/*   changed initA2A routines to use the action_code from the amd_sent_to_a2a table for the corresponding spo_prime_part_no
/*   
/*      Rev 1.133   Aug 28 2006 21:44:18   zf297a
/*   Fixed getScheduledReceiptDate and patched errorMsg - was producing a numeric error.
/*   
/*      Rev 1.132   Aug 18 2006 15:42:54   zf297a
/*   Implemented interfaces processExtForececast and initA2AExtForecast.  Fixed processOnOrder: literal in writeMsg + added order by clause for both cursors.
/*   Fixed action_code for doInsert - always INSERT for included parts and always DELETE for excluded parts, which will make sure they do not exist in SPO.
/*   Changed loadAll to use initA2AExtForecast.
/*   
/*      Rev 1.131   Aug 11 2006 14:27:42   zf297a
/*   Fixed action_code for doInsert procedure
/*   
/*      Rev 1.130   Aug 10 2006 14:38:22   zf297a
/*   Fixed the errorMsg routines to use dbms_output when an exception occurs and then to raise the exception again.
/*   Implemented showReason for isPartValid and isPartValidYorN.  I elimitedn the check of mDebug, since the debugMsg already checks this boolean variable.  Also, if the part passes a test, there is nothing done, but if it fails the test, debugmsg will log the reason to amd_load_details.  debugMsg limits the number of messages recorded by the public variable mDebugThreshold .
/*   Renumbered the pError_location params for the entire package. 
/*   Record all excluded parts to the amd_load_details table.
/*   
/*      Rev 1.129   Aug 04 2006 12:56:56   zf297a
/*   Moved getDueDate to be a public function and added arguments part_no and order_date to its interface.
/*   
/*      Rev 1.128   Aug 04 2006 11:09:30   zf297a
/*   Fixed function includeOrder - retrieved the scheduled_receipt_date before doing compare.
/*   
/*      Rev 1.127   Jul 13 2006 11:48:10   zf297a
/*   Removed converting of part_no to spo_prime_part_no for tmp_a2a_backorder_info - the query that is used to create the xml will do the summation to spo_prime_part_no
/*   
/*      Rev 1.126   Jul 11 2006 14:29:58   c402417
/*   Added the SpoPrimePart function to load all for AmdBackorderSum. And modify the load all for amd_in_transit to amd_in_transit_sum.
/*   
/*      Rev 1.125   Jun 21 2006 09:55:34   zf297a
/*   When doing initA2AOrderInfo make sure the input is sorted by gold_order_number, part_no, and order_date.  By doing this, the genereated line number will be in sync with the order_date 1,2,......N where 1 is the oldest order_date and N is the most recent.
/*   
/*      Rev 1.124   Jun 21 2006 08:51:34   zf297a
/*   Added unique line number for every gold_order_number / part_no pair
/*   
/*      Rev 1.123   Jun 19 2006 10:44:32   zf297a
/*   fixed processOrder - removed erroneous if test. Added some diagnostic info for filters
/*   
/*      Rev 1.122   Jun 08 2006 13:22:34   zf297a
/*   added package name to key1 of amd_load_details for procedure version and moved revision to key2 of amd_load_details.
/*   
/*      Rev 1.121   Jun 08 2006 12:15:24   zf297a
/*   changed getSiteLocation to getSpoLocation in where clause of loadAll for tmp_a2a_demads
/*   
/*      Rev 1.120   Jun 07 2006 21:00:52   zf297a
/*   used getSpoLocation for tmp_a2a_backorder_info and tmp_a2a_demands.  switched to writeMsg instead of dbms_output.  Use mta_truncate_table instead of execute immediate.
/*   
/*      Rev 1.119   May 17 2006 15:00:08   zf297a
/*   removed start_date from on_order_filter
/*   
/*      Rev 1.118   May 17 2006 14:25:20   zf297a
/*   Using amd_on_order_date_filters_pkg routines for on_order date filtering
/*   
/*      Rev 1.117   May 16 2006 12:11:24   zf297a
/*   for initA2AInvInfo routines added the union of amd_rsp_sum to all the appropriate cursors.
/*   
/*      Rev 1.116   May 12 2006 13:58:36   zf297a
/*   Removed deletesOk from the wasPartSent interface.  Now using a global variable mblnSendAllData, which has its own getter and setter.
/*   Changed all init routines to include DELETED action codes and to use all part_no's contained in amd_sent_to_a2a that also have a spo_prime_part_no.
/*   
/*      Rev 1.115   May 12 2006 10:23:12   zf297a
/*   Allowed for A2A part delete transactions to be sent again
/*   
/*      Rev 1.114   May 12 2006 09:58:24   zf297a
/*   Changed processPart so that it sends "deleted" parts as A2A deletes.
/*   
/*      Rev 1.113   Apr 27 2006 12:27:04   zf297a
/*   processBackorder needed an EXIT when backOrder%NOTFOUND to terminate the LOOP otherwise Oracle would issue a ORA-00600 error with a 4454 parameter - meaning the PL/SQL had an infinite loop
/*   
/*      Rev 1.112   Apr 27 2006 08:15:06   zf297a
/*   added system_id to the procedure loadAll
/*   
/*      Rev 1.111   Apr 26 2006 10:05:24   zf297a
/*   Fixed check for an active job at the begining of procedure loadAll
/*   
/*      Rev 1.110   Apr 26 2006 09:28:42   zf297a
/*   Get theJob when the loadAll procedure is started or restarted.
/*   
/*      Rev 1.109   Apr 26 2006 09:23:14   zf297a
/*   Added batch_job and batch_job_steps tracking for the procedure loadAll
/*   
/*      Rev 1.108   Apr 24 2006 14:57:10   zf297a
/*   Fixed isNsnInRblPairs and isNsnInIsgPairs: used cursors since queries could return more than one row.
/*   
/*   Fixed errorMsg to ignore erros when a commit fails, which means an SQL select or DML statement was being executed and "commits" are not allowed then.  
/*   
/*      Rev 1.107   Apr 24 2006 13:28:50   zf297a
/*   Fixed isPartValid by changing the isNsnValid to allow for the nsn to be in amd_rbl_pairs OR  in bssm_isg_pairs.   Previous this was an AND condition.
/*   
/*   Also, started using amd amd_rlb_pairs instead of bssm_rlb_pairs.
/*   
/*      Rev 1.106   Mar 16 2006 23:15:20   zf297a
/*   Added additional filters to isPartValid
/*   
/*      Rev 1.105   Mar 03 2006 14:43:20   zf297a
/*   Implemented the loadAll procedure - this loads all the a2a data from amd
/*   
/*      Rev 1.104   Feb 15 2006 13:39:06   zf297a
/*   Added cur ref's for all init and byDate routines + a common process routine to make sure everything is done the same no matter what selection criteria is used.
/*   
/*      Rev 1.103   Feb 15 2006 10:12:30   zf297a
/*   Fixed InitPartInfo by date: If the part is NOT valid set the action_code to delete (valid parts were getting the action_code set to delete)
/*   
/*      Rev 1.102   Feb 13 2006 10:56:24   zf297a
/*   Added wasPartSent to InsertLocPartLeadTime and UpdateLocPartLeadTime
/*   
/*      Rev 1.101   Jan 06 2006 07:08:10   zf297a
/*   Fixed initA2APartInfo: added isPartValid test
/*   
/*      Rev 1.100   Jan 04 2006 09:14:32   zf297a
/*   For initA2ABomDetail and initA2ABackorderInfo made sure that the part has been sent - i.e. it exists in the amd_sent_to_a2a table and the action_code is not DELETE.
/*   
/*      Rev 1.99   Jan 04 2006 09:01:44   zf297a
/*   Added two overloaded procedures initA2ABackorderInfo which can accept a list of parts or a range of dates like the othe initA2A procedures.
/*   
/*      Rev 1.98   Jan 03 2006 12:44:14   zf297a
/*   Added date range to procedures 
/*   initA2AInvInfo
/*   initA2ARepairInvInfo
/*   initA2AInTransits
/*   initA2ARepairInfo
/*   initA2AOrderInfo
/*   initA2APartInfo
/*   initA2ABomDetail
/*   
/*   
/*      Rev 1.96   Dec 30 2005 01:32:08   zf297a
/*   added initA2ABomDetail by date
/*   
/*      Rev 1.95   Dec 29 2005 16:37:54   zf297a
/*   added initA2A by date procedures for PartInfo, OrderInfo, InvInfo, RepairInfo, InTransits, and RepairInvInfo
/*   
/*      Rev 1.94   Dec 16 2005 09:09:48   zf297a
/*   Removed erroneous reference to tmp_a2a_parts, which is not being used.
/*   
/*      Rev 1.93   Dec 14 2005 11:41:58   zf297a
/*   Fixed updateA2ApartInfo to use the correct rcm_ind.
/*   
/*      Rev 1.92   Dec 14 2005 10:39:08   zf297a
/*   Fixed isPlannerCodeValid - added check for a null planner code.
/*   
/*      Rev 1.91   Dec 07 2005 12:28:42   zf297a
/*   Now handle buffer overflow for dbms_output by disabling the output when this exception occurs.  Also, log the reason for isPartValid's criteria for returning a FALSE using debugMsg.
/*   
/*      Rev 1.90   Dec 07 2005 09:50:06   zf297a
/*   Fixed wasPartSent - checked to make sure the spo_prime_part_no is not null
/*   
/*      Rev 1.89   Dec 05 2005 13:40:54   zf297a
/*   Make sure the part_no is not null before trying to insert or update the tmp_a2a_bom_detail table.
/*   
/*      Rev 1.88   Dec 05 2005 13:29:26   zf297a
/*   Fixed retrieval of time_to_repair from amd_part_locs to allow for the no_data_found exception.
/*   
/*      Rev 1.87   Dec 01 2005 10:26:18   zf297a
/*   made sure spo_prime_part_no is not null before inserting into tmp_a2a_bom_detail
/*   
/*      Rev 1.86   Nov 30 2005 15:09:20   zf297a
/*   added type to errormsg of exception handler for insertTmpA2AInTransits.doUpdate 
/*   
/*      Rev 1.85   Nov 30 2005 15:03:46   zf297a
/*   added type qualifier for tmp_a2a_in_transits for doUpdate
/*   
/*      Rev 1.84   Nov 30 2005 11:32:16   zf297a
/*   added truncate of the tmp_a2a_bom_detail table to the initA2ABomDetail procedure.
/*   
/*      Rev 1.83   Nov 30 2005 10:54:08   zf297a
/*   added amd_test_parts to deletePartInfo.  implemented populateBomDetail.
/*   
/*      Rev 1.82   Nov 30 2005 09:11:50   zf297a
/*   Added isPartValid test when inserting tmp_a2a_repair_info.  Added exception handlers for duplicate keys for function insertTmpA2AInTransits
/*   
/*      Rev 1.81   Nov 15 2005 11:51:52   zf297a
/*   Use cleaned fields for smr_code and planner_code.  Add check for -14552
/*   
/*      Rev 1.80   Nov 10 2005 10:33:26   zf297a
/*   Implemented deleteInvalidParts.  Changed all literal of 'D' to amd_defaults.DELETE_ACTION.  Added "where action_code != amd_defaults.DELETE_ACTION" to all subqueries retrieving part_no's from amd_sent_to_a2a.
/*   
/*   Enhanced the debugMsg routine to ignore exception -14551, where a commit is not allowed during a query.  This exception could occur if some fo the YorN functions are used in a Select query and debug is turned on.
/*   
/*      Rev 1.79   Nov 09 2005 11:10:18   zf297a
/*   Implemented interfaces:  wasPartSentYorN, isPartValidYorN, isPlannerCodeAssign2UserIdYorN, and isNslYorN.
/*   
/*      Rev 1.78   Nov 09 2005 10:35:04   zf297a
/*   Added amd_test_parts table to make it easier to switch test parts.
/*   
/*      Rev 1.77   Oct 28 2005 08:39:36   zf297a
/*   In validateData routine, remove the to_char function for mtbf
/*   
/*      Rev 1.76   Oct 27 2005 15:45:10   c402417
/*   Changed expected_completion_date in tmp_a2a_repair_info to get date from amd_in_repair.repair_need_date.
/*   
/*      Rev 1.75   Oct 27 2005 10:23:10   zf297a
/*   Implemented deletePartInfo so all parts can be deleted or just a set of test cases can be deleted.
/*   
/*      Rev 1.74   Oct 21 2005 07:26:32   zf297a
/*   Added amd_partprime_pkg.DiffPartToPrime to initA2APartLeadTime
/*   
/*      Rev 1.73   Oct 20 2005 11:36:08   zf297a
/*   Removed converting of order_lead_time_cleaned from months to calendar days, since it is already being done by the amd_load.loadGold procedure.
/*   Removed converting of order_lead_time from business days to calendar days, since it is already being don by the amd_load.loadGold procedure.
/*   Removed converting time_to_repair_off_base_cleand from months to calendar days, since it is already being done by the amd_load.loadGold procedure.
/*   Added check that the part was sent before inserting any tmp_a2a_parts_lead_time rows.
/*   
/*      Rev 1.71   Oct 19 2005 11:46:08   zf297a
/*   Changed the arg list for insertTmpA2AOrderInfo and folded the procedure insertTmpA2AOrderInfoLine into insertTmpA2AOrderInfo.  Checked sched_receipt_date and if it is null compute a new due_date based on the order_lead_time (cleaned take precedence).
/*   
/*      Rev 1.70   Oct 18 2005 14:57:08   zf297a
/*   Enhanced debuging of isPartValid
/*   
/*      Rev 1.69   Oct 13 2005 10:18:36   zf297a
/*   Reinstated the in clause for the testParts.  Added additional counters for initA2AOrderInfo.  (include function still needs to be verified).
/*   
/*      Rev 1.68   Oct 11 2005 09:15:34   c402417
/*   changed the where clause in tmp_a2a_repair_info.
/*   
/*      Rev 1.67   Oct 10 2005 09:34:22   zf297a
/*   added price to tmp_a2a_part_info and all insert / update routines for tmp_a2a_part_info
/*   
/*      Rev 1.66   Oct 07 2005 12:18:22   zf297a
/*   Added cage_code to tmp_a2a_order_info and tmp_a2a_part_lead_time.  Created a separate procedure to init tmp_a2a_part_lead_time.
/*   
/*      Rev 1.65   Oct 06 2005 12:22:42   zf297a
/*   Changed set of part test cases.
/*   
/*      Rev 1.64   Oct 05 2005 16:08:22   c402417
/*   added condition to populate data into tmp_a2a_repair_info when ORDER_NO are not in 'RETAIL' or 'II%'.
/*   
/*      Rev 1.63   Sep 29 2005 12:47:20   zf297a
/*   Added check to exclude planner_code of AFD
/*   
/*      Rev 1.62   Sep 13 2005 12:54:48   zf297a
/*   For the includeOrder function removed the voucher test at the start.  If a param is not present for a given voucher, all param will be null, which will result in the order being "included"
/*   
/*      Rev 1.61   Sep 09 2005 13:33:30   zf297a
/*   Changed OrderInfo routines to use getSpoLocation instead of getSiteLocation per Laurie's directions.
/*   
/*      Rev 1.60   Sep 09 2005 11:11:20   zf297a
/*   Changed insertInvInfo to use spo_location, which comes from amd_spare_networks.spo_location.  However, the a2a transactions still refers to it as site_location so that name is left along for the tmp_a2a_inv_info table.
/*   
/*      Rev 1.59   Sep 08 2005 10:30:42   zf297a
/*   added date filter for tmp_a2a_order_info and tmp_a2a_order_info_line ;
/*   
/*      Rev 1.58   Aug 29 2005 14:43:52   zf297a
/*   modified insertA2AOrderInfo to filter by order_date and use the earliest date.
/*   
/*      Rev 1.57   Aug 26 2005 15:10:08   zf297a
/*   Qualified init routines with   and part_no in (select part_no from amd_sent_to_a2a) to make sure the part was sent.
/*   
/*      Rev 1.56   Aug 26 2005 14:51:34   zf297a
/*   Added function isNsnInIsgPairs
/*   
/*      Rev 1.56   Aug 19 2005 12:36:10   zf297a
/*   removed functions bizDays2CalendarDays, months2CalendarDays, and getSiteLocation and put them in amd_utils
/*   
/*      Rev 1.55   Aug 15 2005 14:45:48   zf297a
/*   added initA2ASpoUsers
/*   
/*      Rev 1.54   Aug 12 2005 13:06:44   zf297a
/*   Used getAssignedPlannerCode to determine the planner_code to be used for a2a_part_info - either the current planner or the default planner code.
/*   
/*      Rev 1.53   Aug 11 2005 12:41:54   zf297a
/*   Changed name of the routines that convert business days to calendar days and months to calendar days.  Used these conversion functions in the initA2APartInfo
/*   
/*      Rev 1.52   Aug 10 2005 13:48:04   zf297a
/*   Added commits for the init routines per every COMMIT_THRESHOLD times.  Added validateData to insertPartInfo.
/*      
/*      Rev 1.51   Aug 10 2005 10:00:18   zf297a
/*   Implemented functions convertCleanedOrderLeadTime and convertOrderLeadTime
/*   
/*      Rev 1.50   Aug 10 2005 09:27:04   zf297a
/*   Checked if a planner_code is assigned to a UserId and converted rcm_ind of T to R.
/*   
/*      Rev 1.49   Aug 09 2005 11:54:02   zf297a
/*   Fixed validateData for insertPartInfo: lineNo needed to be initialized and also coneverted to a character when an error is reported via amd_load_details.
/*   
/*      Rev 1.48   Aug 09 2005 10:05:08   zf297a
/*   Enhanced debugMsg by adding a lineNo argument to the interface  and a commit to the implementation.
/*   
/*      Rev 1.47   Aug 09 2005 09:46:54   zf297a
/*   Added validation of input for insertPartInfo, added doUpdate for insertRespSiteAssetMgr, and added substr for the email and name columns so they will not exceed 32 characters.
/*   
/*      Rev 1.46   Aug 04 2005 14:41:12   zf297a
/*   Implemented insertTmpA2ASpoUsers
/*   
/*      Rev 1.45   Aug 03 2005 14:53:56   zf297a
/*   Added sched_receipt_data for tmp_a2a_order_info_line
/*   
/*      Rev 1.44   Aug 02 2005 13:25:50   zf297a
/*   Added debug and dbms_output to isPartValid
/*   
/*      Rev 1.43   Jul 28 2005 10:52:40   zf297a
/*   Applied work around for the Oracle bug that caused this package not to compile with debug.  A view was created that was identical to the cursor partInfo used in initA2APartInfo.  This view is used as the "type" for the rec parameter used by the procedure processPart (partInfo_v%ROWTYPE).  Now the package will compile in "debug" without an error.
/*
/*      Rev 1.42   Jul 22 2005 14:34:34   zf297a
/*   Still getting the compiler error with Toad.  So, I tried eliminating all anonymous blocks in exception handlers, but the problem still persists: Toad displays this message: "Message Code Lang=Oracle was not found. Please verify and re-enter."
/*
/*      Rev 1.41   Jul 22 2005 14:20:36   zf297a
/*   Removed the anonymous block in processPart that declares the smr_code and moved the smr_code up so it belongs to the procedure.  This change enables Toad to compile the package with debug without an error.  For some reason Toad could not handle this syntax.
/*
/*      Rev 1.40   Jul 22 2005 12:24:52   zf297a
/*   Fixed wasPartSent - need paren's around the SQL OR condition otherwise more than one row would be returned.
/*
/*      Rev 1.39   Jul 20 2005 13:46:06   zf297a
/*   Delete the part from the spo via deletePartInfo when it no longer meets the criteria of a "spo part"
/*
/*   Make sure that the part was sent before trying to delete it from the spo. (deletePartInfo now uses wasPartSent)
/*
/*      Rev 1.38   Jul 20 2005 07:46:16   zf297a
/*   using only bems_id for a2a for spo users
/*
/*      Rev 1.37   Jul 19 2005 14:17:58   zf297a
/*   added spoUser procedure to create the a2a transactions for the spo_user
/*
/*      Rev 1.36   Jul 15 2005 10:53:00   zf297a
/*   do not insert into tmp_a2a tables if site_location is null
/*
/*      Rev 1.35   Jul 11 2005 12:38:44   zf297a
/*   added function initA2AInvInfo
/*
/*      Rev 1.34   Jul 11 2005 12:26:20   zf297a
/*   added function initA2AInTransits
/*
/*      Rev 1.33   Jul 11 2005 12:14:52   zf297a
/*   added function initA2ARepairInfo
/*
/*      Rev 1.32   Jul 11 2005 11:54:00   zf297a
/*   updated pError_location (10, 20, 30,...... 450)
/*
/*      Rev 1.31   Jul 11 2005 11:47:46   zf297a
/*   added procedure insertTmpA2AInTransits
/*
/*      Rev 1.30   Jul 11 2005 11:16:50   zf297a
/*   Made wasPartSent and isPartValid public functions
/*
/*      Rev 1.27   Jul 11 2005 10:37:36   zf297a
/*   added procedure to insertTmpA2AOrderInfo and insertTmpA2AOrderInfoLine
/*
/*      Rev 1.26   Jul 06 2005 12:52:58   zf297a
/*   Checked isPlannerCodeValid for all parts
/*
/*      Rev 1.25   Jun 22 2005 15:02:24   c970183
/*   Added flexibility to the Init routines so that the test case can be inserted, changed, or deleted.
/*
/*      Rev 1.24   Jun 10 2005 11:20:02   c970183
/*   Streamlined insertSiteRespAssetMgr, insertInvInfo, and insertRepairInfo.
/*
/*      Rev 1.23   Jun 09 2005 15:03:26   c970183
/*   implemented insert, update, and logical delete for tmp_a2a_site_resp_asset_mgr
/*
/*      Rev 1.22   Jun 08 2005 08:03:50   c970183
/*   Qualified the use of createPartInfo arguments to stop multiple rows from being selected by the getPartInfo routine.
/*
/*      Rev 1.21   May 18 2005 08:57:08   c970183
/*   Added getIndenture public method.  Modified inita2a to use getIndenture.
/*
/*      Rev 1.20   May 18 2005 08:25:50   c970183
/*   Fixed indenture.  Added function name to mArgs debug variable
/*
/*      Rev 1.19   May 13 2005 14:36:06   c970183
/*   Added procedure createPartInfo.  For a given part_no create an update transaction in tmp_a2a_part_info.  action_code may be overridden too.
/*
/*      Rev 1.18   May 02 2005 12:57:12   c970183
/*   Completed part validation routines.
/*
/*      Rev 1.17   Apr 28 2005 14:05:16   c970183
/*   Added part_no filter: if it is not an NSL send it as an A2A transaction.  If it is an NSL, validate that it meets the addional criteria to be sent.
/*
/*      Rev 1.16   Apr 27 2005 07:35:34   c970183
/*   For deletePartPricing - set price_type to AN_ORDER and price to zero.
/*
/*      Rev 1.15   Apr 22 2005 13:57:08   c970183
/*   added return success to all routines handling dup_val_on_index exceptions.
/*
/*      Rev 1.14   Apr 22 2005 10:49:44   c970183
/*   added update's to gaurantee function works.  However, if the unique keys are removed in the future, the update will never get executed and could be removed.
/*
/*      Rev 1.13   Apr 22 2005 08:06:50   c970183
/*   add mArgs to errorMsg
/*
/*      Rev 1.10   Mar 25 2005 11:46:28   c970183
/*   Fixed the update and delete routines to insert data into the tmp_a2a tables and to have the appropriate action_codes: update or delete.
/*
/*      Rev 1.9   03 Sep 2004 10:19:16   c970183
/*   Added check for SQL%ROWCOUNT = 0 after all updates.  This is an error situation that should not occurs.  Also. resequenced pError_location parameters
/*
/*      Rev 1.8   03 Sep 2004 09:59:56   c970183
/*   removed substr for pError_location - its a number not a string
/*
/*      Rev 1.6   03 Sep 2004 08:59:04   c970183
/*   Added substr's to error logging routine to make sure that it is never trying to insert strings longer that the columns that will contain the data: i.e. it should not cause an error when it is supposed to help find errors.
/*
/*      Rev 1.5   27 Aug 2004 14:33:06   c970183
/*   Added constants 'NEW BUY', 'REPAIR', and 'ORDER'.
/*
/*      Rev 1.4   12 Aug 2004 14:54:02   c970183
/*   implemented updatePartInfo function
/*
/*      Rev 1.3   12 Aug 2004 14:41:04   c970183
/*   removed initial prototypes
/*
/*      Rev 1.2   12 Aug 2004 14:30:46   c970183
/*   added insert, update, and delete functions for a2a tables.  implemented insert functions for part data.
/*
/*      Rev 1.1   Jul 20 2004 07:02:32   c970183
/*   Added functions to generate current year.
/*
/*      Rev 1.0   Jul 19 2004 14:10:48   c970183
/*   Initial revision.
    */

 THIS_PACKAGE CONSTANT CHAR(7) := 'a2a_pkg' ;
 mArgs VARCHAR2(2000) ;
 prime_ind VARCHAR2(1) ;
 prime_part AMD_SPARE_PARTS.part_no%TYPE ;
 mblnSendAllData BOOLEAN := FALSE ;

 
 COMMIT_THRESHOLD     CONSTANT NUMBER := 250 ;
 DEBUG_THRESHOLD	  CONSTANT NUMBER := 5000 ;
  
 includeCnt NUMBER := 0 ;
 excludeCnt NUMBER := 0 ;
 
	  


 CURSOR managers IS
 SELECT * FROM AMD_PLANNER_LOGONS ;

 cursor managersNoUser is
	select distinct planner_code, amd_defaults.GetParamValue('nsn_logon_id') logon_id, '3' data_source from amd_national_stock_items
	where planner_code not in (select distinct planner_code from amd_planner_logons)
	and prime_part_no in (select distinct spo_prime_part_no from amd_sent_to_a2a where action_code <> 'D')
	and substr(nsn,1,3) <> 'NSL'
	and planner_code is not null
	union
    select distinct planner_code_cleaned planner_code, amd_defaults.GetParamValue('nsn_logon_id') logon_id, '3' data_source from amd_national_stock_items
	where planner_code not in (select distinct planner_code from amd_planner_logons)
	and prime_part_no in (select distinct spo_prime_part_no from amd_sent_to_a2a where action_code <> 'D')
	and substr(nsn,1,3) <> 'NSL'
	and planner_code_cleaned is not null	
	union
	select distinct planner_code, amd_defaults.GetParamValue('nsl_logon_id') logon_id, '3' data_source from amd_national_stock_items
	where planner_code not in (select distinct planner_code from amd_planner_logons)
	and prime_part_no in (select distinct spo_prime_part_no from amd_sent_to_a2a where action_code <> 'D')
	and substr(nsn,1,3) = 'NSL'
	and planner_code is not null
	union
	select distinct planner_code_cleaned planner_code, amd_defaults.GetParamValue('nsl_logon_id') logon_id, '3' data_source from amd_national_stock_items
	where planner_code not in (select distinct planner_code from amd_planner_logons)
	and prime_part_no in (select distinct spo_prime_part_no from amd_sent_to_a2a where action_code <> 'D')
	and substr(nsn,1,3) = 'NSL'
	and planner_code_cleaned is not null	
	union
	select amd_defaults.GetParamValue('nsn_planner_code')  planner_code, amd_defaults.GetParamValue('nsn_logon_id') logon_id, '3' data_source from dual
	union
	select amd_defaults.GetParamValue('nsl_planner_code')  planner_code, amd_defaults.GetParamValue('nsl_logon_id') logon_id, '3' data_source  from dual
	order by planner_code, logon_id ;

 CURSOR testParts IS
  SELECT sp.mfgr,
      sp.part_no,
      sp.NOMENCLATURE,
      sp.nsn,
      sp.order_lead_time,
      sp.order_lead_time_defaulted,
      sp.unit_cost,
      sp.unit_cost_defaulted,
      sp.unit_of_issue,
      nsi.unit_cost_cleaned,
      nsi.order_lead_time_cleaned,
      nsi.planner_code,
      nsi.planner_code_cleaned,
      nsi.mtbdr,
      nsi.mtbdr_cleaned,
      nsi.smr_code,
      nsi.smr_code_cleaned,
      nsi.smr_code_defaulted,
      nsi.nsi_sid,
      nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND
  FROM AMD_SPARE_PARTS sp,
    AMD_NATIONAL_STOCK_ITEMS nsi
  WHERE sp.nsn = nsi.nsn
     AND sp.action_code != Amd_Defaults.DELETE_ACTION
     AND sp.part_no IN (SELECT part_no FROM AMD_TEST_PARTS) ;


	PROCEDURE writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 IN VARCHAR2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'a2a_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	END writeMsg ;

	function isNumeric(p_string in varchar2) return boolean is
			 l_number number ;
	begin
		 l_number := p_string ;
		 return true ;
	exception when others then
			  return false ;
	end isNumeric ;

 -- do a forward declaration of ErrorMsg, since it will be wrapped by a procedure of the
 -- same name

	 PROCEDURE ErrorMsg(
	     pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE := 'errorMsg',
	     pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE := 'noname',
	     pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE := -100,
	     pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE := '',
	      pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
	     pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
	     pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
	     pKeywordValuePairs IN VARCHAR2 := '') IS
		 
	     key5 AMD_LOAD_DETAILS.KEY_5%TYPE := pKeywordValuePairs ;
		 
	 BEGIN
		  ROLLBACK;
		  IF key5 = '' THEN
		     key5 := pSqlFunction || '/' || pTableName ;
		  ELSE
		   key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
		  END IF ;
		  -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
		  -- do not exceed the length of the column's that the data gets inserted into
		  -- This is for debugging and logging, so efforts to make it not be the source of more
		  -- errors is VERY important
		  
		  dbms_output.put_line('insertError@' || pError_location) ;
		  
		  Amd_Utils.InsertErrorMsg (
		    pLoad_no => Amd_Utils.GetLoadNo(
		      pSourceName => SUBSTR(pSqlfunction,1,20),
		      pTableName  => SUBSTR(pTableName,1,20)),
		    pData_line_no => pError_location,
		    pData_line    => 'a2a_pkg.' || mArgs,
		    pKey_1 => SUBSTR(pKey_1,1,50),
		    pKey_2 => SUBSTR(pKey_2,1,50),
		    pKey_3 => SUBSTR(pKey_3,1,50),
		    pKey_4 => SUBSTR(pKey_4,1,50),
		    pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS') ||
		         ' ' || substr(key5,1,50),
		    pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
		    COMMIT;
	   
	 EXCEPTION WHEN OTHERS THEN
	   dbms_output.enable(10000) ;
	   if pSqlFunction is not null then dbms_output.put_line('pSqlFunction=' || pSqlfunction) ; end if ;
	   if pTableName is not null then dbms_output.put_line('pTableName=' || pTableName) ; end if ;
	   if pError_location is not null then dbms_output.put_line('pError_location=' || pError_location) ; end if ;
	   if pKey_1 is not null then dbms_output.put_line('key1=' || pKey_1) ; end if ;
	   if pkey_2 is not null then dbms_output.put_line('key2=' || pKey_2) ; end if ;
	   if pKey_3 is not null then dbms_output.put_line('key3=' || pKey_3) ; end if ;
	   if pKey_4 is not null then dbms_output.put_line('key4=' || pKey_4) ; end if ;
	   if pKeywordValuePairs is not null then dbms_output.put_line('pKeywordValuePairs=' || pKeywordValuePairs) ; end if ;
	   raise ;
	 END ErrorMsg;
	
	 FUNCTION ErrorMsg(
	     pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
	     pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
	     pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
	     pReturn_code IN NUMBER,
	     pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE,
	      pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
	     pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
	     pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
	     pKeywordValuePairs IN VARCHAR2 := '') RETURN NUMBER IS
	     key5 AMD_LOAD_DETAILS.KEY_5%TYPE := pKeywordValuePairs ;
	 BEGIN
	  ROLLBACK;
	  IF key5 = '' THEN
	     key5 := pSqlFunction || '/' || pTableName ;
	  ELSE
	   key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
	  END IF ;
	  -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
	  -- do not exceed the length of the column's that the data gets inserted into
	  -- This is for debugging and logging, so efforts to make it not be the source of more
	  -- errors is VERY important
	  Amd_Utils.InsertErrorMsg (
	    pLoad_no => Amd_Utils.GetLoadNo(
	      pSourceName => SUBSTR(pSqlfunction,1,20),
	      pTableName  => SUBSTR(pTableName,1,20)),
	    pData_line_no => pError_location,
	    pData_line    => 'a2a_pkg.' || mArgs,
	    pKey_1 => SUBSTR(pKey_1,1,50),
	    pKey_2 => SUBSTR(pKey_2,1,50),
	    pKey_3 => SUBSTR(pKey_3,1,50),
	    pKey_4 => SUBSTR(pKey_4,1,50),
	    pKey_5 => SUBSTR('rc=' || TO_CHAR(nvl(pReturn_code,88888)) ||
	            ' ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS') ||
	         ' ' || key5,1,50),
	    pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
	    COMMIT;
	    RETURN pReturn_code;
	 EXCEPTION WHEN OTHERS THEN
	     if pSqlfunction is not null then dbms_output.put_line('pSqlfunction=' ||	   pSqlfunction) ; end if ;
	     if pTableName is not null then dbms_output.put_line('pTableName=' || pTableName) ; end if ;
	     if pError_location is not null then dbms_output.put_line('pError_location=' || pError_location) ; end if ;
	     if pReturn_code is not null then dbms_output.put_line('pReturn_code=' || pReturn_code) ; end if ;
	     if pKey_1 is not null then dbms_output.put_line('pKey_1=' || pKey_1) ; end if ;
	     if pKey_2 is not null then dbms_output.put_line('pKey_2=' || pKey_2) ; end if ;
	     if pKey_3 is not null then dbms_output.put_line('pKey_3=' || pKey_3) ; end if ;
	     if pKey_4 is not null then dbms_output.put_line('pKey_4=' || pKey_4); end if ;
	     if pKeywordValuePairs is not null then dbms_output.put_line('pKeywordValuePairs=' || pKeywordValuePairs) ; end if ;
		 raise ;
	 END ErrorMsg;
	
	 PROCEDURE debugMsg(msg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE, lineNo IN NUMBER) IS
	 BEGIN
	   IF mDebug THEN
		   Amd_Utils.debugMsg(pMsg => msg,pPackage => 'a2a_pkg', pLocation => lineNo) ;
		   COMMIT ; -- make sure the trace is kept
	   END IF ;
	 EXCEPTION WHEN OTHERS THEN
	 		   IF SQLCODE = -14551 OR SQLCODE = -14552 THEN
			   	  NULL ; -- cannot do a commit inside a query, so ignore the error
			   ELSE
			   	   RAISE ;
			   END IF ;
	 END debugMsg ;
	 
	 FUNCTION getSendAllData RETURN BOOLEAN IS
	 BEGIN
	 	  RETURN mblnSendAllData ;
	 END getSendAllData ;
	 
	 PROCEDURE setSendAllData(theIndicator IN BOOLEAN) IS
	 BEGIN
	 	  mblnSendAllData := theIndicator ;
	 END setSendAllData ; 
	
	
	 PROCEDURE truncateA2Atables IS
	 BEGIN
		 Mta_Truncate_Table('tmp_a2a_part_info','reuse storage');
		 Mta_Truncate_Table('tmp_a2a_part_lead_time','reuse storage');
		 Mta_Truncate_Table('tmp_a2a_part_pricing','reuse storage');
	 END truncateA2Atables ;
	 
	 FUNCTION getIndenture(smr_code_preferred IN AMD_NATIONAL_STOCK_ITEMS.SMR_CODE%TYPE) RETURN TMP_A2A_PART_INFO.indenture%TYPE IS
	 BEGIN
	   IF SUBSTR(smr_code_preferred,1,3) IN ('PBO','PAO') THEN
	    RETURN '1' ;
	   END IF ;
	   RETURN '2' ;
	 END getIndenture ;
	 FUNCTION isPartValid(partNo IN VARCHAR2, smrCode IN VARCHAR2, mtbdr IN NUMBER, plannerCode IN VARCHAR2, showReason in boolean := false) RETURN BOOLEAN IS
	
	    result BOOLEAN := FALSE ;
	    nsn AMD_SPARE_PARTS.NSN%TYPE ;
	
	    FUNCTION demandExists RETURN BOOLEAN IS
	        result NUMBER := 0 ;
	    BEGIN
	       SELECT 1 INTO result
	      FROM dual
	      WHERE EXISTS
	        (SELECT *
	       FROM AMD_DEMANDS demands, AMD_NATIONAL_STOCK_ITEMS items, AMD_SPARE_PARTS parts
	       WHERE isPartValid.partNo = parts.part_no
	       AND parts.action_code != Amd_Defaults.DELETE_ACTION
	       AND parts.nsn = items.nsn
	       AND items.ACTION_CODE != Amd_Defaults.DELETE_ACTION
	       AND items.nsi_sid = demands.nsi_sid
	       AND demands.QUANTITY > 0
	       AND demands.ACTION_CODE != Amd_Defaults.DELETE_ACTION) ;
	   	   IF result > 0 THEN
		   	  null ; -- do  nothing
		   ELSE
		  	 debugMsg('Demand does NOT exist for ' || isPartValid.partNo, 10) ;
		  	 if showReason then dbms_output.put_line('Demand does NOT exist for ' || isPartValid.partNo) ; end if ;
		   END IF ;
	       RETURN (result > 0) ;
	   EXCEPTION
	      WHEN standard.NO_DATA_FOUND THEN
	         RETURN FALSE ;
	      WHEN OTHERS THEN
	          ErrorMsg(pSqlfunction => 'select',
	             pTableName => 'demands / items',
	           pError_location => 10,
	           pKey_1 => isPartValid.partNo,
	           pKey_2 => nsn) ;
	        RAISE ;
	    END demandExists ;
	
	    FUNCTION inventoryExists RETURN BOOLEAN IS
	        result NUMBER := 0 ;
	       primePartNo AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE ;
	    BEGIN
	       <<getPrimePartNo>>
	       BEGIN
	        SELECT items.prime_part_no INTO primePartNo
	       FROM AMD_NATIONAL_STOCK_ITEMS items, AMD_SPARE_PARTS parts
	       WHERE isPartValid.partNo = parts.part_no
	       AND parts.nsn = items.nsn ;
	      EXCEPTION WHEN OTHERS THEN
	          ErrorMsg(pSqlfunction => 'select',
		       pTableName => 'amd_spare_parts',
		       pError_location => 20,
		       pKey_1 => isPartValid.partNo,
		       pKey_2 => nsn) ;
	        RAISE ;
	      END getPrimePartNo ;
	
	      <<doesDataExist>>
	      BEGIN
	        SELECT 1 INTO result
	       FROM dual
	       WHERE EXISTS
	         (SELECT *
	        FROM AMD_ON_HAND_INVS oh
	        WHERE primePartNo = oh.part_no
	        AND oh.ACTION_CODE != Amd_Defaults.DELETE_ACTION
	        AND oh.INV_QTY >0
	        )
	      OR EXISTS
	         (SELECT *
	          FROM AMD_IN_REPAIR ir
	       WHERE primePartNo = ir.PART_NO
	       AND ir.ACTION_CODE != Amd_Defaults.DELETE_ACTION
	       AND ir.REPAIR_QTY > 0
	       )
	      OR EXISTS
	         (SELECT *
	          FROM AMD_ON_ORDER oo
	       WHERE primePartNo = oo.PART_NO
	       AND oo.ACTION_CODE != Amd_Defaults.DELETE_ACTION
	       AND oo.ORDER_QTY > 0
	       )
	      OR EXISTS
	         (SELECT *
	          FROM AMD_IN_TRANSITS it
	       WHERE primePartNo = it.PART_NO
	       AND it.ACTION_CODE != Amd_Defaults.DELETE_ACTION
	       AND it.QUANTITY > 0
	       )  ;
	      EXCEPTION
	            WHEN standard.NO_DATA_FOUND THEN
	         NULL ;
	         WHEN OTHERS THEN
	            ErrorMsg(pSqlfunction => 'select',
		         pTableName => 'exist',
		         pError_location => 30,
		         pKey_1 => isPartValid.partNo,
		         pKey_2 => nsn) ;
	          RAISE ;
	
	      END doesDataExist ;
	      IF result > 0 THEN
		  	 null ; -- do nothing
		  ELSE
		 	debugMsg('Inventory does NOT exist for ' || isPartValid.partNo, 20) ;
	  	 	if showReason then dbms_output.put_line('Inventory does NOT exist for ' || isPartValid.partNo) ; end if ;
		  END IF ; 	 
	      RETURN (result > 0) ;
	    END inventoryExists ;
	
	    FUNCTION isPlannerCodeValid RETURN BOOLEAN IS
	        isValid BOOLEAN  := FALSE ;
	    BEGIN
		   IF plannerCode IS NOT NULL THEN
		       IF LENGTH(plannerCode) >= 2 THEN
		        isValid := UPPER(SUBSTR(plannerCode,1,2)) != 'KE' AND UPPER(SUBSTR(plannerCode,1,2)) != 'SE' ;
				IF isValid THEN
					IF LENGTH(plannerCode) >= 3 THEN
					   isValid := UPPER(SUBSTR(plannerCode,1,3)) != 'AFD' ;
					ELSE
						isValid := TRUE ;
					END IF ;
				END IF ;
		      ELSE
		         isValid := TRUE ;
		      END IF ;
		  END IF ;
	      IF isValid THEN
		  	 null ; -- do nothing
		  else
		 	debugMsg(plannerCode || ' Planner code is NOT valid for ' || isPartValid.partNo, 30) ;
	  	 	if showReason then dbms_output.put_line(plannerCode || ' Planner code is NOT valid for ' || isPartValid.partNo) ; end if ;
		  END IF ;
	      RETURN isValid ;
	    END isPlannerCodeValid ;
	
	    FUNCTION isNsnValid RETURN BOOLEAN IS
	        nsn AMD_NATIONAL_STOCK_ITEMS.nsn%TYPE ;
	       FUNCTION isNsnInRblPairs RETURN BOOLEAN IS
	            result BOOLEAN := FALSE ;
	       BEGIN
	         <<tryOldNsn>>
	         DECLARE
			   CURSOR old_nsns IS
			         SELECT old_nsn
					 FROM AMD_RBL_PAIRS 
					 WHERE old_nsn = isNsnValid.nsn ;
	         BEGIN
			 	  FOR rec IN old_nsns LOOP 
	         	  	  result := TRUE ;
					  EXIT WHEN TRUE ;
				  END LOOP ;
	         	  IF NOT result THEN
			           <<tryNewNsn>>
			           DECLARE
			             	  CURSOR new_nsns IS
			              	  SELECT new_nsn
							  FROM AMD_RBL_PAIRS 
							  WHERE new_nsn = isNsnValid.nsn ;
			           BEGIN
					   		FOR rec IN new_nsns LOOP
			             		result := TRUE ;
								EXIT WHEN TRUE ;
							END LOOP ;
			           EXCEPTION
			              WHEN OTHERS THEN
			                  ErrorMsg(pSqlfunction => 'select',
				               pTableName => 'amd_rbl_pairs',
				               pError_location => 40,
				               pKey_1 => isNsnValid.nsn) ;
			                RAISE ;
			           END tryNewNsn ;
				 END  IF ;
			 EXCEPTION WHEN OTHERS THEN
	              ErrorMsg(pSqlfunction => 'select',
			           pTableName => 'amd_rbl_pairs',
			           pError_location => 50,
			           pKey_1 => isNsnValid.nsn) ;
			     RAISE ;
			 END tryOldNsn ;
			 
		     IF result THEN
			 	null ; -- do nothing
			 ELSE
			   debugMsg(isNsnValid.nsn || ' Nsn is NOT valid for ' || isPartValid.partNo,40) ;
		 	   if showReason then dbms_output.put_line(isNsnValid.nsn || ' Nsn is NOT valid for ' || isPartValid.partNo) ; end if ;
		     END IF ;
					
	         RETURN result ;
	
	       END isNsnInRblPairs ;
		   
	       FUNCTION isNsnInIsgPairs RETURN BOOLEAN IS
	            result BOOLEAN := FALSE ;
	       BEGIN
	           <<tryOldNsn>>
	         DECLARE
	           CURSOR old_nsns IS
				   SELECT old_nsn  
				   FROM bssm_isg_pairs 
				   WHERE old_nsn = isNsnValid.nsn AND lock_sid = 0 ;
	         BEGIN
			 	  FOR rec IN old_nsns LOOP
				      result := TRUE ;
					  EXIT WHEN TRUE ;
				  END LOOP ;
			      IF NOT result THEN
		           <<tryNewNsn>>
		           DECLARE
					 CURSOR new_nsns IS
		              SELECT new_nsn FROM bssm_isg_pairs 
					  WHERE new_nsn = isNsnValid.nsn AND lock_sid = 0 ;
		           BEGIN
				   		FOR rec IN new_nsns LOOP
							result := TRUE ;
							EXIT WHEN TRUE ;
						END LOOP ;
		           EXCEPTION
		              WHEN OTHERS THEN
		                  ErrorMsg(pSqlfunction => 'select',
			               pTableName => 'bssm_isg_pairs',
			               pError_location => 60,
			               pKey_1 => isNsnValid.nsn) ;
			              RAISE ;
		           END tryNewNsn ;
				 END IF ;
			 EXCEPTION
		         WHEN OTHERS THEN
		              ErrorMsg(pSqlfunction => 'select',
		           pTableName => 'bssm_isg_pairs',
		           pError_location => 70,
		           pKey_1 => isNsnValid.nsn) ;
		            RAISE ;
				 
	         END tryOldNsn ;
			 
		     IF result THEN
		 	   null ; -- do nothing
			 ELSE
			   debugMsg('Nsn is NOT in ISG Pairs for ' || isPartValid.partNo,50) ;
		 	   if showReason then dbms_output.put_line('Nsn is NOT in ISG Pairs for ' || isPartValid.partNo) ; end if ;
			 END IF ;
	         RETURN result ;
	
	       END isNsnInIsgPairs ;
	    BEGIN
	       <<getNsn>>
	       BEGIN
	        SELECT parts.nsn INTO isNsnValid.nsn
	       FROM AMD_SPARE_PARTS parts
	       WHERE isPartValid.partNo = parts.part_no ;
	      EXCEPTION WHEN OTHERS THEN
	          ErrorMsg(pSqlfunction => 'select',
		       pTableName => 'amd_spare_parts',
		       pError_location => 80,
		       pKey_1 => isPartValid.partNo,
		       pKey_2 => nsn) ;
	        RAISE ;
	      END getNsn ;
	      RETURN isNsnInRblPairs OR isNsnInIsgPairs ;
	    EXCEPTION
	         WHEN standard.NO_DATA_FOUND THEN
	           RETURN FALSE ;
	    END isNsnValid ;
	
	 BEGIN
	   debugMsg(msg => 'isPartValid(' || partNo || ', ' || smrCode || ', ' || mtbdr || ', ' || plannerCode || ')', lineNo => 60) ;
	   IF UPPER(partNo) = 'F117-PW-100' OR INSTR(UPPER(partNo),'17L8D') > 0 OR INSTR(UPPER(partNo),'17R9Y') > 0 OR INSTR(UPPER(smrCode),'PE') > 0 THEN
	   	  RETURN FALSE ;
	   END IF ;
	   DECLARE
	   		  theCode AMD_SPARE_PARTS.ACQUISITION_ADVICE_CODE%TYPE ;
	   BEGIN
		   SELECT acquisition_advice_code INTO theCode
		   FROM AMD_SPARE_PARTS WHERE part_no = partNo ;
		   IF UPPER(theCode) = 'Y' THEN
		   	  RETURN FALSE ;
		   END IF ;
	   EXCEPTION WHEN OTHERS THEN
	          ErrorMsg(pSqlfunction => 'select',
		       pTableName => 'amd_spare_parts',
		       pError_location => 90,
		       pKey_1 => isPartValid.partNo ) ;
	         RAISE ;
	   END ;
	   IF LENGTH(smrCode) >= 6 THEN
	    IF UPPER(SUBSTR(smrCode,6,1)) = 'T' THEN
	     result := TRUE ;
	    END IF ;
	   END IF ;
	   IF result THEN
	   	  null ; -- do nothing
	   ELSE
	   	  debugMsg(smrCode || ' is NOT a valid smr code', 70) ;
	   	  if showReason then dbms_output.put_line(smrCode || ' is NOT a valid smr code') ; end if ;
	   END IF ;
	   result := result AND isPlannerCodeValid ;
	   IF result AND isNsl(partNo) THEN
	   
	     IF showReason AND (mtbdr IS NOT NULL AND mtbdr > 0) THEN
		 	dbms_output.put_line('mtbdr > 0 for part ' || partNo) ; 
		 END IF ;
		 
	     result := result AND (demandExists OR inventoryExists
	                    OR (mtbdr IS NOT NULL AND mtbdr > 0)
	            OR isNsnValid ) ;
	  END IF ;
	  IF result THEN
	  	 null ; -- do nothing
	  ELSE
	  	 debugMsg('part ' || partNo || ' is NOT valid.',80) ;
	  	 if showReason then dbms_output.put_line('part ' || partNo || ' is NOT valid.') ; end if ;
	  END IF ;
	  RETURN result ;
	 EXCEPTION WHEN OTHERS THEN
		IF SQLCODE = -20000 THEN
			dbms_output.DISABLE ; -- buffer overflow, disable
			RETURN isPartValid(partNo) ; -- try validation again
		ELSE
			RAISE ;
		END IF ;
	
	 END isPartValid ;
	
	 PROCEDURE insertPartInfo(
	       part_no IN VARCHAR2,
	       nomenclature IN VARCHAR2,
	       action_code IN VARCHAR2,
	        mfgr IN VARCHAR2 := NULL,
	       unit_issue IN VARCHAR2 := NULL,
	       smr_code IN VARCHAR2 := NULL,
	       nsn IN VARCHAR2 := NULL,
	       planner_code IN VARCHAR2 := NULL,
	       third_party_flag IN VARCHAR2 := NULL,
	       mtbdr      IN NUMBER := NULL,
	       indenture IN VARCHAR2 := NULL,
		   price IN NUMBER := NULL) IS
	
	   result NUMBER := SUCCESS ;
	  partInfoError EXCEPTION ;
	 BEGIN
	   CASE action_code
	      WHEN Amd_Defaults.INSERT_ACTION THEN
	         result := insertPartInfo(
	        mfgr,
	       part_no,
	       unit_issue,
	       nomenclature,
	       smr_code,
	       nsn,
	       planner_code,
	       third_party_flag,
	       mtbdr,
	       indenture,
		   price) ;
	
	      WHEN Amd_Defaults.UPDATE_ACTION THEN
	         result := updatePartInfo(
	        mfgr,
	       part_no,
	       unit_issue,
	       nomenclature,
	       smr_code,
	       nsn,
	       planner_code,
	       third_party_flag,
	       mtbdr,
	       indenture,
		   price) ;
	
	      WHEN Amd_Defaults.DELETE_ACTION THEN
	         result := deletePartInfo(part_no, nomenclature) ;
	  END CASE ;
	  IF result != SUCCESS THEN
	     RAISE partInfoError ;
	  END IF ;
	 END insertPartInfo ;
	
	 procedure initA2ADemands is
	 begin
		amd_owner.Mta_Truncate_Table('tmp_a2a_demands','reuse storage');
	  		INSERT INTO amd_owner.TMP_A2A_DEMANDS
		   (part_no, site, docno, demand_date, qty, demand_level, action_code, last_update_dt)
	        SELECT Amd_Partprime_Pkg.getSuperPrimePartByNsiSid(a.NSI_SID) part_no,
	  		  	Amd_Utils.getSpoLocation(a.LOC_SID) site,
			a.DOC_NO docno,
			a.DOC_DATE demand_date,
			a.QUANTITY qty,
			NULL demand_level,
			sent.action_code,
			SYSDATE last_update_dt
		   FROM amd_owner.AMD_DEMANDS a, amd_sent_to_a2a sent
		   WHERE Amd_Partprime_Pkg.getSuperPrimePartByNsiSid(a.NSI_SID) = sent.spo_prime_part_no
		   and sent.part_no = sent.spo_prime_part_no						   
		   AND Amd_Utils.getSpoLocation(a.LOC_SID) NOT IN ('FB4454', 'FB4455', 'FB4412', 'FB4490', 'FB4491') ;
		 COMMIT ;
	 end initA2ADemands ;
	 
	 PROCEDURE processExtForecast(extForecast IN extForecastCur) IS
	 		   rec AMD_part_loc_forecasts%ROWTYPE ;
			   cnt NUMBER := 0 ;
			   rc number ;
	 BEGIN
	  	  writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 100,
				pKey1 => 'processExtForecast',
				pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	 	  LOOP
		  	  FETCH extForecast INTO rec ;
		  	  EXIT WHEN extForecast%NOTFOUND ;
			  amd_part_loc_forecasts_pkg.InsertTmpA2A_EF_AllPeriods
				(
					rec.part_no, 
					Amd_Utils.GetSpoLocation(rec.loc_sid) , 
					amd_part_loc_forecasts_pkg.GetCurrentPeriod, 
					rec.forecast_qty , 
					rec.action_code, 
					sysdate 
				)  ;
	     	  cnt := cnt + 1 ;
		 	  IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
			  	 COMMIT ;
			  END IF ;
	 	  END LOOP ;
	  	  writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 110,
				pKey1 => 'processExtForecast',
				pKey2 => 'cnt=' || TO_CHAR(cnt),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;
	 END processExtForecast ;
	 
	 PROCEDURE initA2AExtForecast(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) IS
	  extForecast extForecastCur ;
	  
	 BEGIN
		  writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 120,
					pKey1 => 'initA2AExtForecast',
					pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
					pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
					pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  Mta_Truncate_Table('tmp_a2a_ext_forecast','reuse storage');
		  mblnSendAllData := TRUE ;
		  OPEN extForecast FOR
			  SELECT * FROM AMD_part_loc_forecasts 
			  WHERE
	    	  TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
			  and part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
		  processExtForecast(extForecast) ;
		  CLOSE extForecast ;  
		  writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 130,
					pKey1 => 'initA2AExtForecast',
					pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
					pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
					pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;
	 END initA2AExtForecast ;
	 
	  PROCEDURE initA2AExtForecast(useTestParts IN BOOLEAN := FALSE ) is
	  			extForecast extForecastCur ;
	  begin
		  writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 140,
					pKey1 => 'initA2AExtForecast',
					pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
					pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  mblnSendAllData := TRUE ;
		  Mta_Truncate_Table('TMP_A2A_EXT_FORECAST','reuse storage');
		  IF useTestParts THEN
		  	 OPEN extForecast FOR
				  SELECT *
				  FROM AMD_part_loc_forecasts WHERE
				  part_no IN (SELECT part_no FROM AMD_TEST_PARTS) 
				  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL) ;
		  ELSE
		  	 OPEN extForecast FOR
				  SELECT * FROM AMD_part_loc_forecasts WHERE
				  part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL) ;
		  END IF ;
		  processExtForecast(extForecast) ;
		  CLOSE extForecast ;	 
		  writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 150,
					pKey1 => 'initA2AExtForecast',
					pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
					pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;
	  end initA2AExtForecast ;
	
	
	 PROCEDURE processOnHandInvSum(onHandInvSum IN onHandInvSumCur) IS
	 		   rec AMD_ON_HAND_INVS_SUM%ROWTYPE ;
			   cnt NUMBER := 0 ;
	 BEGIN
	 	  LOOP
		  	  FETCH onHandInvSum INTO rec ;
		  	  EXIT WHEN onHandInvSum%NOTFOUND ;
	          A2a_Pkg.insertInvInfo(rec.part_no,rec.spo_location,rec.qty_on_hand, rec.action_code) ;
	     	  cnt := cnt + 1 ;
		 	  IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
			  	 COMMIT ;
			  END IF ;
	 	  END LOOP ;
		  COMMIT ;
	 END processOnHandInvSum ;
	 
	 PROCEDURE initA2AInvInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) IS
	  invInfoByDate onHandInvSumCur ; 
	   
	 BEGIN
		writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 160,
				pKey1 => 'initA2AInvInfo',
				pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  mblnSendAllData := TRUE ;
	  OPEN invInfoByDate FOR
	    SELECT  
			  	  oh.PART_NO,       
				  SPO_LOCATION,    
				  QTY_ON_HAND,
				  case oh.ACTION_CODE
				  	   when amd_defaults.getDELETE_ACTION then
					   		oh.ACTION_CODE
					   else     
				  	   		sent.ACTION_CODE
				  end action_code,     
				  LAST_UPDATE_DT,  
				  REORDER_POINT,   
				  STOCK_LEVEL     
		FROM AMD_ON_HAND_INVS_SUM oh, amd_sent_to_a2a sent 
	    WHERE TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
	    AND oh.part_no = sent.part_no
		and sent.SPO_PRIME_PART_NO is not null
		UNION ALL
		SELECT rsp.part_no, rsp_location, qty_on_hand, 
		case rsp.action_code
			 when amd_defaults.getDELETE_ACTION then
			 	  rsp.action_code
			 else
			 	 sent.action_code
		end action_code, last_update_dt, NULL reorder_point, NULL stock_level
		FROM AMD_RSP_SUM rsp, amd_sent_to_a2a sent 
		WHERE TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt)
		AND rsp.part_no = sent.part_no
		and sent.spo_prime_part_no is not null ;
	
	  Mta_Truncate_Table('TMP_A2A_INV_INFO','reuse storage');
	  processOnHandInvSum(invInfoByDate) ;
	  CLOSE invInfoByDate ;
	  writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 170,
				pKey1 => 'initA2AInvInfo',
				pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  COMMIT ;
	 END initA2AInvInfo ;
	
	 
	 FUNCTION initA2AInvInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
	  invInfo onHandInvSumCur ;
	  result NUMBER := SUCCESS ;
	
	 BEGIN
	  writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 180,
				pKey1 => 'initA2AInvInfo',
				pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
				pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  mblnSendAllData := TRUE ;
	  Mta_Truncate_Table('TMP_A2A_INV_INFO','reuse storage');
	  IF useTestParts THEN
	  	 OPEN invInfo FOR
			  SELECT 
			  	  oh.PART_NO,       
				  SPO_LOCATION,    
				  QTY_ON_HAND,
				  case oh.action_code
				  	   when amd_defaults.getDELETE_ACTION then
					   		oh.action_code
					   else
					   	   sent.action_code
				  end action_code,     
				  LAST_UPDATE_DT,  
				  REORDER_POINT,   
				  STOCK_LEVEL     
			  FROM AMD_ON_HAND_INVS_SUM oh, amd_sent_to_a2a sent, amd_test_parts testParts 
			  WHERE oh.part_no = testParts.part_no 
			  AND oh.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null
			  UNION ALL
			  SELECT rsp.part_no, rsp_location, qty_on_hand, 
			  case rsp.action_code
			  	   when amd_defaults.getDELETE_ACTION then
				   		rsp.action_code
				   else
				   	   sent.action_code
			  end action_code, last_update_dt, NULL reorder_point, NULL stock_level
			  FROM AMD_RSP_SUM rsp, amd_sent_to_a2a sent, amd_test_parts testParts 
			  WHERE rsp.part_no = testParts.part_no
			  AND rsp.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null ;
	  ELSE
	  	 OPEN invInfo FOR
			  SELECT  
			  	  oh.PART_NO,       
				  SPO_LOCATION,    
				  QTY_ON_HAND,
				  case oh.action_code
				  	   when amd_defaults.getDELETE_ACTION then
					   		oh.action_code
					   else					        
				  	   		sent.ACTION_CODE
				  end action_code,     
				  LAST_UPDATE_DT,  
				  REORDER_POINT,   
				  STOCK_LEVEL     
	  		  FROM AMD_ON_HAND_INVS_SUM oh, amd_sent_to_a2a sent 
			  WHERE oh.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null
			  UNION ALL
			  SELECT rsp.part_no, rsp_location, qty_on_hand, 
			  case rsp.action_code
			  	   when amd_defaults.getDELETE_ACTION then
				   		rsp.action_code
				   else
				   	   sent.action_code
			  end action_code, last_update_dt, NULL reorder_point, NULL stock_level
			  FROM AMD_RSP_SUM rsp, amd_sent_to_a2a sent
			  WHERE rsp.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null ;
	  END IF ;
	  processOnHandInvSum(invInfo) ;
	  CLOSE invInfo ;	 
	  writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 190,
				pKey1 => 'initA2AInvInfo',
				pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  COMMIT ;
	  RETURN result ;
	 END initA2AInvInfo ;
	
	PROCEDURE processRepairInvInfo(repairInvInfo IN repairInvInfoCur) IS
			  rec AMD_REPAIR_INVS_SUM%ROWTYPE ;
			  cnt NUMBER := 0 ;
	BEGIN
	     writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 200,
				pKey1 => 'proecessRepairInvInfo',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		 LOOP
		 	 FETCH repairInvInfo INTO rec ;
			 EXIT WHEN repairInvInfo%NOTFOUND ;
	         A2a_Pkg.insertRepairInvInfo(rec.part_no,rec.site_location,rec.qty_on_hand, rec.action_code) ;
	     	 cnt := cnt + 1 ;
		 	 IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
			   COMMIT ;
			 END IF ;
		 END LOOP ;
	     writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 210,
				pKey1 => 'proecessRepairInvInfo',
				pKey2 => 'cnt=' || TO_CHAR(cnt),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		 COMMIT ;
	END processRepairInvInfo ;
	 
	PROCEDURE initA2ARepairInvInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) IS
	  repairInvInfoByDate repairInvInfoCur ;
	  
	  cnt NUMBER := 0 ;
	  
	BEGIN
	  writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 220,
				pKey1 => 'initA2ARepairInvInfo',
				pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  Mta_Truncate_Table('TMP_A2A_REPAIR_INV_INFO','reuse storage');
	  mblnSendAllData := TRUE ;
	  OPEN repairInvInfoByDate FOR
		  SELECT * FROM AMD_REPAIR_INVS_SUM 
		  WHERE
		  TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
		  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
	  processRepairInvInfo(repairInvInfoByDate) ;
	  CLOSE repairInvInfoByDate ;
	  writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 230,
				pKey1 => 'initA2ARepairInvInfo',
				pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  COMMIT ;
	END initA2ARepairInvInfo ;
	
	   
	FUNCTION initA2ARepairInvInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
	  repairInvInfo repairInvInfoCur ;
	  result NUMBER := SUCCESS ;
	
	 BEGIN
	  writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 240,
				pKey1 => 'initA2ARepairInvInfo',
				pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
				pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  Mta_Truncate_Table('TMP_A2A_REPAIR_INV_INFO','reuse storage');
	  mblnSendAllData := TRUE ;
	  IF useTestParts THEN
	  	 OPEN repairInvInfo FOR
			  SELECT *
			  FROM AMD_REPAIR_INVS_SUM WHERE
			  part_no IN (SELECT part_no FROM AMD_TEST_PARTS)
			  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
	  ELSE
	  	 OPEN repairInvInfo FOR
			  SELECT * FROM AMD_REPAIR_INVS_SUM WHERE
			  part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
	  END IF ;
	  processRepairInvInfo(repairInvInfo) ;
	  CLOSE repairInvInfo ;
	
	  writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 250,
				pKey1 => 'initA2ARepairInvInfo',
				pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  COMMIT ;
	  RETURN result ;
	 END initA2ARepairInvInfo ;
	 
	 PROCEDURE processInTransits(inTransits IN inTransitsCur) IS
	 		   cnt NUMBER := 0 ;
			   rec AMD_IN_TRANSITS_SUM%ROWTYPE ;
	 BEGIN
	      writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 260,
				pKey1 => 'processInTransits',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	 	  LOOP
		  	  FETCH inTransits INTO rec ;
			  EXIT WHEN inTransits%NOTFOUND ;
			  A2a_Pkg.insertTmpA2AInTransits(
			       rec.part_no,
			       rec.site_location,
			       rec.quantity,
			       rec.serviceable_flag,
			       rec.action_code) ;	   
	       	  cnt := cnt + 1 ;
		      IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
			    COMMIT ;
		      END IF ;
		  END LOOP ;
		  COMMIT ;
	      writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 270,
				pKey1 => 'processInTransits',
				pKey2 => 'cnt=' || TO_CHAR(cnt),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;
	 END processInTransits ;
	 
	 PROCEDURE initA2AInTransits(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) IS
	  inTransitsByDate inTransitsCur ;
	  
	 BEGIN
		  writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 280,
					pKey1 => 'initA2AInTransits',
					pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
					pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
					pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  Mta_Truncate_Table('tmp_a2a_in_transits','reuse storage');
		  mblnSendAllData := TRUE ;
		  OPEN inTransitsByDate FOR
			  SELECT * FROM AMD_IN_TRANSITS_SUM 
			  WHERE
			  TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
			  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
		  processInTransits(inTransitsByDate) ;
		  CLOSE inTransitsByDate ;  
		  writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 290,
					pKey1 => 'initA2AInTransits',
					pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
					pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
					pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;
	 END initA2AInTransits ;
	 
	 FUNCTION initA2AInTransits(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
	  inTransits inTransitsCur ;
	
	  result NUMBER := SUCCESS ;
	
	 BEGIN
		  writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 300,
					pKey1 => 'initA2AInTransits',
					pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
					pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
		  Mta_Truncate_Table('tmp_a2a_in_transits','reuse storage');
		  mblnSendAllData := TRUE ;
		  IF useTestParts THEN
		  	 OPEN inTransits FOR
				  SELECT *
				  FROM AMD_IN_TRANSITS_SUM  WHERE
				  part_no IN (SELECT part_no FROM AMD_TEST_PARTS)
				  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
		  ELSE
		  	  OPEN inTransits FOR
				  SELECT * FROM AMD_IN_TRANSITS_SUM  WHERE 
				  part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
		  END IF ;
		  
		  processInTransits(inTransits) ;
		  CLOSE inTransits ;	  
		  writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 310,
					pKey1 => 'initA2AInTransits',
					pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
					pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;  
		  RETURN result ;
	 END initA2AInTransits ;
	
	 PROCEDURE processInRepair(inRepair IN inRepairCur) IS
	 		   cnt NUMBER := 0 ;
			   rec AMD_IN_REPAIR%ROWTYPE ;
	 BEGIN
	  	  writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 320,
				pKey1 => 'processInRepair',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
	 	  LOOP
		  	  FETCH inRepair INTO rec ;
			  EXIT WHEN inRepair%NOTFOUND ;
	     	  A2a_Pkg.insertRepairInfo(rec.part_no,rec.loc_sid,rec.order_no,rec.repair_date,A2a_Pkg.OPEN_STATUS,rec.repair_qty,
	                rec. repair_need_date, rec.action_code) ;
	     	  cnt := cnt + 1 ;
		 	  IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
			     COMMIT ;
			  END IF ;		  
		  END LOOP ;
	  	  writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 330,
				pKey1 => 'processInRepair',
				pKey2 => 'cnt=' || TO_CHAR(cnt),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
		  COMMIT ;
	 END processInRepair ;
	 
	 PROCEDURE initA2ARepairInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) IS
	  
	  repairsByDate inRepairCur ;
	  
	 BEGIN
	  	  writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 340,
				pKey1 => 'initA2ARepairInfo',
				pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
	  	  Mta_Truncate_Table('tmp_a2a_repair_info','reuse storage');
		  mblnSendAllData := TRUE ;
		  OPEN repairsByDate FOR
			  SELECT * FROM AMD_IN_REPAIR 
			  WHERE
			  TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
			  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
		  processInRepair(repairsByDate) ;
		  CLOSE repairsByDate ;	  	  
	  	  writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 350,
				pKey1 => 'initA2ARepairInfo',
				pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;  
	 END initA2ARepairInfo ;
	 
	 FUNCTION initA2ARepairInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
	  repairs inRepairCur ;
	  result NUMBER := SUCCESS ;
	
	 BEGIN
	  writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 360,
		pKey1 => 'initA2ARepairInfo',
		pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
		pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
	  Mta_Truncate_Table('tmp_a2a_repair_info','reuse storage');
	  mblnSendAllData := TRUE ;
	  IF useTestParts THEN
	  	 OPEN repairs FOR
		  SELECT *
		  FROM AMD_IN_REPAIR WHERE
		  part_no IN (SELECT part_no FROM AMD_TEST_PARTS)
		  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
	  ELSE
	  	 OPEN repairs FOR
			  SELECT * FROM AMD_IN_REPAIR WHERE 
			  part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
	  END IF ;
	  processInRepair(repairs) ;
	  CLOSE repairs ;
	  writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 370,
		pKey1 => 'initA2ARepairInfo',
		pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
		pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  COMMIT ;  
	  RETURN result ;
	 END initA2ARepairInfo ;
	
	 PROCEDURE processOnOrder(onOrder IN onOrderCur) IS
	 		   cnt NUMBER := 0 ;
			   rec AMD_ON_ORDER%ROWTYPE ;
	 BEGIN
		  writeMsg(pTableName => 'tmp_a2a_order_info', pError_location => 380,
			pKey1 => 'processOnOrder',
			pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
	 	  LOOP
		  	  FETCH onOrder INTO rec ;
			  EXIT WHEN onOrder%NOTFOUND ;
	          insertTmpA2AOrderInfo(rec.gold_order_number,rec.loc_sid,rec.order_date,rec.part_no,rec.order_qty, rec.sched_receipt_date, rec.action_code) ;
	      	  cnt := cnt + 1 ;
		 	  IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
			    COMMIT ;
			  END IF ;
		  END LOOP ;
		  writeMsg(pTableName => 'tmp_a2a_order_info', pError_location => 390,
			pKey1 => 'processOnOrder',
			pKey2 => 'cnt=' || TO_CHAR(cnt),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
		  COMMIT ;
	 END processOnOrder ;
	 
	 -- create a2a for a specific set of dates
	 PROCEDURE initA2AOrderInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) IS
	  ordersByDate onOrderCur ;
	 BEGIN
		  writeMsg(pTableName => 'tmp_a2a_order_info', pError_location => 400,
			pKey1 => 'initA2AOrderInfo',
			pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
			pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
			pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  includeCnt := 0 ;
		  excludeCnt := 0 ;  
	  	  Mta_Truncate_Table('tmp_a2a_order_info','reuse storage');
	  	  Mta_Truncate_Table('tmp_a2a_order_info_line','reuse storage');
		  mblnSendAllData := TRUE ;
		  OPEN ordersByDate FOR
			  SELECT  
				  oo.PART_NO,  
				  LOC_SID,
				  ORDER_DATE,         
				  ORDER_QTY,          
				  GOLD_ORDER_NUMBER,  
				  case oo.ACTION_CODE
				  	   when amd_defaults.getDELETE_ACTION then
					   		oo.ACTION_CODE
					   else  
				  	   		 sent.ACTION_CODE
				  end action_code,        
				  LAST_UPDATE_DT,     
				  SCHED_RECEIPT_DATE		  
				  FROM AMD_ON_ORDER OO, amd_sent_to_a2a sent 
			  WHERE TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
			  AND oo.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null  
			  ORDER BY gold_order_number, part_no, order_date ;
		  processOnOrder(ordersByDate) ;
		  CLOSE ordersByDate ;	  
	  	  writeMsg(pTableName => 'tmp_a2a_order_info', pError_location => 410,
			pKey1 => 'initA2AOrderInfo',
			pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
			pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
			pKey4 => 'excludeCnt=' || TO_CHAR(excludeCnt),
			pData => 'includeCnt=' || includeCnt || ' ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
		  COMMIT ;
	 END initA2AOrderInfo ;
	 
	 FUNCTION initA2AOrderInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
	  onOrders onOrderCur ;
	  result NUMBER := SUCCESS ;
	  orders NUMBER := 0 ;
	  lines NUMBER := 0 ;
	
	 BEGIN
	  writeMsg(pTableName => 'tmp_a2a_order_info', pError_location => 420,
			pKey1 => 'initA2AOrderInfo',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
	  Mta_Truncate_Table('tmp_a2a_order_info','reuse storage');
	  Mta_Truncate_Table('tmp_a2a_order_info_line','reuse storage');
	  mblnSendAllData := TRUE ;
	  includeCnt := 0 ;
	  excludeCnt := 0 ;
	  IF useTestParts THEN
	  	 OPEN onOrders FOR
		  SELECT 
				  oo.PART_NO,  
				  LOC_SID,
				  ORDER_DATE,         
				  ORDER_QTY,          
				  GOLD_ORDER_NUMBER,
				  case oo.ACTION_CODE
				  	   when amd_defaults.getDELETE_ACTION then
					   		oo.ACTION_CODE
					   else  
				  	   		 sent.ACTION_CODE
				  end action_code,        
				  LAST_UPDATE_DT,     
				  SCHED_RECEIPT_DATE		  
		  FROM AMD_ON_ORDER OO, amd_sent_to_a2a sent, amd_test_parts testParts 
		  WHERE oo.part_no = testParts.PART_NO 
		  AND oo.part_no = sent.part_no
		  and sent.SPO_PRIME_PART_NO is not null	 
		  ORDER BY gold_order_number, part_no, order_date ;
	  ELSE
	  	  OPEN onOrders FOR 
			  SELECT 
				  oo.PART_NO,  
				  LOC_SID,
				  ORDER_DATE,         
				  ORDER_QTY,          
				  GOLD_ORDER_NUMBER,  
				  case oo.ACTION_CODE
				  	   when amd_defaults.getDELETE_ACTION then
					   		oo.ACTION_CODE
					   else  
				  	   		 sent.ACTION_CODE
				  end action_code,        
				  LAST_UPDATE_DT,     
				  SCHED_RECEIPT_DATE		  
			  FROM AMD_ON_ORDER OO, amd_sent_to_a2a sent 
			  WHERE oo.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null  
			  ORDER BY gold_order_number, part_no, order_date ;
	  END IF ;
	  processOnOrder(onOrders) ;
	  CLOSE onOrders ;
	
	  SELECT COUNT(*) INTO orders FROM TMP_A2A_ORDER_INFO ;
	  SELECT COUNT(*) INTO lines FROM TMP_A2A_ORDER_INFO_LINE ;
	  writeMsg(pTableName => 'tmp_a2a_order_info', pError_location => 430,
			pKey1 => 'initA2AOrderInfo',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'orders=' || TO_CHAR(orders),
			pKey4 => 'lines=' || TO_CHAR(lines),
			pData => 'includeCnt=' || includeCnt || ' excludeCnt=' || excludeCnt, 
			pComments => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
	  RETURN result ;
	 END initA2AOrderInfo ;

	 function getActionCode(part_no in amd_sent_to_a2a.part_no%type) return amd_sent_to_a2a.action_code%type is
			   theActionCode amd_sent_to_a2a.action_code%type ;
	 begin
		 select action_code into theActionCode from amd_sent_to_a2a where part_no = getActionCode.part_no ;
		 return theActionCode ;
	 end getActionCode ;
	 
	 PROCEDURE insertPartLeadTime(
	        part_no IN tmp_a2a_part_lead_time.PART_NO%type,
	        lead_time_type tmp_a2a_part_lead_time.LEAD_TIME_TYPE%type,
	        lead_time IN tmp_a2a_part_lead_time.LEAD_TIME%type,
	        action_code IN TMP_A2A_PART_LEAD_TIME.action_code%TYPE) IS
		   
	  partLeadTimeError EXCEPTION ;
	  result NUMBER := SUCCESS ;
	 BEGIN
	   CASE action_code
	      WHEN Amd_Defaults.INSERT_ACTION THEN
	         result := InsertPartLeadTime(part_no, lead_time_type, lead_time) ;
	     WHEN Amd_Defaults.UPDATE_ACTION THEN
	         result := UpdatePartLeadTime(part_no, lead_time_type, lead_time) ;
	     WHEN Amd_Defaults.DELETE_ACTION THEN
	         result := DeletePartLeadTime(part_no) ;
	   END CASE ;
	   IF result != SUCCESS THEN
	    RAISE partLeadTimeError ;
	   END IF ;
	 END insertPartLeadTime ;
	 
	 PROCEDURE insertTmpA2APartLeadTime(part_no IN VARCHAR2, 
	 		   order_lead_time IN TMP_A2A_PART_LEAD_TIME.LEAD_TIME%TYPE,
			   order_lead_time_cleaned IN TMP_A2A_PART_LEAD_TIME.LEAD_TIME%TYPE,
			   order_lead_time_defaulted IN TMP_A2A_PART_LEAD_TIME.lead_time%TYPE) IS
			   
	       lead_time tmp_a2a_part_lead_time.LEAD_TIME%type  ;
		   result NUMBER ;
		   
		   action_code tmp_a2a_part_lead_time.action_code%type := getActionCode(part_no) ;
		      
		   
	 BEGIN
	
	    IF order_lead_time_cleaned IS NOT NULL THEN
	       lead_time := order_lead_time_cleaned ;
	    ELSIF order_lead_time IS NOT NULL THEN
	       lead_time := order_lead_time ;
	    ELSE
	     lead_time := order_lead_time_defaulted ;
	    END IF ;
	 
	    IF lead_time IS not null or (lead_time is null and action_code = amd_defaults.DELETE_ACTION) THEN
		     insertPartLeadTime(part_no => part_no, lead_time_type => NEW_BUY, lead_time => lead_time,
								action_code => action_code) ;
	    END IF ;
	   
	 END insertTmpA2APartLeadTime ;
	 
	 
	 FUNCTION getPartInfo RETURN partCur IS
			  parts partCur ;
	 BEGIN
	 	  OPEN parts FOR
			  SELECT sp.mfgr,
			      sp.part_no,
			      sp.NOMENCLATURE,
			      sp.nsn,
			      sp.order_lead_time,
			      sp.order_lead_time_defaulted,
			      sp.unit_cost,
			      sp.unit_cost_defaulted,
			      sp.unit_of_issue,
			      nsi.unit_cost_cleaned,
			      nsi.order_lead_time_cleaned,
			      nsi.planner_code,
			      nsi.planner_code_cleaned,
			      nsi.mtbdr,
			      nsi.mtbdr_cleaned,
			      nsi.smr_code,
			      nsi.smr_code_cleaned,
			      nsi.smr_code_defaulted,
			      nsi.nsi_sid,
			      nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND,
				  nsi.last_update_dt,
				  nsi.action_code
			  FROM AMD_SPARE_PARTS sp,
			    AMD_NATIONAL_STOCK_ITEMS nsi
			  WHERE sp.nsn = nsi.nsn
			     AND sp.action_code != Amd_Defaults.DELETE_ACTION ;
				 
		RETURN parts ;
			  
	 END getPartInfo ;
	 
	 FUNCTION getTestData RETURN partCur IS
	 		  parts partCur ;
	 BEGIN
	 	  OPEN parts FOR 
			  SELECT sp.mfgr,
			      sp.part_no,
			      sp.NOMENCLATURE,
			      sp.nsn,
			      sp.order_lead_time,
			      sp.order_lead_time_defaulted,
			      sp.unit_cost,
			      sp.unit_cost_defaulted,
			      sp.unit_of_issue,
			      nsi.unit_cost_cleaned,
			      nsi.order_lead_time_cleaned,
			      nsi.planner_code,
			      nsi.planner_code_cleaned,
			      nsi.mtbdr,
			      nsi.mtbdr_cleaned,
			      nsi.smr_code,
			      nsi.smr_code_cleaned,
			      nsi.smr_code_defaulted,
			      nsi.nsi_sid,
			      nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND,
				  nsi.last_update_dt,
				  nsi.action_code
			  FROM AMD_SPARE_PARTS sp,
			    AMD_NATIONAL_STOCK_ITEMS nsi
			  WHERE sp.nsn = nsi.nsn
			     AND sp.action_code != Amd_Defaults.DELETE_ACTION
			     AND sp.part_no IN (SELECT part_no FROM AMD_TEST_PARTS) ;
		 
		 RETURN parts ;
		  
	END getTestData ;
	 
	PROCEDURE processPartLeadTimes(parts IN partCur) IS
	  rec partInfoRec ;
	  cnt NUMBER := 0  ;
	  
	BEGIN
	     writeMsg(pTableName => 'tmp_a2a_part_lead_time', pError_location => 440,
			pKey1 => 'processPartLeadTimes',
			pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
		 LOOP
			FETCH parts INTO rec ;
			EXIT WHEN parts%NOTFOUND ;
			
			IF wasPartSent(rec.part_no) THEN
			       insertTmpA2APartLeadTime(part_no => rec.part_no,
			 						order_lead_time => rec.order_lead_time,
								order_lead_time_cleaned => rec.order_lead_time_cleaned,
								order_lead_time_defaulted => rec.order_lead_time_defaulted) ;
					cnt := cnt + 1 ;
			END IF ;
					 
			IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
			  COMMIT ;
			END IF ;
			
		 END LOOP ;
	     writeMsg(pTableName => 'tmp_a2a_part_lead_time', pError_location => 450,
			pKey1 => 'processPartLeadTimes',
			pKey2 => 'cnt=' || TO_CHAR(cnt),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		 COMMIT ;  	 
	END processPartLeadTimes ;
			   
	 PROCEDURE initA2APartLeadTime(useTestParts IN BOOLEAN := FALSE) IS
	 		   cnt NUMBER := 0 ;
			   parts partCur ;
	 BEGIN
	  writeMsg(pTableName => 'tmp_a2a_part_lead_time', pError_location => 460,
			pKey1 => 'initA2APartLeadTime',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	  Mta_Truncate_Table('tmp_a2a_part_lead_time','reuse storage');
	  IF useTestParts THEN
	  	 parts := getTestData ;
	  ELSE
	    parts := getPartInfo ;
	  END IF ;
	  processPartLeadTimes(parts) ;
	  CLOSE parts ;
	  Amd_Partprime_Pkg.DiffPartToPrime  ;
	  writeMsg(pTableName => 'tmp_a2a_part_lead_time', pError_location => 470,
			pKey1 => 'initA2APartLeadTime',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  COMMIT ;  	 
	 END initA2APartLeadTime ;
	 
	 FUNCTION getValidRcmInd(rcmInd IN VARCHAR2) RETURN VARCHAR2 IS
	 BEGIN
	 	  IF UPPER(rcmInd) = 'T' THEN
		  	 RETURN 'R' ;
		  ELSE
		  	  RETURN UPPER(rcmInd) ;
		  END IF ;
	 END getValidRcmInd ;
	
	 PROCEDURE validateData(
	       mfgr IN VARCHAR2,
	       part_no IN VARCHAR2,
	       unit_issue IN VARCHAR2,
	       nomenclature IN VARCHAR2,
	       smr_code IN VARCHAR2,
	       nsn IN VARCHAR2,
	       planner_code IN VARCHAR2,
	       third_party_flag IN VARCHAR2,
	       mtbdr      IN NUMBER,
	       indenture IN VARCHAR2,
	 	   rcm_ind OUT TMP_A2A_PART_INFO.rcm_ind%TYPE) IS
	 
	 		   lineNo NUMBER := 0 ;
			   rec TMP_A2A_PART_INFO%ROWTYPE ;
	 BEGIN
	      lineNo := lineNo + 1;rec.cage_code := validateData.mfgr ;
	      lineNo := lineNo + 1;rec.part_no := validateData.part_no ;
	      lineNo := lineNo + 1;rec.unit_issue := validateData.unit_issue ;
	      lineNo := lineNo + 1;rec.noun := validateData.nomenclature ;
	      lineNo := lineNo + 1;rec.rcm_ind := SUBSTR(validateData.smr_code,6,1) ;
		  
	   	  rcm_ind := getValidRcmInd(rec.rcm_ind) ;
		  
	      lineNo := lineNo + 1;rec.nsn_fsc := SUBSTR(validateData.nsn, 1, 4) ;
	      lineNo := lineNo + 1;rec.nsn_niin := SUBSTR(validateData.nsn, 5, 9) ;
	      lineNo := lineNo + 1;rec.resp_asset_mgr := validateData.planner_code ;
	      lineNo := lineNo + 1;rec.third_party_flag := validateData.third_party_flag ;
	      lineNo := lineNo + 1;rec.mtbf := validateData.mtbdr ;
	      lineNo := lineNo + 1;rec.preferred_smrcode := validateData.smr_code ;
	      lineNo := lineNo + 1;rec.indenture := validateData.indenture ;
	 EXCEPTION WHEN OTHERS THEN
	        ErrorMsg(pSqlfunction => 'none',
		      pTableName => 'validateData',
		      pError_location => 480,
		      pKey_1 => TO_CHAR(lineNo)) ;
		 RAISE ;
	 END validateData ;
	
	PROCEDURE insertTimeToRepair(part_no IN AMD_SPARE_PARTS.part_no%TYPE,
			  nsi_sid IN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE,
			  time_to_repair_off_base_cleand IN AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base_cleand%TYPE) IS
			  
	    time_to_repair NUMBER ;
	    time_to_repair_defaulted NUMBER ;
		result NUMBER ;
		action_code tmp_a2a_part_lead_time.action_code%type := getActionCode(part_no) ;
	BEGIN
		BEGIN
		  SELECT time_to_repair,
		      time_to_repair_defaulted
		      INTO time_to_repair, time_to_repair_defaulted
		      FROM AMD_PART_LOCS
		      WHERE nsi_sid = insertTimeToRepair.nsi_sid
		      AND   loc_sid = 23 ;
		EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		  NULL ; -- do nothing
		  WHEN OTHERS THEN
		       ErrorMsg(pSqlfunction => 'select',
			     pTableName => 'amd_part_locs',
			     pError_location => 490,
			     pKey_1 => TO_CHAR(insertTimeToRepair.nsi_sid), pKey_2 => '23') ;
		     RAISE ;
		 END ;
	
		 IF insertTimeToRepair.time_to_repair_off_base_cleand IS NOT NULL THEN
		    time_to_repair := insertTimeToRepair.time_to_repair_off_base_cleand ;
		 ELSIF time_to_repair IS NOT NULL THEN
		    time_to_repair := ROUND(time_to_repair) ; -- time_to_repair is stored as calendar days 
		 				  	 					   	 -- round to nearest integer
		 ELSE
		  time_to_repair := time_to_repair_defaulted ;
		 END IF ;
	
		 IF time_to_repair IS not NULL or (time_to_repair is null and action_code = amd_defaults.DELETE_ACTION) THEN	 	
			  InsertPartLeadTime(
			      part_no,
			      REPAIR,
			      time_to_repair,
				  action_code) ;		
	 	END IF ;
		
	END insertTimeToRepair ;

	procedure insertPartPricing( 
	        part_no IN tmp_a2a_part_pricing.PART_NO%type,
	       price_type IN tmp_a2a_part_pricing.PRICE_TYPE%type,
	       unit_cost IN tmp_a2a_part_pricing.PRICE%type ,
		   action_code in tmp_a2a_part_pricing.action_code%type)  IS
		   
		   result number ;
		   
	begin
	   CASE action_code
	      WHEN Amd_Defaults.INSERT_ACTION THEN
	         result := insertPartPricing(part_no, price_type, unit_cost) ;
	     WHEN Amd_Defaults.UPDATE_ACTION THEN
	         result := updatePartPricing(part_no, price_type, unit_cost) ;
	     WHEN Amd_Defaults.DELETE_ACTION THEN
	         result := deletePartPricing(part_no) ;
	   END CASE ;
	end insertPartPricing ;
		
	PROCEDURE insertUnitCost (
			  part_no IN AMD_SPARE_PARTS.part_no%TYPE,
			  unit_cost_cleaned IN AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE,
			  unit_cost IN AMD_SPARE_PARTS.unit_cost%TYPE, 
			  unit_cost_defaulted IN AMD_SPARE_PARTS.unit_cost_defaulted%TYPE) IS
			  
	    unitCost NUMBER ;
		result 	 NUMBER ;
		action_code tmp_a2a_part_pricing.action_code%type := getActionCode(part_no) ;
		
	BEGIN
	    IF unit_cost_cleaned IS NOT NULL THEN
	       unitCost := unit_cost_cleaned ;
	    ELSIF insertUnitCost.unit_cost IS NOT NULL THEN
	       unitCost := insertUnitCost.unit_cost ;
	    ELSE
	       unitCost := insertUnitCost.unit_cost_defaulted ;
	    END IF;
	
	    IF unitCost IS NOT NULL or (unitCost is null and action_code = amd_defaults.DELETE_ACTION) THEN
	       InsertPartPricing(
	          part_no,
	         'ORDER',
	         unitCost,
			 action_code) ;
			 	
	    END IF ;
	END insertUnitCost ;
	
	  PROCEDURE processPart(rec IN partInfoRec, action_code IN VARCHAR2 := NULL) IS
	       smr_code_preferred AMD_NATIONAL_STOCK_ITEMS.SMR_CODE%TYPE :=
	              Amd_Preferred_Pkg.GetPreferredValue(rec.smr_code_cleaned, rec.smr_code, rec.smr_code_defaulted) ;
	  BEGIN
	   
	   InsertPartInfo(
	       rec.part_no,
	       rec.nomenclature,
	       NVL(action_code,rec.action_code),
	        rec.mfgr,
	       rec.unit_of_issue, -- unit_issue
	       smr_code_preferred,
	       rec.nsn,
	       Amd_Preferred_Pkg.getPreferredValue(rec.planner_code_cleaned, rec.planner_code),
	       NULL , -- third_party_flag
	       Amd_Preferred_Pkg.getPreferredValue(rec.mtbdr_cleaned, rec.mtbdr),
	       getIndenture(smr_code_preferred),
		   Amd_Preferred_Pkg.getPreferredValue(rec.unit_cost_cleaned, rec.unit_cost)) ;
	
	   IF wasPartSent(rec.part_no) THEN
		   insertTmpA2APartLeadTime(part_no => rec.part_no, 
		   						order_lead_time => rec.order_lead_time, 
								order_lead_time_cleaned => rec.order_lead_time_cleaned, 
								order_lead_time_defaulted => rec.order_lead_time_defaulted) ;
		
			insertTimeToRepair (part_no => rec.part_no, nsi_sid => rec.nsi_sid,
							   time_to_repair_off_base_cleand => rec.time_to_repair_off_base_cleand ) ;
							
			insertUnitCost (part_no => rec.part_no, unit_cost => rec.unit_cost,
						   unit_cost_cleaned => rec.unit_cost_cleaned,
						   unit_cost_defaulted => rec.unit_cost_defaulted) ;
		END IF ;
	  END processPart ;
	
	 
	 PROCEDURE processParts(parts IN partCur) IS
	 		   rec partInfoRec ;
			   cnt NUMBER := 0 ;
	 BEGIN
	      writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 500,
			pKey1 => 'processParts',
			pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	 	  
		  LOOP
		  	  FETCH parts INTO rec ;
			  EXIT WHEN parts%NOTFOUND ;		
			  processPart(rec) ;
			  cnt := cnt + 1 ;
		      IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
		   	   COMMIT ;
		      END IF ;		 
		  END LOOP ;
	      writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 510,
			pKey1 => 'processParts',
			pKey2 => 'cnt=' || TO_CHAR(cnt),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
		  COMMIT ;
		  
	 END processParts ;
	 
	 -- allow for collecting data by last_update_dt
	 PROCEDURE initA2APartInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) IS
	 
	 		   preferred_smr_code  AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE ;
			   rcm_ind 			   TMP_A2A_PART_INFO.rcm_ind%TYPE ;
			   indenture 		   TMP_A2A_PART_INFO.indenture%TYPE ;
			   preferred_unit_cost TMP_A2A_PART_INFO.price%TYPE ;
			   nsn_fsc 			   TMP_A2A_PART_INFO.nsn_fsc%TYPE ;
			   nsn_niin 		   TMP_A2A_PART_INFO.nsn_niin%TYPE ;
			   cnt				   NUMBER := 0 ;
			   parts			   partCur ;
			   
	 BEGIN
	      writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 520,
			pKey1 => 'initA2APartInfo',
			pKey2 => 'start_dt=' || TO_CHAR(start_dt,'MM/DD/YYYY'),
			pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
			pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	 	  mblnSendAllData := TRUE ;
	  	  truncateA2Atables ;
		  OPEN parts FOR
			SELECT sp.mfgr,
			      sp.part_no,
			      sp.NOMENCLATURE,
			      sp.nsn,
			      sp.order_lead_time,
			      sp.order_lead_time_defaulted,
			      sp.unit_cost,
			      sp.unit_cost_defaulted,
			      sp.unit_of_issue,
			      nsi.unit_cost_cleaned,
			      nsi.order_lead_time_cleaned,
			      nsi.planner_code,
			      nsi.planner_code_cleaned,
			      nsi.mtbdr,
			      nsi.mtbdr_cleaned,
			      nsi.smr_code,
			      nsi.smr_code_cleaned,
			      nsi.smr_code_defaulted,
			      nsi.nsi_sid,
			      nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND,
			      CASE 
				  WHEN TRUNC(sp.last_update_dt) >= TRUNC(nsi.last_update_dt)
					THEN sp.last_update_dt
				  ELSE
					nsi.LAST_UPDATE_DT
			      END AS last_update_dt,
			    CASE 
				WHEN sp.action_code = nsi.action_code
					THEN sp.action_code
				ELSE
					CASE 
						WHEN sp.action_code = 'D' OR nsi.action_code = 'D'
							THEN 'D'
						WHEN sp.action_code = 'C' OR nsi.action_code = 'C'
							THEN 'C'
						ELSE
							'A'
					END
				END AS action_code
			  FROM AMD_SPARE_PARTS sp,
			    AMD_NATIONAL_STOCK_ITEMS nsi
			  WHERE sp.nsn = nsi.nsn  
			     AND (TRUNC(sp.last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
				      OR TRUNC(nsi.last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) ) ;
					   
		  processParts(parts) ;
		  CLOSE parts ;	  
	      writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 530,
			pKey1 => 'initA2APartInfo',
			pKey2 => 'start_dt=' || TO_CHAR(start_dt,'MM/DD/YYYY'),
			pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
			pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;  	 
	 END initA2APartInfo ;
	 
	
	 FUNCTION initA2APartInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
	     result NUMBER := SUCCESS ;
	 	 parts partCur ;
	
	 BEGIN
	  writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 540,
			pKey1 => 'initA2APartInfo',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	  mblnSendAllData := TRUE ;
	  truncateA2Atables ;
	  IF useTestParts THEN
	  	 parts := getTestData ;
	  ELSE
	     parts := getPartInfo ;
	  END IF ;
	  processParts(parts) ;
	  CLOSE parts ;
	
	  writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 550,
			pKey1 => 'initA2APartInfo',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  COMMIT ;  	 
	  RETURN result ;
	
	 END initA2APartInfo ;
	 
	 PROCEDURE deletePartInfo(partInfo IN part2DeleteCur) IS
	 		   rec part2Delete ;
			   cnt NUMBER := 0 ;		   
	 		   PROCEDURE processPart(rec IN part2Delete) IS
			   			 result NUMBER ;
			   BEGIN
	   		   		result := A2a_Pkg.DeletePartInfo(rec.part_no, rec.nomenclature) ;
			   END processPart ;
	 BEGIN
	  	  writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 560,
			pKey1 => 'deletePartInfo',
			pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	 	  LOOP
		  	  FETCH partInfo INTO rec ;
			  EXIT WHEN partInfo%NOTFOUND ;
			  processPart(rec) ;
			  cnt := cnt + 1 ;
		  END LOOP ;
	  	  writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 570,
			pKey1 => 'deletePartInfo',
			pKey2 => 'cnt=' || TO_CHAR(cnt),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;
	 END deletePartInfo ;
	 
	 PROCEDURE deletePartInfo(useTestParts IN BOOLEAN := FALSE) IS
			   parts part2DeleteCur ;
	 BEGIN
	  writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 580,
			pKey1 => 'deletePartInfo',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	  truncateA2Atables ;
	  IF useTestParts THEN
	  	 OPEN parts FOR 
			   SELECT part_no, nomenclature FROM AMD_SPARE_PARTS
			   WHERE part_no IN (SELECT part_no FROM AMD_TEST_PARTS) 
			   AND action_code != Amd_Defaults.DELETE_ACTION ;
	  ELSE
	    OPEN parts FOR	 
			   SELECT part_no, nomenclature FROM AMD_SPARE_PARTS WHERE action_code != Amd_Defaults.DELETE_ACTION ;
	  END IF ;
	  deletePartInfo(parts) ;
	  CLOSE parts ;
	  writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 590,
			pKey1 => 'deletePartInfo',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	  COMMIT ;  	 
	 END deletePartInfo ;
	
	
	 PROCEDURE updateA2ApartInfo(
	        mfgr IN VARCHAR2,
	       part_no IN VARCHAR2,
	       unit_issue IN VARCHAR2,
	       nomenclature IN VARCHAR2,
	       smr_code IN VARCHAR2,
	       nsn IN VARCHAR2,
	       planner_code IN VARCHAR2,
	       third_party_flag IN VARCHAR2,
	       mtbdr      IN NUMBER,
	       indenture IN VARCHAR2,
	       action_code IN VARCHAR2,
		   price IN NUMBER)  IS
	
	         result NUMBER ;
			 plannerCode AMD_PLANNERS.planner_code%TYPE := getAssignedPlannerCode(part_no, planner_code) ;
			 rcm_ind TMP_A2A_PART_INFO.rcm_ind%TYPE := getValidRcmInd(SUBSTR(updateA2ApartInfo.smr_code,6,1)) ;
	 BEGIN
	 	 
	   UPDATE TMP_A2A_PART_INFO
	
	   SET
	     cage_code = updateA2ApartInfo.mfgr,
	     unit_issue = updateA2ApartInfo.unit_issue,
	     noun = updateA2ApartInfo.nomenclature,
	     rcm_ind = updateA2ApartInfo.rcm_ind,
	     nsn_fsc = SUBSTR(updateA2ApartInfo.nsn, 1, 4),
	     nsn_niin = SUBSTR(updateA2ApartInfo.nsn, 5, 9),
	     resp_asset_mgr = updateA2ApartInfo.plannerCode,
	     third_party_flag = updateA2ApartInfo.third_party_flag,
	     mtbf = updateA2ApartInfo.mtbdr,
	     preferred_smrcode = updateA2ApartInfo.smr_code,
	     indenture = updateA2ApartInfo.indenture,
	     action_code = updateA2ApartInfo.action_code,
	     last_update_dt = SYSDATE,
		 price = updateA2APartInfo.price
	
	    WHERE part_no = updateA2ApartInfo.part_no ;
	
	 EXCEPTION WHEN OTHERS THEN
	     ErrorMsg(pSqlfunction => 'update',
		     pTableName => 'tmp_a2a_part_info',
		     pError_location => 600,
		     pKey_1 => part_no,
		     pKey_2 => mfgr,
		     pKey_3 => nomenclature,
		     pKey_4 => nsn) ;
	   	 RAISE ;
	 END updateA2ApartInfo ;
	
	 FUNCTION isNsl(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN IS
	    nsn AMD_SPARE_PARTS.nsn%TYPE ;
	 BEGIN
	
	   <<getNsn>>
	   BEGIN
	    SELECT nsn INTO isNsl.nsn
	    FROM AMD_SPARE_PARTS
	    WHERE partNo = part_no ;
	   EXCEPTION WHEN OTHERS THEN
	        ErrorMsg(pSqlfunction => 'select',
		     pTableName => 'amd_spare_parts',
		     pError_location => 610,
		     pKey_1 => partNo) ;
	      RAISE ;
	   END getNsn ;
	   IF UPPER(SUBSTR(nsn,1,3)) = 'NSL' AND mDebug THEN
	   	  debugMsg(partNo || ' is an NSL part.', 90) ;
	   END IF;
	   RETURN UPPER(SUBSTR(nsn,1,3)) = 'NSL' ;
	 END isNsl ;
	 
	 FUNCTION isNslYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 IS
	 BEGIN
	 	  IF isNsl(partNo) THEN
		    RETURN 'Y' ;
		  ELSE
		    RETURN 'N' ;
		  END IF ;
	  END isNslYorN ;
	
	 FUNCTION wasPartSent(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN IS
	      part_no AMD_SENT_TO_A2A.PART_NO%TYPE ;
	 BEGIN
	
	   IF mblnSendAllData THEN
		   SELECT part_no INTO part_no FROM AMD_SENT_TO_A2A WHERE part_no = partNo
			   AND spo_prime_part_no IS NOT NULL ;
	   ELSE
		   SELECT part_no INTO part_no FROM AMD_SENT_TO_A2A WHERE part_no = partNo
		       AND (action_code = Amd_Defaults.INSERT_ACTION OR action_code = Amd_Defaults.UPDATE_ACTION)
			   AND spo_prime_part_no IS NOT NULL ;
	   END IF ;
	   
	   RETURN TRUE ;
	
	 EXCEPTION WHEN standard.NO_DATA_FOUND THEN
	     RETURN FALSE ;
	 END wasPartSent ;
	 
	 FUNCTION isPlannerCodeAssigned2UserId(plannerCode IN VARCHAR2) RETURN BOOLEAN IS
	 		  result NUMBER := 0 ;
	 BEGIN
	 	  <<isPlannerAssigned>>
	 	  BEGIN
	 	  	   SELECT 1 INTO result FROM dual WHERE EXISTS  (SELECT planner_code FROM AMD_PLANNER_LOGONS WHERE planner_code = plannerCode) ;
		  EXCEPTION 
		  	WHEN standard.NO_DATA_FOUND THEN
				 NULL ;
		  	WHEN OTHERS THEN
		        ErrorMsg(pSqlfunction => 'select',
			     pTableName => 'amd_planner_logons',
			     pError_location => 620,
			     pKey_1 => plannerCode) ;
			   RAISE ;
	 	 END isPlannerAssigned ;
		  
		 RETURN result = 1;
		 
	 END isPlannerCodeAssigned2UserId ;
	
	 
	
	 FUNCTION isPartValid (partNo IN AMD_SPARE_PARTS.part_no%TYPE, showReason in boolean := false) RETURN BOOLEAN IS
	    result BOOLEAN := FALSE ;
	    smrCode AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE ;
		smrCodeCleaned AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE ;
	    mtbdr   AMD_NATIONAL_STOCK_ITEMS.mtbdr%TYPE ;
	    mtbdr_cleaned AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE ;
	    plannerCode AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE ;
		part_no AMD_SPARE_PARTS.part_no%TYPE ;
		plannerCodeCleaned AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE ;
	 BEGIN
	   debugMsg(msg => 'isPartValid(' || partNo || ')', lineNo => 100) ;
	   <<doesPartExist>>
	   BEGIN
	   		SELECT part_no INTO isPartValid.part_no FROM AMD_SPARE_PARTS 
			WHERE partNo = part_no AND action_code != Amd_Defaults.DELETE_ACTION ;
	   EXCEPTION
	   		WHEN standard.NO_DATA_FOUND THEN
				 IF mDebug THEN
				 	debugMsg(partNo || ' does not exist in amd_spare_parts or has been logically deleted.', lineNo => 110) ; 
				 END IF ;
				 RETURN FALSE ;
	   END doesPartExist ;
	   
	   <<getPrimePartData>>
	   BEGIN
	    SELECT smr_code, smr_code_cleaned, mtbdr, mtbdr_cleaned, planner_code, planner_code_cleaned INTO smrCode, smrCodeCleaned, mtbdr, mtbdr_cleaned, plannerCode, plannerCodeCleaned
	    FROM AMD_NATIONAL_STOCK_ITEMS items, AMD_NSI_PARTS parts
	    WHERE isPartValid.partNo = parts.part_no
	    AND parts.UNASSIGNMENT_DATE IS NULL
	    AND parts.nsi_sid = items.nsi_sid ;
	   EXCEPTION
	     WHEN standard.NO_DATA_FOUND THEN
		   IF mDebug THEN
		   	  debugMsg(partNo || ' is NOT valid amd_nsi_parts.UNASSIGNMENT_DATE is not be NULL', lineNo => 120) ;
		   END IF ;
	       RETURN FALSE ;
	     WHEN OTHERS THEN
	         ErrorMsg(pSqlfunction => 'select',
		      pTableName => 'items / parts',
		      pError_location => 630,
		      pKey_1 => isPartValid.partNo) ;
	         RAISE ;
	   END getPrimePartData ;
	   RETURN isPartValid(partNo => partNo, smrCode => Amd_Preferred_Pkg.getPreferredValue(smrCodeCleaned,smrCode), mtbdr => Amd_Preferred_Pkg.getPreferredValue(mtbdr_cleaned,mtbdr), plannerCode => Amd_Preferred_Pkg.GetPreferredValue(plannerCodeCleaned,plannerCode), showReason => showReason) ;
	 END isPartValid ;
	
	 FUNCTION createPartInfo(part_no IN VARCHAR2,
	        action_code IN VARCHAR2 := Amd_Defaults.UPDATE_ACTION) RETURN NUMBER IS
	  TYPE  partInfo IS RECORD(
	        mfgr AMD_SPARE_PARTS.mfgr%TYPE,
	       part_no AMD_SPARE_PARTS.part_no%TYPE,
	       unit_of_issue AMD_SPARE_PARTS.unit_of_issue%TYPE,
	       nomenclature AMD_SPARE_PARTS.nomenclature%TYPE,
	       smr_code AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE,
	       smr_code_cleaned AMD_NATIONAL_STOCK_ITEMS.SMR_CODE_CLEANED%TYPE,
	       smr_code_defaulted AMD_NATIONAL_STOCK_ITEMS.SMR_CODE_DEFAULTED%TYPE,
	       nsn AMD_SPARE_PARTS.nsn%TYPE,
	       planner_code AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE,
	       planner_code_cleaned AMD_NATIONAL_STOCK_ITEMS.PLANNER_CODE_CLEANED%TYPE,
	       third_party_flag TMP_A2A_PART_INFO.third_party_flag%TYPE,
	       mtbdr      AMD_NATIONAL_STOCK_ITEMS.mtbdr%TYPE,
	       mtbdr_cleaned AMD_NATIONAL_STOCK_ITEMS.MTBDR_CLEANED%TYPE,
	       indenture TMP_A2A_PART_INFO.indenture%TYPE,
		   unit_cost_cleaned AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE,
		   unit_cost AMD_SPARE_PARTS.UNIT_COST%TYPE) ;
	
	
	  rec partInfo ;
	
	  rc NUMBER := A2a_Pkg.SUCCESS ;
	
	  FUNCTION insertPartInfo(rec partInfo) RETURN NUMBER IS
	  BEGIN
	    RETURN A2a_Pkg.insertPartInfo(mfgr => rec.mfgr,
	                part_no => rec.part_no, unit_issue => rec.unit_of_issue,
	             nomenclature => rec.nomenclature, smr_code => rec.smr_code,
	             nsn => rec.nsn, planner_code => rec.planner_code,
	             third_party_flag => rec.third_party_flag, mtbdr => rec.mtbdr,
	             indenture => rec.indenture,
				 price => Amd_Preferred_Pkg.getPreferredValue(rec.unit_cost_cleaned,rec.unit_cost)) ;
	  END insertPartInfo ;
	
	  FUNCTION updatePartInfo(rec partInfo) RETURN NUMBER IS
	  BEGIN
	    RETURN A2a_Pkg.updatePartInfo(mfgr => rec.mfgr,
	                part_no => rec.part_no, unit_issue => rec.unit_of_issue,
	             nomenclature => rec.nomenclature, smr_code => rec.smr_code,
	             nsn => rec.nsn, planner_code => rec.planner_code,
	             third_party_flag => rec.third_party_flag, mtbdr => rec.mtbdr,
	             indenture => rec.indenture,
				 price => Amd_Preferred_Pkg.getPreferredValue(rec.unit_cost_cleaned, rec.unit_cost)) ;
	  END updatePartInfo ;
	
	  PROCEDURE errorMsgCIP(pError_location IN NUMBER) IS
	  BEGIN
	       errorMsg(pSqlfunction => 'insert',
	    pTableName => 'tmp_a2a_part_info',
	    pError_location => pError_location,
	    pKey_1 => part_no) ;
	  END errorMsgCIP ;
	
	  PROCEDURE getPartInfo IS
	  BEGIN
	      SELECT mfgr, part_no, unit_of_issue, nomenclature,
	       smr_code, smr_code_cleaned, smr_code_defaulted,
	       sp.nsn, planner_code, planner_code_cleaned, mtbdr, mtbdr_cleaned,
		   unit_cost, unit_cost_cleaned
	       INTO
	       rec.mfgr, rec.part_no, rec.unit_of_issue, rec.nomenclature,
	       rec.smr_code, rec.smr_code_cleaned, rec.smr_code_defaulted,
	       rec.nsn, rec.planner_code, rec.planner_code_cleaned, rec.mtbdr, rec.mtbdr_cleaned,
		   rec.unit_cost, rec.unit_cost_cleaned 
	   FROM AMD_SPARE_PARTS sp,
	   AMD_NATIONAL_STOCK_ITEMS items
	   WHERE sp.part_no = createPartInfo.part_no
	   AND sp.nsn = items.nsn ;
	   rec.indenture := getIndenture(Amd_Preferred_Pkg.GetPreferredValue(rec.smr_code_cleaned, rec.smr_code, rec.smr_code_defaulted)) ;
	   rec.third_party_flag := A2a_Pkg.THIRD_PARTY_FLAG ;
	  EXCEPTION
	     WHEN OTHERS THEN
	        errorMsgCIP(pError_location => 640) ;
	      	RAISE ;
	  END getPartInfo ;
	 BEGIN
	   IF mDebug THEN
	    debugMsg('part_no=' || createPartInfo.part_no || ' action_code=' || createPartInfo.action_code, lineNo => 130) ;
	   END IF ;
	   getPartInfo ;
	
	   CASE createPartInfo.action_code
	      WHEN Amd_Defaults.UPDATE_ACTION THEN
	         <<updateAction>>
	       BEGIN
	          rc := updatePartInfo(rec) ;
	       EXCEPTION
	          WHEN OTHERS THEN
	            errorMsgCIP(pError_location => 650) ;
	          	RAISE ;
	       END updateAction ;
	
	      WHEN Amd_Defaults.INSERT_ACTION THEN
	         <<insertAction>>
	       BEGIN
	      rc := insertPartInfo(rec => rec) ;
	       EXCEPTION
	          WHEN OTHERS THEN
	            errorMsgCIP(pError_location => 660) ;
	          	RAISE ;
	       END insertAction ;
	
	      WHEN Amd_Defaults.DELETE_ACTION THEN
	         <<deleteAction>>
	       BEGIN
	      rc := deletePartInfo( part_no => rec.part_no,
	             nomenclature => rec.nomenclature) ;
	       EXCEPTION
	          WHEN OTHERS THEN
	            errorMsgCIP(pError_location => 670) ;
	          	RAISE ;
	       END deleteAction ;
	     ELSE
	        debugMsg('Invalid action_code ' || createPartInfo.action_code, lineNo => 140) ;
	        RAISE A2a_Pkg.APPLICATION_ERROR ;
	   END CASE ;
	
	   RETURN rc ;
	 EXCEPTION
	    WHEN OTHERS THEN
	       errorMsgCIP(pError_location => 680) ;
	       RAISE ;
	 END createPartInfo  ;
	
	 
	 
	 FUNCTION InsertPartInfo(
	       mfgr IN VARCHAR2,
	       part_no IN VARCHAR2,
	       unit_issue IN VARCHAR2,
	       nomenclature IN VARCHAR2,
	       smr_code IN VARCHAR2,
	       nsn IN VARCHAR2,
	       planner_code IN VARCHAR2,
	       third_party_flag IN VARCHAR2,
	       mtbdr      IN NUMBER,
	       indenture IN VARCHAR2,
		   price IN NUMBER) RETURN NUMBER IS
	
	     result NUMBER ;
		 rcm_ind TMP_A2A_PART_INFO.RCM_IND%TYPE ;
		 plannerCode AMD_PLANNERS.planner_code%TYPE := getAssignedPlannerCode(part_no, planner_code) ;
		 
	
	 BEGIN
	   mArgs := 'InsertPartInfo(' || mfgr || ', ' || part_no || ', ' || unit_issue || ', ' || nomenclature
	       || ', ' || smr_code || ', ' || nsn || ', ' || planner_code || ', ' || third_party_flag
	      || ', ' || mtbdr || ', ' || indenture || ')' ;
	   validateData (
	       mfgr,
	       part_no,
	       unit_issue,
	       nomenclature,
	       smr_code,
	       nsn,
	       planner_code,
	       third_party_flag,
	       mtbdr,
	       indenture,
		   rcm_ind) ;
	   IF isPartValid(partNo => part_no, smrCode => smr_code, mtbdr => mtbdr, plannerCode => planner_code) THEN
	    INSERT INTO TMP_A2A_PART_INFO
	    (
	       cage_code,
	       part_no,
	       unit_issue,
	       noun,
	       rcm_ind,
	       nsn_fsc,
	       nsn_niin,
	       resp_asset_mgr,
	       third_party_flag,
	       mtbf,
	       preferred_smrcode,
	       indenture,
	       action_code,
	       last_update_dt,
		   price
	   )
	   VALUES
	   (
	        insertPartInfo.mfgr,
	       insertPartInfo.part_no,
	       insertPartInfo.unit_issue,
	       insertPartInfo.nomenclature,
	       insertPartInfo.rcm_ind,
	       SUBSTR(insertPartInfo.nsn, 1, 4),
	       SUBSTR(insertPartInfo.nsn, 5, 9),
	       insertPartInfo.plannerCode,
	       insertPartInfo.third_party_flag,
	       insertPartInfo.mtbdr,
	       insertPartInfo.smr_code,
	       insertPartInfo.indenture,
	       Amd_Defaults.INSERT_ACTION,
	       SYSDATE,
		   insertPartInfo.price
	   ) ;
	  ELSE
	   result := A2a_Pkg.DeletePartInfo(part_no, nomenclature) ;
	
	  END IF ;
	
	  RETURN SUCCESS ;
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	       updateA2ApartInfo( mfgr, part_no, unit_issue, nomenclature, smr_code, nsn,
	       planner_code, third_party_flag, mtbdr, indenture, Amd_Defaults.INSERT_ACTION, price) ;
	      RETURN SUCCESS ;
	
	     WHEN OTHERS THEN
	         ErrorMsg(pSqlfunction => 'insert',
		      pTableName => 'tmp_a2a_part_info',
		      pError_location => 690,
		      pKey_1 => part_no,
		      pKey_2 => mfgr,
		      pKey_3 => nomenclature,
		      pKey_4 => nsn) ;
	       RAISE ;
	
	 END InsertPartInfo ;
	
	
	 FUNCTION UpdatePartInfo(
	       mfgr IN VARCHAR2,
	       part_no IN VARCHAR2,
	       unit_issue IN VARCHAR2,
	       nomenclature IN VARCHAR2,
	       smr_code IN VARCHAR2,
	       nsn IN VARCHAR2,
	       planner_code IN VARCHAR2,
	       third_party_flag IN VARCHAR2,
	       mtbdr      IN NUMBER,
	       indenture IN VARCHAR2,
		   price IN NUMBER) RETURN NUMBER IS
	  
	  result NUMBER ;
	  rcm_ind TMP_A2A_PART_INFO.rcm_ind%TYPE ;
	  
	 BEGIN
	   mArgs := 'UpdatePartInfo(' || mfgr || ', ' || part_no || ', ' || unit_issue || ', '
	     || nomenclature || ', ' || smr_code || ', ' || nsn || ', ' || planner_code
	    || ', ' || third_party_flag || ', ' || mtbdr || ', ' || indenture ||')' ;
	   debugMsg(msg => mArgs, lineNo => 150 ) ;
	   
	   validateData (
	       mfgr,
	       part_no,
	       unit_issue,
	       nomenclature,
	       smr_code,
	       nsn,
	       planner_code,
	       third_party_flag,
	       mtbdr,
	       indenture,
		   rcm_ind) ;
		   
	   IF isPartValid(partNo => part_no, smrCode => smr_code, mtbdr => mtbdr, plannerCode => planner_code) THEN
	    INSERT INTO TMP_A2A_PART_INFO
	    (
	       cage_code,
	       part_no,
	       unit_issue,
	       noun,
	       rcm_ind,
	       nsn_fsc,
	       nsn_niin,
	       resp_asset_mgr,
	       third_party_flag,
	       mtbf,
	       preferred_smrcode,
	       indenture,
	       action_code,
	       last_update_dt,
		   price
	   )
	   VALUES
	   (
	        UpdatePartInfo.mfgr,
	       UpdatePartInfo.part_no,
	       UpdatePartInfo.unit_issue,
	       UpdatePartInfo.nomenclature,
	       rcm_ind,
	       SUBSTR(UpdatePartInfo.nsn, 1, 4),
	       SUBSTR(UpdatePartInfo.nsn, 5, 9),
	       UpdatePartInfo.planner_code,
	       UpdatePartInfo.third_party_flag,
	       UpdatePartInfo.mtbdr,
	       UpdatePartInfo.smr_code,
	       UpdatePartInfo.indenture,
	       Amd_Defaults.UPDATE_ACTION,
	       SYSDATE,
		   updatePartInfo.price
	   ) ;
	  ELSE
	   result := A2a_Pkg.DeletePartInfo(part_no, nomenclature) ;
	
	  END IF ;
	  RETURN SUCCESS ;
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	       updateA2ApartInfo( mfgr, part_no, unit_issue, nomenclature, smr_code, nsn,
	       planner_code, third_party_flag, mtbdr, indenture, Amd_Defaults.UPDATE_ACTION, price) ;
	      RETURN SUCCESS ;
	     WHEN OTHERS THEN
		 	  ErrorMsg(pSqlfunction => 'update',
		       pTableName => 'tmp_a2a_part_info',
		       pError_location => 700,
		       pKey_1 => part_no,
		       pKey_2 => mfgr,
		       pKey_3 => nomenclature,
		       pKey_4 => nsn) ;
		    RAISE ;
	
	
	
	 END UpdatePartInfo;
	
	 FUNCTION DeletePartInfo(
	       part_no IN VARCHAR2, nomenclature IN VARCHAR2) RETURN NUMBER IS
	  result NUMBER ;
	  PROCEDURE makeA2AdeletePartInfo IS
	  BEGIN
	    debugMsg(msg => 'makeA2AdeletePartInfo', lineNo => 160) ;
	    UPDATE TMP_A2A_PART_INFO
	    SET noun = DeletePartInfo.nomenclature,
	    action_code = Amd_Defaults.DELETE_ACTION,
	    last_update_dt = SYSDATE
	    WHERE part_no = DeletePartInfo.part_no ;
	
	  EXCEPTION WHEN OTHERS THEN
	  	ErrorMsg(pSqlfunction => 'delete',
	      pTableName => 'tmp_a2a_part_info',
	      pError_location => 710,
	      pKey_1 => part_no) ;
	   RAISE ;
	
	  END makeA2AdeletePartInfo ;
	
	 BEGIN
	   mArgs := 'DeletePartInfo(' || part_no || ', ' || nomenclature || ')' ;
	   debugMsg(msg => mArgs, lineNo => 170 ) ;
	   -- mblnSendAllData allows parts to be deleted even if they have been deleted previously.  This
	   -- allows the system to send all types of A2A transactions when the initPartInfoA2A is executed
	   IF wasPartSent(partNo => part_no)  THEN
	    INSERT INTO TMP_A2A_PART_INFO
	    (
	       part_no,
	       noun,
	       action_code,
	       last_update_dt
	    )
	    VALUES
	    (
	         DeletePartInfo.part_no,
	       nomenclature,
	       Amd_Defaults.DELETE_ACTION,
	       SYSDATE
	    ) ;
	   END IF ;
	   RETURN SUCCESS ;
	 EXCEPTION
	  WHEN standard.DUP_VAL_ON_INDEX THEN
	    makeA2AdeletePartInfo ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'delete',
	      pTableName => 'tmp_a2a_part_info',
	      pError_location => 720,
	      pKey_1 => part_no) ;
	   RAISE ;
	
	 END DeletePartInfo ;
	
	 PROCEDURE updateA2ApartLeadTime(
	        part_no IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       lead_time IN NUMBER,
	       action_code IN VARCHAR2)  IS
	     result NUMBER ;
		 cage_code TMP_A2A_PART_LEAD_TIME.cage_code%TYPE := Amd_Utils.getCageCode(part_no) ;
	 BEGIN
	
	   UPDATE TMP_A2A_PART_LEAD_TIME
	   SET lead_time = updateA2ApartLeadTime.lead_time,
	   action_code = updateA2ApartLeadTime.action_code,
	   last_update_dt = SYSDATE,
	   cage_code = updateA2aPartLeadTime.cage_code
	   WHERE part_no = updateA2ApartLeadTime.part_no
	   AND lead_time_type = updateA2ApartLeadTime.lead_time_type ;
	
	 EXCEPTION WHEN OTHERS THEN
	    ErrorMsg(pSqlfunction => 'update',
	       pTableName => 'tmp_a2a_part_lead_time',
	       pError_location => 730,
	       pKey_1 => part_no,
	       pKey_2 => lead_time_type,
	       pKey_3 => lead_time,
		   pKey_4 => cage_code) ;
	   RAISE ;
	 END updateA2ApartLeadTime ;
	
	
	 FUNCTION InsertPartLeadTime(
	        part_no IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       lead_time IN NUMBER) RETURN NUMBER IS
	  result NUMBER ;
	  cage_code TMP_A2A_PART_LEAD_TIME.cage_code%TYPE := Amd_Utils.getCageCode(part_no) ;
	  PROCEDURE validateData IS
	  			lineNo NUMBER := 0 ;
				rec TMP_A2A_PART_LEAD_TIME%ROWTYPE ;
	  BEGIN
	  	   lineNo := lineNo + 1;rec.part_no := part_no ;
	  	   lineNo := lineNo + 1;rec.lead_time_type := lead_time_type ;
	  	   lineNo := lineNo + 1;rec.lead_time := lead_time ;
	  EXCEPTION WHEN OTHERS THEN
	  	 errorMsg(	   
		     pSqlfunction => ':=',
		     pTableName => 'tmp_a2a_part_lead_time',
		     pError_location => 740,
		     pKey_1 => TO_CHAR(lineNo)) ;
		 RAISE ;
	  END validateData ;
	 BEGIN
	   mArgs := 'updateA2APartLeadTime(' || part_no || ', ' || lead_time_type || ', ' || lead_time || ')' ;
	   validateData ;
	   IF isPartValid(part_no) AND wasPartSent(part_no) THEN
	    INSERT INTO TMP_A2A_PART_LEAD_TIME
	    (
	     part_no,
		 cage_code,
	     lead_time_type,
	     lead_time,
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	    part_no,
		insertPartLeadTime.cage_code,
	    lead_time_type,
	    lead_time,
	    Amd_Defaults.INSERT_ACTION,
	    SYSDATE
	    ) ;
	   END IF ;
	
	   RETURN SUCCESS ;
	
	 EXCEPTION
	  WHEN standard.DUP_VAL_ON_INDEX THEN
	    updateA2ApartLeadTime(part_no, lead_time_type, lead_time, Amd_Defaults.INSERT_ACTION) ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'insert',
	      pTableName => 'tmp_a2a_part_lead_time',
	      pError_location => 750,
	      pKey_1 => part_no,
	      pKey_2 => lead_time_type,
	      pKey_3 => lead_time) ;
	   RAISE ;
	
	 END InsertPartLeadTime ;
	
	 FUNCTION UpdatePartLeadTime(
	        part_no IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       lead_time IN NUMBER) RETURN NUMBER IS
	  result NUMBER ;
	  cage_code TMP_A2A_PART_LEAD_TIME.cage_code%TYPE := Amd_Utils.getCageCode(part_no) ;
	 BEGIN
	   mArgs := 'UpdatePartLeadTime(' || part_no || ', ' || lead_time_type || ', ' || lead_time || ')' ;
	   IF isPartValid(part_no) AND wasPartSent(part_no) THEN
	    INSERT INTO TMP_A2A_PART_LEAD_TIME
	    (
	     part_no,
		 cage_code,
	     lead_time_type,
	     lead_time,
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	    part_no,
		updatePartLeadTime.cage_code,
	    lead_time_type,
	    lead_time,
	    Amd_Defaults.UPDATE_ACTION,
	    SYSDATE
	    ) ;
	   END IF ;
	   RETURN SUCCESS ;
	
	 EXCEPTION
	  WHEN standard.DUP_VAL_ON_INDEX THEN
	    updateA2ApartLeadTime(part_no, lead_time_type, lead_time, Amd_Defaults.UPDATE_ACTION) ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'update',
	      pTableName => 'tmp_a2a_part_lead_time',
	      pError_location => 760,
	      pKey_1 => part_no,
	      pKey_2 => lead_time_type,
	      pKey_3 => lead_time) ;
	
	    RAISE ;
	 END UpdatePartLeadTime ;
	
	
	 FUNCTION DeletePartLeadTime(
	        part_no IN VARCHAR2) RETURN NUMBER IS
	
	   rc NUMBER ;
	   cage_code TMP_A2A_PART_LEAD_TIME.cage_code%TYPE := Amd_Utils.getCageCode(part_no) ;
	
	   PROCEDURE makeDelete IS
	       rc NUMBER ;
	   BEGIN
	       UPDATE TMP_A2A_PART_LEAD_TIME
	     SET action_code = Amd_Defaults.DELETE_ACTION,
	     last_update_dt = SYSDATE
	     WHERE part_no = DeletePartLeadTime.part_no
	     AND lead_time_type = REPAIR ;
	   EXCEPTION WHEN OTHERS THEN
	     ErrorMsg(pSqlfunction => 'update',
	      pTableName => 'tmp_a2a_part_lead_time',
	      pError_location => 770,
	      pKey_1 => part_no) ;
	    RAISE ;
	
	   END makeDelete ;
	
	 BEGIN
	   mArgs := 'DeletePartLeadTime(' || part_no || ')' ;
	   IF isPartValid(part_no) AND wasPartSent(part_no) THEN
	    INSERT INTO TMP_A2A_PART_LEAD_TIME
	    (
	     part_no,
		 cage_code,
	     lead_time_type,
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	    part_no,
		deletePartLeadTime.cage_code,
	    REPAIR,
	    Amd_Defaults.DELETE_ACTION,
	    SYSDATE
	    ) ;
	   END IF ;
	   RETURN SUCCESS ;
	
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	    makeDelete ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	     ErrorMsg(pSqlfunction => 'insert',
	      pTableName => 'tmp_a2a_part_lead_time',
	      pError_location => 780,
	      pKey_1 => part_no) ;
	    RAISE ;
	
	 END DeletePartLeadTime ;
	
	
	 PROCEDURE updateA2ApartPricing(
	        part_no IN VARCHAR2,
	       price_type IN VARCHAR2,
	       price IN NUMBER,
	       action_code IN VARCHAR2)  IS
	      result NUMBER ;
	 BEGIN
	   UPDATE TMP_A2A_PART_PRICING
	   SET
	   price_fiscal_year = TO_CHAR(SYSDATE, 'YYYY'),
	   price_type = updateA2ApartPricing.price_type,
	   price = updateA2ApartPricing.price,
	   action_code = updateA2ApartPricing.action_code,
	   last_update_dt = SYSDATE
	
	   WHERE part_no = updateA2ApartPricing.part_no ;
	
	 EXCEPTION WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'update',
	      pTableName => 'tmp_a2a_part_pricing',
	      pError_location => 790,
	      pKey_1 => part_no,
	      pKey_2 => price_type,
	      pKey_3 => price,
	      pKey_4 => TO_CHAR(SYSDATE, 'YYYY') );
	  RAISE ;
	 END updateA2ApartPricing ;
	
	 FUNCTION InsertPartPricing(
	        part_no IN VARCHAR2,
	       price_type IN VARCHAR2,
	       unit_cost IN NUMBER) RETURN NUMBER IS
	  result NUMBER ;
	  price NUMBER := unit_cost ;
	 BEGIN
	   mArgs := 'InsertPartPricing(' || part_no || ', ' || price_type || ', ' || unit_cost || ')' ;
	   IF isPartValid(part_no) THEN
	    IF price IS NULL THEN
	     price := 4999.99 ;
	    END IF ;
	    INSERT INTO TMP_A2A_PART_PRICING
	    (
	     part_no,
	     price_fiscal_year,
	     price_type,
	     price,
	     price_date, -- do not sendthis field
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	     part_no,
	     TO_CHAR(SYSDATE, 'YYYY'),
	     price_type,
	     price,
	     SYSDATE,
	     Amd_Defaults.INSERT_ACTION,
	     SYSDATE
	    ) ;
	   END IF ;
	
	   RETURN SUCCESS ;
	
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	    updateA2ApartPricing(part_no,price_type,price,Amd_Defaults.INSERT_ACTION) ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'insert',
	      pTableName => 'tmp_a2a_part_pricing',
	      pError_location => 800,
	      pKey_1 => part_no,
	      pKey_2 => price_type,
	      pKey_3 => unit_cost,
	      pKey_4 => TO_CHAR(SYSDATE, 'YYYY') );
	   RAISE ;
	
	 END InsertPartPricing ;
	
	
	 FUNCTION UpdatePartPricing(
	        part_no IN VARCHAR2,
	       price_type IN VARCHAR2,
	       unit_cost IN NUMBER) RETURN NUMBER IS
	  result NUMBER ;
	 BEGIN
	   mArgs := 'UpdatePartPricing(' || part_no || ', ' || price_type || ', ' || unit_cost || ')' ;
	   IF isPartValid(part_no) THEN
	    INSERT INTO TMP_A2A_PART_PRICING
	    (
	     part_no,
	     price_fiscal_year,
	     price_type,
	     price,
	     price_date, -- do not sent this field
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	     part_no,
	     TO_CHAR(SYSDATE, 'YYYY'),
	     price_type,
	     unit_cost,
	     SYSDATE,
	     Amd_Defaults.UPDATE_ACTION,
	     SYSDATE
	    ) ;
	   END IF ;
	
	   RETURN SUCCESS ;
	
	
	
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	    updateA2ApartPricing(part_no,price_type, unit_cost,Amd_Defaults.UPDATE_ACTION) ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'update',
	      pTableName => 'tmp_a2a_part_pricing',
	      pError_location => 810,
	      pKey_1 => part_no,
	      pKey_2 => price_type,
	      pKey_3 => unit_cost,
	      pKey_4 => TO_CHAR(SYSDATE, 'YYYY') );
	   RAISE ;
	
	 END UpdatePartPricing ;
	
	
	 FUNCTION DeletePartPricing(
	        part_no IN VARCHAR2) RETURN NUMBER IS
	  result NUMBER ;
	
	  PROCEDURE makeDelete IS
	  BEGIN
	    UPDATE TMP_A2A_PART_PRICING
	    SET action_code = Amd_Defaults.DELETE_ACTION,
	    last_update_dt = SYSDATE
	    WHERE part_no = DeletePartPricing.part_no ;
	  EXCEPTION WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'update',
	      pTableName => 'tmp_a2a_part_pricing',
	      pError_location => 820,
	      pKey_1 => part_no) ;
	   RAISE ;
	
	  END makeDelete ;
	
	 BEGIN
	      mArgs := 'DeletePartPricing(' || part_no || ')' ;
	   IF isPartValid(part_no) THEN
	    INSERT INTO TMP_A2A_PART_PRICING
	    (
	     part_no,
	     price_type,
	     price,
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	     part_no,
	     A2a_Pkg.AN_ORDER,
	     0,
	     Amd_Defaults.DELETE_ACTION,
	     SYSDATE
	    ) ;
	   END IF ;
	
	   RETURN SUCCESS ;
	
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	    makeDelete ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'update',
	      pTableName => 'tmp_a2a_part_pricing',
	      pError_location => 830,
	      pKey_1 => part_no) ;
	   RAISE ;
	
	 END DeletePartPricing ;
	
	 PROCEDURE updateA2AlocPartLeadTime(
	        part_no IN VARCHAR2,
	       location_name IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       time_to_repair IN NUMBER,
	       action_code IN VARCHAR2) IS
	      result NUMBER ;
	 BEGIN
	   UPDATE TMP_A2A_LOC_PART_LEAD_TIME
	   SET
	    site_location = location_name,
	    lead_time_type = updateA2AlocPartLeadTime.lead_time_type,
	    lead_time = time_to_repair,
	    action_code = updateA2AlocPartLeadTime.action_code,
	    last_update_dt = SYSDATE
	   WHERE part_no = updateA2AlocPartLeadTime.part_no ;
	
	 EXCEPTION WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'insert',
	      pTableName => 'tmp_a2a_loc_part_lead_time',
	      pError_location => 840,
	      pKey_1 => part_no,
	      pKey_2 => lead_time_type,
	      pKey_3 => time_to_repair );
	  RAISE ;
	 END updateA2AlocPartLeadTime ;
	
	 FUNCTION InsertLocPartLeadTime(
	        part_no IN VARCHAR2,
	       loc_sid IN NUMBER,
	       location_name IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       time_to_repair IN NUMBER) RETURN NUMBER IS
	  result NUMBER ;
	 BEGIN
	      mArgs := 'InsertLocPartLeadTime(' || part_no || ', ' || loc_sid || ', ' || location_name || ', ' || lead_time_type || ', ' || time_to_repair || ')' ;
	    IF isPartValid(part_no) AND wasPartSent(part_no) THEN
	    INSERT INTO TMP_A2A_LOC_PART_LEAD_TIME
	    (
	     part_no,
	     site_location,
	     lead_time_type,
	     lead_time,
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	      part_no,
	      location_name,
	      lead_time_type,
	      time_to_repair,
	      Amd_Defaults.INSERT_ACTION,
	      SYSDATE
	    ) ;
	   END IF ;
	   RETURN SUCCESS ;
	
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	    updateA2AlocPartLeadTime(part_no,location_name,lead_time_type,time_to_repair,Amd_Defaults.INSERT_ACTION) ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'insert',
	      pTableName => 'tmp_a2a_loc_part_lead_time',
	      pError_location => 850,
	      pKey_1 => part_no,
	      pKey_2 => loc_sid,
	      pKey_3 => lead_time_type,
	      pKey_4 => time_to_repair );
	   RAISE ;
	 END InsertLocPartLeadTime ;
	
	
	 FUNCTION UpdateLocPartLeadTime(
	        part_no IN VARCHAR2,
	       loc_sid IN NUMBER,
	       location_name IN VARCHAR2,
	       lead_time_type IN VARCHAR2,
	       time_to_repair IN NUMBER) RETURN NUMBER IS
	  result NUMBER ;
	 BEGIN
	      mArgs := 'UpdateLocPartLeadTime(' || part_no || ', ' || loc_sid || ', ' || location_name || ', ' || lead_time_type || ', ' || time_to_repair || ')' ;
	   IF isPartValid(part_no) AND wasPartSent(part_no) THEN
	    INSERT INTO TMP_A2A_LOC_PART_LEAD_TIME
	    (
	     part_no,
	     site_location,
	     lead_time_type,
	     lead_time,
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	      part_no,
	      location_name,
	      lead_time_type,
	      time_to_repair,
	      Amd_Defaults.UPDATE_ACTION,
	      SYSDATE
	    ) ;
	   END IF ;
	   RETURN SUCCESS ;
	
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	    updateA2AlocPartLeadTime(part_no,location_name,lead_time_type,time_to_repair,Amd_Defaults.UPDATE_ACTION) ;
	    RETURN SUCCESS ;
	
	  WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'update',
	      pTableName => 'tmp_a2a_loc_part_lead_time',
	      pError_location => 860,
	      pKey_1 => part_no,
	      pKey_2 => loc_sid,
	      pKey_3 => lead_time_type,
	      pKey_4 => time_to_repair );
	
	   RAISE ;
	
	 END UpdateLocPartLeadTime ;
	
	
	 FUNCTION DeleteLocPartLeadTime(
	        part_no IN VARCHAR2,
	       loc_sid IN NUMBER,
	       location_name IN NUMBER) RETURN NUMBER IS
	  result NUMBER ;
	  PROCEDURE makeDelete IS
	  BEGIN
	    UPDATE TMP_A2A_LOC_PART_LEAD_TIME
	    SET action_code = Amd_Defaults.DELETE_ACTION,
	    last_update_dt = SYSDATE
	    WHERE part_no = DeleteLocPartLeadTime.part_no
	    AND loc_sid = DeleteLocPartLeadTime.loc_sid ;
	  EXCEPTION WHEN OTHERS THEN
	   ErrorMsg(pSqlfunction => 'delete',
	      pTableName => 'tmp_a2a_loc_part_lead_time',
	      pError_location => 870,
	      pKey_1 => part_no,
	      pKey_2 => loc_sid,
	      pKey_3 => location_name );
	
	   RAISE ;
	
	  END makeDelete ;
	 BEGIN
	      mArgs := 'DeleteLocPartLeadTime(' || part_no || ', ' || loc_sid || ', ' || location_name || ')' ;
	   IF wasPartSent(part_no) THEN
	    INSERT INTO TMP_A2A_LOC_PART_LEAD_TIME
	    (
	     part_no,
	     site_location,
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	      part_no,
	      location_name,
	      Amd_Defaults.DELETE_ACTION,
	      SYSDATE
	    ) ;
	   END IF ;
	   RETURN SUCCESS ;
	
	 EXCEPTION WHEN OTHERS THEN
	 	ErrorMsg(pSqlfunction => 'delete',
	     pTableName => 'tmp_a2a_loc_part_lead_time',
	     pError_location => 880,
	     pKey_1 => part_no,
	     pKey_2 => loc_sid,
	     pKey_3 => location_name );
	
	  RAISE ;
	
	 END DeleteLocPartLeadTime ;
	
	 PROCEDURE initA2ASpoUsers IS
	 		   CURSOR allUsers IS
			   SELECT * FROM AMD_USERS ;
	 BEGIN
	  	  Mta_Truncate_Table('tmp_a2a_spo_users','reuse storage');
	 	  FOR rec IN allUsers LOOP
			  insertTmpA2ASpoUsers(rec.bems_id, rec.stable_email, rec.last_name, rec.first_Name, Amd_Defaults.INSERT_ACTION) ;
		  END LOOP ;
	 END initA2ASpoUsers ;
	 
	 PROCEDURE deleteAllSiteRespAssetMgr IS
	 BEGIN
	   Mta_Truncate_Table('tmp_a2a_site_resp_asset_mgr','reuse storage');
	   FOR rec IN managers LOOP
	     insertSiteRespAssetMgr(assetMgr => rec.planner_code, logonId => rec.logon_id, action_code => Amd_Defaults.DELETE_ACTION,
		 								 data_source => rec.data_source) ;
	   END LOOP ;
	 END deleteAllSiteRespAssetMgr ;
	
	 PROCEDURE initSiteRespAssetMgr IS
	 		   cnt number := 0 ;
			   cntNoUser number := 0 ;
	 BEGIN
	   writeMsg(pTableName => 'tmp_a2a_site_resp_asset_mgr', pError_location => 890,
		pKey1 => 'initSiteRespAssetMgr',
		pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	   Mta_Truncate_Table('tmp_a2a_site_resp_asset_mgr','reuse storage');
	   FOR rec IN managers LOOP
	     cnt := cnt + 1 ;
	     insertSiteRespAssetMgr(assetMgr => rec.planner_code, logonId => rec.logon_id, action_code => Amd_Defaults.INSERT_ACTION,
		 								 data_source => rec.data_source) ;
	   END LOOP ;
	   /*
	   for rec in managersNoUser loop
	   	 cntNoUser := cntNoUser + 1 ;
	     insertSiteRespAssetMgr(assetMgr => rec.planner_code, logonId => rec.logon_id, action_code => Amd_Defaults.INSERT_ACTION,
		 								 data_source => rec.data_source) ;
	   end loop ;
	   */
	   writeMsg(pTableName => 'tmp_a2a_site_resp_asset_mgr', pError_location => 900,
		pKey1 => 'initSiteRespAssetMgr',
		pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
		pKey3 => 'cnt=' || to_char(cnt) ) ;
		-- pKey4 => 'cntNoUser=' || to_char(cntNoUser) ) ; 
	   commit ; 	 
	 END initSiteRespAssetMgr ;
	
	 PROCEDURE insertSiteRespAssetMgr(
	        assetMgr IN TMP_A2A_SITE_RESP_ASSET_MGR.SITE_RESP_ASSET_MGR%TYPE,
	       logonId  IN TMP_A2A_SITE_RESP_ASSET_MGR.TOOL_LOGON_ID%TYPE,
	       action_code IN TMP_A2A_SITE_RESP_ASSET_MGR.action_code%TYPE,
		   data_source in tmp_a2a_site_resp_asset_mgr.data_source%type) IS
		   
		   PROCEDURE doUpdate IS
		   BEGIN
		        UPDATE TMP_A2A_SITE_RESP_ASSET_MGR
		        SET last_update_dt = SYSDATE,
		        action_code = insertSiteRespAssetMgr.action_code,
				data_source = insertSiteRespAssetMgr.data_source
		        WHERE site_resp_asset_mgr = InsertSiteRespAssetMgr.assetMgr
				AND tool_logon_id = insertSiteRespAssetMgr.logonId ;
			EXCEPTION WHEN OTHERS THEN
		       ErrorMsg( pSqlfunction => 'update', pTableName => 'tmp_a2a_site_resp_asset_mgr', pError_location => 910,
		         pkey_1 => assetMgr, pKey_2 => logonId, pKey_3 => data_source) ;
		       RAISE ;
		   
		   END doUpdate ;
	 BEGIN
	   mArgs := 'insertSiteRespAssetMgr(' || assetMgr || ', ' || logonId || ', ' || data_source || ')' ;
	   <<insertTmpA2ASiteRespAssetMgr>>
	   BEGIN
	    INSERT INTO TMP_A2A_SITE_RESP_ASSET_MGR
	    (site_resp_asset_mgr, tool_logon_id, action_code, data_source, last_update_dt)
	    VALUES (assetmgr, logonid, insertSiteRespAssetMgr.action_code, data_source, SYSDATE) ;
	   EXCEPTION
	       WHEN standard.DUP_VAL_ON_INDEX THEN
		   		doUpdate ;
	     WHEN OTHERS THEN
	       ErrorMsg( pSqlfunction => 'insert', pTableName => 'tmp_a2a_site_resp_asset_mgr', pError_location => 920,
	         pkey_1 => assetMgr, pKey_2 => logonId, pKey_3 => data_source) ;
	       RAISE ;
	      END insertTmpA2ASiteRespAssetMgr ;
	
	 EXCEPTION WHEN OTHERS THEN
	    ErrorMsg( pSqlfunction => 'insert', pTableName => 'tmp_a2a_site_resp_asset_mgr', pError_location => 930,
	      pkey_1 => assetMgr, pKey_2 => logonId, pKey_3 => data_source ) ;
		raise ;
	 END insertSiteRespAssetMgr ;
	
	 PROCEDURE doUpdate(part_no IN TMP_A2A_INV_INFO.part_no%TYPE,
	    spo_location IN TMP_A2A_INV_INFO.site_location%TYPE,
	    inv_qty IN TMP_A2A_INV_INFO.QTY_ON_HAND%TYPE,
	    action_code IN TMP_A2A_INV_INFO.action_code%TYPE) IS
	  BEGIN
	     UPDATE TMP_A2A_INV_INFO
	    SET 
	    qty_on_hand = doUpdate.inv_qty,
	    action_code = doUpdate.action_code,
	    last_update_dt = SYSDATE
	    WHERE part_no = doUpdate.part_no
	    AND site_location = doUpdate.spo_location ;
	
	  EXCEPTION WHEN OTHERS THEN
	    ErrorMsg( pSqlfunction => 'select', pTableName => 'tmp_a2a_inv_info', pError_location => 940,
	      pkey_1 => part_no, pKey_2 => spo_location) ;
	    RAISE ;
	
	 END doUpdate ;
	
	 PROCEDURE insertInvInfo(part_no IN TMP_A2A_INV_INFO.part_no%TYPE,
	    spo_location IN TMP_A2A_INV_INFO.site_location%TYPE ,
	    qty_on_hand IN TMP_A2A_INV_INFO.QTY_ON_HAND%TYPE,
	    action_code IN TMP_A2A_INV_INFO.action_code%TYPE)  IS
	
	
	 BEGIN
	  IF wasPartSent(insertInvInfo.part_no)
	     AND spo_location IS NOT NULL THEN
	    INSERT INTO TMP_A2A_INV_INFO
	   (
	    part_no,
	    site_location,
	    qty_on_hand,
	    action_code,
	    last_update_dt
	   )
	   VALUES
	   (
	    insertInvInfo.part_no,
	    insertInvInfo.spo_location,
	    insertInvInfo.qty_on_hand,
	    insertInvInfo.action_code,
	    SYSDATE
	   );
	  END IF ;
	
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	       doUpdate( part_no, spo_location, qty_on_hand, action_code) ;
	  WHEN OTHERS THEN
	     ErrorMsg( pSqlfunction => 'insert', pTableName => 'tmp_a2a_inv_info', pError_location => 950,
	       pkey_1 => part_no, pKey_2 => spo_location) ;
	     RAISE ;
	
	 END insertInvInfo ;
	
	
	PROCEDURE insertRepairInvInfo(part_no IN TMP_A2A_REPAIR_INV_INFO.part_no%TYPE,
	    site_location IN TMP_A2A_REPAIR_INV_INFO.site_location%TYPE,
	    inv_qty IN TMP_A2A_REPAIR_INV_INFO.QTY_ON_HAND%TYPE,
	    action_code IN TMP_A2A_REPAIR_INV_INFO.action_code%TYPE)  IS
	
	 BEGIN
	  IF wasPartSent(insertRepairInvInfo.part_no)
	     AND site_location IS NOT NULL THEN
	    INSERT INTO TMP_A2A_REPAIR_INV_INFO
	   (
	    part_no,
	    site_location,
	    qty_on_hand,
	    action_code,
	    last_update_dt
	   )
	   VALUES
	   (
	    insertRepairInvInfo.part_no,
	    insertRepairInvInfo.site_location,
	    insertRepairInvInfo.inv_qty,
	    insertRepairInvInfo.action_code,
	    SYSDATE
	   );
	  END IF ;
	
	 EXCEPTION
	     WHEN standard.DUP_VAL_ON_INDEX THEN
	    doUpdate( part_no, site_location, inv_qty, action_code) ;
	  WHEN OTHERS THEN
	     ErrorMsg( pSqlfunction => 'insert', pTableName => 'tmp_a2a_repair_inv_info', pError_location => 960,
	       pkey_1 => part_no, pKey_2 => site_location) ;
	     RAISE ;
	
	 END insertRepairInvInfo ;
	 
	
	 FUNCTION getNsiSid(part_no IN VARCHAR2) RETURN VARCHAR2 IS
	    nsisid NUMBER ;
	    result NUMBER ;
	 BEGIN
	   SELECT nsi.nsi_sid INTO nsisid
	   FROM AMD_NATIONAL_STOCK_ITEMS nsi,
	   AMD_SPARE_PARTS asp
	   WHERE asp.part_no = getnsisid.part_no
	   AND asp.nsn = nsi.nsn ;
	
	   RETURN nsisid ;
	
	 EXCEPTION WHEN OTHERS THEN
	    errormsg( psqlfunction => 'select', ptablename => 'amd_national_stock_items', pError_location => 970,
	      pkey_1 => part_no) ;
	    RAISE ;
	
	 END getNsiSid ;
	
	    FUNCTION getTimeToRepair(loc_sid  IN AMD_IN_REPAIR.loc_sid%TYPE,
	             part_no IN VARCHAR2)
	
	    RETURN AMD_PART_LOCS.time_to_repair%TYPE IS
	
	    result NUMBER ;
	
	    time_to_repair AMD_PART_LOCS.time_to_repair%TYPE ;
	    time_to_repair_defaulted AMD_PART_LOCS.time_to_repair_defaulted%TYPE ;
	
	    no_time_to_repair    EXCEPTION ;
	
	    nsisid NUMBER := getnsisid(part_no) ;
	
	 BEGIN
	  <<execSelectTimeToRepair>>
	  BEGIN
	   SELECT time_to_repair, time_to_repair_defaulted
	   INTO time_to_repair, time_to_repair_defaulted
	   FROM AMD_PART_LOCS
	   WHERE nsi_sid = nsisid
	   AND loc_sid = gettimetorepair.loc_sid ;
	
	   IF time_to_repair IS NOT NULL THEN
	    NULL ; -- do nothing use time_to_repair
	   ELSIF time_to_repair_defaulted IS NOT NULL THEN
	       time_to_repair := time_to_repair_defaulted ;
	   ELSE
	    time_to_repair := Amd_Defaults.time_to_repair_onbase ;
	   END IF ;
	
	  EXCEPTION
	   WHEN NO_DATA_FOUND THEN
	     time_to_repair := Amd_Defaults.time_to_repair_onbase ;
	   WHEN OTHERS THEN
	      errormsg( psqlfunction => 'select', ptablename => 'amd_part_locs', pError_location => 980,
	        pkey_1 => part_no, pkey_2 => loc_sid) ;
	    RAISE ;
	
	  END execSelectTimeToRepair ;
	
	  RETURN time_to_repair ;
	
	 END getTimeToRepair ;
	
	 PROCEDURE insertRepairInfo(part_no IN TMP_A2A_REPAIR_INFO.part_no%TYPE,
	    loc_sid IN NUMBER,
	    doc_no IN TMP_A2A_REPAIR_INFO.doc_no%TYPE, 
	    repair_date IN TMP_A2A_REPAIR_INFO.repair_date%TYPE,
	    status IN TMP_A2A_REPAIR_INFO.status%TYPE,
	    quantity IN TMP_A2A_REPAIR_INFO.quantity%TYPE /* repair_qty */,
		expected_completion_date  IN TMP_A2A_REPAIR_INFO.expected_completion_date%TYPE,
	    action_code IN TMP_A2A_REPAIR_INFO.action_code%TYPE)  IS
	
	   site_location TMP_A2A_REPAIR_INFO.site_location%TYPE  := Amd_Utils.getSpoLocation(loc_sid) ;
	
	   /* Not needed in tmp_a2a_repair_info */
	 -- expectedCompletionDate TMP_A2A_REPAIR_INFO.expected_completion_date%TYPE
	       --  := repair_date + gettimetorepair(loc_sid,part_no) ;
	
	  PROCEDURE doUpdate IS
	  BEGIN
	    UPDATE TMP_A2A_REPAIR_INFO
	    SET doc_no = insertRepairInfo.doc_no,
	    status = insertRepairInfo.status,
	    quantity = insertRepairInfo.quantity,
		expected_completion_date = insertRepairInfo.expected_completion_date,
	    action_code = insertRepairInfo.action_code,
	    last_update_dt = SYSDATE
	    WHERE part_no = insertRepairInfo.part_no
		AND doc_no = insertRepairInfo.doc_no 
		AND site_location = insertRepairInfo.site_location
	    AND repair_date = insertRepairInfo.repair_date ;
	
	  EXCEPTION WHEN OTHERS THEN
	     errormsg( psqlfunction => 'update', ptablename => 'tmp_a2a_repair_info', pError_location => 990,
	       pkey_1 => part_no, pkey_2 => loc_sid, pkey_3 => doc_no, pkey_4 => TO_CHAR(repair_date,'MM/DD/YYYY'),pKeywordValuePairs => 'status=' || status || '  qty=' || quantity || ' action=' || action_code) ;
	     RAISE ;
	  END doUpdate ;
	
	  BEGIN
	   -- added isPartValid test DSE 11/30/05
	   IF isPartValid(insertRepairInfo.part_no) AND wasPartSent(insertRepairInfo.part_no)
		  AND doc_no NOT LIKE 'R%'  
		  AND doc_no NOT LIKE 'II%'
		  AND site_location IS NOT NULL 
	   THEN
	    INSERT INTO TMP_A2A_REPAIR_INFO
	   (
	    part_no,
	    site_location,
	    doc_no,
	    repair_date,
	    status,
	    receipt_date,
	    expected_completion_date,
	    quantity,
	    action_code,
	    last_update_dt
	   )
	   VALUES
	   (
	    part_no,
	    site_location,
	    doc_no, 
	    repair_date,
	    insertRepairInfo.status, -- OPEN
	    NULL,
	    expected_completion_date,
	    insertRepairInfo.quantity, -- repair_qty
	    insertRepairInfo.action_code,
	    SYSDATE
	   );
	  END IF ;
	 EXCEPTION
	   WHEN standard.DUP_VAL_ON_INDEX THEN
	       doUpdate ;
	   WHEN OTHERS THEN
	     errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_repair_info', pError_location => 1000,
	 pkey_1 => part_no, pkey_2 => loc_sid, pkey_3 => doc_no, pkey_4 => TO_CHAR(repair_date,'MM/DD/YYYY'),pKeywordValuePairs => 'status=' || status || '  qty=' || quantity || ' action=' || action_code) ;
	     RAISE ;
	 END insertRepairInfo ;
	
	 FUNCTION getDueDate(part_no in AMD_ON_ORDER.PART_NO%TYPE, order_date in AMD_ON_ORDER.ORDER_DATE%TYPE)  RETURN DATE IS
	 
	 		  order_lead_time AMD_SPARE_PARTS.ORDER_LEAD_TIME%TYPE ;
			  order_lead_time_defaulted AMD_SPARE_PARTS.ORDER_LEAD_TIME_DEFAULTED%TYPE ;
			  order_lead_time_cleaned AMD_NATIONAL_STOCK_ITEMS.order_lead_time_cleaned%TYPE ;
	 BEGIN
	      <<getOrderLeadTime>>
	 	  BEGIN
	 	  	   SELECT order_lead_time, order_lead_time_defaulted INTO order_lead_time, order_lead_time_defaulted FROM AMD_SPARE_PARTS WHERE part_no = getDueDate.part_no ;
		  EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		  	   order_lead_time := NULL ;
		  END getOrderLeadTime ;
		  
		  <<getOrderLeadTimeCleaned>>
		  BEGIN
		  	   SELECT order_lead_time_cleaned INTO order_lead_time_cleaned FROM AMD_NATIONAL_STOCK_ITEMS items, AMD_SPARE_PARTS parts WHERE parts.part_no = getDueDate.part_no AND parts.nsn = items.nsn ;
		  EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		  	   order_lead_time_cleaned := NULL ;	   
		  END getOrderLeadTimeCleaned ;
		  
		  RETURN getDueDate.order_date + Amd_Preferred_Pkg.GetPreferredValue(order_lead_time_cleaned, order_lead_time, NVL(order_lead_time_defaulted,1)) ;
	  
	 END getDueDate ;
	
	 FUNCTION includeOrder(gold_order_number IN AMD_ON_ORDER.gold_order_number%TYPE, 
	 		  			  order_date IN AMD_ON_ORDER.order_date%TYPE,
						  part_no in amd_on_order.part_no%type) RETURN BOOLEAN IS
	 
	 	  ON_ORDER_DATES_FILTER_NAME CONSTANT VARCHAR2(14) := 'on_order_dates' ;
	 	  created_order_date DATE ;
		  sched_receipt_date_from DATE ;
		  sched_receipt_date_to DATE ;
		  numberOfCalanderDays NUMBER ;
		  sched_receipt_date AMD_ON_ORDER.SCHED_RECEIPT_DATE%TYPE ;
		  lineOfCode number := 0 ;
		  
		  FUNCTION getSchedReceiptDate  RETURN DATE IS
		  		   sched_receipt_date AMD_ON_ORDER.SCHED_RECEIPT_DATE%TYPE ;
		  BEGIN
		  	   SELECT sched_receipt_date INTO sched_receipt_date
			   FROM AMD_ON_ORDER
			   WHERE AMD_ON_ORDER.GOLD_ORDER_NUMBER =  includeOrder.gold_order_number
			   and amd_on_order.ORDER_DATE = includeOrder.order_date ;
			   RETURN sched_receipt_date ;
		  EXCEPTION 
		  		WHEN standard.NO_DATA_FOUND THEN
		  			 return null ;
		  END getSchedReceiptDate ;
		  
		  --function calculate
	
		  PROCEDURE recordReason (theReason IN VARCHAR2) IS
		  BEGIN	  
			   writeMsg(pTableName => 'tmp_a2a_order_info_line',pError_location => 1010,
			   		pKey1 => 'gold_order_number=' || gold_order_number,
					pKey2 => 'order_date=' || TO_CHAR(order_date,'MM/DD/YYYY HH:MI:SS AM'),
					pKey3 => 'reason=' || theReason) ;
		  END recordReason ;
		  
		  function iif(condition in boolean, truePart in varchar2, falsePart in varchar2) return varchar2 is
		  begin
		  	   if condition then
			   	  return truePart ;
			   else
			   	  return falsePart ;
			   end if ;
		  end iif ;
		  
	 BEGIN
	 	  --IF SUBSTR(gold_order_number,1,2) IN ('AM', 'BA', 'BN', 'BR', 'LB', 'RS', 'SE') THEN
		  --	 RETURN TRUE ; -- include
		  --END IF ;
		  lineOfCode := 1 ;
		  created_order_date := Amd_On_Order_Date_Filters_Pkg.getOrderCreateDate(ON_ORDER_DATES_FILTER_NAME,SUBSTR(gold_order_number,1,2)) ;
		  sched_receipt_date_from := Amd_On_Order_Date_Filters_Pkg.getScheduledReceiptDateFrom(ON_ORDER_DATES_FILTER_NAME,SUBSTR(gold_order_number,1,2)) ;
		  sched_receipt_date_to := Amd_On_Order_Date_Filters_Pkg.getScheduledReceiptDateTo(ON_ORDER_DATES_FILTER_NAME,SUBSTR(gold_order_number,1,2)) ;
		  Amd_On_Order_Date_Filters_Pkg.getScheduledReceiptDateCalDays(ON_ORDER_DATES_FILTER_NAME,SUBSTR(gold_order_number,1,2), numberOfCalanderDays) ;
		  lineOfCode := 2 ;
		  IF created_order_date IS NOT NULL THEN
		  	 IF order_date >= created_order_date THEN
			 	recordReason('order_date >= created_order_date') ;
			 	RETURN FALSE ; -- exclude
			 END IF ;
		  END IF ;
		  lineOfCode := 3 ;
		  IF numberOfCalanderDays IS NOT NULL THEN
		  	 sched_receipt_date := getSchedReceiptDate ;
		  	 IF sched_receipt_date IS NULL then
			 	sched_receipt_date := getDueDate(part_no => part_no, order_date => order_date) ;
			 end if ;
		 	 IF sched_receipt_date > SYSDATE + numberOfCalanderDays THEN
		 	   recordReason('sched_receipt_date > ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') || ' + ' || TO_CHAR(numberOfCalanderDays) ) ; 
			   RETURN FALSE ; -- exclude
			 END IF ;
		 END IF ;
		  lineOfCode := 4 ;
		 IF sched_receipt_date_from IS NOT NULL THEN
		 	IF sched_receipt_date_to IS NOT NULL THEN
			   IF sched_receipt_date_from <= sched_receipt_date_to THEN
			   	  sched_receipt_date := getSchedReceiptDate ;
				  if sched_receipt_date is null then
				  	 sched_receipt_date := getDueDate(part_no => part_no, order_date => order_date) ;
				  end if ;
			   	  IF sched_receipt_date >= sched_receipt_date_from AND sched_receipt_date <= sched_receipt_date_to THEN
				  	 RETURN TRUE ; -- include
				  ELSE
			 	     recordReason('sched_receipt_date NOT BETWEEN sched_receipt_date_from AND sched_receipt_date_to') ; 
				  	 RETURN FALSE ; -- exclude
				  END IF ;
			   END IF ;
			END IF ;
	     END IF ;
		 
		 RETURN TRUE ; -- include
	 exception when others then
	 	 dbms_output.put_line('includeOrder: lineOfCode=' || lineOfCode) ;
	     errormsg( psqlfunction => 'select', ptablename => 'amd_on_order', pError_location => 1020,
	 	 		   pkey_1 => gold_order_number, pkey_2 => to_char(order_date,'MM/DD/YYYY'), 
				   pkey_3 => part_no,
				   pKey_4 => iif(sched_receipt_date is null,'NULL',to_char(sched_receipt_date,'MM/DD/YYYY')), 
				   pKeywordValuePairs => 'numberOfCalanderDays=' || iif(numberOfCalanderDays is NULL,'NULL',to_char(numberOfCalanderDays)) ) ; /* 
				   		|| ' sched_receipt_date_from=' || iif(sched_receipt_date_from is NULL,'NULL',to_char(sched_receipt_date_from,'MM/DD/YYYY')) 
						|| ' sched_receipt_date_to=' || iif(sched_receipt_date_to is NULL,'NULL',to_char(sched_receipt_date_to,'MM/DD/YYYY'))
						|| ' created_order_date=' || iif(created_order_date is NULL,'NULL',to_char(created_order_date,'MM/DD/YYYY')) ) ; */
	     RAISE ;
	 
	 END includeOrder ;
	 
	
	
	
	 PROCEDURE insertTmpA2AOrderInfo(gold_order_number IN AMD_ON_ORDER.GOLD_ORDER_NUMBER%TYPE,
	     loc_sid IN AMD_ON_ORDER.LOC_SID%TYPE,
	     order_date IN AMD_ON_ORDER.ORDER_DATE%TYPE,
	     part_no IN AMD_ON_ORDER.PART_NO%TYPE,
	     order_qty IN AMD_ON_ORDER.ORDER_QTY%TYPE,
		 sched_receipt_date IN AMD_ON_ORDER.SCHED_RECEIPT_DATE%TYPE,
	     action_code IN TMP_A2A_ORDER_INFO.action_code%TYPE) IS
	
	   	 site_location TMP_A2A_ORDER_INFO_LINE.SITE_LOCATION%TYPE := Amd_Utils.getSpoLocation(loc_sid) ;
		 lineNumber NUMBER := 0 ;
		 current_created_date TMP_A2A_ORDER_INFO.CREATED_DATE%TYPE := NULL ;
		 lineOfCode number := 0 ;
		 
		 cage_code TMP_A2A_ORDER_INFO.cage_code%TYPE := Amd_Utils.getCageCode(part_no) ;
	
		PROCEDURE insertTmpA2AOrderInfoLine(action_code in tmp_a2a_order_info_line.ACTION_CODE%type) IS
		
			 due_date TMP_A2A_ORDER_INFO_LINE.DUE_DATE%TYPE ;
			 
			 
			 PROCEDURE doUpdate IS
			 BEGIN
			 		UPDATE TMP_A2A_ORDER_INFO_LINE
					SET 
					    loc_sid = insertTmpA2AOrderInfo.loc_sid,
					    site_location = insertTmpA2AOrderInfo.site_location,
					    qty_ordered = insertTmpA2AOrderInfo.order_qty,
					    action_code = insertTmpA2AOrderInfoLine.action_code,
					    last_update_dt = SYSDATE,
						due_date = insertTmpA2AOrderInfoLine.due_date,
						line = lineNumber
					WHERE order_no = insertTmpA2AOrderInfo.gold_order_number
					AND part_no = insertTmpA2AOrderInfo.part_no
					AND created_date = insertTmpA2AOrderInfo.order_date ;
			  
			 EXCEPTION WHEN OTHERS THEN
			     errormsg( psqlfunction => 'update', ptablename => 'tmp_a2a_order_info_line', pError_location => 1030,
			       pkey_1 => gold_order_number) ;
			     RAISE ;
			 END doUpdate ;
		 
			 FUNCTION getNextLineNumber RETURN NUMBER IS
			 		  result NUMBER := 1 ;
			 BEGIN
			 	  SELECT MAX(line) INTO result
				  FROM TMP_A2A_ORDER_INFO_LINE
				  WHERE order_no = insertTmpA2AOrderInfo.gold_order_number
				  AND part_no = insertTmpA2AOrderInfo.part_no ;
				  IF result IS NULL THEN
				  	 RETURN 1 ;
				  ELSE		
				  			RETURN result + 1 ;
				  END IF ;
			 EXCEPTION 
			 		   WHEN standard.NO_DATA_FOUND THEN
			 	  	   		RETURN 1 ;
					   WHEN OTHERS THEN
					     errormsg( psqlfunction => 'select', ptablename => 'tmp_a2a_order_info_line', pError_location => 1040,
					       pkey_1 => gold_order_number, pKey_2 => part_no, pKey_3 => TO_CHAR(order_date,'MM/DD/YYYY HH:MI:SS AM'), pKey_4 => TO_CHAR(lineNumber)) ;
					     RAISE ;			   
			 END getNextLineNumber ;
		 
		BEGIN
			  IF sched_receipt_date IS NULL THEN
			   	 due_date := getDueDate(part_no => insertTmpA2AOrderInfo.part_no, order_date => insertTmpA2AOrderInfo.order_date) ;
			  ELSE
			  	 due_date := sched_receipt_date ;
			  END IF ;
			  
			  lineNumber := getNextLineNumber ;
			  
			  INSERT INTO TMP_A2A_ORDER_INFO_LINE
			 (
			  order_no,
			  part_no,
			  loc_sid,
			  site_location,
			  created_date,
			  status,
			  line,
			  qty_ordered,
			  qty_received,
			  action_code,
			  last_update_dt,
			  due_date
			 )
			 VALUES
			 (
			  gold_order_number,
			  part_no,
			  loc_sid,
			  site_location,
			  order_date,
			  'O',
			  lineNumber,
			  order_qty,
			  0,
			  insertTmpA2AOrderInfoLine.action_code,
			  SYSDATE,
			  due_date
			 );
			 COMMIT ;
		EXCEPTION
			  WHEN standard.DUP_VAL_ON_INDEX THEN
			 doUpdate ;
			 
			  WHEN OTHERS THEN
			     errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_order_info_line', pError_location => 1050,
			       pkey_1 => gold_order_number) ;
			     RAISE ;
		END insertTmpA2aOrderInfoLine ;
		
		PROCEDURE doUpdate(action_code in tmp_a2a_order_info.action_code%type) IS
		 BEGIN
		   UPDATE TMP_A2A_ORDER_INFO
		   SET
		   cage_code = insertTmpA2AOrderInfo.cage_code, 
		   loc_sid = insertTmpA2AOrderInfo.loc_sid,
		   site_location = insertTmpA2AOrderInfo.site_location,
		   created_date = insertTmpA2AOrderInfo.order_date,
		   status = 'O',
		   action_code = doUpdate.action_code,
		   last_update_dt = SYSDATE
		   WHERE order_no = insertTmpA2AOrderInfo.gold_order_number 
		AND part_no = insertTmpA2AOrderInfo.part_no ;
		 EXCEPTION WHEN OTHERS THEN
		    errormsg( psqlfunction => 'update', ptablename => 'tmp_a2a_order_info', pError_location => 1060,
		      pkey_1 => gold_order_number) ;
		    RAISE ;
		 END doUpdate ;
		 
		 PROCEDURE doInsert(action_code in tmp_a2a_order_info.action_code%type) IS
		 BEGIN
			    INSERT INTO TMP_A2A_ORDER_INFO
			   (
			    order_no,
			    part_no,
				cage_code,
			    loc_sid,
			    site_location,
			    created_date,
			    status,
			    action_code,
			    last_update_dt
			   )
			   VALUES
			   (
			    gold_order_number,
			    part_no,
				insertTmpA2AOrderInfo.cage_code,
			    loc_sid,
			    site_location,
			    order_date,
			    'O',
			    doInsert.action_code,
			    SYSDATE
			   );
			
			EXCEPTION
			  WHEN standard.DUP_VAL_ON_INDEX THEN
			    doUpdate(doInsert.action_code) ; -- update with the most recent order date
			  WHEN OTHERS THEN 
			    errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_order_info', pError_location => 1070,
			      pkey_1 => gold_order_number) ;
			    RAISE ;
			  
		 END doInsert ;
		 
	
	 BEGIN
		   lineOfCode := 1 ;
		   IF wasPartSent(insertTmpA2AOrderInfo.part_no) AND site_location IS NOT NULL THEN
			lineOfCode := 2 ; 
			IF includeOrder(gold_order_number => gold_order_number,order_date => order_date,
							part_no => insertTmpA2AOrderInfo.part_no) THEN
				lineOfCode := 3 ;
				includeCnt := includeCnt + 1 ;
				declare
					   sent_action_code amd_sent_to_a2a.action_code%type  ;
					   theAction tmp_a2a_order_info_line.action_code%type ;
				begin
					 select action_code into sent_action_code from amd_sent_to_a2a where part_no = insertTmpA2AOrderInfo.part_no ;
					 -- a deleted order should be deleted from the SPO
					 -- a part that has been deleted from SPO should have its order deleted too
					 if insertTmpA2AOrderInfo.action_code = amd_defaults.DELETE_ACTION or sent_action_code = amd_defaults.DELETE_ACTION then
					 	theAction := amd_defaults.DELETE_ACTION ; 
					 else
					 	 theAction := insertTmpA2AOrderInfo.action_code ; 
					 end if ;						
					 doInsert(theAction) ; 
		 			 insertTmpA2AOrderInfoLine(theAction) ;
				end ;
			ELSE
			    lineOfCode := 4 ;
				excludeCnt := excludeCnt + 1 ;
				doInsert(amd_defaults.DELETE_ACTION) ; -- always set the action code to delete for execluded tmp_a2a_Order_Info
				insertTmpA2AOrderInfoLine(amd_defaults.DELETE_ACTION) ;
			    writeMsg(pTableName => 'tmp_a2a_order_info_line',pError_location => 1080,
			   		pKey1 => 'gold_order_number=' || gold_order_number,
					pKey2 => 'part_no= ' || insertTmpA2AOrderInfo.part_no,
					pKey3 => 'site_location= ' || insertTmpA2AOrderInfo.site_location,
					pKey4 => 'order_date=' || TO_CHAR(insertTmpA2AOrderInfo.order_date,'MM/DD/YYYY HH:MI:SS AM'),
					pData => 'excluded') ;
			END IF ;
				
		  END IF ;
		 
	 EXCEPTION
		   WHEN OTHERS THEN
			  dbms_output.put_line('insertTmpA2AOrderInfo: lineNumber=' || nvl(lineNumber,9999) || ' lineOfCode=' || nvl(lineOfCode,9999) ) ; 
		      errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_order_info', pError_location => 1090,
		        pkey_1 => 'gold_order_number=' || to_char(Nvl(gold_order_number,0)),
				pKey_2 => 'part_no=' || insertTmpA2AOrderInfo.part_no,
				pKey_3 => 'site_location=' || insertTmpA2AOrderInfo.site_location,
				pKey_4 => 'order_date=' || TO_CHAR(insertTmpA2AOrderInfo.order_date,'MM/DD/YYYY HH:MI:SS AM'),
				pKeywordValuePairs => 'lineNumber=' || TO_CHAR(NVL(lineNumber,0)) || ' lineOfCode=' || to_char(lineOfCode) || ' action_code=' || action_code ) ;
		      RAISE ;
	 END insertTmpA2AOrderInfo ;
	
	
	 PROCEDURE insertTmpA2AInTransits(part_no IN AMD_IN_TRANSITS_SUM.part_no%TYPE,
	   site_location     IN AMD_IN_TRANSITS_SUM.site_location%TYPE,
	   quantity      IN AMD_IN_TRANSITS_SUM.quantity%TYPE,
	   serviceable_flag  IN AMD_IN_TRANSITS_SUM.serviceable_flag%TYPE,
	   action_code   IN TMP_A2A_IN_TRANSITS.action_code%TYPE) IS
	
	 -- site_location TMP_A2A_IN_TRANSITS.site_location%TYPE := Amd_Utils.getSpoLocation(to_loc_sid) ;
	    -- added doUpdate DSE 11/30/05
	 	PROCEDURE doUpdate IS
		BEGIN
			 UPDATE TMP_A2A_IN_TRANSITS
			 SET
			     qty = insertTmpA2AInTransits.quantity,
			     action_code = insertTmpA2AInTransits.action_code,
			     last_update_dt = SYSDATE
			WHERE part_no = insertTmpA2AInTransits.part_no
			AND site_location = insertTmpA2AInTransits.site_location 
			AND TYPE = insertTmpA2AInTransits.serviceable_flag ;
			
		EXCEPTION WHEN OTHERS THEN
	      errormsg( psqlfunction => 'update', ptablename => 'tmp_a2a_in_transits', pError_location => 1100,
	        pkey_1 => insertTmpA2AInTransits.part_no, pKey_2 => insertTmpA2AInTransits.site_location,
			pkey_3 => insertTmpA2AInTransits.serviceable_flag) ;
	      RAISE ;	
		END doUpdate ;
	
	 BEGIN
	  IF quantity > 0 
	  AND wasPartSent(insertTmpA2AInTransits.part_no)
	  AND isPartValid(insertTmpA2AInTransits.part_no) -- added isPartValid DSE 11/30/05 
	  AND site_location IS NOT NULL  THEN
	    INSERT INTO TMP_A2A_IN_TRANSITS
	    (
	     part_no,
	     site_location,
	     qty,
	     TYPE,
	     action_code,
	     last_update_dt
	    )
	    VALUES
	    (
	     insertTmpA2AInTransits.part_no,
	     insertTmpA2AInTransits.site_location,
	     insertTmpA2AInTransits.quantity,
	     insertTmpA2AInTransits.serviceable_flag,
	     insertTmpA2AInTransits.action_code,
	     SYSDATE
	    ) ;
	  END IF ;
	  -- added exception handlers DSE 11/30/05
	 EXCEPTION
	 		  WHEN standard.DUP_VAL_ON_INDEX THEN
			  	   doUpdate ;
			  WHEN OTHERS THEN 
			      errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_in_transits', pError_location => 1110,
			        pkey_1 => insertTmpA2AInTransits.part_no, pKey_2 => insertTmpA2AInTransits.site_location) ;
			      RAISE ;
			  	   
	 END insertTmpA2AInTransits ;
	
	
	 PROCEDURE spoUser(bems_id IN TMP_A2A_SPO_USERS.BEMS_ID%TYPE,
	  action_code IN TMP_A2A_SPO_USERS.ACTION_CODE%TYPE) IS
	
	  spoUserUpdateError EXCEPTION ;
	
	
	
	 BEGIN
	
	
	  <<insertA2A>>
	  BEGIN
	
	   INSERT INTO TMP_A2A_SPO_USERS
	   (BEMS_ID,  ACTION_CODE, LAST_UPDATE_DT)
	   VALUES (spoUser.bems_id, spoUser.action_code, SYSDATE) ;
	
	  EXCEPTION
	   WHEN standard.DUP_VAL_ON_INDEX THEN
	     NULL ; -- ignore
	   WHEN OTHERS THEN
	    errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_spo_users', pError_location => 1120,
	        pkey_1 => bems_id) ;
	    RAISE ;
	  END insertA2A ;
	
	
	 END spoUser ;
	
	 PROCEDURE insertTmpA2ASpoUsers(bems_id IN TMP_A2A_SPO_USERS.bems_id%TYPE,
	       stable_email     IN TMP_A2A_SPO_USERS.EMAIL%TYPE,
	       last_name      IN VARCHAR2,
	       first_name  IN VARCHAR2,
	       action_code   IN TMP_A2A_IN_TRANSITS.action_code%TYPE) IS
		   
		   PROCEDURE doUpdate IS
		   			 theEmail TMP_A2A_SPO_USERS.email%TYPE ;
					 theName TMP_A2A_SPO_USERS.name%TYPE ;
					 debugIt BOOLEAN := A2a_Pkg.mDebug ; -- save current debug settings
		   BEGIN
		   		SELECT email, name INTO theEmail, theName FROM TMP_A2A_SPO_USERS WHERE bems_id = insertTmpA2ASpoUsers.bems_id ;
				A2a_Pkg.mDebug := TRUE ; -- always record the before and after
				debugMsg(msg => 'before update bems_id = ' || bems_id || 'email= ' || theEmail || 'last_name=' || theName, lineNo => 180) ;
				
		   		UPDATE TMP_A2A_SPO_USERS
				SET email = SUBSTR(insertTmpA2ASpoUsers.stable_email,1,32),
				name = SUBSTR(last_name || ', ' || first_name,1,32),
				action_code = insertTmpA2ASpoUsers.action_code,
				last_update_dt = SYSDATE
				WHERE bems_id = insertTmpA2ASpoUsers.bems_id ;
				
				debugMsg(msg => 'after update bems_id = ' || bems_id || 'email= ' || SUBSTR(stable_email,1,32) || 'last_name=' || SUBSTR(last_name || ', ' || first_name,1,32), lineNo => 190) ;
				A2a_Pkg.mDebug := debugIt ; -- restore
				
		   EXCEPTION WHEN OTHERS THEN
			    errormsg( psqlfunction => 'update', ptablename => 'tmp_a2a_spo_users', pError_location => 1130,
			        pkey_1 => bems_id) ;
			    RAISE ;
		   END doUpdate ;
		   
	 BEGIN
	 	  INSERT INTO TMP_A2A_SPO_USERS
		  (bems_id, email, NAME, action_code, last_update_dt)
		  VALUES(bems_id, SUBSTR(stable_email,1,32), SUBSTR(last_name || ', ' || first_name,1,32), action_code, SYSDATE) ;
	 EXCEPTION
	 		  WHEN standard.DUP_VAL_ON_INDEX THEN
			  	   doUpdate ;
			  WHEN OTHERS THEN
				    errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_spo_users', pError_location => 1140,
				        pkey_1 => bems_id) ;
				    RAISE ;
			  
	 END insertTmpA2ASpoUsers ;
	
	
	  FUNCTION getAssignedPlannerCode(part_no IN TMP_A2A_PART_INFO.part_no%TYPE,
	 		  planner_code IN AMD_PLANNERS.planner_code%TYPE) RETURN AMD_PLANNERS.planner_code%TYPE  IS
			  
			  plannerCode AMD_PLANNERS.planner_code%TYPE ;
			  
	  BEGIN
		IF isPlannerCodeAssigned2UserId(planner_code) THEN
			  plannerCode := planner_code ;
		ELSE
		   IF isNsl(part_no) THEN
			  	 plannerCode := Amd_Defaults.NSL_PLANNER_CODE ;
		  ELSE
			 plannerCode := Amd_Defaults.NSN_PLANNER_CODE ;
		   END IF ;
		   debugMsg('For part ' || part_no || ' planner_code ' || planner_code || ' is not assigned to a users.  Using default of ' || plannerCode, 200) ; 
		END IF ;
		
		RETURN plannerCode ;
		
	  END getAssignedPlannerCode ;
	
	  FUNCTION wasPartSentYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 IS 
	  BEGIN
	  	   IF wasPartSent(partNo) THEN
		   	 RETURN 'Y' ;
		   ELSE
		     RETURN 'N' ;
		   END IF ;
	  END wasPartSentYorN ;
	  
	  FUNCTION isPartValidYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE, showReason in varchar2 := 'N') RETURN VARCHAR2 IS
	  		   showReasonBool boolean := false ;
	  BEGIN
	  	   if showReason <> 'N' then
		  	   if upper(substr(showReason,1,1)) = 'Y' then
			   	  showReasonBool := true ;
			   end if ;
		   end if ;
	  	   IF isPartValid(partNo, showReason => showReasonBool) THEN
		       RETURN 'Y' ;
		   ELSE
		       RETURN 'N' ;
		   END IF ;
	  END isPartValidYorN ;
	  
	  FUNCTION isPlannerCodeAssign2UserIdYorN(plannerCode IN VARCHAR2) RETURN VARCHAR2 IS
	  BEGIN
	  	   IF isPlannerCodeAssigned2UserId(plannerCode) THEN
		     RETURN 'Y' ;
		   ELSE
		     RETURN 'N' ;
		   END IF ;
	  END isPlannerCodeAssign2UserIdYorN ;
	  
	  PROCEDURE deleteInvalidParts (testOnly IN BOOLEAN := FALSE) IS
		  CURSOR sentParts IS
		  SELECT part_no FROM AMD_SENT_TO_A2A
		  WHERE action_code != Amd_Defaults.DELETE_ACTION
		  AND spo_prime_part_no IS NOT NULL ;
		  
		  nomenclature AMD_SPARE_PARTS.NOMENCLATURE%TYPE ;
		  rc NUMBER ;
		  cnt NUMBER := 0 ;
	  			
	  BEGIN
	  	   writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 1150,
			pKey1 => 'deleteInvalidParts',
			pKey2 => 'testOnly=' || Amd_Utils.boolean2Varchar2(testOnly),
			pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	  	   FOR rec IN sentParts LOOP
		   	   IF NOT isPartValid(rec.part_no)  THEN
			   	  SELECT nomenclature INTO nomenclature FROM AMD_SPARE_PARTS WHERE part_no = rec.part_no ;
				  IF NOT testOnly THEN
				   	  rc := A2a_Pkg.DeletePartInfo(rec.part_no,nomenclature) ;
					  UPDATE AMD_SENT_TO_A2A
					  SET action_code = Amd_Defaults.DELETE_ACTION,
					  transaction_date = SYSDATE
					  WHERE part_no = rec.part_no ; 
				  END IF ;
				  cnt := cnt + 1 ;
				  debugMsg('part ' || rec.part_no || ' to be deleted from the spo via an a2a transaction.', 210) ;			  
			   END IF ;
		   END LOOP ;
	  	   writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 1160,
			pKey1 => 'deleteInvalidParts',
			pKey2 => 'testOnly=' || Amd_Utils.boolean2Varchar2(testOnly),
			pKey3 => 'cnt=' || TO_CHAR(cnt),
			pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		   COMMIT ;  	 
	  END deleteInvalidParts ;
	
	PROCEDURE populateBomDetail(part_no IN TMP_A2A_BOM_DETAIL.part_no%TYPE,
			  included_part IN TMP_A2A_BOM_DETAIL.INCLUDED_PART%TYPE,
			  action_code IN TMP_A2A_BOM_DETAIL.action_code%TYPE,
			  quantity IN TMP_A2A_BOM_DETAIL.QUANTITY%TYPE := Amd_Defaults.BOM_QUANTITY,
			  bom IN TMP_A2A_BOM_DETAIL.BOM%TYPE := Amd_Defaults.BOM,
			  begin_date IN TMP_A2A_BOM_DETAIL.BEGIN_DATE%TYPE := NULL,
			  end_date IN TMP_A2A_BOM_DETAIL.end_date%TYPE := NULL) IS
			  
			  PROCEDURE doUpdate IS
			  BEGIN
			 	  UPDATE TMP_A2A_BOM_DETAIL
				  SET action_code = populateBomDetail.action_code,
				  last_update_dt = SYSDATE
				  WHERE part_no = populateBomDetail.part_no ; 
			  EXCEPTION WHEN OTHERS THEN
			    errormsg( psqlfunction => 'update', ptablename => 'tmp_a2a_bom_detail', pError_location => 1170,
			        pkey_1 => populateBomDetail.part_no, pkey_2 => populateBomDetail.included_part) ;
				RAISE ;
			  END doUpdate ;
		BEGIN
			 IF part_no IS NOT NULL THEN
				 INSERT INTO TMP_A2A_BOM_DETAIL
				 (part_no, included_part, quantity, bom, begin_date, end_date, action_code, last_update_dt)
				 VALUES
				 (populateBomDetail.part_no, populateBomDetail.included_part, 
				 	populateBomDetail.quantity, populateBomDetail.bom, 
					populateBomDetail.begin_date, populateBomDetail.end_date,
					populateBomDetail.action_code,SYSDATE) ;
			END IF ;
		EXCEPTION
			 WHEN standard.DUP_VAL_ON_INDEX THEN
			 	  doUpdate ;
		     WHEN OTHERS THEN
			    errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_bom_detail', pError_location => 1180,
			        pkey_1 => populateBomDetail.part_no, pkey_2 => populateBomDetail.included_part) ;
			    RAISE ;		 
		END populateBomDetail ; 
	
	  PROCEDURE processPart(rec IN AMD_SENT_TO_A2A%ROWTYPE) IS
	  BEGIN
	  	   populateBomDetail(part_no => rec.spo_prime_part_no,
		   	 included_part => rec.spo_prime_part_no,
			 action_code => rec.action_code) ;
	  END processPart ; 
	
	 PROCEDURE processBomDetail(bomDetail IN bomDetailCur) IS
	 		   cnt NUMBER := 0 ;
			   rec AMD_SENT_TO_A2A%ROWTYPE ;
	 BEGIN
	  	  writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1190,
			pKey1 => 'processBomDetail',
			pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	 	  LOOP
		  	  FETCH bomDetail INTO rec ;
			  EXIT WHEN bomDetail%NOTFOUND ;
			  IF rec.spo_prime_part_no IS NOT NULL THEN
				  processPart(rec) ;
				  cnt := cnt + 1 ;
				  IF MOD(cnt,commit_threshold) = 0 THEN
					 COMMIT ;
				  END IF ;
			  END IF ;
		  END LOOP ;
	  	  writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1200,
			pKey1 => 'processBomDetail',
			pKey2 => 'cnt=' || TO_CHAR(cnt),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
		  COMMIT ;
	 END processBomDetail ;
	 
	 PROCEDURE initA2ABomDetail(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE ) IS
		  partsByDate bomDetailCur ;
		  cnt NUMBER := 0 ;
		BEGIN
	  	  writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1210,
			pKey1 => 'initA2ABomDetail',
			pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
			pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
			pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	   	  Mta_Truncate_Table('tmp_a2a_bom_detail','reuse storage');
		  mblnSendAllData := TRUE ;
		  OPEN partsByDate FOR
			  SELECT *
			  FROM AMD_SENT_TO_A2A 
			  WHERE 
			  TRUNC(transaction_date) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
			  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
		 processBomDetail(partsByDate) ;
		 CLOSE partsByDate ; 
	  	  writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1220,
			pKey1 => 'initA2ABomDetail',
			pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
			pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
			pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;  	 
		END initA2ABomDetail ;
		
		PROCEDURE initA2ABomDetail(useTestParts IN BOOLEAN := FALSE) IS
		  parts bomDetailCur ;
		   
		BEGIN
	  	  writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1230,
			pKey1 => 'initA2ABomDetail',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	   	  Mta_Truncate_Table('tmp_a2a_bom_detail','reuse storage');
		  mblnSendAllData := TRUE ;
		  IF useTestParts THEN
		    OPEN parts FOR
			  SELECT *
			  FROM AMD_SENT_TO_A2A 
			  WHERE part_no IN (SELECT part_no FROM AMD_TEST_PARTS) 
		  	  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
		  ELSE
		    OPEN parts FOR
			  SELECT *
			  FROM AMD_SENT_TO_A2A WHERE
		  	  part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL);
		  END IF ;
		  processBomDetail(parts) ;
		  CLOSE parts ;		
	  	  writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1240,
			pKey1 => 'initA2ABomDetail',
			pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
			pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;  	 
		END initA2ABomDetail ;
	
		PROCEDURE processBackorder(rec IN AMD_BACKORDER_SUM%ROWTYPE, site_location IN TMP_A2A_BACKORDER_INFO.site_location%TYPE) IS
		   PROCEDURE doUpdate IS
		   BEGIN
		  	   UPDATE TMP_A2A_BACKORDER_INFO
			   SET qty = rec.qty,
			   action_code = rec.action_code,
			   last_update_dt = rec.last_update_dt
			   WHERE part_no = rec.part_no
			   AND site_location = processBackorder.site_location
			   AND loc_sid = rec.loc_sid ;
		   EXCEPTION WHEN OTHERS THEN
			    errormsg( psqlfunction => 'update', ptablename => 'tmp_a2a_backorder_info', pError_location => 1250,
			        pkey_1 => rec.part_no, pkey_2 => TO_CHAR(rec.loc_sid), pkey_3 => site_location) ;
		   		RAISE ;
		   END doUpdate ;
		   
		   FUNCTION getSpoPrimePartNo(part_no AMD_SENT_TO_A2A.part_no%TYPE) RETURN AMD_SENT_TO_A2A.SPO_PRIME_PART_NO%TYPE IS
		   			spo_prime_part_no AMD_SENT_TO_A2A.SPO_PRIME_PART_NO%TYPE ;
		   BEGIN
		   		SELECT DISTINCT spo_prime_part_no INTO spo_prime_part_no 
				FROM AMD_SENT_TO_A2A
				WHERE part_no = getSpoPrimePartNo.part_no ;
				RETURN spo_prime_part_no ;
		   END getSpoPrimePartNo ;
		   
		BEGIN
			INSERT INTO TMP_A2A_BACKORDER_INFO
				(part_no, loc_sid, site_location,qty, action_code, last_update_dt)
				VALUES
				(rec.part_no, rec.loc_sid, site_location, rec.qty, rec.action_code, rec.last_update_dt);
		EXCEPTION 
			WHEN standard.DUP_VAL_ON_INDEX THEN
				doUpdate ;
			WHEN OTHERS THEN
			    errormsg( psqlfunction => 'insert', ptablename => 'tmp_a2a_backorder_info', pError_location => 1260,
			        pkey_1 => rec.part_no, pkey_2 => TO_CHAR(rec.loc_sid), pkey_3 => site_location) ;
				RAISE ;
		END processBackorder ;
	    PROCEDURE processBackOrder(backOrder IN backOrderCur) IS
				  cnt NUMBER := 0 ;
				  rec AMD_BACKORDER_SUM%ROWTYPE ;
		 		  site_location TMP_A2A_BACKORDER_INFO.site_location%TYPE ;
		BEGIN
		  	 writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1270,
				pKey1 => 'processBackOrder',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
			 LOOP
			 	 FETCH backOrder INTO rec ;
				 EXIT WHEN backOrder%NOTFOUND ;
			  	 site_location := Amd_Utils.getSpoLocation(rec.loc_sid) ;
				 IF site_location IS NOT NULL THEN
			  	  	 processBackorder(rec, site_location) ;
					 cnt := cnt + 1 ;
					 IF MOD(cnt,commit_threshold) = 0 THEN
						 COMMIT ;
					 END IF ;
				 END IF ;
			 END LOOP ;
		  	 writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1280,
				pKey1 => 'processBackOrder',
				pKey2 => 'cnt=' || TO_CHAR(cnt),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
			 COMMIT ;
		END processBackOrder ;
		
	 	PROCEDURE initA2ABackorderInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE ) IS
		  
		  backOrdersByDate backOrderCur ;
		  
		BEGIN
		  	 writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1290,
				pKey1 => 'initA2ABackorderInfo',
				pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	   	  Mta_Truncate_Table('tmp_a2a_backorder_info','reuse storage');
		  mblnSendAllData := TRUE ;
		  OPEN backOrdersByDate FOR
			  SELECT
				  bo.PART_NO,         
				  bo.LOC_SID,         
				  QTY,
				  case bo.action_code
				  	   when amd_defaults.getDELETE_ACTION then
					   		bo.action_code             
				  	   else
					   	   sent.ACTION_CODE
				  end action_code,    
				  LAST_UPDATE_DT 		  
			  FROM AMD_BACKORDER_SUM bo, amd_sent_to_a2a sent 
			  WHERE 
			  TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
		  	  AND bo.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null ;
			  
		  processBackOrder(backOrdersByDate) ;
		  CLOSE backOrdersByDate ;	  
		  writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1300,
				pKey1 => 'initA2ABackorderInfo',
				pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
		  COMMIT ;
		END initA2ABackorderInfo ;
	
	 	PROCEDURE initA2ABackorderInfo(useTestParts IN BOOLEAN := FALSE ) IS
		  parts backOrderCur ;
		  useTestPartsString VARCHAR2(5) := 'False' ;
		BEGIN
		  writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1310,
				pKey1 => 'initA2ABackorderInfo',
				pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
				pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  	 
	   	  Mta_Truncate_Table('tmp_a2a_backorder_info','reuse storage');
		  mblnSendAllData := TRUE ;
		  IF useTestParts THEN
		  	 OPEN parts FOR
			  SELECT 
				  bo.PART_NO,         
				  LOC_SID,         
				  QTY,             
				  case bo.action_code
				  	   when amd_defaults.getDELETE_ACTION then
					   		bo.action_code
					   else    
					   		sent.ACTION_CODE
				  end action_code,
				  LAST_UPDATE_DT 		  
			  FROM AMD_BACKORDER_SUM bo, amd_sent_to_a2a sent, amd_test_parts testParts 
			  WHERE 
			  bo.part_no = testParts.part_no 
		  	  AND bo.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null ;
			  
		  	  useTestPartsString := 'True' ;
		  ELSE
		  	  OPEN parts FOR
			  SELECT 
				  bo.PART_NO,         
				  LOC_SID,         
				  QTY,
				  case bo.action_code
				  	   when amd_defaults.getDELETE_ACTION then
					   		bo.action_code
					   else             
				  	   		sent.ACTION_CODE
				  end action_code,    
				  LAST_UPDATE_DT 		  
			  FROM AMD_BACKORDER_SUM bo, amd_sent_to_a2a sent
			  WHERE bo.part_no = sent.part_no
			  and sent.SPO_PRIME_PART_NO is not null ;
			  
		  END IF ;
		  processBackOrder(parts) ;
		  CLOSE parts ;
		  writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1320,
				pKey1 => 'initA2ABackorderInfo',
				pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		  COMMIT ;  	 
		END initA2ABackorderInfo ;
	
		PROCEDURE loadAll(startStep IN NUMBER := 1, endStep IN NUMBER := 15, debugIt IN BOOLEAN := FALSE, system_id IN AMD_BATCH_JOBS.SYSTEM_ID%TYPE := 'LOAD_ALL_A2A') IS
				  rc NUMBER := 0 ;
				  SPO_USERS CONSTANT VARCHAR2(9) := 'SPO_USERS' ;
				  RESP_ASSET_MGR CONSTANT VARCHAR2(14) := 'RESP_ASSET_MGR' ;
				  PART_INFO CONSTANT VARCHAR2(9) := 'PART_INFO' ;
				  ORDER_INFO CONSTANT VARCHAR2(10) := 'ORDER_INFO' ;
				  REPAIR_INFO CONSTANT VARCHAR2(11) := 'REPAIR_INFO' ; 
				  IN_TRANSITS CONSTANT VARCHAR2(11) := 'IN_TRANSITS' ; 
				  INV_INFO CONSTANT VARCHAR2(8) := 'INV_INFO' ;
				  REPAIR_INV_INFO CONSTANT VARCHAR2(15) := 'REPAIR_INV_INFO' ;
				  BACKORDER_INFO CONSTANT VARCHAR2(14) := 'BACKORDER_INFO' ;
				  LOC_PART_LEAD_TIME CONSTANT VARCHAR2(18) := 'LOC_PART_LEAD_TIME' ;
				  LOC_PART_OVERRIDE CONSTANT VARCHAR2(17) := 'LOC_PART_OVERRIDE' ;
				  BOM_DETAIL CONSTANT VARCHAR2(10) := 'BOM_DETAIL' ;
				  EXT_FORECAST CONSTANT VARCHAR2(12) := 'EXT_FORECAST' ;
				  PART_FACTORS CONSTANT VARCHAR2(12) := 'PART_FACTORS' ;
				  DEMANDS CONSTANT VARCHAR2(7) := 'DEMANDS' ;
				  
				  theJob AMD_BATCH_JOBS.BATCH_JOB_NUMBER%TYPE ;
				  batch_step_number AMD_BATCH_JOB_STEPS.BATCH_STEP_NUMBER%TYPE ;
		BEGIN
		   writeMsg(pTableName => 'loadAll', pError_location => 1330,
				pKey1 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
			mblnSendAllData := TRUE ;
			IF NOT Amd_Batch_Pkg.isJobActive(system_id => loadAll.system_id) THEN
			   Amd_Batch_Pkg.start_job(system_id => loadAll.system_id,description => 'Load all the A2A transactions') ;
			END IF ;
			
			theJob := Amd_Batch_Pkg.getActiveJob(system_id => loadAll.system_id) ;
			
			A2a_Pkg.mDebug := debugIt ;
			FOR step IN startStep..endStep LOOP
				IF step = 1 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => SPO_USERS) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => SPO_USERS, package_name => THIS_PACKAGE, procedure_name => SPO_USERS) ;
						amd_owner.A2a_Pkg.initA2ASpoUsers ;
					END IF ;
				ELSIF step = 2 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => RESP_ASSET_MGR) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => RESP_ASSET_MGR, package_name => THIS_PACKAGE, procedure_name => RESP_ASSET_MGR) ;
							amd_owner.A2a_Pkg.initSiteRespAssetMgr ;
					END IF ;
				ELSIF step = 3 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => PART_INFO) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => PART_INFO, package_name => THIS_PACKAGE, procedure_name => PARt_INFO) ;
							rc := amd_owner.A2a_Pkg.initA2APartInfo(useTestParts => FALSE) ;
					END IF ;
				ELSIF step = 4 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => ORDER_INFO) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => ORDER_INFO, package_name => THIS_PACKAGE, procedure_name => ORDER_INFO) ;
						rc := amd_owner.A2a_Pkg.initA2AOrderInfo(useTestParts => FALSE) ;
						Amd_Partprime_Pkg.DiffPartToPrime ; -- set amd_sent_to_a2a.spo_prime_part_no
					END IF ;
				ELSIF step = 5 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => REPAIR_INFO) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => REPAIR_INFO, package_name => THIS_PACKAGE, procedure_name => REPAIR_INFO) ;
						rc := amd_owner.A2a_Pkg.initA2ARepairInfo(useTestParts => FALSE) ;
					END IF ;
				ELSIF step = 6 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => IN_TRANSITS) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => IN_TRANSITS, package_name => THIS_PACKAGE, procedure_name => IN_TRANSITS) ;
							rc := amd_owner.A2a_Pkg.initA2AInTransits(useTestParts => FALSE) ;
					END IF ;
				ELSIF step = 7 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => INV_INFO) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => INV_INFO, package_name => THIS_PACKAGE, procedure_name => INV_INFO) ;
							rc := amd_owner.A2a_Pkg.initA2AInvInfo(useTestParts => FALSE) ;
					END IF ;
				ELSIF step = 8 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => REPAIR_INV_INFO) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => REPAIR_INV_INFO, package_name => THIS_PACKAGE, procedure_name => REPAIR_INV_INFO) ;
							rc := amd_owner.A2a_Pkg.initA2ARepairInvInfo(useTestParts => FALSE) ;
					END IF ;
				ELSIF step = 9 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => BACKORDER_INFO) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => BACKORDER_INFO, package_name => THIS_PACKAGE, procedure_name => BACKORDER_INFO) ;
						amd_owner.A2a_Pkg.initA2ABackorderInfo(useTestParts => FALSE) ;
					END IF ;
				ELSIF step = 10 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => LOC_PART_LEAD_TIME) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => LOC_PART_LEAD_TIME, package_name => THIS_PACKAGE, procedure_name => LOC_PART_LEAD_TIME) ;
							amd_owner.Amd_Location_Part_Leadtime_Pkg.LoadAllA2A ;
					END IF ;
				ELSIF step = 11 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => LOC_PART_OVERRIDE) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => LOC_PART_OVERRIDE, package_name => THIS_PACKAGE, procedure_name => LOC_PART_OVERRIDE) ;
						amd_owner.Amd_Location_Part_Override_Pkg.loadAllA2A ;
					END IF ;
				ELSIF step = 12 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => BOM_DETAIL) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => BOM_DETAIL, package_name => THIS_PACKAGE, procedure_name => BOM_DETAIL) ;
							amd_owner.A2a_Pkg.initA2ABomDetail(useTestParts => FALSE) ;
					END IF ;
				ELSIF step = 13 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => EXT_FORECAST) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => EXT_FORECAST, package_name => THIS_PACKAGE, procedure_name => EXT_FORECAST) ;
						<<loadExtForecast>>
						DECLARE
							cnt NUMBER ;
						BEGIN
							<<getCnt>>
							BEGIN
								SELECT COUNT(*) INTO cnt FROM AMD_PART_LOC_FORECASTS ;
							EXCEPTION WHEN standard.NO_DATA_FOUND THEN
								cnt := 0 ;
							END getCnt ;
							IF cnt = 0 THEN
								amd_owner.Amd_Part_Loc_Forecasts_Pkg.LoadInitial ;
							ELSE
								initA2AExtForecast(useTestParts => false) ;
							END IF ;
						END loadExtForecast ;
					END IF ;
				ELSIF step = 14 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => PART_FACTORS) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => PART_FACTORS, package_name => THIS_PACKAGE, procedure_name => PART_FACTORS) ;
							amd_owner.Amd_Part_Factors_Pkg.loadAllA2A ;
					END IF ;
				ELSIF step = 15 THEN
				 	IF NOT Amd_Batch_Pkg.isStepComplete(batch_job_number => theJob, system_id => loadAll.system_id,
		   					description => DEMANDS) THEN
					 	Amd_Batch_Pkg.start_step(batch_job_number => theJob, system_id => loadAll.system_id,
							description => DEMANDS, package_name => THIS_PACKAGE, procedure_name => DEMANDS) ;
						initA2ADemands ;
					END IF ;
				END IF ;
				COMMIT ;
				 batch_step_number := Amd_Batch_Pkg.getActiveStep(batch_job_number => theJob, system_id => loadAll.system_id) ;
				 IF batch_step_number IS NOT NULL THEN
				 	 Amd_Batch_Pkg.end_step(batch_job_number => theJob, system_id => loadAll.system_id,
						batch_step_number => batch_step_number) ;
				 END IF ;
				 COMMIT ;
		  		 writeMsg(pTableName => 'loadAll', pError_location => 1340,
				 		pKey1 => 'step=' || step,
						pKey2 => 'rc=' || rc) ;
				 COMMIT ;
				 rc := 0 ;
			END LOOP ;
			Amd_Batch_Pkg.end_job(batch_job_number => theJob, system_id => loadAll.system_id) ;
		    writeMsg(pTableName => 'loadAll', pError_location => 1350,
				pKey1 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		END loadAll ;
		
		PROCEDURE version IS
		BEGIN
			 writeMsg(pTableName => 'a2a_pkg', 
			 		pError_location => 1360, pKey1 => 'a2a_pkg', pKey2 => '$Revision:   1.138  $') ;
		 	 dbms_output.put_line('a2a_pkg: $Revision:   1.138  $') ;
		END version ;
			
	BEGIN
	
	  <<getDebugParam>>
	  DECLARE
	  	 param AMD_PARAM_CHANGES.PARAM_VALUE%TYPE ;
	  BEGIN
	     SELECT param_value INTO param FROM AMD_PARAM_CHANGES WHERE param_key = 'debugA2A' ;
	     mDebug := (param = '1');
	  EXCEPTION WHEN OTHERS THEN
	     mDebug := FALSE ;
	  END getDebugParam;
END A2a_Pkg ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_PART_LOC_FORECASTS_PKG AS
 /*
      $Author:   zf297a  $
	$Revision:   1.21  $
        $Date:   Sep 26 2006 16:22:12  $
    $Workfile:   AMD_PART_LOC_FORECASTS_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PART_LOC_FORECASTS_PKG.pkb.-arc  $
/*   
/*      Rev 1.21   Sep 26 2006 16:22:12   zf297a
/*   Fixed insert into amd_bssm__s_base_part_periods
/*   
/*      Rev 1.20   Sep 14 2006 10:07:30   zf297a
/*   Raise an applicaton error when no date is found for the latest Rbl Run from BSSM.
/*   
/*      Rev 1.19   Sep 05 2006 12:52:00   zf297a
/*   Added dbms_output to version
/*   
/*      Rev 1.18   Aug 18 2006 15:45:10   zf297a
/*   Implemented doExtForecast.
/*   
/*      Rev 1.17   Aug 14 2006 14:13:50   zf297a
/*   Fixed code to generated ExtForecast deletes.
/*   
/*      Rev 1.16   Aug 01 2006 12:15:00   zf297a
/*   Removed redundant getLatestRblRunBssm from for loop
/*   
/*      Rev 1.15   Aug 01 2006 12:01:00   zf297a
/*   Fixed LoadLatestRblRun so that it will use the most recent date contained in the name field of bssm_locks.  Used Raise_Application_Error when no date is found in the name field.
/*   
/*      Rev 1.14   Jul 26 2006 10:11:40   zf297a
/*   Implemented function getLatestRblRunBssm
/*   
/*      Rev 1.13   Jul 26 2006 09:34:10   zf297a
/*   Made duplicate field a required field for all tmp_a2a's
/*   
/*      Rev 1.12   Jun 12 2006 13:10:42   zf297a
/*   Fixed error messages.  Resequenced pError_location.  Enhanced use of writeMsg.  Fixed to_char format for minutes MI.
/*   
/*      Rev 1.11   Jun 09 2006 12:17:28   zf297a
/*   implemented version
/*   
/*      Rev 1.10   Jun 04 2006 21:47:58   zf297a
/*   Make sure LoadTmpAmdPartLocForecasts uses non-null spo_prime_part_no
/*   
/*      Rev 1.9   Jun 01 2006 12:20:38   zf297a
/*   switched from dbms_output to amd_utils.writeMsg.
/*   
/*      Rev 1.8   May 12 2006 14:41:56   zf297a
/*   Changed all loadAll routines to use all action_codes and to use the action_code data to create the A2A transactions.  Also use the SendAllData property of the a2a_pkg in conjunction with the isPartValid and the wasPartSent functions.
/*   
/*      Rev 1.7   Apr 05 2006 12:42:38   zf297a
/*   Limitied loop of 60 periods to just 1 with a duplicate value of 60.
/*   
/*      Rev 1.6   Feb 15 2006 21:52:08   zf297a
/*   Added a ref cursor, a type, and a common process routine.
/*   
/*      Rev 1.4   Jan 03 2006 07:56:40   zf297a
/*   Added procedure loadA2AByDate
/*   
/*      Rev 1.3   Dec 16 2005 14:29:38   zf297a
/*   Moved the truncate of tmp_a2a_ext_forecast from LoadTmpAmdPartLocForecast to LoadTmpAmdPartLocForecasts_Add.
/*   
/*      Rev 1.2   Dec 15 2005 12:11:00   zf297a
/*   Added truncate of tmp_a2a_ext_forecast to LoadTmpAmdPartLocForecasts
/*   
/*      Rev 1.1   Dec 06 2005 10:36:52   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*   
/*      Rev 1.0   Dec 01 2005 09:44:12   zf297a
/*   Initial revision.
*/

-- will need to constantly diff after all to check for new and deleted parts --

	PKGNAME CONSTANT VARCHAR2(30) := 'AMD_PART_LOC_FORECASTS_PKG' ; 
	
	-- REALLY_OLD_DATE CONSTANT DATE := TO_DATE('06/10/1965', 'MM/DD/YYYY') ;
	
		procedure writeMsg(
					pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
					pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
					pKey1 IN VARCHAR2 := '',
					pKey2 IN VARCHAR2 := '',
					pKey3 IN VARCHAR2 := '',
					pKey4 in varchar2 := '',
					pData IN VARCHAR2 := '',
					pComments IN VARCHAR2 := '')  IS
		BEGIN
			Amd_Utils.writeMsg (
					pSourceName => 'amd_part_loc_forecasts_pkg',	
					pTableName  => pTableName,
					pError_location => pError_location,
					pKey1 => pKey1,
					pKey2 => pKey2,
					pKey3 => pKey3,
					pKey4 => pKey4,
					pData    => pData,
					pComments => pComments);
		end writeMsg ;
	
	FUNCTION ErrorMsg(
				pSourceName in amd_load_status.SOURCE%type,
				pTableName in amd_load_status.TABLE_NAME%type,
				pError_location in amd_load_details.DATA_LINE_NO%type,
				pReturn_code in number,			
				pKey1 in varchar2 := '',
				pKey2 in varchar2 := '',
				pKey3 in varchar2 := '',
				pData in varchar2 := '',
				pComments in varchar2 := '') return number is
	BEGIN
		ROLLBACK; -- rollback may not be complete if running with mDebug set to true
		amd_utils.InsertErrorMsg (
				pLoad_no => amd_utils.GetLoadNo(pSourceName => pSourceName,	pTableName  => pTableName),
				pData_line_no => pError_location,
				pData_line    => pData,
				pKey_1 => substr(pKey1,1,50),
				pKey_2 => substr(pKey2,1,50),			
				pKey_3 => pKey3,
				pKey_4 => to_char(pReturn_code),
				pKey_5 => to_char(sysdate,'MM/DD/YYYY HH:MI:SS'),
				pComments => 'sqlcode('||sqlcode||') sqlerrm('||sqlerrm||') ' || pComments);
		COMMIT;
		RETURN pReturn_code;
	END ;
	
	/*
	FUNCTION IsTableEmpty(pTableName VARCHAR2) RETURN NUMBER IS
		  returnCode NUMBER ;
		  sql_stmt varchar2(1000) ;
	BEGIN	  
		  IF pTableName IS NULL THEN
		  	 returnCode := -1 ;
		  END IF ;
		  sql_stmt := 'SELECT count(*) FROM ' || pTableName || ' where rownum < 2' ;
		  EXECUTE IMMEDIATE sql_stmt INTO returnCode ;
		  RETURN returnCode ;	  
	EXCEPTION WHEN OTHERS THEN
		  RETURN -1 ;	  
	END ;
	*/  
	
	
	FUNCTION GetFirstDateOfMonth(pDate DATE) RETURN DATE IS
	BEGIN
		 IF ( pDate IS null ) THEN
		 	RETURN null ;
	 	 END IF ;	
	  	 RETURN ( last_day(add_months(pDate, -1)) + 1 );
	END GetFirstDateOfMonth ;
	
	FUNCTION getLatestRblRunBssm(lockName in bssm_locks.NAME%type) RETURN DATE IS
			 str VARCHAR2(100) ;
	begin
	 		 /* spec denotes specific format of month Mon DD, YYYY  that will be in best spares
			 	text field */
			 str := lockName ;
		   	 IF owa_pattern.match(str, '(\w \d{2}, \d{4})(.*)') THEN
		   	  	  owa_pattern.CHANGE(str, '(\w \d{2}, \d{4})(.*)', '\1') ;
		   		  return to_date(str, 'Mon DD, YYYY') ;
		   	 END IF ;
			 raise_application_error(-20001,'No date found for the latest RBL Run.') ;
	end getLatestRblRunBssm ;
	
	
	FUNCTION getLatestRblRunAmd RETURN DATE IS
				-- for initial run --
		retLatestRblRun DATE := null ;
		returnCode NUMBER ;	 
	BEGIN
		retLatestRblRun := to_date(amd_defaults.GetParamValue(PARAMS_LATEST_RBL_RUN_DATE), 'MM/DD/YYYY') ;
		--IF ( retLatestRblRun IS null ) THEN
		--   retLatestRblRun := REALLY_OLD_DATE ;
		--END IF ;
		RETURN retLatestRblRun ;   
	EXCEPTION WHEN OTHERS THEN
			returnCode := ErrorMsg(
					   pSourceName 	  	  => 'getLatestRblRunAmd',
					   pTableName  	  	  => 'amd_params - problem getting latest Rbl run',
					   pError_location 	  => 10,
					   pReturn_code	  	  => 99,
					   pKey1			  => '',
		   			   pKey2			  => '',
					   pKey3			  => '',		   
					   pData			  => '',
					   pComments		  => PKGNAME) ;		
					   RAISE ;	  	
	END getLatestRblRunAmd ; 
	
	FUNCTION getCurrentPeriod RETURN DATE IS
	   	retCurPeriod DATE := null ;	
		returnCode NUMBER ;		
	BEGIN
		retCurPeriod := to_date(amd_defaults.GetParamValue( PARAMS_CURRENT_PERIOD_DATE ), 'MM/DD/YYYY') ;
		--IF ( retCurPeriod IS null ) THEN
		--   retCurPeriod := REALLY_OLD_DATE ;
		--END IF ;
			/* make sure 1st day of month */
		retCurPeriod := getFirstDateOfMonth(retCurPeriod) ;
		RETURN retCurPeriod ;		
	EXCEPTION WHEN OTHERS THEN
			returnCode := ErrorMsg(
					   pSourceName 	  	  => 'getCurrentPeriod',
					   pTableName  	  	  => 'amd_params - problem getting current period',
					   pError_location 	  => 20,
					   pReturn_code	  	  => 99,
					   pKey1			  => '',
		   			   pKey2			  => '',
					   pKey3			  => '',		   
					   pData			  => '',
					   pComments		  => PKGNAME) ;		
					   RAISE ;	  	
	END getCurrentPeriod ;
	
	
	PROCEDURE setLatestRblRunAmd(pRblRunDate DATE) IS
	BEGIN
		UPDATE amd_param_changes
		SET param_value = to_char(pRblRunDate, 'MM/DD/YYYY'),
			effective_date = sysdate, 
			user_id = PARAM_USER 
		WHERE param_key = PARAMS_LATEST_RBL_RUN_DATE ;
		COMMIT ;
	END setLatestRblRunAmd ;
	
	
	PROCEDURE setCurrentPeriod(pCurrentPeriodDate DATE) IS
	BEGIN
		UPDATE amd_param_changes
		SET param_value = to_char(getFirstDateOfMonth(pCurrentPeriodDate), 'MM/DD/YYYY'),
			effective_date = sysdate, 
			user_id = PARAM_USER 
		WHERE param_key = PARAMS_CURRENT_PERIOD_DATE  ;
		COMMIT ;
	END setCurrentPeriod ;
	
	
	PROCEDURE  InsertTmpA2A_EF (
			pPartNo 			   VARCHAR2,
			pLocation			   VARCHAR2,
			pForecastType		   VARCHAR2,
			pPeriod				   DATE,
			pQty				   NUMBER, 
			pActionCode 	   	   VARCHAR2, 
			pLastUpdateDt 		   DATE,
			pDuplicate			   number  ) IS
			
			procedure insertTmpA2A is
			begin
				INSERT INTO tmp_a2a_ext_forecast (
					  part_no,
					  location,
					  demand_forecast_type,
					  period,
					  quantity,
					  action_code,
					  last_update_dt,
					  duplicate 	
				)
				VALUES
				(
				 	  pPartNo,
					  pLocation,
					  pForecastType,
					  trunc(pPeriod),
					  pQty,
					  pActionCode,
					  pLastUpdateDt,
					  pDuplicate	
				) ;
				
			EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
				UPDATE tmp_a2a_ext_forecast
				SET		
					period 		   = trunc(pPeriod),
					quantity 	   = pQty,
					action_code	   = pActionCode,
					last_update_dt = pLastUpdateDt 			   	   
				WHERE
					part_no 	   = pPartNo 	AND
					location	   = pLocation	AND
					period		   = pPeriod ; 	
			end insertTmpA2A ;
			
	BEGIN
	
		if pActionCode = amd_defaults.DELETE_ACTION and a2a_pkg.wasPartSent(pPartNo) then
		   insertTmpA2A ;
		else
		    if (a2a_pkg.isPartValid(pPartNo) or a2a_pkg.getSendAllData) and a2a_pkg.wasPartSent(pPartNo) then
			   insertTmpA2A ;
			end if ;		 
		 end if ;
		 
	END InsertTmpA2A_EF ;
	
	
	PROCEDURE InsertTmpA2A_EF_AllPeriods(pPartNo VARCHAR2, pLocation VARCHAR2, pStartPeriod DATE, pQty NUMBER, pActionCode VARCHAR2, pLastUpdateDt DATE ) IS
			 period DATE ;	  	
	BEGIN
			 period := add_months(pStartPeriod, -1) ;
			 FOR i IN 1 .. ROLLING_PERIOD_MONTHS
			 LOOP
			 	 InsertTmpA2A_EF (pPartNo, pLocation, DEMAND_FORECAST_TYPE, add_months(period, i), pQty, pActionCode, pLastUpdateDt, 60 ) ;
				 exit when i = 1 ; -- process only one record and 60 will be automaticlly generated for the duplicate column
			 END LOOP ;	 
	END InsertTmpA2A_EF_AllPeriods ;
	
	PROCEDURE TmpA2A_EF_AddMonth(startDate DATE) IS
			 
		 CURSOR cur IS
			 SELECT 
			 		part_no,
					spo_location location, 
					startDate period,
					forecast_qty quantity,
					Amd_Defaults.INSERT_ACTION action_code,
					sysdate last_update_dt
			 FROM 
				 	amd_part_loc_forecasts aplf, 
					amd_spare_networks asn				
			 WHERE
			 	  	aplf.loc_sid = asn.loc_sid AND
					aplf.action_code != Amd_Defaults.DELETE_ACTION AND
					asn.action_code != Amd_Defaults.DELETE_ACTION AND
				 	nvl(aplf.forecast_qty, 0) > 0 ORDER BY part_no ;
			returnCode NUMBER ;		
	BEGIN		 
		FOR rec IN cur 
		LOOP
			BEGIN
			  -- this is called prior to diffing and after part info determines added/deleted parts.
			  -- add check for if part deleted so that an add month is not sent for a deleted part
			  -- which will not know till subsequent diff occurs.
				 IF (NOT amd_location_part_leadtime_pkg.IsPartDeleted(rec.part_no) ) THEN
				 		 
				 	InsertTmpA2A_EF
				 	 (	
					 	rec.part_no,
						rec.location,
						DEMAND_FORECAST_TYPE,
						rec.period,
						rec.quantity,
						rec.action_code,
						rec.last_update_dt,
						60 -- duplicate
					 )	;				
			 	 END IF ;
			EXCEPTION WHEN OTHERS THEN
				returnCode := ErrorMsg(
						   pSourceName 	  	  => 'InsertTmpA2A_EF',
						   pTableName  	  	  => 'tmp_a2a_ext_forecast',
						   pError_location 	  => 30,
						   pReturn_code	  	  => 99,
						   pKey1			  => rec.part_no,
			   			   pKey2			  => rec.location,
						   pKey3			  => rec.period,		   
						   pData			  => '',
						   pComments		  => PKGNAME) ;		
						   RAISE ;
						   	   			
			END ;	 	
		END LOOP ;
		COMMIT ;
	END TmpA2A_EF_AddMonth ;	  
	
	PROCEDURE LoadAmdBssmSBasePartPeriods(pLockSid bssm_s_base_part_periods.lock_sid%TYPE, pScenarioSid bssm_s_base_part_periods.scenario_sid%TYPE) IS
		returnCode NUMBER ;
		recordExists VARCHAR2(1) := null;
	BEGIN
		 -- make sure data exists before deleting local amd copy
		BEGIN 
			SELECT 'x' INTO recordExists
			FROM bssm_s_base_part_periods
				  WHERE scenario_sid = pScenarioSid
				  AND lock_sid = pLockSid AND rownum = 1 ;
		EXCEPTION WHEN OTHERS THEN
			returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadAmdBssmSBasePartPeriods',
				   pTableName  	  	  => 'amd_bssm_s_base_part_periods',
				   pError_location 	  => 40,
				   pReturn_code	  	  => 99,
				   pKey1			  => 'lock_sid:' || pLockSid,
	   			   pKey2			  => 'scenario_sid:' || pScenarioSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME || 'bssm locks indicates new run but problem retrieving bssm_s_base_part_periods.') ;		
				   RAISE ;
		END ;	
		BEGIN	   
			mta_truncate_table('amd_bssm_s_base_part_periods','reuse storage');
			COMMIT ;
			INSERT INTO amd_bssm_s_base_part_periods
				   SELECT 
				     LOCK_SID,
  					 SCENARIO_SID,
  					 SCENARIO_PERIOD,
  					 NSN,
					 SRAN,
  					 TARGET_STOCK01,
  					 TARGET_STOCK02,
  					 TARGET_STOCK03,
  					 TARGET_STOCK04,
  					 TARGET_STOCK05,
  					 DEMAND_RATE01,
  					 DEMAND_RATE02,
  					 DEMAND_RATE03,
  					 DEMAND_RATE04,
  					 DEMAND_RATE05,
  					 STOCK_LEVEL01,
  					 STOCK_LEVEL02,
  					 STOCK_LEVEL03,
  					 STOCK_LEVEL04,
  					 STOCK_LEVEL05,
					  PERCENT_REPLACE01,
					  PERCENT_REPLACE02,
					  PERCENT_REPLACE03,
					  PERCENT_REPLACE04,
					  PERCENT_REPLACE05,
					  REORDER_QUANT01,
					  REORDER_QUANT02,
					  REORDER_QUANT03,
					  REORDER_QUANT04,
					  REORDER_QUANT05,
					  sysdate
					  FROM bssm_s_base_part_periods
					  WHERE scenario_sid = pScenarioSid
					  AND lock_sid = pLockSid ; 
			COMMIT ;		  
		EXCEPTION WHEN OTHERS THEN
				 returnCode := ErrorMsg(
					   pSourceName 	  	  => 'LoadAmdBssmSBasePartPeriods',
					   pTableName  	  	  => 'amd_bssm_s_base_part_periods',
					   pError_location 	  => 50,
					   pReturn_code	  	  => 99,
					   pKey1			  => '',
		   			   pKey2			  => '',
					   pKey3			  => '',		   
					   pData			  => '',
					   pComments		  => PKGNAME) ;		
					   RAISE ;
		END ;			   	   
	END ; 
	
	--  amd_bssm_s_base_part_periods only can hold one rbl run, do not need to query by lock_sid scenario_sid 
	PROCEDURE LoadTmpAmdPartLocForecasts IS
		 returnCode NUMBER ;	  
	BEGIN
		writeMsg(pTableName => 'tmp_amd_part_loc_forecasts', pError_location => 60,
				pKey1 => 'LoadTmpAmdPartLocForecasts',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
		 mta_truncate_table('tmp_amd_part_loc_forecasts', 'reuse storage') ;
		 COMMIT ;
	     INSERT INTO tmp_amd_part_loc_forecasts 
		 		(loc_sid, part_no, forecast_qty, action_code, last_update_dt) 
		 SELECT loc_sid, 
		 		spo_prime_part_no part_no,
				round(sum(nvl(demand_rate01, 0)), DP) forecast_qty, 
				Amd_Defaults.INSERT_ACTION, 
				SYSDATE
	 		   FROM amd_bssm_s_base_part_periods bsbpp, 
			   		amd_nsns an, 
					amd_spare_networks asn, 
					amd_national_stock_items ansi,
					amd_sent_to_a2a asta
	 		   WHERE 
			   spo_prime_part_no is not null 
			   and bsbpp.nsn = an.nsn	 
			   AND an.nsi_sid = ansi.nsi_sid
		       AND ansi.prime_part_no = asta.part_no
			   AND decode(asn.loc_id, Amd_Defaults.AMD_WAREHOUSE_LOCID, Amd_Defaults.BSSM_WAREHOUSE_SRAN, asn.loc_id) = bsbpp.sran		    
		   	   AND ansi.action_code != Amd_Defaults.DELETE_ACTION
	   		   AND asta.action_code != Amd_Defaults.DELETE_ACTION
			   AND asn.action_code != Amd_Defaults.DELETE_ACTION
			   GROUP BY spo_prime_part_no, loc_sid 
			   HAVING round(sum(nvl(demand_rate01, 0)), DP) > 0 ;
			   
		writeMsg(pTableName => 'tmp_amd_part_loc_forecasts', pError_location => 70,
				pKey1 => 'LoadTmpAmdPartLocForecasts',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
	EXCEPTION WHEN OTHERS THEN
		returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadTmpAmdPartLocForecasts',
				   pTableName  	  	  => 'tmp_amd_part_loc_forecasts',
				   pError_location 	  => 80,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;	   
	END LoadTmpAmdPartLocForecasts ;		  
	
	PROCEDURE LoadLatestRblRun IS
		 CURSOR rbl_cur IS	 		
			 SELECT lock_sid, rbl_scenario_sid, 
			 getLatestRblRunBssm(name) latestRblRunBssm, last_data_date 
			 FROM bssm_locks
		 	 WHERE last_data_date = (SELECT max(last_data_date)  
		  			    FROM bssm_locks 
						WHERE rbl_scenario_sid IS NOT NULL)
		 	 AND rbl_scenario_sid IS NOT NULL
			 order by  getLatestRblRunBssm(name) ;
			 
		     latestRblRunAmd DATE ;
			 latestRblRunBssm DATE := null ;	
			 lockSid bssm_locks.lock_sid%TYPE ;
			 scenarioSid VARCHAR2(5) ;
			 str VARCHAR2(100) ;
			 rec rbl_cur%ROWTYPE ;	 
		returnCode NUMBER ;	 
		errorComment VARCHAR2(100) := null ;
	BEGIN	  
		latestRblRunAmd := getLatestRblRunAmd ;
	    -- use the last row with the most recent date for latestRblRunBssm
		FOR rec IN rbl_cur
		LOOP
		     latestRblRunBssm := rec.latestRblRunBssm ;	 	 
		   	 scenarioSid := rec.rbl_scenario_sid ;
		   	 lockSid := rec.lock_sid ;
		END LOOP ;	 
		
		IF latestRblRunBssm IS NULL THEN
		    Raise_Application_Error(-20000, 'latestRblRunBssm date is null. Perhaps the pattern to match the date changed or bssm locks has no rbl run.') ;
		ELSIF (trunc(latestRblRunBssm) > trunc(latestRblRunAmd)) THEN
			  -- keep amd copy since runs can be accidently deleted from bssm side
			LoadAmdBssmSBasePartPeriods( lockSid, scenarioSid ) ;
		 	setLatestRblRunAmd(latestRblRunBssm) ;
		END IF ;
	    	
	EXCEPTION WHEN OTHERS THEN
		returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadExtForecastAndLatestRblRun',
				   pTableName  	  	  => 'amd_bssm_s_base_part_periods',
				   pError_location 	  => 90,
				   pReturn_code	  	  => 99,
				   pKey1			  => 'latestRblRunAmd:' || latestRblRunAmd,
	   			   pKey2			  => 'latestRblRunBssm:' || latestRblRunBssm,
				   pKey3			  => '',	   
				   pData			  => '',
				   pComments		  => PKGNAME || ': ' || errorComment) ;		
				   RAISE ;
	END LoadLatestRblRun ;
	
	PROCEDURE LoadTmpAmdPartLocForecasts_Add IS
		currentPeriodAmd DATE 	  := 	getCurrentPeriod ;
		currentPeriod 	 DATE 	  := 	getFirstDateOfMonth(sysdate) ;	
		returnCode NUMBER ;  
	BEGIN
		mta_truncate_table('tmp_a2a_ext_forecast', 'reuse storage') ;
		IF ( trunc(currentPeriodAmd) < trunc(currentPeriod) )  THEN
			TmpA2A_EF_AddMonth(currentPeriod) ;		
		END IF ;
		setCurrentPeriod(currentPeriod) ;
		-- though rbl only quarterly run, parts can be added or deleted during each run
	    	-- which may be part of the last rbl run.  Load tmp_amd_part_loc_forecasts 
			-- for subsequent diff whether new rbl run or not.
		LoadTmpAmdPartLocForecasts ;
	EXCEPTION WHEN OTHERS THEN
		returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadTmpAmdPartLocForecasts_Add',
				   pTableName  	  	  => 'tmp_amd_part_loc_forecasts',
				   pError_location 	  => 100,
				   pReturn_code	  	  => 99,
				   pKey1			  => 'currentPeriod:' || currentPeriod,
	   			   pKey2			  => 'currentPeriodAmd:' || currentPeriodAmd,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME ) ;		
				   RAISE ;	
	END LoadTmpAmdPartLocForecasts_Add ;
	
	PROCEDURE UpdateAmdPartLocForecasts (
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE, 
			pActionCode					amd_part_loc_forecasts.action_code%TYPE,
			pLastUpdateDt				amd_part_loc_forecasts.last_update_dt%TYPE ) IS
	BEGIN
		 UPDATE amd_part_loc_forecasts
		 SET 
		 	 forecast_qty 	= pForecastQty,
		 	 action_code 	= pActionCode,
			 last_update_dt	= pLastUpdateDt
		 WHERE
		 	 part_no = pPartNo AND
			 loc_sid = pLocSid ;
	END	UpdateAmdPartLocForecasts ;	
	
	PROCEDURE InsertAmdPartLocForecasts (
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE, 
			pActionCode					amd_part_loc_forecasts.action_code%TYPE,
			pLastUpdateDt				amd_part_loc_forecasts.last_update_dt%TYPE ) IS
	BEGIN
	    INSERT INTO amd_part_loc_forecasts
			  (	
			  	part_no,
			  	loc_sid, 
				forecast_qty,
				action_code,
				last_update_dt
			  ) VALUES (
			  	pPartNo,
				pLocSid,
				pForecastQty,
				pActionCode,
				pLastUpdateDt
			  ) ;
	EXCEPTION WHEN DUP_VAL_ON_INDEX THEN	  		
		 	 UpdateAmdPartLocForecasts
			 (
			  	pPartNo,
				pLocSid,
				pForecastQty,
				pActionCode,
				pLastUpdateDt
			 ) ;
	
	END	InsertAmdPartLocForecasts ;	
					  
	
	
	FUNCTION InsertRow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE ) 
			return NUMBER IS
			returnCode NUMBER ;
	BEGIN 
		BEGIN  
		  	InsertAmdPartLocForecasts
			(
			 	pPartNo,
				pLocSid,
				pForecastQty,
				Amd_Defaults.INSERT_ACTION,
				sysdate
			) ;
		EXCEPTION WHEN OTHERS THEN
			returnCode := ErrorMsg(
				   pSourceName 	  	  => 'InsertRow.InsertAmdPartLocForecasts',
				   pTableName  	  	  => 'amd_part_loc_forecasts',
				   pError_location 	  => 110,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;	  
		END ;	
		BEGIN			   	  		   
		  	InsertTmpA2A_EF_AllPeriods
			(
				pPartNo, 
				Amd_Utils.GetSpoLocation(pLocSid) , 
				GetCurrentPeriod, 
				pForecastQty , 
				Amd_Defaults.INSERT_ACTION, 
				sysdate 
			)  ;
		EXCEPTION WHEN OTHERS THEN
				returnCode := ErrorMsg(
				   pSourceName 	  	  => 'InsertRow.InsertTmpA2A_EF_AllPeriods',
				   pTableName  	  	  => 'tmp_a2a_ext_forecast',
				   pError_location 	  => 120,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;
		END ;		
		RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;		   
	END InsertRow ;		
			
			
			
	FUNCTION UpdateRow(
			pPartNo                  amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                  amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty			 amd_part_loc_forecasts.forecast_qty%TYPE ) 
			RETURN NUMBER IS
			returnCode NUMBER ;
	BEGIN
		 BEGIN
		 	   UpdateAmdPartLocForecasts
				 (
			  		 pPartNo,
					 pLocSid,
					 pForecastQty,
					 Amd_Defaults.UPDATE_ACTION,
					 sysdate
			 	 ) ;
		 EXCEPTION WHEN OTHERS THEN		
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'UpdateRow.UpdateAmdPartLocForecasts',
				   pTableName  	  	  => 'amd_part_loc_forecasts',
				   pError_location 	  => 130,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;
		 END ; 
		 BEGIN
				 -- likely 59 months 
			   InsertTmpA2A_EF_AllPeriods
			   	(
					pPartNo, 
					Amd_Utils.GetSpoLocation(pLocSid) , 
					GetCurrentPeriod, 
					pForecastQty , 
					Amd_Defaults.UPDATE_ACTION, 
					sysdate 
				)  ;
		 EXCEPTION WHEN OTHERS THEN		
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'UpdateRow.InsertTmpA2A_EF_AllPeriods',
				   pTableName  	  	  => 'tmp_a2a_ext_forecast',
				   pError_location 	  => 140,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;
		 END ; 		
					
		RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;		
	END UpdateRow ;		
							
	
	FUNCTION DeleteRow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE ) 
			RETURN NUMBER IS
			returnCode NUMBER ;
	BEGIN 
		BEGIN
		  	UpdateAmdPartLocForecasts
			 (
			  	pPartNo,
				pLocSid,
				pForecastQty,
				Amd_Defaults.DELETE_ACTION,
				sysdate
			 ) ;
		EXCEPTION WHEN OTHERS THEN		
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'DeleteRow.UpdateAmdPartLocForecasts',
				   pTableName  	  	  => 'amd_part_loc_forecasts',
				   pError_location 	  => 150,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;
		END ; 	 
		BEGIN	 
		  	IF ( NOT amd_location_part_leadtime_pkg.IsPartDeleted(pPartNo) ) THEN	  	  
			  	InsertTmpA2A_EF_AllPeriods
				(
					pPartNo, 
					Amd_Utils.GetSpoLocation(pLocSid) , 
					GetCurrentPeriod, 
					pForecastQty , 
					Amd_Defaults.DELETE_ACTION, 
					sysdate 
				)  ;
			END IF ;	
		EXCEPTION WHEN OTHERS THEN		
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'DeleteRow.InsertTmpA2A_EF_AllPeriods',
				   pTableName  	  	  => 'tmp_a2a_ext_forecast',
				   pError_location 	  => 160,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;
		END ; 		
		RETURN SUCCESS ; 
	EXCEPTION WHEN OTHERS THEN	 	
		RETURN FAILURE ;	  
	END DeleteRow ;		
	
	procedure processPartLocForecasts(partLocForecasts in partLocForecastsCur) is
		cnt number := 0 ;
		sdate date :=  GetFirstDateOfMonth(sysdate) ;
		rec partLocForecastsRec ;
	begin
		 writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 170,
				pKey1 => 'processLocPartForecasts',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS')) ;
		 loop
		 	 fetch partLocForecasts into rec ;
			 exit when partLocForecasts%NOTFOUND ;
			 InsertTmpA2A_EF_AllPeriods(
			 				   rec.part_no, 
							   rec.spo_location, 
							   sdate, 
							   rec.forecast_qty, 
							   rec.action_code,
							   sysdate ) ;
			 cnt := cnt + 1 ;
			 if mod(cnt, 500) = 0 then
			 	commit ;
			 end if ;
		 end loop ;
	
		 writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 180,
				pKey1 => 'processLocPartForecasts',
				pKey2 => 'cnt=' || to_char(cnt),
				pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS')) ;
		 commit ;
	end processPartLocForecasts ;
	
	procedure loadA2AByDate(from_dt in date := a2a_pkg.start_dt, to_dt in date := sysdate) is
		theCursor partLocForecastsCur ;
		sdate DATE ;	
		returnCode NUMBER ;	   
	begin
		 writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 190,
		 		pKey1 => 'loadA2AByDate',
				pKey2 => 'from_dt=' || to_char(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || to_char(to_dt,'MM/DD/YYYY'),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS')) ;
	
		mta_truncate_table('tmp_a2a_ext_forecast','reuse storage');
		a2a_pkg.setSendAllData(true) ;
		open theCursor for
		  SELECT  part_no, spo_location, forecast_qty, aplf.action_code
			 FROM amd_part_loc_forecasts aplf, amd_spare_networks asn
			 WHERE 
			 	   asn.action_code != Amd_Defaults.DELETE_ACTION
			 	   AND asn.loc_sid = aplf.loc_sid
				   AND nvl(forecast_qty, 0) > 0 
				   and trunc(aplf.last_update_dt) between trunc(from_dt) and trunc(to_dt) ;
		processPartLocForecasts(theCursor) ;
		close theCursor ;	 
	
		 writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 200,
		 		pKey1 => 'loadA2AByDate',
				pKey2 => 'from_dt=' || to_char(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || to_char(to_dt,'MM/DD/YYYY'),
				pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS')) ;
				
	EXCEPTION WHEN OTHERS THEN		
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'amd_part_loc_forecast_pkg.loadA2AByDate',
				   pTableName  	  	  => 'tmp_a2a_part_loc_forecasts',
				   pError_location 	  => 210,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME ) ;		
				   RAISE ;
	end loadA2AByDate ;
	
	PROCEDURE LoadAllA2A IS
		theCursor partLocForecastsCur ;
		returnCode number ;
	BEGIN
		writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 220,
				pKey1 => 'LoadAllA2A',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
		mta_truncate_table('tmp_a2a_ext_forecast','reuse storage');
		a2a_pkg.setSendAllData(true) ;
		open theCursor for 
		  SELECT  part_no, spo_location, forecast_qty, aplf.action_code
			 FROM amd_part_loc_forecasts aplf, amd_spare_networks asn
			 WHERE 
			 	   asn.action_code != Amd_Defaults.DELETE_ACTION
			 	   AND asn.loc_sid = aplf.loc_sid
				   AND nvl(forecast_qty, 0) > 0 ;
		processPartLocForecasts(theCursor) ;
		close theCursor ;	 
		
		writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 230,
				pKey1 => 'LoadAllA2A',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
	EXCEPTION WHEN OTHERS THEN		
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadAllA2A',
				   pTableName  	  	  => 'tmp_a2a_part_loc_forecasts',
				   pError_location 	  => 240,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME ) ;		
				   RAISE ;
	END LoadAllA2A ;
	
	
	PROCEDURE LoadInitial IS
		 returnCode NUMBER ;	
	BEGIN
		writeMsg(pTableName => 'tmp_amd_part_loc_forecasts', pError_location => 250,
				pKey1 => 'LoadInitial',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
		LoadTmpAmdPartLocForecasts ;
		mta_truncate_table('amd_part_loc_forecasts','reuse storage');
		BEGIN 
			 INSERT INTO amd_part_loc_forecasts
			 SELECT * FROM tmp_amd_part_loc_forecasts 
			 	WHERE action_code != Amd_Defaults.DELETE_ACTION ;
			
		EXCEPTION WHEN OTHERS THEN		
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadInitial',
				   pTableName  	  	  => 'amd_part_loc_forecasts',
				   pError_location 	  => 260,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME || ': Insert into amd_part_loc_forecasts') ;		
				   RAISE ;
		END ;
		LoadAllA2A ;
		
		writeMsg(pTableName => 'tmp_amd_part_loc_forecasts', pError_location => 270,
				pKey1 => 'LoadInitial',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	END LoadInitial ;	

	procedure doExtForecast is
	begin
		 LoadLatestRblRun ;
		 LoadTmpAmdPartLocForecasts_Add ;
	end doExtForecast ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_part_loc_forecasts_pkg', 
		 		pError_location => 280, pKey1 => 'amd_part_loc_forecasts_pkg', pKey2 => '$Revision:   1.21  $') ;
		 dbms_output.put_line('amd_part_loc_forecasts_pkg: $Revision:   1.21  $') ;
	end version ;
	
END AMD_PART_LOC_FORECASTS_PKG ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_PART_LOCS_LOAD_PKG
IS
    /*   				
		
       $Author:   zf297a  $
     $Revision:   1.8  $
         $Date:   Jun 09 2006 12:12:20  $
     $Workfile:   amd_part_locs_load_pkg.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_part_locs_load_pkg.pkb-arc  $
   
      Rev 1.8   Jun 09 2006 12:12:20   zf297a
   implemented version
   
      Rev 1.7   Dec 06 2005 10:33:56   zf297a
   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
   
      Rev 1.4.1.1   Jun 13 2005 09:19:06   c970183
   Added PVCS keywords
   
*/
/*
	--  Date	  	  By			History
   	--  ----		  --			-------
   	--  10/10/01	  	  ks		initial implementation
   	--  12/11/01	  	  dse		Added named param for amd_preferred_pkg.GetUnitCost(.....
   	--  8/14/02		  ks            change fsl query to be more efficient.
	--  6/01/05		  ks		changes to support AMD 1.7.1 - change to RSP_ON_HAND, RSP_OBJECTIVE
	--					mod to queries for bssm, eg. lock_sid use '0' instead of 0
*/
  	ERRSOURCE constant varchar2(20) := 'amdpartlocsloadpkg';
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_part_locs_load_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;

	function ErrorMsg(
					pSqlfunction in varchar2,
					pTableName in varchar2,
					pError_location in number,
					pReturn_code in number,
					pKey_1 in varchar2,
			 		pKey_2 in varchar2 := '',
					pKey_3 in varchar2 := '',
					pKey_4 in varchar2 := '',					
					pKeywordValuePairs in varchar2 := '') return number is
	begin
		rollback;
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => pSqlfunction,
						pTableName  => pTableName),
				pData_line_no => pError_location,
				pData_line    => 'amd_part_locs_pkg',
				pKey_1 => pKey_1,
				pKey_2 => pKey_2,
				pKey_3 => pKey_3,
				pKey_4 => pKey_4,
				pKey_5 => 'rc=' || to_char(pReturn_code) ||
					       ' ' || to_char(sysdate,'MM/DD/YYYY HH:MM:SS') ||
						   ' ' || pKeywordValuePairs,
				pComments => 'sqlcode('||sqlcode||') sqlerrm('||sqlerrm||')');
		commit;
		return pReturn_code;
	end ErrorMsg;
	function GetAmdNsiRec(pNsiSid amd_national_stock_items.nsi_sid%type) return amd_national_stock_items%rowtype is
			amdNsiRec amd_national_stock_items%rowtype := null;
		begin
	    	select *
			into amdNsiRec
			from amd_national_stock_items
			where nsi_sid = pNsiSid;
			return amdNsiRec;
		exception
			when no_data_found then
				 return amdNsiRec;
	end GetAmdNsiRec;

	/* function GetOffBaseRepairCost, logic same as previous load version */
	function  GetOffBaseRepairCost(pPartNo char) return amd_part_locs.cost_to_repair%type is
		offBaseRepairCost   amd_part_locs.cost_to_repair%type := null;
		--
		--    Use only PART   number because POI1 does not have Cage Code.
		--
	begin
		select
			sum(nvl(ext_price,0))/count(*)
		into offBaseRepairCost
		from poi1
		where
			part = pPartNo
			and substr(ccn,1,5) in ( select ccn_prefix from amd_ccn_prefix )
			and nvl(ext_price,0) > 0;
		return(offBaseRepairCost);
	exception
		when no_data_found then
			 return null;
	end GetOffBaseRepairCost;

	/* function get_off_base_tat, logic same as previous load version
	   removed offbasediag time from previous version */
	function GetOffBaseTurnAround (pPartno char) return amd_part_locs.time_to_repair%type is
		-- goldpart      char(50);
		offBaseTurnAroundTime amd_part_locs.time_to_repair%type;

	begin
		select
			avg( completed_docdate  - created_docdate)
		into offBaseTurnAroundTime
		from ord1
		where
			part = pPartNo
			and nvl(action_taken,'*') in ('A', 'B', 'E', 'G', '*' )
			and order_type = 'J'
			and completed_docdate is not null
		group by part;
		return offBaseTurnAroundTime;
	exception
		when no_data_found then
			return null;
	end GetOffBaseTurnAround;

	function  GetOnBaseRepairCost (pPartno   varchar2) return   number is

		--
		-- on base repair cost is to be calculated using data
		-- from tmp_lccost table.
		-- this table will be loaded on a monthly basis from rmads and the result
		-- are stored in amd_on_base_repair_costs.
		--
		-- formular:
		--
		-- on base repair cost = average mhr * average dollars($20)
		--
		-- where average mhr is calculated by add up the manhours for each ajcn,
		--  and then divide by the   number of total ajcn for the part.
		--
		--  average dollars is default to $20 per hour at this time.
		--
		--  note: if no part found, default the on base repair cost to $40.00
		--
		onBaseRepairCost number;
	begin
		begin
			select
				on_base_repair_cost
			into onBaseRepairCost
			from amd_on_base_repair_costs
			where part_no = pPartno;
		exception
			when no_data_found then
				return null;
		end;
		return onBaseRepairCost;
	end GetOnBaseRepairCost;
	
		/* kcs change to ramp%ROWTYPE from rampData_rec */
	function GetRampData(pNsn ramp.nsn%type, pLocSid amd_spare_networks.loc_sid%type) return ramp%ROWTYPE is
		/* rampData rampData_rec := null; */
		rampData ramp%ROWTYPE := null;
		locId amd_spare_networks.loc_id%type;
	begin
		locId := amd_utils.GetLocId(pLocSid);
		if (locId is null) then
		    return rampData;
		else
			return GetRampData(pNsn, locId);
		end if;
	end GetRampData;

		/* kcs change to ramp%ROWTYPE from rampData_rec */
   	function GetRampData(pNsn ramp.nsn%type, pLocId amd_spare_networks.loc_id%type) return ramp%ROWTYPE is
	    cursor rampData_cur (pNsn ramp.nsn%type, pLocId amd_spare_networks.loc_id%type) is
			select * 
			from
			   ramp
			where
			   current_stock_number = pNsn and
			   substr(sc, 8, 6) = pLocId;
		nsn ramp.current_stock_number%type;
		rampData rampData_cur%rowtype := null;
		-- though currently ramp does not return more than one record, design
		-- of ramp table allows. current_stock_number is not part of key.
		-- use explicit cursor just in case.

 	begin
		nsn := amd_utils.FormatNsn(pNsn, 'GOLD');
	  	if (not rampData_cur%isOpen) then
		   open rampData_cur(nsn, pLocId);
		end if;
		fetch rampData_cur into
			  rampData;
		close rampData_cur;
		return rampData;
  	end GetRampData;

	--
	-- Select all MOB's from AMD then
	-- remove MOB's from BSSM that have 'N''s
	-- and add FSL's from BSSM that have 'Y''s

	-- lifted from current version, modified to go to
	-- amd_national_stock_items table and add 'OFFBASE' parts.
	-- to minimize recoding, made cursor since amd_part_locs needs nsi and not nsn.

	-- Bob Eberlein's note says that bssm will only carry the current part in
	-- bssm_parts (i.e. not all versions of nsn like nsl, ncz, nsn).
	-- implies won't need to determine which one is "live" in his system
	-- and negates the potential for 3 "nsns" in bssm_parts relating to one nsi_sid.
	-- just pull nsi_sid by amd_nsns, in case bssm_parts one step behind (load
	-- currently less frequent than amd load).

	procedure LoadAmdPartLocations is
			amdNsiRec amd_national_stock_items%rowtype := null;
			amdPartLocsRec amd_part_locs%rowtype := null;
			unitCost amd_spare_parts.unit_cost%type := null;
			locId amd_spare_networks.loc_id%type := null;
			partBaseCleanRec amd_cleaned_from_bssm_pkg.partBaseFields := null;
			/* kcs rampData rampData_rec; */
			rampData ramp%ROWTYPE ;
			countRecs number := 0;
		cursor partLocsMobList_cur is
			    --
			    -- MOB SELECTION LOGIC
			    --
				--
				-- Select all MOB's from AMD
				--
				-- the order by is to speed up processing of records.
				-- some info is not location dependent currently and therefore
				-- does not have to be re-retrieved.  saves 80% time for 97k+ records.
				-- based on substr if smr null or < 3 chars will be not part of 1st select,
				-- though mdd would.  confirmed with laurie for now, consistent with previous load.
				select * from (
					select
						ansi.nsi_sid,
						asn.loc_sid
					from
						amd_national_stock_items ansi,
						amd_spare_networks asn
					where
						asn.loc_type = 'MOB'
						and substr(amd_preferred_pkg.GetSmrCode(ansi.nsn),3,1) != 'D'
						and ansi.action_code in ('A', 'C')
						and asn.action_code in ('A', 'C')
					--
					-- MOB EXCLUSION LOGIC
					--
					minus
					((select
						-- bbp.nsn
						an.nsi_sid,
						asn.loc_sid
					from
						bssm_base_parts bbp,
						amd_spare_networks asn,
						amd_nsns an
					where
						lock_sid         = '0'
						and bbp.nsn = an.nsn
						and bbp.sran     = asn.loc_id
						and asn.loc_type = 'MOB'
						and bbp.replacement_indicator = 'N'
						and asn.action_code in ('A', 'C')
					minus
					select
						-- bbp.nsn,
						an.nsi_sid,
						asn.loc_sid
					from
						bssm_base_parts bbp,
						amd_spare_networks asn,
						amd_nsns an
					where
						lock_sid         = '2'
						and bbp.nsn = an.nsn
						and bbp.sran     = asn.loc_id
						and asn.loc_type = 'MOB'
						and asn.action_code in ('A', 'C')
						and bbp.replacement_indicator = 'Y')

					union
					select
						-- bbp.nsn,
						an.nsi_sid,
						asn.loc_sid
					from
						bssm_base_parts bbp,
						amd_spare_networks asn,
						amd_nsns an
					where
						lock_sid         = '2'
						and bbp.nsn = an.nsn
						and bbp.sran     = asn.loc_id
						and asn.loc_type = 'MOB'
						and bbp.replacement_indicator = 'N'
						and asn.action_code in ('A', 'C'))
				) order by nsi_sid;

				--
				-- FSL SELECTION LOGIC
				--b1
				--
				-- Select valid combo's using capability logic and valid in
				-- locks 0 and 2
				--
		cursor partLocsFslList_cur is
			  select * from (
				(
				select
				-- bp.nsn,
					an.nsi_sid,
					asn.loc_sid
				from
					bssm_parts bp,
					bssm_bases bb,
					amd_spare_networks asn,
					amd_national_stock_items ansi,
					amd_nsns an
				where
					bp.capability_requirement > 0
					and bp.lock_sid         = '0'
					and bb.lock_sid         = '0'
					and sign((bp.capability_requirement - bb.capabilty_level)) != -1
					and bb.sran             = asn.loc_id
					and asn.loc_type        = 'FSL'
					-- and bp.nsn              = ansi.nsn
					and bp.nsn				= an.nsn
					and an.nsi_sid			= ansi.nsi_sid
					and ansi.action_code in ('A', 'C')
					and asn.action_code in ('A', 'C')

				union
				select
					 -- bbp.nsn,
					ansi.nsi_sid,
					asn.loc_sid
				from
					bssm_base_parts bbp,
					amd_spare_networks asn,
					amd_national_stock_items ansi,
					amd_nsns an
				where
					lock_sid         in ('0','2')
					and bbp.sran     = asn.loc_id
					and asn.loc_type = 'FSL'
					and asn.action_code in ('A', 'C')
					and ansi.action_code in ('A', 'C')
					and bbp.replacement_indicator = 'Y'
					and bbp.nsn      = an.nsn
					and an.nsi_sid = ansi.nsi_sid)
				--
				-- Subtract invalid combo's in locks 2 and 0
				--
				minus
				(select
					-- bbp.nsn,
					an.nsi_sid,
					asn.loc_sid
				from
					bssm_base_parts bbp,
					amd_spare_networks asn,
					amd_nsns an
				where
					lock_sid         = '2'
					and bbp.sran     = asn.loc_id
					and asn.loc_type = 'FSL'
					and bbp.replacement_indicator = 'N'
					and bbp.nsn = an.nsn
					and asn.action_code in ('A', 'C')
				union
				select
					  -- bbp.nsn
					an.nsi_sid,
					asn.loc_sid
				from
					bssm_base_parts bbp,
					amd_spare_networks asn,
					amd_nsns an
				where
					lock_sid         = '0'
					and bbp.sran     = asn.loc_id
					and asn.loc_type = 'FSL'
					and bbp.nsn = an.nsn
					and asn.action_code in ('A', 'C')
					and bbp.replacement_indicator = 'N'
					and not exists
						(select 'x'
						from bssm_base_parts bbp2
						where
							lock_sid      = '2'
							and bbp2.sran = bbp.sran
							and bbp2.nsn  = bbp.nsn
							and bbp2.replacement_indicator = 'Y'))
				) order by nsi_sid;

		cursor partLocsOffBaseList_cur is
				select
					   ansi.nsi_sid,
					   ansi.prime_part_no,
					   asn.loc_sid
				from
					   amd_national_stock_items ansi,
					   amd_spare_networks asn
				where
					   asn.loc_id = OFFBASE_LOCID and
					   ansi.action_code in ('A', 'C') and
					   asn.action_code in ('A', 'C');
		/* changed to insert statement --			   
		cursor partLocsWareHouse_cur is
			    select
					   ansi.nsi_sid,
					   asn.loc_sid
				from
					   amd_national_stock_items ansi,
					   amd_spare_networks asn
				where
					   asn.loc_id = amd_from_bssm_pkg.AMD_WAREHOUSE_LOCID and
					   ansi.action_code in ('A', 'C') and
					   asn.action_code in ('A', 'C');
		*/			   
	-- end cursor definitions


		procedure InsertIntoAmdPartLocs(pRec amd_part_locs%rowtype) is
		begin
			 insert into amd_part_locs
			 		(
					nsi_sid,
					loc_sid,
					awt,
					awt_defaulted,
					cost_to_repair,
					cost_to_repair_defaulted,
					mic,
					mic_defaulted,
					removal_ind,
					removal_ind_defaulted,
					removal_ind_cleaned,
					repair_level_code,
					repair_level_code_defaulted,
					repair_level_code_cleaned,
					time_to_repair,
					time_to_repair_defaulted,
					tactical,
					action_code,
					last_update_dt,
					rsp_on_hand,
					rsp_objective,
					order_cost,
					holding_cost,
					backorder_fixed_cost,
					backorder_variable_cost
					)
			 values (
			 		pRec.nsi_sid,
					pRec.loc_sid,
					pRec.awt,
					pRec.awt_defaulted,
					pRec.cost_to_repair,
					pRec.cost_to_repair_defaulted,
					pRec.mic,
					pRec.mic_defaulted,
					pRec.removal_ind,
					pRec.removal_ind_defaulted,
					pRec.removal_ind_cleaned,
					pRec.repair_level_code,
					pRec.repair_level_code_defaulted,
					pRec.repair_level_code_cleaned,
					pRec.time_to_repair,
					pRec.time_to_repair_defaulted,
					pRec.tactical,
					pRec.action_code,
					pRec.last_update_dt,
					pRec.rsp_on_hand,
					pRec.rsp_objective,
					pRec.order_cost,
					pRec.holding_cost,
					pRec.backorder_fixed_cost,
					pRec.backorder_variable_cost
				);
		end InsertIntoAmdPartLocs;

	begin
			--
			-- load mobs into part locations
			--
		countRecs := 0;

		for partLocsMobRec in partLocsMobList_cur
		loop
			begin
					 -- minimize retrieving of amdNsiRec and onbaserepaircost, note order by in cursor
					 -- all of the hardcoded null assignments related to amdPartLocsRec fields,
					 -- could be taken out, already handled with
					 --	amdPartLocsRec := null.  takes up minimal time, left in for visibility.
				rampData := null;
				if (partLocsMobRec.nsi_sid != amdNsiRec.nsi_sid or amdNsiRec.nsi_sid is null) then
				   amdPartLocsRec := null;
				   amdNsiRec := GetAmdNsiRec(partLocsMobRec.nsi_sid);
				   amdPartLocsRec.nsi_sid := partLocsMobRec.nsi_sid;
				   amdPartLocsRec.cost_to_repair := GetOnBaseRepairCost(amdNsiRec.prime_part_no);
				   if (amdPartLocsRec.cost_to_repair is null) then
				   		-- currently default is 40
				     	   amdPartLocsRec.cost_to_repair_defaulted := amd_defaults.COST_TO_REPAIR_ONBASE;
				   end if;
				end if;

				locId := amd_utils.GetLocId(partLocsMobRec.loc_sid);

				amdPartLocsRec.loc_sid := partLocsMobRec.loc_sid;
				amdPartLocsRec.awt := null;
				amdPartLocsRec.awt_defaulted := null;

				amdPartLocsRec.mic := null;
				amdPartLocsRec.mic_defaulted := null;
					-- Eric Honma, default MOB 'Y'  FSL 'N' for repair_indicator/repair_level_code
					-- and removal indicator.
					-- also part of exception table bssm_base_parts
					-- if removal ind cleaned is 'N' then error in cursor
				amdPartLocsRec.removal_ind := null;
				amdPartLocsRec.removal_ind_defaulted := 'Y';
			        -- will retrieve all cleanable fields for bssm base parts
					-- cleaning done as a post process to speed up
				amdPartLocsRec.removal_ind_cleaned := null;
				amdPartLocsRec.repair_level_code := null;
				amdPartLocsRec.repair_level_code_defaulted := 'Y';
				amdPartLocsRec.repair_level_code_cleaned := null;
				rampData := GetRampData(amdNsiRec.nsn, locId);
				amdPartLocsRec.time_to_repair := rampData.avg_repair_cycle_time;
				 -- lauries "command decision" treat null and 0 as same => need default.
				if (nvl(amdPartLocsRec.time_to_repair,0) = 0) then
				   amdPartLocsRec.time_to_repair := null;
				   amdPartLocsRec.time_to_repair_defaulted := amd_defaults.TIME_TO_REPAIR_ONBASE;
				end if;
				amdPartLocsRec.tactical := 'Y';
				amdPartLocsRec.action_code := amd_defaults.INSERT_ACTION;
				amdPartLocsRec.last_update_dt := SYSDATE;
				/* kcs changes to support bssm 603 and amd1.7.1 
				amdPartLocsRec.rsp_on_hand := rampData.wrm_balance;
				amdPartLocsRec.rsp_objective := rampData.wrm_level;
				*/
				amdPartLocsRec.rsp_on_hand := nvl(rampData.wrm_balance, 0) + nvl(rampData.spram_balance, 0) + nvl(rampData.hpmsk_balance, 0) ;
				amdPartLocsRec.rsp_objective := nvl(rampData.wrm_level, 0) + nvl(rampData.spram_level, 0) + nvl(rampData.hpmsk_level_qty, 0) ;
					-- filled in afterwards in separate process, bssm only source for now
					-- look in amd_from_bssm_pkg,
					-- null assignment here just to note
				amdPartLocsRec.order_cost := null;
				amdPartLocsRec.holding_cost := null;
				amdPartLocsRec.backorder_fixed_cost := null;
				amdPartLocsRec.backorder_variable_cost := null;
					-- insert record
				InsertIntoAmdPartLocs(amdPartLocsRec);
				if (countRecs > COMMIT_AFTER) then
					commit;
					countRecs := 0;
				else
					countRecs := countRecs + 1;
				end if;
			exception
				when others then
					 amd_utils.InsertErrorMsg(amd_utils.GetLoadNo(ERRSOURCE, 'mob cursor'),partlocsmobrec.nsi_sid, partlocsmobrec.loc_sid,null,null,null,substr(SQLCODE || ' ' || SQLERRM,1, 2000));
			end;
		end loop;
		commit;


			--
			-- load fsls into part locations
			--
	    amdNsiRec := null;
		for partLocsFslRec in partLocsFslList_cur
		loop
			begin
				rampData := null;
					 -- minimize retrieving of amdNsiRec and onbaserepaircost
				if (partLocsFslRec.nsi_sid != amdNsiRec.nsi_sid or amdNsiRec.nsi_sid is null) then
				   amdPartLocsRec := null;
				   amdNsiRec := GetAmdNsiRec(partLocsFslRec.nsi_sid);
				   amdPartLocsRec.nsi_sid := partLocsFslRec.nsi_sid;
				   amdPartLocsRec.cost_to_repair := GetOnBaseRepairCost(amdNsiRec.prime_part_no);
				   if (amdPartLocsRec.cost_to_repair is null) then
				   		-- currently default is 40
				   		amdPartLocsRec.cost_to_repair_defaulted := amd_defaults.COST_TO_REPAIR_ONBASE;
				   end if;
				end if;


				locId := amd_utils.GetLocId(partLocsFslRec.loc_sid);

				amdPartLocsRec.loc_sid := partLocsFslRec.loc_sid;
				amdPartLocsRec.awt := null;
				amdPartLocsRec.awt_defaulted := null;

				amdPartLocsRec.mic := null;
				amdPartLocsRec.mic_defaulted := null;
					-- Eric Honma, default MOB 'Y'  FSL 'N' for repair_indicator/repair_level_code
					-- and removal indicator.
					-- also part of exception table bssm_base_parts
					-- if removal ind cleaned is 'N' then error in cursor
				amdPartLocsRec.removal_ind := null;
				amdPartLocsRec.removal_ind_defaulted := 'N';
					-- cleaning done as a post process to speed up
				amdPartLocsRec.removal_ind_cleaned := null;
				amdPartLocsRec.repair_level_code := null;
				amdPartLocsRec.repair_level_code_defaulted := 'N';
				amdPartLocsRec.repair_level_code_cleaned := null;
				rampData := GetRampData(amdNsiRec.nsn, locId);
				amdPartLocsRec.time_to_repair := rampData.avg_repair_cycle_time;
				 -- lauries "command decision" treat null and 0 as same => need default.
				if (nvl(amdPartLocsRec.time_to_repair,0) = 0) then
				   amdPartLocsRec.time_to_repair := null;
				   amdPartLocsRec.time_to_repair_defaulted := amd_defaults.TIME_TO_REPAIR_ONBASE;
				end if;
				amdPartLocsRec.tactical := 'Y';
				amdPartLocsRec.action_code := amd_defaults.INSERT_ACTION;
				amdPartLocsRec.last_update_dt := SYSDATE;
				/* kcs changes to support bssm 603 and amd1.7.1 
				amdPartLocsRec.rsp_on_hand := rampData.wrm_balance;
				amdPartLocsRec.rsp_objective := rampData.wrm_level;
				*/
				amdPartLocsRec.rsp_on_hand := nvl(rampData.wrm_balance, 0) + nvl(rampData.spram_balance, 0) + nvl(rampData.hpmsk_balance, 0) ;
				amdPartLocsRec.rsp_objective := nvl(rampData.wrm_level, 0) + nvl(rampData.spram_level, 0) + nvl(rampData.hpmsk_level_qty, 0) ;	-- filled in afterwards in separate process, bssm only source for now
					-- look in amd_from_bssm_pkg,
					-- null assignment here just to note
				amdPartLocsRec.order_cost := null;
				amdPartLocsRec.holding_cost := null;
				amdPartLocsRec.backorder_fixed_cost := null;
				amdPartLocsRec.backorder_variable_cost := null;
				InsertIntoAmdPartLocs(amdPartLocsRec);
			exception
				when others then
					 amd_utils.InsertErrorMsg(amd_utils.GetLoadNo(ERRSOURCE, 'fsl cursor'),partlocsfslrec.nsi_sid, partlocsfslrec.loc_sid,null,null,null, substr(SQLCODE || ' ' || SQLERRM,1, 2000));
			end;
		end loop;
		commit;

			--
			-- load offbase into part locations
			--
		countRecs := 0;
		for partLocsOffBaseRec in partLocsOffBaseList_cur
			-- partLocsOffBaseRec only has nsn and location.
			-- should change defaulted to pull from params table.
			-- cursors all tied to ansi so nsn, partno in cursor will be in ansi
		loop
			begin
				amdPartLocsRec := null;
				amdPartLocsRec.nsi_sid := partLocsOffBaseRec.nsi_sid;
				amdPartLocsRec.loc_sid := partLocsOffBaseRec.loc_sid;
				amdPartLocsRec.awt := null;
				amdPartLocsRec.awt_defaulted := null;
				amdPartLocsRec.cost_to_repair := GetOffBaseRepairCost(partLocsOffBaseRec.prime_part_no);
				if (amdPartLocsRec.cost_to_repair is null) then
				   		-- amd_preferred throws exception
						-- currently unit cost is null.
				    begin
					    unitCost := amd_preferred_pkg.GetUnitCost( pNsi_Sid => partLocsOffBaseRec.nsi_sid);
					    amdPartLocsRec.cost_to_repair_defaulted := unitCost * (amd_defaults.UNIT_COST_FACTOR_OFFBASE);
					exception
						when no_data_found then
							 amdPartLocsRec.cost_to_repair_defaulted := null;
					end;
				end if;
				amdPartLocsRec.mic := null;
					-- no real meaning of following for offbase, set to null
				amdPartLocsRec.removal_ind := null;
				amdPartLocsRec.removal_ind_defaulted := null;
				amdPartLocsRec.removal_ind_cleaned := null;
				amdPartLocsRec.repair_level_code := null;
				amdPartLocsRec.repair_level_code_defaulted := null;
				amdPartLocsRec.repair_level_code_cleaned := null;

				amdPartLocsRec.time_to_repair := GetOffBaseTurnAround(partLocsOffBaseRec.prime_part_no);
				if (amdPartLocsRec.time_to_repair is null) then
				   amdPartLocsRec.time_to_repair_defaulted := amd_defaults.TIME_TO_REPAIR_OFFBASE;
				end if;
				amdPartLocsRec.tactical := 'Y';
				amdPartLocsRec.action_code := amd_defaults.INSERT_ACTION;
				amdPartLocsRec.last_update_dt := SYSDATE;
				amdPartLocsRec.rsp_on_hand := null;
				amdPartLocsRec.rsp_objective := null;
				amdPartLocsRec.order_cost := null;
				amdPartLocsRec.holding_cost := null;
				amdPartLocsRec.backorder_fixed_cost := null;
				amdPartLocsRec.backorder_variable_cost := null;

				  -- insert record
				InsertIntoAmdPartLocs(amdPartLocsRec);
				if (countRecs > COMMIT_AFTER) then
					commit;
					countRecs := 0;
				else
					countRecs := countRecs + 1;
				end if;
			exception
				when others then
					 amd_utils.InsertErrorMsg(amd_utils.GetLoadNo(ERRSOURCE, 'offbasecursor'),partlocsoffbaserec.nsi_sid, partlocsoffbaserec.loc_sid,null,null,null, substr(SQLCODE || ' ' || SQLERRM,1, 2000));
			end;
		end loop;
		commit;
			--
			-- load warehouse parts
			--
		countRecs := 0;
		/*
		for partLocsWhRec in partLocsWareHouse_cur
		loop
			begin
					-- most of the values have no meaning w/respect to the warehouse.
					-- list is just used to accommodate ROP/ROQ in amd_part_loc_time_periods for now.
				amdPartLocsRec := null;
				amdPartLocsRec.nsi_sid := partLocsWhRec.nsi_sid;
				amdPartLocsRec.loc_sid := partLocsWhRec.loc_sid;
				amdPartLocsRec.tactical := 'Y';
				amdPartLocsRec.action_code := amd_defaults.INSERT_ACTION;
				amdPartLocsRec.last_update_dt := SYSDATE;
				   -- insert record
				InsertIntoAmdPartLocs(amdPartLocsRec);
				if (countRecs > COMMIT_AFTER) then
					commit;
					countRecs := 0;
				else
					countRecs := countRecs + 1;
				end if;
			exception
				when others then
					 amd_utils.InsertErrorMsg(amd_utils.GetLoadNo(ERRSOURCE, 'WH cursor'),partLocsWhRec.nsi_sid, partLocsWhRec.loc_sid,null,null,null, substr(SQLCODE || ' ' || SQLERRM,1, 2000));
			end;
  	    end loop;
		*/
		begin
			 insert into amd_part_locs 
			 (nsi_sid, loc_sid, tactical, action_code, last_update_dt)
			 	select
					   ansi.nsi_sid,
					   asn.loc_sid,
					   'Y',
					   amd_defaults.INSERT_ACTION,
					   SYSDATE					   
				from
					   amd_national_stock_items ansi,
					   amd_spare_networks asn
				where
					   asn.loc_id = amd_from_bssm_pkg.AMD_WAREHOUSE_LOCID and
					   ansi.action_code in ('A', 'C') and
					   asn.action_code in ('A', 'C') ;
		exception
				when others then
					 amd_utils.InsertErrorMsg(amd_utils.GetLoadNo(ERRSOURCE, 'WH'),  null, null, null,null,null, substr(SQLCODE || ' ' || SQLERRM,1, 2000));
		end ;
		commit;

	end LoadAmdPartLocations;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_part_locs_load_pkg', 
		 		pError_location => 999, pKey1 => 'amd_part_locs_load_pkg', pKey2 => '$Revision:   1.8  $') ;
	end version ;
	
BEGIN
	 null;
END AMD_PART_LOCS_LOAD_PKG;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_PART_FACTORS_PKG AS

 /*
      $Author:   zf297a  $
	$Revision:   1.6  $
        $Date:   Jun 09 2006 12:03:06  $
    $Workfile:   AMD_PART_FACTORS_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PART_FACTORS_PKG.pkb.-arc  $
/*   
/*      Rev 1.6   Jun 09 2006 12:03:06   zf297a
/*   implemented interface version
/*   
/*      Rev 1.5   Mar 03 2006 12:38:32   zf297a
/*   removed amd_location_part_leadtime_pkg.getBatchRunStart and replaced it with amd_batch_pkg.getLastStartTime, which will always return the start time of the last job regardless of whether it has completed or not.  This allows the procedures that select a2a data to be run even if the batch job has completed.  Only the data that has changed since the batch job started will be sent.  This should only be a small amount of data.
/*   
/*      Rev 1.4   Jan 03 2006 13:03:18   zf297a
/*   Added date range to procedure loadA2AByDate
/*   
/*      Rev 1.3   Jan 03 2006 08:07:42   zf297a
/*   Added procedure loadA2AByDate
/*   
/*      Rev 1.2   Dec 16 2005 08:49:30   zf297a
/*   Added truncate of tmp_a2a_part_factors table when tmp_amd_part_factors is loaded.
/*   
/*      Rev 1.1   Dec 06 2005 10:30:26   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*   
/*      Rev 1.0   Oct 31 2005 08:04:54   zf297a
/*   Initial revision.
*/


	PKGNAME CONSTANT VARCHAR2(30) := 'AMD_PART_FACTORS_PKG' ;
	
	TYPE mtd_rec IS RECORD (
		 rts NUMBER,
		 nrts NUMBER,
		 condemn NUMBER
	) ;
	
	
	
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_part_factors_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	FUNCTION ErrorMsg(
				pSourceName in amd_load_status.SOURCE%TYPE,
				pTableName in amd_load_status.TABLE_NAME%TYPE,
				pError_location in amd_load_details.DATA_LINE_NO%TYPE,
				pReturn_code in number,			
				pKey1 in varchar2 := '',
				pKey2 in varchar2 := '',
				pKey3 in varchar2 := '',
				pData in varchar2 := '',
				pComments in varchar2 := '') RETURN number IS
	BEGIN
		ROLLBACK; -- rollback may not be complete if running with mDebug set to true
		amd_utils.InsertErrorMsg (
				pLoad_no => amd_utils.GetLoadNo(pSourceName => pSourceName,	pTableName  => pTableName),
				pData_line_no => pError_location,
				pData_line    => pData,
				pKey_1 => substr(pKey1,1,50),
				pKey_2 => substr(pKey2,1,50),			
				pKey_3 => pKey3,
				pKey_4 => to_char(pReturn_code),
				pKey_5 => to_char(sysdate,'MM/DD/YYYY HH:MM:SS'),
				pComments => 'sqlcode('||sqlcode||') sqlerrm('||sqlerrm||') ' || pComments);
		COMMIT;
		RETURN pReturn_code;
	END ;
	
	
	
	
	
	
	FUNCTION DefaultMtdToDataSys(pLocId amd_spare_networks.LOC_ID%TYPE )
			 RETURN mtd_rec IS
			 retRec mtd_rec ;
	BEGIN
			 retRec.rts := 0 ;
	 		 retRec.nrts := 0 ;
	 		 retRec.condemn := 0 ;
			 IF (pLocId = amd_defaults.AMD_WAREHOUSE_LOCID) THEN
			 	retRec.condemn := DEFAULT_WHSE_COND ;
			 ELSE
			 	retRec.nrts := 1 ; 
			 END IF ;		 	 
			 RETURN retRec ;
	END ;
	
	FUNCTION GetCriticalityFromSubs(pSpoPrimePartNo amd_sent_to_a2a.spo_prime_part_no%TYPE)
		RETURN	amd_national_stock_items.CRITICALITY%TYPE IS
		CURSOR cur IS
	 		   SELECT criticality_cleaned, criticality
				FROM amd_sent_to_a2a asta, amd_national_stock_items ansi
				WHERE
				spo_prime_part_no = pSpoPrimePartNo
				AND part_no != spo_prime_part_no
				AND ansi.prime_part_no = part_no 
				AND asta.action_code != Amd_Defaults.DELETE_ACTION
				AND ansi.action_code != Amd_Defaults.DELETE_ACTION ;
		retCrit amd_national_stock_items.CRITICALITY%TYPE := null ;		
		SubHasCritOfOne boolean := false ;		
	BEGIN
		FOR rec IN cur
		LOOP
			IF ( amd_preferred_pkg.GetPreferredValue(rec.criticality_cleaned, rec.criticality) = 1 ) THEN
			   SubHasCritOfOne := true ;
			END IF ;
		END LOOP ; 
		IF ( SubHasCritOfOne ) THEN
		   RETURN 1 ;
		ELSE 
		   RETURN null ;
		END IF ;
	END ;
	
	FUNCTION CorrectCriticality(pCrit amd_national_stock_items.CRITICALITY%TYPE) 
		RETURN amd_national_stock_items.CRITICALITY%TYPE IS	
	BEGIN
		IF (pCrit IS NULL ) THEN
		   RETURN null ;
		ELSIF ( pCrit <= 0 ) THEN
		   RETURN 0 ;
		ELSIF ( pCrit > 0 AND pCrit <= .1) THEN
		   RETURN .1 ;
		ELSIF ( pCrit > .1 AND pCrit <= .5) THEN  
		   RETURN .5 ;
		ELSIF ( pCrit > .5 ) THEN
		   RETURN 1 ;
		END IF ;
	END ;	
	
	FUNCTION DetermineCriticality(pCrit amd_national_stock_items.CRITICALITY%TYPE, 
			 					  pPartNo amd_spare_parts.part_no%TYPE ) 
		RETURN amd_national_stock_items.CRITICALITY%TYPE IS
		retCrit amd_national_stock_items.CRITICALITY%TYPE := null ;
	BEGIN
		 IF ( pCrit IS NULL ) THEN
		 	 retCrit := GetCriticalityFromSubs(pPartNo) ;
		 	 IF ( retCrit IS NOT NULL ) THEN
			 	RETURN correctCriticality(retCrit) ;
			 ELSIF (amd_location_part_leadtime_pkg.IsPartRepairable(pPartNo) = 'Y') THEN
			 	RETURN CRITICALITY_REPAIRABLE_DEFAULT ;
			 ELSE
			 	RETURN CRITICALITY_CONSUMABLE_DEFAULT ;
			 END IF ;		 	
		 ELSE
		 	 RETURN correctCriticality(pCrit) ;
		 END IF ;
	END ;	
	
	
	
	FUNCTION DetermineCriticality(pCrit amd_national_stock_items.CRITICALITY%TYPE, 
			 					  pNsiSid amd_national_stock_items.nsi_sid%TYPE ) 
		RETURN amd_national_stock_items.CRITICALITY%TYPE IS
		primePartNo amd_national_stock_items.prime_part_no%TYPE := null ;
	BEGIN
		IF ( pCrit IS NULL ) THEN 
			SELECT prime_part_no INTO primePartNo
				FROM amd_national_stock_items
				WHERE action_code != Amd_Defaults.DELETE_ACTION
				AND nsi_sid = pNsiSid ;
				RETURN DetermineCriticality(pCrit, primePartNo) ;
		ELSE 
			RETURN pCrit ;
		END IF ;			
	EXCEPTION WHEN OTHERS THEN
		RETURN null ; 
	END ;	
	
	/* current spec says to send a default nrts, rts, cond to vub, vcd, basc,
	   others - mob, fsl, ctlatl, uk will use #'s from best spares.
	   Below will have to be maintained */
	FUNCTION IsAutoDefaulted(pLocRow amd_spare_networks%ROWTYPE ) 
			 RETURN boolean IS		 
	 BEGIN	
		 IF ( pLocRow.loc_id NOT IN (Amd_Defaults.AMD_WAREHOUSE_LOCID, Amd_Defaults.AMD_UK_LOC_ID) 
		 	AND pLocRow.loc_type NOT IN ('FSL', 'MOB' ) ) THEN 	 
			 RETURN true ;
		 ELSE
		 	 RETURN false ;
		 END IF ;
	EXCEPTION WHEN NO_DATA_FOUND THEN
		 RETURN true ;
	END ;
	
	FUNCTION AutoDefaultMtd
			 RETURN mtd_rec IS
			 retMtdRec mtd_rec ;
	BEGIN
		 	 retMtdRec.nrts := 1 ;
			 retMtdRec.rts := 0 ;
			 retMtdRec.condemn := 0 ;	 
			 RETURN retMtdRec ;
	END ;
		
	FUNCTION ConvertMtdToDataSys (pLocId amd_spare_networks.LOC_ID%TYPE, pCapabilityLevel VARCHAR2, pRepairInd VARCHAR2, pNrts NUMBER, pRts NUMBER, pCondemn NUMBER) 
			 RETURN mtd_rec IS
			 retRec mtd_rec ;
			 tot NUMBER ;
	BEGIN
		 	
			 retRec.rts := ROUND(nvl(pRts, 0), DP) ;
	 		 retRec.nrts := ROUND(nvl(pNrts, 0), DP) ;
	 		 retRec.condemn := ROUND(nvl(pCondemn, 0), DP) ;
	
		  	 tot := retRec.rts + retRec.nrts + retRec.condemn ;
			  	
				
		 	 IF (tot = 0 OR retRec.rts < 0 OR retRec.nrts < 0 OR retRec.condemn < 0 ) THEN
			 	 RETURN DefaultMtdToDataSys(pLocId) ;
			 END IF ;	
			 	 /* normalize */		 	 
			 IF (tot != 1) THEN
				 retRec.rts := ROUND(retRec.rts/tot, DP) ;
				 retRec.nrts := ROUND(retRec.nrts/tot, DP) ;
		 		 retRec.condemn := ROUND(retRec.condemn/tot, DP) ;
			 END IF ;
			 IF ( pLocId = amd_defaults.AMD_WAREHOUSE_LOCID ) THEN
			 	-- double check w/Dave if rts = 1 
			 	IF (retRec.rts = 1) THEN
				   retRec.condemn := 0 ;
				ELSE
			 		retRec.condemn := ROUND(retRec.condemn/(1 - retRec.rts), DP) ;
				END IF ;	
			  	retRec.rts := 0 ;
				retRec.nrts := 0 ;			
				/* not warehouse */
			 ELSIF ( nvl(pCapabilityLevel, 'notO') = '0' AND nvl(pRepairInd, 'Y') = 'Y' )THEN
			 	retRec.nrts := 1 - retRec.rts ;
				retRec.condemn := 0 ;
			 ELSE	 
			 	retRec.nrts := 1 ;
				retRec.condemn := 0 ;
				retRec.rts := 0 ;
			 END IF ;
			 RETURN retRec ;
	END ConvertMtdToDataSys ;		 
	
	
	PROCEDURE  InsertTmpA2A_PF (
	   			      pPartNo   		   VARCHAR2,
					  pBaseName 		   VARCHAR2, 
					  pMtbdr			   NUMBER, 
					  pMttr				   NUMBER,
					  pPassUpRate		   NUMBER, 
					  pRts				   NUMBER,
					  pCmdmdRate 		   NUMBER,								 
					  pCriticalityCode	   NUMBER,
					  pActionCode 		   VARCHAR2, 
					  pLastUpdateDt 	   DATE ) IS
	BEGIN
		BEGIN 
			if a2a_pkg.isPartValid(pPartNo) and a2a_pkg.wasPartSent(pPartNo) then
				INSERT INTO tmp_a2a_part_factors (
						   part_no,
						   base_name,
						   mtbdr,
						   mttr,
						   nrts,
						   rts,				   
						   cmdmd_rate,
						   criticality_code,
						   action_code,
						   last_update_dt		
				)
				VALUES
			    (
				 	  	  pPartNo,
						  pBaseName,  
						  pMtbdr, 
						  pMttr,
						  pPassUpRate, 
						  pRts, 
						  pCmdmdRate,								 
						  pCriticalityCode,
						  pActionCode, 
						  pLastUpdateDt 
					 	  
				);
			end if ;
		EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
			UPDATE tmp_a2a_part_factors
			SET	   
				   mtbdr 	= pMtbdr,
				   mttr		= pMttr,
				   rts		= pRts,
				   nrts		= pPassUpRate,
				   cmdmd_rate = pCmdmdRate,
				   criticality_code = pCriticalityCode,
				   action_code		= pActionCode,
				   last_update_dt	= pLastUpdateDt
			WHERE
				   part_no 			= pPartNo 	   AND
				   base_name		= pBaseName	  ;
		END ;	
	END InsertTmpA2A_PF;		
		
	
	PROCEDURE UpdateAmdPartFactors (
	  			pPartNo                      amd_part_factors.part_no%TYPE,
				pLocSid                      amd_part_factors.loc_sid%TYPE,
				pPassUpRate					 amd_part_factors.pass_up_rate%TYPE ,
				pRts						 amd_part_factors.rts%TYPE ,										
				pCmdmdRate					 amd_part_factors.cmdmd_rate%TYPE ,
		  	    pActionCode					 amd_part_factors.action_code%TYPE ,
		  	    pLastUpdateDt				 amd_part_factors.last_update_dt%TYPE ) IS
	
	BEGIN
		 	  UPDATE amd_part_factors
			  SET 
			  	  pass_up_rate		 		= pPassUpRate,
				  rts						= pRts,
				  cmdmd_rate				= pCmdmdRate,
			  	  action_code				= pActionCode,
				  last_update_dt			= pLastUpdateDt
			  WHERE
			  	  part_no = pPartNo AND
				  loc_sid = pLocSid ;
	END UpdateAmdPartFactors ;		  					   
	
	PROCEDURE UpdateTmpAmdPartFactors (
			    pPartNo                      amd_part_factors.part_no%TYPE,
				pLocSid                      amd_part_factors.loc_sid%TYPE,
				pPassUpRate					 amd_part_factors.pass_up_rate%TYPE ,
				pRts						 amd_part_factors.rts%TYPE ,										
				pCmdmdRate					 amd_part_factors.cmdmd_rate%TYPE ,
		  	    pActionCode					 amd_part_factors.action_code%TYPE ,
		  	    pLastUpdateDt				 amd_part_factors.last_update_dt%TYPE ) IS
	
	BEGIN
		 	  UPDATE tmp_amd_part_factors
			  SET 
			  	  pass_up_rate		 		= pPassUpRate,
				  rts						= pRts,
				  cmdmd_rate				= pCmdmdRate,
			  	  action_code				= pActionCode,
				  last_update_dt			= pLastUpdateDt
			  WHERE
			  	  part_no = pPartNo AND
				  loc_sid = pLocSid ;
	END UpdateTmpAmdPartFactors ;		
	
	PROCEDURE InsertAmdPartFactors (
			  pPartNo                   amd_part_factors.part_no%TYPE,
			  pLocSid 					amd_spare_networks.loc_sid%TYPE, 
			  pPassUpRate				amd_part_factors.pass_up_rate%TYPE ,
			  pRts						amd_part_factors.rts%TYPE ,										
			  pCmdmdRate				amd_part_factors.cmdmd_rate%TYPE ,
			  pActionCode				amd_part_factors.action_code%TYPE ,
			  pLastUpdateDt				amd_part_factors.last_update_dt%TYPE ) IS
	BEGIN
		 INSERT INTO amd_part_factors 
		 (
		  		part_no,
				loc_sid,
				pass_up_rate,
				rts,
				cmdmd_rate,
				action_code,
				last_update_dt
		 )
		 VALUES 
		 (
		  	  pPartNo,
			  pLocSid,
			  pPassUpRate,
			  pRts,
			  pCmdmdRate,
			  pActionCode,
			  pLastUpdateDt	 
		 ) ;	 
	EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
			  UpdateAmdPartFactors (
		   			pPartNo,
		  			pLocSid,
		  			pPassUpRate,
		  			pRts,										
		  			pCmdmdRate,
		  	  	    pActionCode,
		  	  	    pLastUpdateDt ) ;
			  	 
	END InsertAmdPartFactors ;
	
	PROCEDURE InsertTmpAmdPartFactors (
			  pPartNo 			   		amd_part_factors.part_no%TYPE,
			  pLocSid 					amd_part_factors.loc_sid%TYPE, 
			  pPassUpRate				amd_part_factors.pass_up_rate%TYPE ,
			  pRts						amd_part_factors.rts%TYPE ,										
			  pCmdmdRate				amd_part_factors.cmdmd_rate%TYPE ,
			  pActionCode				amd_part_factors.action_code%TYPE ,
			  pLastUpdateDt				amd_part_factors.last_update_dt%TYPE ) IS
	BEGIN
		 INSERT INTO tmp_amd_part_factors 
		 (
		  		part_no,
				loc_sid,
				pass_up_rate,
				rts,
				cmdmd_rate,
				action_code,
				last_update_dt
		 )
		 VALUES 
		 (
		  	  pPartNo,
			  pLocSid,
			  pPassUpRate,
			  pRts,
			  pCmdmdRate,
			  pActionCode,
			  pLastUpdateDt	 
		 ) ;	 
	EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
			  UpdateTmpAmdPartFactors (
		   			pPartNo,
		  			pLocSid,
		  			pPassUpRate,
		  			pRts,										
		  			pCmdmdRate,
		  	  	    pActionCode,
		  	  	    pLastUpdateDt ) ;
			  	 
	END InsertTmpAmdPartFactors ;
	
	FUNCTION InsertRow(		
			pPartNo                      amd_part_factors.part_no%TYPE,
			pLocSid                      amd_part_factors.loc_sid%TYPE,
			pPassUpRate					 amd_part_factors.pass_up_rate%TYPE ,
			pRts						 amd_part_factors.rts%TYPE ,										
			pCmdmdRate					 amd_part_factors.cmdmd_rate%TYPE ,
			pCriticality				 amd_national_stock_items.criticality%TYPE,
			pCriticalityChanged			 amd_national_stock_items.criticality_changed%TYPE,
			pCriticalityCleaned			 amd_national_stock_items.criticality_cleaned%TYPE )
			return NUMBER  IS
			locationInfo amd_spare_networks%ROWTYPE ;	
			mtdRec mtd_rec := null ; 	
			crit amd_national_stock_items.criticality%TYPE := null ;
			returnCode NUMBER ;
	BEGIN		
		BEGIN
			 InsertAmdPartFactors
			 (
			   	  pPartNo,
			 	  pLocSid,
			  	  pPassUpRate,
				  pRts, 										
				  pCmdmdRate,
			  	  Amd_Defaults.INSERT_ACTION,
			  	  sysdate
			 ) ;	  
		EXCEPTION WHEN OTHERS THEN
		 		   returnCode := ErrorMsg(
				   pSourceName 	  	  => 'InsertRow.InsertAmdPartFactors',
				   pTableName  	  	  => 'amd_part_factors',
				   pError_location 	  => 20,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;	  		  			  	
		END ;	 
		
		BEGIN
			locationInfo := amd_utils.GetLocationInfo(pLocSid) ; 
			crit := DetermineCriticality(amd_preferred_pkg.GetPreferredValue(pCriticalityCleaned, pCriticality), pPartNo) ;
		    InsertTmpA2A_PF(
				pPartNo,
				locationInfo.spo_location,
				null,  /* mtbdr */
				null,  /* mttr */
				pPassUpRate,
				pRts,			
				pCmdmdRate,
				crit,
				AMD_DEFAULTS.INSERT_ACTION,
				SYSDATE )	;
		EXCEPTION WHEN OTHERS THEN
		 		   returnCode := ErrorMsg(
				   pSourceName 	  	  => 'InsertRow.insertTmpA2A_PF',
				   pTableName  	  	  => 'tmp_a2a_part_factors',
				   pError_location 	  => 20,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;	  		  			  	
		END ;
		RETURN SUCCESS ;	
	EXCEPTION WHEN OTHERS THEN		 
		RETURN FAILURE ;	  
		
	END InsertRow ;
	
	FUNCTION UpdateRow(
			pPartNo                      amd_part_factors.part_no%TYPE,
			pLocSid                      amd_part_factors.loc_sid%TYPE,
			pPassUpRate					 amd_part_factors.pass_up_rate%TYPE ,
			pRts						 amd_part_factors.rts%TYPE ,										
			pCmdmdRate					 amd_part_factors.cmdmd_rate%TYPE ,
			pCriticality				 amd_national_stock_items.criticality%TYPE,
			pCriticalityChanged			 amd_national_stock_items.criticality_changed%TYPE,
			pCriticalityCleaned			 amd_national_stock_items.criticality_cleaned%TYPE )
			return NUMBER  IS
			locationInfo amd_spare_networks%ROWTYPE ;	
			mtdRec mtd_rec := null ; 	
			returnCode NUMBER ;
			crit amd_national_stock_items.criticality%TYPE ;
	BEGIN
		BEGIN
		    UpdateAmdPartFactors
			(
					pPartNo,
					pLocSid,
					pPassUpRate,
					pRts,										
					pCmdmdRate,
			  	    Amd_Defaults.UPDATE_ACTION,
			  	    sysdate
			 ) ;	
		EXCEPTION WHEN OTHERS THEN
		 		   returnCode := ErrorMsg(
				   pSourceName 	  	  => 'UpdateRow.UpdateAmdPartFactors',
				   pTableName  	  	  => 'tmp_amd_part_factors',
				   pError_location 	  => 30,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;
		END ;	
		
		BEGIN
			locationInfo := amd_utils.GetLocationInfo(pLocSid) ;
			crit := DetermineCriticality(amd_preferred_pkg.GetPreferredValue(pCriticalityCleaned, pCriticality), pPartNo) ;
		    InsertTmpA2A_PF(
				pPartNo,
				locationInfo.spo_location,
				null,  /* mtbdr */
				null,  /* mttr */
				pPassUpRate,
				pRts,			
				pCmdmdRate,
				crit,
	 			AMD_DEFAULTS.UPDATE_ACTION,
	 			SYSDATE 
			  )	;
		EXCEPTION WHEN OTHERS THEN
		 		   returnCode := ErrorMsg(
				   pSourceName 	  	  => 'UpdateRow.insertTmpA2A_PF',
				   pTableName  	  	  => 'tmp_a2a_part_factors',
				   pError_location 	  => 40,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;	  		  			  	
		END ;
		RETURN SUCCESS ;	
	EXCEPTION WHEN OTHERS THEN		 
		RETURN FAILURE ;	  
	
	END UpdateRow ;
	
	FUNCTION DeleteRow(
			pPartNo                      amd_part_factors.part_no%TYPE,
			pLocSid                      amd_part_factors.loc_sid%TYPE,
			pPassUpRate					 amd_part_factors.pass_up_rate%TYPE ,
			pRts						 amd_part_factors.rts%TYPE ,										
			pCmdmdRate					 amd_part_factors.cmdmd_rate%TYPE ,
			pCriticality				 amd_national_stock_items.criticality%TYPE,
			pCriticalityChanged			 amd_national_stock_items.criticality_changed%TYPE,
			pCriticalityCleaned			 amd_national_stock_items.criticality_cleaned%TYPE )
			return NUMBER  IS
		    locationInfo amd_spare_networks%ROWTYPE ;	
			mtdRec mtd_rec := null ; 	
			crit amd_national_stock_items.criticality%TYPE := null ;	
			returnCode NUMBER ;	
	BEGIN	
	   	BEGIN
			UpdateAmdPartFactors
			(
	 			pPartNo,
				pLocSid,
				pPassUpRate,
				pRts,										
				pCmdmdRate,
		  	    Amd_Defaults.DELETE_ACTION,
		  	    sysdate
	
			 ) ;
		EXCEPTION WHEN OTHERS THEN
		 		   returnCode := ErrorMsg(
				   pSourceName 	  	  => 'DeleteRow.UpdateAmdPartFactors',
				   pTableName  	  	  => 'amd_part_factors',
				   pError_location 	  => 50,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;	  		  			  	
		END ;	
		
		BEGIN
		--	IF (NOT amd_location_part_leadtime_pkg.IsPartDeleted(pPartNo) ) THEN 
				locationInfo := amd_utils.GetLocationInfo(pLocSid) ; 
				crit := DetermineCriticality(amd_preferred_pkg.GetPreferredValue(pCriticalityCleaned, pCriticality), pPartNo) ;		
			    InsertTmpA2A_PF(
					pPartNo,
					locationInfo.spo_location,
					null,  /* mtbdr */
					null,  /* mttr */
					pPassUpRate,
					pRts,			
					pCmdmdRate,
					crit,
					AMD_DEFAULTS.DELETE_ACTION,
					SYSDATE )	;
	--		END IF ;		
		EXCEPTION WHEN OTHERS THEN
		 		   returnCode := ErrorMsg(
				   pSourceName 	  	  => 'DeleteRow.InsertTmpA2A_PF',
				   pTableName  	  	  => 'tmp_a2a_part_factors',
				   pError_location 	  => 20,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME) ;		
				   RAISE ;
		END ;
		RETURN SUCCESS ;	
	EXCEPTION WHEN OTHERS THEN		 
		RETURN FAILURE ;	
	END DeleteRow ;
	
	/*   
		 ----------------------------------------------
		 Load related procedures 
		 ----------------------------------------------
	*/
	
	
	FUNCTION GetRepairIndicator(pNsn bssm_base_parts.nsn%TYPE, pSran bssm_base_parts.sran%TYPE, pLockSid bssm_locks.LOCK_SID%TYPE) 
		 RETURN VARCHAR2 IS 
		 retRI bssm_base_parts.repair_indicator%TYPE ;	 	  
	BEGIN 
		 IF ((pNsn IS NULL) OR (pSran IS NULL) ) THEN
		 	RETURN null ;
		 END IF ;
	 
		 SELECT repair_indicator INTO retRI
		 	FROM bssm_base_parts bbp, amd_nsns an 
		 	WHERE bbp.lock_sid = pLockSid
			AND   an.nsn = bbp.nsn 
			AND	  an.nsi_sid = (SELECT nsi_sid FROM amd_nsns WHERE nsn = pNsn)
			AND   bbp.sran =  pSran ;
		 RETURN retRI ;	 	
	EXCEPTION WHEN NO_DATA_FOUND THEN
		 RETURN null ;	 
	END ;
	
	FUNCTION GetCapabilityLevel(pLocId amd_spare_networks.loc_id%TYPE) 
		 RETURN bssm_bases.capabilty_level%TYPE IS
		 retCap bssm_bases.capabilty_level%TYPE := null ;
	BEGIN
		 SELECT capabilty_level INTO retCap 
	  	    FROM bssm_bases 
	  	 	WHERE sran = decode(pLocId, Amd_Defaults.AMD_WAREHOUSE_LOCID, Amd_Defaults.BSSM_WAREHOUSE_SRAN, pLocId)
	  		AND lock_sid = '0' ;
		 RETURN retCap ;	
	EXCEPTION WHEN NO_DATA_FOUND THEN
		 RETURN null ;	
	END ;
	
	
	PROCEDURE LoadTmpAmdPartFactorsByLocType ( pLocType IN amd_spare_networks.loc_type%TYPE ) IS 
			  -- no mapping of amd loc_id to bssm sran for this one, use ByLocId if needed
		 CURSOR partFactors_cur IS
		  	SELECT spo_prime_part_no part_no,
				   ansi.nsn, 
				   loc_sid, 
				   loc_type,
				   loc_id,			   			  
	   	  		   amd_preferred_pkg.GetPreferredValue(rts_avg_cleaned, rts_avg, rts_avg_defaulted) rts,
			  	   amd_preferred_pkg.GetPreferredValue(nrts_avg_cleaned, nrts_avg, nrts_avg_defaulted) nrts,
			  	   amd_preferred_pkg.GetPreferredValue(condemn_avg_cleaned, condemn_avg, condemn_avg_defaulted) condemn
				FROM amd_national_stock_items ansi, amd_sent_to_a2a asta,
					 amd_spare_networks asn
		 		WHERE asta.part_no = asta.spo_prime_part_no 
				AND asta.spo_prime_part_no = ansi.prime_part_no 
				AND asta.action_code != Amd_Defaults.DELETE_ACTION
				AND ansi.action_code != Amd_Defaults.DELETE_ACTION
				AND asn.action_code != Amd_Defaults.DELETE_ACTION
				AND asn.loc_type = pLocType ;		
		I NUMBER := 0 ;		
		mtdRec mtd_rec ;
		locationInfo amd_spare_networks%ROWTYPE ;
		returnCode NUMBER ;	
	BEGIN
	    FOR rec IN partFactors_cur
	    LOOP
			BEGIN
				locationInfo.loc_type := rec.loc_type ;
				locationInfo.loc_id := rec.loc_id ;
				mtdRec := null ;
			    IF IsAutoDefaulted( locationInfo ) THEN
				 	mtdRec := AutoDefaultMtd ;
				ELSE			
					mtdRec := convertMtdToDataSys(
				 		 locationInfo.loc_id,		
						 GetCapabilityLevel(rec.loc_id) ,
						 amd_preferred_pkg.GetPreferredValue(				 					 
					   	 					GetRepairIndicator(rec.nsn, rec.loc_id, '2'),
					   						GetRepairIndicator(rec.nsn, rec.loc_id, '0') 
										  ),
						 rec.nrts,
						 rec.rts,
						 rec.condemn
					);
				END IF ;	
				InsertTmpAmdPartFactors
				 (
				   	  rec.part_no,
				 	  rec.loc_sid,
				  	  mtdRec.nrts,
					  mtdRec.rts, 										
					  mtdRec.condemn,
				  	  Amd_Defaults.INSERT_ACTION,
				  	  sysdate
				 ) ;	  
				IF ( I > COMMITAFTER ) THEN
				   I := 0 ;
				   COMMIT ;
				END IF ;       	
				I := I + 1 ;
		  	EXCEPTION WHEN OTHERS THEN
		 		   returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadTmpAmdPartFactorsByLocType',
				   pTableName  	  	  => 'tmp_amd_part_factors',
				   pError_location 	  => 20,
				   pReturn_code	  	  => 99,
				   pKey1			  => 'locType:' || rec.loc_type,
			   	   pKey2			  => 'partNo:' || rec.part_no,
				   pKey3			  => 'locSid:' || rec.loc_sid,		     
				   pData			  => '',
				   pComments		  => PKGNAME ) ;		
				   RAISE ;
			END ;
	    END LOOP;
	   	COMMIT ;  
	END ;
	 
	
	PROCEDURE LoadTmpAmdPartFactors(pAmdLocId  IN  amd_spare_networks.loc_id%TYPE, 
			  						pBssmSran  IN  bssm_base_parts.sran%TYPE ) IS
		 CURSOR partFactors_cur IS
		  	SELECT spo_prime_part_no part_no,
				   ansi.nsn, 
				   loc_sid, 
				   loc_type,
				   loc_id,
				   amd_preferred_pkg.GetPreferredValue(rts_avg_cleaned, rts_avg, rts_avg_defaulted) rts,
			  	   amd_preferred_pkg.GetPreferredValue(nrts_avg_cleaned, nrts_avg, nrts_avg_defaulted) nrts,
			  	   amd_preferred_pkg.GetPreferredValue(condemn_avg_cleaned, condemn_avg, condemn_avg_defaulted) condemn
				FROM amd_national_stock_items ansi, amd_sent_to_a2a asta,
					 amd_spare_networks asn
		 		WHERE asta.part_no = asta.spo_prime_part_no 
				AND asta.spo_prime_part_no = ansi.prime_part_no 
				AND asta.action_code != Amd_Defaults.DELETE_ACTION
				AND ansi.action_code != Amd_Defaults.DELETE_ACTION
				AND asn.action_code != Amd_Defaults.DELETE_ACTION
				AND asn.loc_id = pAmdLocId ;		
		I NUMBER := 0 ;		
		mtdRec mtd_rec ;
		locationInfo amd_spare_networks%ROWTYPE ;
		returnCode NUMBER ;	
	BEGIN
	    FOR rec IN partFactors_cur
	    LOOP
			BEGIN
				locationInfo.loc_type := rec.loc_type ;
				locationInfo.loc_id := rec.loc_id ;
				mtdRec := null ;
			    IF IsAutoDefaulted( locationInfo ) THEN
				 	mtdRec := AutoDefaultMtd ;
				ELSE			
					mtdRec := convertMtdToDataSys(
				 		 locationInfo.loc_id,		
						 GetCapabilityLevel(rec.loc_id) ,
						 amd_preferred_pkg.GetPreferredValue(				 					 
					   	 					GetRepairIndicator(rec.nsn, rec.loc_id, '2'),
					   						GetRepairIndicator(rec.nsn, rec.loc_id, '0') 
										  ),
						 rec.nrts,
						 rec.rts,
						 rec.condemn
					);
				END IF ;	
				InsertTmpAmdPartFactors
				 (
				   	  rec.part_no,
				 	  rec.loc_sid,
				  	  mtdRec.nrts,
					  mtdRec.rts, 										
					  mtdRec.condemn,
				  	  Amd_Defaults.INSERT_ACTION,
				  	  sysdate
				 ) ;	  
				IF ( I > COMMITAFTER ) THEN
				   I := 0 ;
				   COMMIT ;
				END IF ;       	
				I := I + 1 ;			
			EXCEPTION WHEN OTHERS THEN
				 		   returnCode := ErrorMsg(
						   pSourceName 	  	  => 'LoadTmpAmdPartFactorsByLocType',
						   pTableName  	  	  => 'tmp_amd_part_factors',
						   pError_location 	  => 20,
						   pReturn_code	  	  => 99,
						   pKey1			  => 'locType:' || rec.loc_type,
			   			   pKey2			  => 'partNo:' || rec.part_no,
						   pKey3			  => 'locSid:' || rec.loc_sid,		   
						   pData			  => '',
						   pComments		  => PKGNAME ) ;		
						   RAISE ;
			END ;
	    END LOOP;
	   	COMMIT ;
		   
	END ;
	
	procedure loadA2AByDate(from_dt in date := a2a_pkg.start_dt, to_dt in date := sysdate) is
		CURSOR cur(fromDate in date, toDate in date) IS
			   SELECT ansi.nsi_sid,
			   		  pass_up_rate,
					  rts,
					  cmdmd_rate,
			   		  criticality_cleaned,
					  criticality,
					  prime_part_no,
					  loc_id,
					  loc_type, 
					  spo_location
			   FROM amd_part_factors apf, amd_national_stock_items ansi, amd_spare_networks asn
			   WHERE apf.part_no = ansi.prime_part_no 
			   		 AND apf.loc_sid = asn.loc_sid 
					 AND apf.action_code != Amd_Defaults.DELETE_ACTION 
					 AND ansi.action_code != Amd_Defaults.DELETE_ACTION
					 AND asn.action_code !=  Amd_Defaults.DELETE_ACTION   
					 and trunc(apf.last_update_dt) between trunc(fromDate) and trunc(toDate) ;
		I NUMBER := 0 ;
		returnCode NUMBER ;
		crit amd_national_stock_items.criticality%TYPE ;
	BEGIN
	  	dbms_output.put_line('amd_part_factors.loadA2AByDate(' || from_dt || ',' || to_dt || ') started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
		mta_truncate_table('tmp_a2a_part_factors','reuse storage');
		COMMIT ;
		FOR rec IN cur(from_dt, to_dt) 
		LOOP
			crit := DetermineCriticality(amd_preferred_pkg.GetPreferredValue(rec.criticality_cleaned, rec.criticality), rec.nsi_sid ) ;     	
			InsertTmpA2A_PF(
	 			rec.prime_part_no,
	 			rec.spo_location,
	 			null,  -- mtbdr 
	 			null,  -- mttr 
	 			rec.pass_up_rate,
	 			rec.rts,
	 			rec.cmdmd_rate,
				crit,
	 			AMD_DEFAULTS.INSERT_ACTION,
	 			SYSDATE 
			 )	;
			IF ( I > COMMITAFTER ) THEN
			   I := 0 ;
			   COMMIT ;
			END IF ;
			I := I + 1 ;
		END LOOP ;
	  	dbms_output.put_line('amd_part_factors.loadA2AByDate(' || from_dt || ',' || to_dt || ') ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
	EXCEPTION WHEN OTHERS THEN
	  returnCode := ErrorMsg(
				   pSourceName 	  	  => 'loadA2AByDate',
				   pTableName  	  	  => 'tmp_a2a_part_factors',
				   pError_location 	  => 60,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME || ': loadA2AByDate(' || from_dt || ',' || to_dt || ')') ;		
				   RAISE ;
	END loadA2AByDate ;
		
						
	PROCEDURE LoadAllA2A IS
		CURSOR cur IS
			   SELECT ansi.nsi_sid,
			   		  pass_up_rate,
					  rts,
					  cmdmd_rate,
			   		  criticality_cleaned,
					  criticality,
					  prime_part_no,
					  loc_id,
					  loc_type, 
					  spo_location
			   FROM amd_part_factors apf, amd_national_stock_items ansi, amd_spare_networks asn
			   WHERE apf.part_no = ansi.prime_part_no 
			   		 AND apf.loc_sid = asn.loc_sid 
					 AND apf.action_code != Amd_Defaults.DELETE_ACTION 
					 AND ansi.action_code != Amd_Defaults.DELETE_ACTION
					 AND asn.action_code !=  Amd_Defaults.DELETE_ACTION   ;
		I NUMBER := 0 ;
		returnCode NUMBER ;
		crit amd_national_stock_items.criticality%TYPE ;
	BEGIN
		mta_truncate_table('tmp_a2a_part_factors','reuse storage');
		COMMIT ;
		FOR rec IN cur
		LOOP
			crit := DetermineCriticality(amd_preferred_pkg.GetPreferredValue(rec.criticality_cleaned, rec.criticality), rec.nsi_sid ) ;     	
			InsertTmpA2A_PF(
	 			rec.prime_part_no,
	 			rec.spo_location,
	 			null,  -- mtbdr 
	 			null,  -- mttr 
	 			rec.pass_up_rate,
	 			rec.rts,
	 			rec.cmdmd_rate,
				crit,
	 			AMD_DEFAULTS.INSERT_ACTION,
	 			SYSDATE 
			 )	;
			IF ( I > COMMITAFTER ) THEN
			   I := 0 ;
			   COMMIT ;
			END IF ;
			I := I + 1 ;
		END LOOP ;
	EXCEPTION WHEN OTHERS THEN
	  returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadAllA2A',
				   pTableName  	  	  => 'tmp_a2a_part_factors',
				   pError_location 	  => 60,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME || ': LoadAllA2A') ;		
				   RAISE ;
	END ;
	
	
	/* assumption is virtuals will always get default values which likely be the case.
	   therefore don't waste storage in amd_part_factors and process separately.
	   Just check status of amd_sent_to_a2a to determine if part deleted or added.
	   If changed, do nothing as always same defaults.
	   If defaults do change can process all with doAllA2A passed as true */
	 
	PROCEDURE ProcessA2AVirtualLocs( pDoAllA2A boolean, pVirtSpoLocation amd_spare_networks.LOC_ID%TYPE ) IS
		CURSOR cur(pVirtSpoLocation VARCHAR2) IS
			SELECT asta.spo_prime_part_no, 
				   asta.action_code, 
				   asta.transaction_date, 
				   criticality_cleaned, 
				   criticality, 
				   criticality_changed,
				   ansi.last_update_dt,
				   nsi_sid, 
				   pVirtSpoLocation spo_location 
			FROM amd_sent_to_a2a asta, amd_national_stock_items ansi
			WHERE asta.part_no = asta.spo_prime_part_no 
			AND ansi.prime_part_no = asta.spo_prime_part_no 
			AND ansi.action_code != Amd_Defaults.DELETE_ACTION
			ORDER BY nsi_sid ;  
			  	 
			
		mtdRec mtd_rec ;	 	  
		crit amd_national_stock_items.criticality%TYPE ;
		lastNsiSid amd_national_stock_items.nsi_sid%TYPE := -333 ;
		batchStart DATE := nvl(amd_batch_pkg.getLastStartTime, to_date('01/01/2100', 'MM/DD/YYYY') );
		critHasChanged boolean := false ;
	BEGIN
		mtdRec := AutoDefaultMtd ; 
		FOR rec IN cur(pVirtSpoLocation) 
		LOOP
			critHasChanged := false ;
			IF ( rec.criticality_changed = 'Y' AND rec.last_update_dt >= batchStart ) THEN
			   critHasChanged := true ;
			END IF ;
			IF (lastNsiSid != rec.nsi_sid) THEN		   		    
			   	crit := DetermineCriticality(amd_preferred_pkg.GetPreferredValue(rec.criticality_cleaned, rec.criticality), rec.nsi_sid  );
			END IF ;	
			IF ( pDoAllA2A ) THEN
		   		InsertTmpA2A_PF(
		 			rec.spo_prime_part_no,
		 			rec.spo_location,
		 			null,  -- mtbdr 
		 			null,  -- mttr
					mtdRec.nrts,
					mtdRec.rts,
		 			mtdRec.condemn,
					crit,
		 			AMD_DEFAULTS.INSERT_ACTION,
	 			SYSDATE 
				)	;
			ELSIF ( rec.action_code = Amd_Defaults.INSERT_ACTION AND rec.transaction_date >= batchStart )THEN
			   InsertTmpA2A_PF(
		 			rec.spo_prime_part_no,
		 			rec.spo_location,
		 			null,  -- mtbdr 
		 			null,  -- mttr 
					mtdRec.nrts,
					mtdRec.rts,
		 			mtdRec.condemn,				
					crit,
		 			AMD_DEFAULTS.INSERT_ACTION,
	 			   SYSDATE 
				  ) ;
			ELSIF ( rec.action_code = Amd_Defaults.DELETE_ACTION AND rec.transaction_date >= batchStart  ) THEN
				-- if action_code deleted, do nothing since part info deletes part  
			   InsertTmpA2A_PF(
		 			rec.spo_prime_part_no,
		 			rec.spo_location,
		 			null,  -- mtbdr 
		 			null,  -- mttr 
					mtdRec.nrts,
					mtdRec.rts,
		 			mtdRec.condemn,				
					crit,
		 			AMD_DEFAULTS.DELETE_ACTION,
	 			   SYSDATE 
				  ) ;	   
			ELSIF (rec.action_code != Amd_Defaults.DELETE_ACTION AND critHasChanged) THEN
			   InsertTmpA2A_PF(
		 			rec.spo_prime_part_no,
		 			rec.spo_location,
		 			null,  -- mtbdr 
		 			null,  -- mttr 
					mtdRec.nrts,
					mtdRec.rts,
		 			mtdRec.condemn,				
					crit,
		 			AMD_DEFAULTS.UPDATE_ACTION,
	 			   SYSDATE 
				  ) ;	   
			END IF ;				   
			lastNsiSid := rec.nsi_sid ;
		END LOOP ;
		COMMIT ;
	END ;
	
	PROCEDURE ProcessA2AVirtualLocs IS
		 doAllA2A boolean := false ;	  
	BEGIN
		  ProcessA2AVirtualLocs(doAllA2A, amd_location_part_leadtime_pkg.VIRTUAL_UAB_SPO_LOCATION) ;
	  	  ProcessA2AVirtualLocs(doAllA2A, amd_location_part_leadtime_pkg.VIRTUAL_COD_SPO_LOCATION) ;
	END ;
	
	
	PROCEDURE LoadTmpAmdPartFactors(pAmdLocId  IN  amd_spare_networks.loc_id%TYPE ) IS
	BEGIN
		 LoadTmpAmdPartFactors(pAmdLocId, pAmdLocId ) ;
	END ;
	
	
	PROCEDURE LoadTmpAmdPartFactors IS
		 NO_BSSM_SRAN varchar2(6) := null ;
	BEGIN
		 mta_truncate_table('tmp_amd_part_factors','reuse storage');
		 mta_truncate_table('tmp_a2a_part_factors','reuse storage') ;
		 	  -- mob and fsls 
		 LoadTmpAmdPartFactorsByLocType('MOB') ;
	 	 LoadTmpAmdPartFactorsByLocType('FSL') ;
		 	  -- whse - bssm 'W'', amd 'CTLATL' 
		 LoadTmpAmdPartFactors(amd_defaults.AMD_WAREHOUSE_LOCID, amd_defaults.BSSM_WAREHOUSE_SRAN ) ;
		 LoadTmpAmdPartFactors(amd_defaults.AMD_UK_LOC_ID ) ;
		 LoadTmpAmdPartFactors(amd_defaults.AMD_BASC_LOC_ID ) ;
			 
	END ;
	
	
	PROCEDURE LoadInitial IS
		 returnCode NUMBER ;	  
		 doAllA2A boolean := true ;	 
	BEGIN
		 mta_truncate_table('amd_part_factors','reuse storage');
		 COMMIT ;
		 LoadTmpAmdPartFactors ;
		 INSERT INTO amd_part_factors
		 	SELECT * FROM tmp_amd_part_factors ;
		 COMMIT ;
		 LoadAllA2A ;
		 ProcessA2AVirtualLocs(doAllA2A, amd_location_part_leadtime_pkg.VIRTUAL_UAB_SPO_LOCATION ) ;
		 ProcessA2AVirtualLocs(doAllA2A, amd_location_part_leadtime_pkg.VIRTUAL_COD_SPO_LOCATION ) ;
	EXCEPTION WHEN OTHERS THEN
	  returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadInitial',
				   pTableName  	  	  => 'tmp_amd_part_factors',
				   pError_location 	  => 70,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',		   
				   pData			  => '',
				   pComments		  => PKGNAME || ': LoadInitial') ;		
				   RAISE ;
	END ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_part_factors_pkg', 
		 		pError_location => 80, pKey1 => 'amd_part_factors', pKey2 => '$Revision:   1.6  $') ;
	end version ;

END AMD_PART_FACTORS_PKG ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_PARTPRIME_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.6  $
     $Date:   Jun 09 2006 12:07:14  $
    $Workfile:   AMD_PARTPRIME_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PARTPRIME_PKG.pkb.-arc  $
/*   
/*      Rev 1.6   Jun 09 2006 12:07:14   zf297a
/*   implemented interface version
/*   
/*      Rev 1.5   Jun 07 2006 09:19:48   zf297a
/*   Optimizie DiffToPartPrime to send only parts that need to be sent rather than all the parts.
/*   
/*      Rev 1.4   Jun 05 2006 10:55:12   zf297a
/*   Enhanced error reporting.  For DiffPartToPrime if not all the valid parts have been sent, then execute a2a_pkg.initA2APartInfo
/*   
/*      Rev 1.3   Feb 03 2006 08:04:04   zf297a
/*   Converted to use the new amd_rbl_pairs table
/*   
/*      Rev 1.2   Dec 15 2005 12:14:34   zf297a
/*   Added truncate of table tmp_a2a_part_alt_rel_delete to DiffPartToPrime
/*   
/*      Rev 1.1   Dec 06 2005 10:27:20   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*   
/*      Rev 1.0   Dec 01 2005 09:41:48   zf297a
/*   Initial revision.
*/
/* need to resolve - what if new_nsn is not a prime in amd ????? */
/*  need to clean up and streamline logic on this package */

	PKGNAME CONSTANT VARCHAR2(30) := 'AMD_PARTPRIME_PKG' ;
	
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_partprime_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;

	procedure ErrorMsg(
				pTableName in amd_load_status.TABLE_NAME%TYPE,
				pError_location in amd_load_details.DATA_LINE_NO%TYPE,
				pKey1 in varchar2 := '',
				pKey2 in varchar2 := '',
				pKey3 in varchar2 := '',
				pKey4 in varchar2 := '',
				pComments in varchar2 := '')  IS
	BEGIN
		ROLLBACK; -- rollback may not be complete if running with mDebug set to true
		amd_utils.InsertErrorMsg (
				pLoad_no => amd_utils.GetLoadNo(pSourceName => 'amd_partprime_pkg',	pTableName  => pTableName),
				pData_line_no => pError_location,
				pData_line    => 'amd_partprime_pkg',
				pKey_1 => substr(pKey1,1,50),
				pKey_2 => substr(pKey2,1,50),			
				pKey_3 => substr(pKey3,1,50),
				pKey_4 => substr(pKey4,1,50),
				pKey_5 => to_char(sysdate,'MM/DD/YYYY HH:MI:SS AM'),
				pComments => 'sqlcode('||sqlcode||') sqlerrm('||sqlerrm||') ' || pComments);
		COMMIT;
	END errorMsg ;
	
	
	FUNCTION getNsiSid(pNsn VARCHAR2)
			 RETURN NUMBER IS
		retNsiSid NUMBER ;
	BEGIN
		SELECT nsi_sid INTO retNsiSid
			   FROM amd_nsns an
			   WHERE  an.nsn = pNsn ;
		RETURN retNsiSid ;
	EXCEPTION WHEN NO_DATA_FOUND THEN
		RETURN null ;	
	END ;	
	
	
	FUNCTION getSuperPrimePartByNsiSid(pNsiSid NUMBER) 
			 RETURN VARCHAR2 IS
		retPrimePart amd_national_stock_items.prime_part_no%TYPE := null;
		partNo amd_spare_parts.part_no%TYPE ; 	 		 
	BEGIN
		SELECT prime_part_no INTO partNo
			FROM amd_national_stock_items
			WHERE nsi_sid = pNsiSid
			AND action_code != Amd_Defaults.DELETE_ACTION  ;
	   	return getSuperPrimePart(partNo) ;				 
	EXCEPTION 
			  WHEN NO_DATA_FOUND THEN
			  	   return null ;
			  when others then	 
		 		   ErrorMsg(
				   pTableName  	  	  => 'amd_national_stock_items',
				   pError_location 	  => 10,
				   pKey1			  => 'pNsiSid=' || to_char(pNsiSid) ) ;
				   RAISE ;	  		  			  	
	END getSuperPrimePartByNsiSid;
	
	FUNCTION getSuperPrimePartRBL(pNsn VARCHAR2) 
			 RETURN VARCHAR2 IS
		 retPrimePart amd_national_stock_items.prime_part_no%TYPE := null;
		 nsiSid NUMBER ;	 
	BEGIN
		 nsiSid := getNsiSid(pNsn) ;
		 SELECT ansi.prime_part_no INTO retPrimePart
		 		FROM amd_rbl_pairs brp, amd_nsns an, amd_national_stock_items ansi
		 		WHERE brp.old_nsn in (SELECT nsn FROM amd_nsns WHERE nsi_sid = nsiSid)  
		 		AND brp.new_nsn = an.nsn
				and brp.ACTION_CODE != Amd_defaults.DELETE_ACTION 
		 		AND an.nsi_sid = ansi.nsi_sid AND ansi.action_code != Amd_Defaults.DELETE_ACTION;			
		 RETURN retPrimePart ;
	EXCEPTION 
			  WHEN NO_DATA_FOUND THEN
		 	  	   RETURN null ;
			  when others then	 
		 		   ErrorMsg(
				   pTableName  	  	  => 'amd_rbl_pairs/amd_nsns',
				   pError_location 	  => 20,
				   pKey1			  => 'pNsn=' || pNsn) ;
				   RAISE ;	  		  			  	
	END getSuperPrimePartRBL ;
	
	
	FUNCTION getPrimePartAMD(pNsn VARCHAR2)
			 RETURN VARCHAR2 IS
		 retPrimePart amd_national_stock_items.prime_part_no%TYPE := null;
	BEGIN
		 SELECT ansi.prime_part_no INTO retPrimePart
		 		FROM amd_national_stock_items ansi, amd_nsns an
		 		WHERE an.nsn = pNsn AND an.nsi_sid = ansi.nsi_sid AND ansi.action_code != Amd_Defaults.DELETE_ACTION;			
		 RETURN retPrimePart ;
	EXCEPTION 
			  WHEN NO_DATA_FOUND THEN
		 	  	   RETURN null ;
			  when others then	 
		 		   ErrorMsg(
				   pTableName  	  	  => 'amd_national_stock_items',
				   pError_location 	  => 30,
				   pKey1			  => 'pNsn=' || pNsn) ;
				   RAISE ;	  		  			  	
	END getPrimePartAMD ;	 
	
	
	FUNCTION getNsn(pPart VARCHAR2)
			 RETURN VARCHAR2 IS
		retNsn amd_nsns.nsn%TYPE ;
	BEGIN
		 SELECT nsn INTO retNsn
	 		FROM amd_spare_parts asp
			WHERE asp.part_no = pPart AND action_code != Amd_Defaults.DELETE_ACTION; 
		 RETURN retNsn ;	
	EXCEPTION 
			  WHEN NO_DATA_FOUND THEN
		 	  	   RETURN null ; 		
			  when others then	 
		 		   ErrorMsg(
				   pTableName  	  	  => 'amd_spare_parts',
				   pError_location 	  => 40,
				   pKey1			  => 'pPart=' || pPart) ;
				   RAISE ;	  		  			  	
	END ;		
	
	/* RBL new_nsn sometimes did not meet the minimum requirements to be
	   sent over as A2A (e.g. SMR Code did not end in 'T')
	   Easiest affirmation of minimum reqs is checking if active part in
	   amd_sent_to_a2a table */
	FUNCTION MeetMinA2AReqs(pPart VARCHAR2)
			 RETURN boolean IS
		tmpPart amd_spare_parts.part_no%TYPE ; 	 
	BEGIN
		SELECT part_no INTO tmpPart
			FROM amd_sent_to_a2a
			WHERE part_no = pPart AND action_code != Amd_Defaults.DELETE_ACTION;
		RETURN true ;	
	EXCEPTION 
			  WHEN NO_DATA_FOUND THEN
			  	RETURN false ;	
			  when others then	 
		 		   ErrorMsg(
				   pTableName  	  	  => 'amd_sent_to_a2a',
				   pError_location 	  => 50,
				   pKey1			  => 'pPart=' || pPart) ;
				   RAISE ;	  		  			  	
	END MeetMinA2AReqs ;
	
	/*  main function with the business logic, try to keep most of it here */
	FUNCTION getSuperPrimePart(pPart VARCHAR2) 
			 RETURN VARCHAR2 IS
		retPrimePart amd_national_stock_items.prime_part_no%TYPE := null;
		nsn amd_spare_parts.nsn%TYPE ;
	BEGIN
		nsn := getNsn(pPart) ;
		IF ( nsn IS NOT NULL ) THEN 
		   retPrimePart := getSuperPrimePartRBL(nsn) ;
		   IF ( (retPrimePart IS NULL) OR (NOT MeetMinA2AReqs(retPrimePart)) ) THEN
		   	  retPrimePart := getPrimePartAMD(nsn) ;
		   END IF ;	  
		END IF ;		   
	    RETURN retPrimePart ;
	exception when others then
	  ErrorMsg(
	   pTableName  	  	  => 'getSuperPrimePart',
	   pError_location 	  => 60,
	   pKey1			  => 'pPart=' || pPart) ;
	   RAISE ;	  		  			  	
	
	END ;
	
	
	
	FUNCTION getSuperPrimeNsiSidByNsn(pNsn VARCHAR2) 
			 RETURN NUMBER IS
			 retNsiSid NUMBER := NULL ;
			 prime amd_spare_parts.part_no%TYPE ;
	BEGIN	
			 prime := getPrimePartAMD(pNsn) ; 
			 IF (prime IS NULL ) THEN
			 	return NULL ;
			 ELSE	
			 	prime := getSuperPrimePart(prime) ;	
			 END IF ;		 		 		 
			 return amd_utils.GetNsiSidFromPartNo(prime) ;	
	EXCEPTION 
			  WHEN no_data_found THEN
			  	   return null ;
			 when others then
				  ErrorMsg(
				   pTableName  	  	  => 'getSuperPrimeNsiSidByNsn',
				   pError_location 	  => 70,
				   pKey1			  => 'pNsn=' || pNsn) ;
				   RAISE ;	  		  			  	
	END getSuperPrimeNsiSidByNsn ;		 
			  
	
	FUNCTION getSuperPrimeNsiSid(pPart VARCHAR2)
			 RETURN NUMBER IS
		 retNsiSid NUMBER := NULL ;	 
		 prime amd_spare_parts.part_no%TYPE ;
	BEGIN
		 prime := getSuperPrimePart(pPart) ;
		 IF (prime IS NOT NULL ) THEN
		 	 retNsiSid := amd_utils.GetNsiSidFromPartNo(prime) ;
		 END IF ;		
		 RETURN retNsiSid ;
	exception when others then
				  ErrorMsg(
				   pTableName  	  	  => 'getSuperPrimeNsiSid',
				   pError_location 	  => 80,
				   pKey1			  => 'pPart=' || pPart) ;
				   RAISE ;	  		  			  	
	END getSuperPrimeNsiSid;		 
			
	FUNCTION getSuperPrimeNsiSidByNsiSid(pNsiSid NUMBER) 
			 RETURN NUMBER  IS
		 retNsiSid NUMBER := NULL ;	
		 tmpNsn amd_nsns.nsn%TYPE ; 
	BEGIN
		 SELECT nsn INTO tmpNsn
		 		FROM amd_national_stock_items 
				WHERE nsi_sid = pNsiSid AND action_code != Amd_Defaults.DELETE_ACTION ;
		 RETURN getSuperPrimeNsiSidByNsn(tmpNsn) ;
	EXCEPTION 
		 WHEN NO_DATA_FOUND THEN
		 	  RETURN null ;	 
		 when others then
			  ErrorMsg(
			   pTableName  	  	  => 'getSuperPrimeNsiSidByNsiSid',
			   pError_location 	  => 90,
			   pKey1			  => 'pNsiSid=' || to_char(pNsiSid)) ;
			   RAISE ;	  		  			  	
	END getSuperPrimeNsiSidByNsiSid ;		
			 
	PROCEDURE updatePrimeASTA(pPart VARCHAR2, pSpoPrimePart VARCHAR2, pDate DATE) IS
	BEGIN
		 UPDATE amd_sent_to_a2a
		 SET	spo_prime_part_no = pSpoPrimePart,
		 		spo_prime_part_chg_date = pDate
		 WHERE  part_no = pPart ;
	exception
		 when others then
			  ErrorMsg(
			   pTableName  	  	  => 'amd_sent_to_a2a',
			   pError_location 	  => 100,
			   pKey1			  => 'pPart=' || pPart,
			   pKey2			  => 'pSpoPrimePart=' || pSpoPrimePart,
			   pkey3			  => 'pDate=' || to_char(pDate,'MM/DD/YYYY HH:MI:SS AM')) ;
			   RAISE ;	  		  			  	
	END updatePrimeASTA; 		 
	
	PROCEDURE InsertA2A_PartAltRelDel(pPart VARCHAR2, pPrime VARCHAR2) IS
		 partCage amd_spare_parts.mfgr%TYPE := null ;
		 primeCage amd_spare_parts.mfgr%TYPE := null ;
	BEGIN
	 	 <<getPartCage>>
	 	 begin
			 SELECT mfgr INTO partCage
			 	 FROM amd_spare_parts 
			 	 WHERE part_no = pPart ;
		 exception when others then
			  ErrorMsg(pTableName => 'amd_spare_parts', pError_location 	  => 110,
			   pKey1 => 'pPart=' || pPart) ;
		      RAISE ;	  		  			  			 
		 end getPartCage;
		 
		 <<getPrimeCage>> 
	 	 begin
		 	 SELECT mfgr INTO primeCage
			 	 FROM amd_spare_parts 
			 	 WHERE part_no = pPrime ;
		 exception when others then
			  ErrorMsg(pTableName => 'amd_spare_parts', pError_location 	  => 120,
			   pKey1 => 'pPart=' || pPart) ;
		      RAISE ;	  		  			  			 
		 end getPrimeCage ; 
		 
		 <<insertTmpA2APartAltRelDelete>>
		 begin 	  
			 	 INSERT INTO tmp_a2a_part_alt_rel_delete
			 	 (
			 	  	part_no, cage_code, prime_part,prime_cage, last_update_dt 
			 	 )
			 	 VALUES 
			 	 (
			 	  	pPart, partCage, pPrime, primeCage, sysdate 	
			 	 ) ;
		EXCEPTION 
			  WHEN DUP_VAL_ON_INDEX THEN
			  	 begin
				 	 UPDATE tmp_a2a_part_alt_rel_delete
					 SET	cage_code = partCage,
					 		prime_cage = primeCage
					 WHERE part_no    = pPart AND
					 	   prime_part = pPrime ;
				 exception when others then	   		   	 	
					  ErrorMsg(
					   pTableName  	  	  => 'tmp_a2a_part_alt_rel_delete',
					   pError_location 	  => 130,
					   pKey1			  => 'pPart=' || pPart,
					   pKey2			  => 'pPrime=' || pPrime) ;
					   RAISE ;	  		  			  	
				 end ;
			 when others then	   		   	 	
				  ErrorMsg(
				   pTableName  	  	  => 'tmp_a2a_part_alt_rel_delete',
				   pError_location 	  => 140,
				   pKey1			  => 'pPart=' || pPart,
				   pKey2			  => 'pPrime=' || pPrime) ;
				   RAISE ;	  		  			  	
		 END insertTmpA2APartAltRelDelete ;
		 
	END InsertA2A_PartAltRelDel ; 
	 
	FUNCTION getSuperPrimeNsiSidByNsn_A2A(pNsn VARCHAR2) RETURN NUMBER IS
		retNsiSid NUMBER := NULL ;	 
		prime amd_spare_parts.part_no%TYPE ;
	BEGIN
		prime := getPrimePartAMD(pNsn) ; 
		prime := getSuperPrimePart(prime) ;
		IF (prime IS NULL ) THEN
			RETURN null ;
		ELSIF (NOT MeetMinA2AReqs(prime)) THEN
			RETURN null ;		
		END IF ; 		 
		return amd_utils.GetNsiSidFromPartNo(prime) ;	
	EXCEPTION 
			  WHEN no_data_found THEN
			  	return null ;
			  when others then	 
				  ErrorMsg(
				   pTableName  	  	  => 'getSuperPrimeNsiSidByNsn_A2A',
				   pError_location 	  => 150,
				   pKey1			  => 'pNsn=' || pNsn) ;
				   RAISE ;	  		  			  	
	END getSuperPrimeNsiSidByNsn_A2A ; 
	 
	PROCEDURE DiffPartToPrime IS
		CURSOR getCandidates_cur IS
			   SELECT part_no, spo_prime_part_no
			   FROM amd_sent_to_a2a asta
			   WHERE asta.action_code != Amd_Defaults.DELETE_ACTION;
		latestPrime amd_spare_parts.part_no%TYPE ;
	    status NUMBER ;
		function areAllPartsSent return boolean is
				 PossibleValidPartsCount number ;
				 currentValidPartsCount number ;
		begin
			 select count(part_no) into possibleValidPartsCount 
			 from amd_spare_parts 
			 where action_code <> amd_defaults.DELETE_ACTION 
			 and a2a_pkg.isPartValidYorN(part_no) = 'Y' ;
			 
			 select count(*) into currentValidPartsCount 
			 from amd_sent_to_a2a 
			 where action_code <> amd_defaults.DELETE_ACTION ;
			 
			 return currentValidPartsCount >= possibleValidPartsCount ;
		end areAllPartsSent ;
		
		procedure sendParts is
				  partsToSend a2a_pkg.partCur ;
		begin
				  open partsToSend for
					SELECT sp.mfgr,
				      sp.part_no,
				      sp.NOMENCLATURE,
				      sp.nsn,
				      sp.order_lead_time,
				      sp.order_lead_time_defaulted,
				      sp.unit_cost,
				      sp.unit_cost_defaulted,
				      sp.unit_of_issue,
				      nsi.unit_cost_cleaned,
				      nsi.order_lead_time_cleaned,
				      nsi.planner_code,
				      nsi.planner_code_cleaned,
				      nsi.mtbdr,
				      nsi.mtbdr_cleaned,
				      nsi.smr_code,
				      nsi.smr_code_cleaned,
				      nsi.smr_code_defaulted,
				      nsi.nsi_sid,
				      nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND,
				      CASE 
					  WHEN TRUNC(sp.last_update_dt) >= TRUNC(nsi.last_update_dt)
						THEN sp.last_update_dt
					  ELSE
						nsi.LAST_UPDATE_DT
				      END AS last_update_dt,
				    CASE 
					WHEN sp.action_code = nsi.action_code
						THEN sp.action_code
					ELSE
						CASE 
							WHEN sp.action_code = 'D' OR nsi.action_code = 'D'
								THEN 'D'
							WHEN sp.action_code = 'C' OR nsi.action_code = 'C'
								THEN 'C'
							ELSE
								'A'
						END
					END AS action_code
				  FROM AMD_SPARE_PARTS sp,
				    AMD_NATIONAL_STOCK_ITEMS nsi
				  WHERE
				  sp.part_no in (select part_no from amd_spare_parts where action_code <> amd_defaults.DELETE_ACTION and a2a_pkg.isPartValidYorN(sp.part_no) = 'Y'
				                 minus
								 select part_no from amd_sent_to_a2a where action_code <> amd_defaults.DELETE_ACTION)			   
				  and sp.nsn = nsi.nsn ;
			a2a_pkg.processParts(partsToSend) ;
			close partsToSend ;
		end sendParts ;
			  
		 
	BEGIN
		if not areAllPartsSent then
		   sendParts ; -- make sure all parts get sent
		end if ;
		Mta_Truncate_Table('tmp_a2a_part_alt_rel_delete','reuse storage'); 	 
	    FOR a2aRec IN getCandidates_cur 
		LOOP
			BEGIN	
		        latestPrime := getSuperPrimePart(a2aRec.part_no) ;	
				    -- should never really occur 						
				IF ( latestPrime IS NULL ) THEN
				   RAISE NO_DATA_FOUND ;
				END IF ;   			
					-- case for just added part
				IF ( a2aRec.spo_prime_part_no IS NULL ) THEN		  
				     updatePrimeASTA(a2aRec.part_no, latestPrime, null) ;		  
				ELSE 
					 IF ( a2aRec.spo_prime_part_no != latestPrime ) THEN
				   	 	InsertA2A_PartAltRelDel(a2aRec.part_no, a2aRec.spo_prime_part_no) ;
						status := a2a_pkg.createPartInfo(a2aRec.part_no, Amd_Defaults.INSERT_ACTION) ;				
						updatePrimeASTA(a2aRec.part_no, latestPrime, sysdate ) ;
						-- if previously spo prime part record, catch event of changed prime	
						-- important for those tables with nsi_sid
						IF ( a2aRec.spo_prime_part_no = a2aRec.part_no ) THEN
						   amd_demand.prime_part_change(a2aRec.spo_prime_part_no, latestPrime) ;
						END IF ;			
				     END IF ;
				END IF ;  
			EXCEPTION WHEN OTHERS THEN
		 		   ErrorMsg(
					   pTableName  	  	  => 'amd_sent_to_a2a',
					   pError_location 	  => 160,
					   pKey1			  => 'partNo: <' || a2aRec.part_no || '>',
		   			   pKey2			  => 'currentSpoPrime:<' || a2aRec.spo_prime_part_no || '>',
					   pKey3			  => 'latestPrime: <' || latestPrime || '>') ;		   
				   RAISE ;	  		  			  	
			END ;	 	 
		END LOOP ;
		COMMIT ;	
	END ;		 
  
	procedure version is
	begin
		 writeMsg(pTableName => 'amd_partprime_pkg', 
		 		pError_location => 170, pKey1 => 'amd_partprime_pkg', pKey2 => '$Revision:   1.6  $') ;
	end version ;
  

 
END AMD_PARTPRIME_PKG ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_org_deployment_pkg AS
/*
      $Author:   zf297a  $
    $Revision:   1.2  $
     $Date:   Jun 09 2006 12:38:20  $
    $Workfile:   amd_org_deployment_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_org_deployment_pkg.pkb-arc  $
/*   
/*      Rev 1.2   Jun 09 2006 12:38:20   zf297a
/*   implemented version
/*   
/*      Rev 1.1   Dec 01 2005 09:39:04   zf297a
/*   added pvcs keywords
*/

	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_org_deployment_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
  PROCEDURE load_org_deployment IS

  BEGIN
 -- We want to completely overwrite the stuff over in SPO because there's not
 -- that many records (20) at the time of this program creation.
 --   1)  Delete the deletes ('D') from previous runs in
 --       tmp_a2a_org_deployment table.
 --   2)  Update the adds ('A's) from previous run to
 --       'D' for deletes to refresh SPO.
 --   3)  Re run the query to pick up any new MOBs or FSLs
    DELETE FROM tmp_a2a_org_deployment
      WHERE action_code = 'D';

    UPDATE tmp_a2a_org_deployment
       SET action_code = 'D'
     WHERE action_code = 'A';

    INSERT INTO tmp_a2a_org_deployment
       (base_name, qty, action_code )
    SELECT a.spo_location, count(b.tail_no), 'A'
      FROM amd_spare_networks a,
           amd_ac_assigns b
     WHERE a.loc_sid = b.loc_sid
       AND a.loc_type = 'MOB'
       AND nvl(b.assignment_start,sysdate) <= sysdate
       AND nvl(b.assignment_end,sysdate) >= sysdate
     GROUP BY a.spo_location
     UNION
    SELECT spo_location, 0, 'A'
      FROM amd_spare_networks
     WHERE loc_type = 'FSL'
     GROUP BY spo_location;
  EXCEPTION
    WHEN others THEN
      rollback;
  END load_org_deployment;
  
	procedure version is
	begin
		 writeMsg(pTableName => 'amd_org_deployment_pkg', 
		 		pError_location => 10, pKey1 => 'amd_org_deployment_pkg', pKey2 => '$Revision:   1.2  $') ;
	end version ;

END amd_org_deployment_pkg;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_on_order_date_filters_pkg AS
/******************************************************************************
       $Author:   zf297a  $
     $Revision:   1.4  $
         $Date:   Jun 09 2006 12:34:12  $
     $Workfile:   AMD_ON_ORDER_DATE_FILTERS_PKG.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_ON_ORDER_DATE_FILTERS_PKG.pkb.-arc  $
/*   
/*      Rev 1.4   Jun 09 2006 12:34:12   zf297a
/*   implemented version
/*   
/*      Rev 1.3   May 17 2006 14:58:36   zf297a
/*   removed start_date - not needed
/*
/*      Rev 1.2   May 17 2006 14:21:24   zf297a
/*   Added setScheduledReceiptDateCalDays and
/*   getScheduledReceiptDateCalDays
/*
/*      Rev 1.1   May 17 2006 13:25:08   zf297a
/*   Implemented procedures and functions using amd_on_order_date_filters table.
/*
/*      Rev 1.0   May 17 2006 12:24:26   zf297a
/*   Initial revision.
******************************************************************************/


	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_on_order_date_filters_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	FUNCTION getOrderCreateDate(filter_name in amd_on_order_date_filters.FILTER_NAME%type, voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE IS
			 theDate date ;
	BEGIN
		 select order_create_date into theDate
		 from amd_on_order_date_filters
		 where filter_name = getOrderCreateDate.filter_name
		 and voucher_prefix = getOrderCreateDate.voucher_prefix ;
		 RETURN theDate ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getOrderCreateDate ;


	PROCEDURE setOrderCreateDate(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  					voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
								orderCreateDate IN amd_on_order_date_filters.ORDER_CREATE_DATE%type) IS
	BEGIN
		 update amd_on_order_date_filters
		 set order_create_date = orderCreateDate
		 where filter_name = setOrderCreateDate.filter_name
		 and voucher_prefix = setOrderCreateDate.voucher_prefix ;
	END setOrderCreateDate ;

	FUNCTION getScheduledReceiptDateFrom(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			 				voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE IS
			 theDate date ;
	BEGIN
		 select scheduled_receipt_date_from into theDate
		 from amd_on_order_date_filters
		 where filter_name = getScheduledReceiptDateFrom.filter_name
		 and voucher_prefix = getScheduledReceiptDateFrom.voucher_prefix ;
		 RETURN theDate ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getScheduledReceiptDateFrom ;

	FUNCTION getScheduledReceiptDateTo(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			 				voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE IS
			 theDate date ;
	BEGIN
		 select scheduled_receipt_date_to into theDate
		 from amd_on_order_date_filters
		 where filter_name = getScheduledReceiptDateTo.filter_name
		 and voucher_prefix = getScheduledReceiptDateTo.voucher_prefix ;
		 RETURN theDate ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getScheduledReceiptDateTo ;

	PROCEDURE setScheduledReceiptDates(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										fromDate IN DATE, toDate DATE) IS
	BEGIN
		 update amd_on_order_date_filters
		 set scheduled_receipt_date_from = fromDate,
		 scheduled_receipt_date_to = toDate,
		 calendar_days = null
		 where filter_name = setScheduledReceiptDates.filter_name
		 and voucher_prefix = setScheduledReceiptDates.voucher_prefix ;
	END setScheduledReceiptDates ;

	PROCEDURE setScheduledReceiptDateCalDays(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										calendar_days IN NUMBER) IS
	BEGIN
		 update amd_on_order_date_filters
		 set scheduled_receipt_date_from = null,
		 scheduled_receipt_date_to = null,
		 calendar_days = setScheduledReceiptDateCalDays.calendar_days
		 where filter_name = setScheduledReceiptDateCalDays.filter_name
		 and voucher_prefix = setScheduledReceiptDateCalDays.voucher_prefix ;
	END setScheduledReceiptDateCalDays ;

   	procedure getScheduledReceiptDateCalDays(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										calendar_days out amd_on_order_date_filters.CALENDAR_DAYS%type) IS
	BEGIN
		 select calendar_days into calendar_days
		 from amd_on_order_date_filters
		 where filter_name = getScheduledReceiptDateCalDays.filter_name
		 and voucher_prefix = getScheduledReceiptDateCalDays.voucher_prefix ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		 calendar_days := null ;
	END getScheduledReceiptDateCalDays ;

	PROCEDURE getOnOrderDateFilters(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
			  orderCreateDate 		  OUT amd_on_order_date_filters.ORDER_CREATE_DATE%type,
			  schedReceiptDateFrom 	  OUT amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_FROM%type,
			  schedReceiptDateTo 	  OUT amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_TO%type,
			  schedReceiptCalDays 	  OUT amd_on_order_date_filters.CALENDAR_DAYS%type) is
	BEGIN
		 select order_create_date, scheduled_receipt_date_from, scheduled_receipt_date_to, calendar_days
		 into orderCreateDate, schedReceiptDateFrom, schedReceiptDateTo, schedReceiptCalDays
		 from amd_on_order_date_filters
		 where filter_name = getOnOrderDateFilters.filter_name
		 and voucher_prefix = getOnOrderDateFilters.voucher_prefix ;
	END getOnOrderDateFilters ;

	PROCEDURE setOnOrderDateFilters(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
			  orderCreateDate 		  in amd_on_order_date_filters.ORDER_CREATE_DATE%type,
			  schedReceiptDateFrom 	  in amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_FROM%type,
			  schedReceiptDateTo 	  in amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_TO%type,
			  schedReceiptCalDays 	  in amd_on_order_date_filters.CALENDAR_DAYS%type) is
	BEGIN
		 begin
			 insert into amd_on_order_date_filters
			 (filter_name, voucher_prefix, order_create_date, scheduled_receipt_date_from, scheduled_receipt_date_to, calendar_days)
			 values( filter_name, voucher_prefix, orderCreateDate, schedReceiptDateFrom, schedReceiptDateTo, schedReceiptCalDays) ;
		 exception when standard.DUP_VAL_ON_INDEX then
		 	 update amd_on_order_date_filters
			 set order_create_date = orderCreateDate,
			 scheduled_receipt_date_from = schedReceiptDateFrom,
			 scheduled_receipt_date_to = schedReceiptDateTo,
			 calendar_days = schedReceiptCalDays
			 where filter_name = setOnOrderDateFilters.filter_name
			 and voucher_prefix = setOnOrderDateFilters.voucher_prefix ;
		 end ;
	END setOnOrderDateFilters ;

	FUNCTION isVoucher(voucher IN VARCHAR2) RETURN BOOLEAN IS
			theVoucher VARCHAR2(2) ;
	BEGIN
		 SELECT DISTINCT SUBSTR(gold_order_number,1,2) INTO theVoucher FROM AMD_ON_ORDER
		 WHERE LOWER(SUBSTR(gold_order_number,1,2)) = LOWER(isVoucher.voucher) ;
		 RETURN TRUE ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		 RETURN FALSE ;
	END isVoucher ;

	PROCEDURE clearOnOrderParams(filter_name in amd_on_order_date_filters.FILTER_NAME%type) IS
	BEGIN
		 update amd_on_order_date_filters
		 set order_create_date = null,
		 scheduled_receipt_date_from = null,
		 scheduled_receipt_date_to = null,
		 calendar_days = null
		 where filter_name = clearOnOrderParams.filter_name ;
	END clearOnOrderParams ;

	FUNCTION numberOfOnOrderParams(filter_name in amd_on_order_date_filters.FILTER_NAME%type) RETURN NUMBER IS
			 cnt NUMBER ;
	BEGIN
		SELECT COUNT(*) INTO cnt FROM AMD_ON_ORDER_DATE_FILTERS where filter_name = numberOfOnOrderParams.filter_name ;
		RETURN cnt ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		RETURN 0 ;
	END numberOfOnOrderParams ;

	FUNCTION getVouchers RETURN ref_cursor IS
		 vouchers_cursor ref_cursor ;
	BEGIN
		 OPEN vouchers_cursor FOR
		 SELECT DISTINCT SUBSTR(gold_order_number,1,2) voucher
		 FROM AMD_ON_ORDER
		 ORDER BY voucher ;
		 RETURN vouchers_cursor ;
	END getVouchers ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_on_order_date_filters_pkg', 
		 		pError_location => 10, pKey1 => 'amd_on_order_date_filters_pkg', pKey2 => '$Revision:   1.4  $') ;
	end version ;

END amd_on_order_date_filters_pkg;
/

show errors

CREATE OR REPLACE PACKAGE BODY Amd_Location_Part_Override_Pkg AS

 /*
      $Author:   zf297a  $
	$Revision:   1.38  $
        $Date:   Sep 05 2006 12:47:08  $
    $Workfile:   AMD_LOCATION_PART_OVERRIDE_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_LOCATION_PART_OVERRIDE_PKG.pkb.-arc  $
/*   
/*      Rev 1.38   Sep 05 2006 12:47:08   zf297a
/*   Renumbered pError_location's values
/*   
/*      Rev 1.37   Aug 31 2006 16:02:12   zf297a
/*   Added more exception handlers.  Added dbms_output to version procedure.
/*   
/*      Rev 1.36   Aug 31 2006 15:34:22   zf297a
/*   Replaced errorMsg function with errorMsg procedure
/*   
/*      Rev 1.35   Aug 31 2006 14:56:12   zf297a
/*   Added more when others exceptions
/*   fixed loadAllA2A to use the amd_sent_to_a2a action_code 
/*   
/*      Rev 1.34   Aug 31 2006 12:03:18   zf297a
/*   Used not exists instead of function inInTmpA2AYorN
/*   Used action_code from amd_sent_to_a2a in most cases
/*   
/*   
/*      Rev 1.33   Jul 17 2006 11:21:00   zf297a
/*   Added cursor_spoSum for warehouse.  This amount get subtracted from the spo_total_inventory
/*   
/*      Rev 1.32   Jun 16 2006 09:21:54   zf297a
/*   For LoadWhse added a cursor_rspSum which get summed with cursor_basesSum resulting in substracting out the rsp sum for the final tsl_override_qty that gets put into tmp_amd_location_part_override.
/*   
/*      Rev 1.31   Jun 12 2006 13:22:32   zf297a
/*   use symbolic constants UK_LOCATION and BASC_LOCATION.
/*   
/*      Rev 1.30   Jun 09 2006 11:56:00   zf297a
/*   implemented version
/*   
/*      Rev 1.29   Jun 07 2006 11:11:04   zf297a
/*   For the loadAll unioned amd_rsp_sum with amd_location_part_overrides to get the non zero tsl's.
/*   
/*      Rev 1.28   Jun 07 2006 09:45:06   zf297a
/*   for loadRspZeroTsl fixed the sql for the cursors where amd_location_part_override_pkg.isInTmpA2AYorN(spo_prime_part_no, mob || '_RSP') = 'N' is needed (the value was checked for was not all 'N''s and the mob was not concatenated with the literal '_RSP')
/*   
/*      Rev 1.27   Jun 03 2006 20:25:54   zf297a
/*   enhanced the use of writeMsg
/*   
/*      Rev 1.26   Jun 03 2006 19:09:54   zf297a
/*   added:
/*   and parts.action_code != amd_defaults.getDELETE_ACTION
/*   to the last open tsl cursor of procedure LoadZeroTslA2A
/*   
/*      Rev 1.25   Jun 03 2006 18:59:36   zf297a
/*   fixed procedure amd_location_part_override_pkg.LoadZeroTslA2A(pDoAllA2A BOOLEAN, pSpoLocation VARCHAR2,from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE) 
/*    to use select's similar to the following: 
/*    SELECT distinct primes.spo_prime_part_no,
/*      amd_defaults.getINSERT_ACTION,
/*      sysdate,
/*      theLocation spo_location,
/*      ansi.nsn,
/*      ansi.nsi_sid,
/*      0 override_qty
/*      FROM (select distinct spo_prime_part_no from amd_sent_to_a2a where action_code <> 'D') primes, 
/*      AMD_NATIONAL_STOCK_ITEMS ansi
/*      WHERE amd_location_part_override_pkg.isInTmpA2AYorN(primes.spo_prime_part_no, theLocation) = 'N'
/*      AND ansi.prime_part_no = primes.spo_prime_part_no
/*      AND ansi.action_code != Amd_Defaults.getDELETE_ACTION 
/*     
/*   and procedure amd_location_part_override_pkg.LoadZeroTslA2A(doAllA2A IN BOOLEAN := FALSE, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE) 
/*   
/*   was fixed by adding an additional invocation of 
/*   amd_location_part_override_pkg.LoadZeroTslA2A(pDoAllA2A BOOLEAN, pSpoLocation VARCHAR2,from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE) 
/*   
/*   for pSpoLocation equal to amd_location_part_override_pkg.THE_WAREHOUSE (FD2090).
/*   
/*   
/*      Rev 1.24   Jun 01 2006 22:20:24   zf297a
/*   Fiixed query for loadRspZeroTsl - added qualification for amd_spare_parts - part_no = spo_prime_part_no
/*   
/*      Rev 1.23   Jun 01 2006 12:01:14   zf297a
/*   Added writeMsg to the beginning of processTsl
/*   
/*      Rev 1.22   Jun 01 2006 10:57:52   zf297a
/*   Fixed loadRspZeroTsl's.  use amd_utils.writeMsg instead of dbms_output
/*   
/*      Rev 1.21   May 31 2006 08:20:46   zf297a
/*   Used Mta_Truncate_Table for loadAllA2A instead of truncateIfOld
/*   
/*      Rev 1.20   May 12 2006 14:00:36   zf297a
/*   For loadAllA2A include all action_codes and all parts that are in amd_sent_to_a2a  where the spo_prime_part_no is filled in too.
/*   
/*      Rev 1.19   Apr 28 2006 13:16:24   zf297a
/*   Implemented the loadRspZeroTslA2A
/*   
/*      Rev 1.18   Apr 21 2006 14:02:00   zf297a
/*   Made insertTmpA2ALPO public, so prototype could be removed.  Also made sure that insertTmpA2ALPO never updates an existing tmp_a2a record with a zero quantity.
/*   
/*      Rev 1.17   Apr 20 2006 13:23:00   zf297a
/*   Added an insertTmpA2A routine for the processTsl procedure.  This routine is used only to insert zero tsl's.  If a tmp_a2a row exists already, it is not overwritten.
/*   
/*      Rev 1.16   Mar 23 2006 09:08:56   zf297a
/*   Use truncateIfOld for tmp_a2a_loc_part_override - .  The table will get truncated if there is no active batch job or it will get truncated if there is an active batch job and the table has not changed since the batch job started.
/*   
/*      Rev 1.15   Mar 06 2006 08:37:34   zf297a
/*   Removed unused references to amd_batch_jobs
/*   
/*      Rev 1.14   Mar 05 2006 15:26:36   zf297a
/*   Added debug code.
/*   
/*      Rev 1.13   Mar 05 2006 14:16:24   zf297a
/*   Added amd_utils.debugMsg to record counts and procedure completion.
/*   Added enhanced processing to tsl's.
/*   
/*      Rev 1.12   Mar 03 2006 12:06:22   zf297a
/*   Moved boolean2Varchar2 to amd_utils.  Used amd_batch_pkg.getLastStartTime instead of amd_location_part_leadtime_pkg.getBatchRunStart.  This will retrieve the last batch start time even if the job has finished.  This way any data changed since the last batch job has been run, can have a2a transactions created for it.  (The only other choice with the previous method would be the "send all" method versus what has changed since the last batch start time).
/*   Added more qualification for the tsl cursor in procedure loadZeroTslA2APartsWithNoTsls
/*   
/*   
/*      Rev 1.11   Feb 24 2006 15:07:26   zf297a
/*   Streamlined routines handling TSL's.  Added some additional TSL loads.
/*   
/*      Rev 1.10   Feb 17 2006 09:25:10   zf297a
/*   Changed requisition_objective to demand_level
/*   
/*      Rev 1.9   Feb 15 2006 21:22:52   zf297a
/*   Added ref cursor's, type's and common process routines.
/*   
/*      Rev 1.8   Jan 03 2006 12:56:26   zf297a
/*   Added date range to procedures loadZeroTslA2AByDate and loadA2AByDate
/*   
/*      Rev 1.7   Jan 03 2006 09:13:06   zf297a
/*   Changed name from loadByDate to loadA2AByDate
/*   
/*      Rev 1.6   Dec 30 2005 01:20:08   zf297a
/*   add loadByDate
/*   
/*      Rev 1.5   Dec 15 2005 12:16:44   zf297a
/*   Added truncate table tmp_a2a_loc_part_override to LoadTmpAmdLocPartOverride
/*   
/*      Rev 1.4   Dec 06 2005 09:52:36   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*   
/*      Rev 1.3   Nov 15 2005 11:57:26   zf297a
/*   Add additional where clauses to load all the data.  Added return statement for insertedTmpA2ALPO.
/*   
/*      Rev 1.2   Nov 10 2005 11:08:24   zf297a
/*   Added global counters for insert, update, and delete and public getter's.
/*   
/*   Added a testData Cursor.
/*   
/*   Added counters and displaying of start/end messages for all the load routines.
/*   
/*      Rev 1.1   Oct 28 2005 12:46:04   zf297a
/*   Added check for wasPartSent before inserting to tmp_a2a_loc_part_override
/*   
/*      Rev 1.0   Oct 19 2005 12:40:56   zf297a
/*   Initial revision.
/*   
/*      Rev 1.0   Oct 18 2005 13:07:22   zf297a
/*   Initial revision.
		 */

	PKGNAME CONSTANT VARCHAR2(30) := 'AMD_LOCATION_PART_OVERRIDE_PKG' ;
	
	COMMIT_THRESHOLD CONSTANT NUMBER := 250 ;
	
	insertCnt NUMBER := 0 ;
	updateCnt NUMBER := 0 ;
	deleteCnt NUMBER := 0 ;
	
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_location_part_override_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	PROCEDURE ErrorMsg(
	    pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
	    pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
	    pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
	    pKey1 IN AMD_LOAD_DETAILS.KEY_1%TYPE := '',
	    pKey2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
	    pKey3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
	    pKey4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
	    pComments IN VARCHAR2 := '') IS
	 
	    key5 AMD_LOAD_DETAILS.KEY_5%TYPE := pComments ;
	 
	BEGIN
	  ROLLBACK;
	  IF key5 = '' THEN
	     key5 := pSqlFunction || '/' || pTableName ;
	  ELSE
	   key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
	  END IF ;
	  -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
	  -- do not exceed the length of the column's that the data gets inserted into
	  -- This is for debugging and logging, so efforts to make it not be the source of more
	  -- errors is VERY important
	  Amd_Utils.InsertErrorMsg (
	    pLoad_no => Amd_Utils.GetLoadNo(
	      pSourceName => SUBSTR(pSqlfunction,1,20),
	      pTableName  => SUBSTR(pTableName,1,20)),
	    pData_line_no => pError_location,
	    pData_line    => 'amd_location_part_override_pkg',
	    pKey_1 => SUBSTR(pKey1,1,50),
	    pKey_2 => SUBSTR(pKey2,1,50),
	    pKey_3 => SUBSTR(pKey3,1,50),
	    pKey_4 => SUBSTR(pKey4,1,50),
	    pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS') ||
	         ' ' || substr(key5,1,50),
	    pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
	    COMMIT;
	  
	EXCEPTION WHEN OTHERS THEN
	  if pSqlFunction is not null then dbms_output.put_line('pSqlFunction=' || pSqlfunction) ; end if ;
	  if pTableName is not null then dbms_output.put_line('pTableName=' || pTableName) ; end if ;
	  if pError_location is not null then dbms_output.put_line('pError_location=' || pError_location) ; end if ;
	  if pKey1 is not null then dbms_output.put_line('key1=' || pKey1) ; end if ;
	  if pkey2 is not null then dbms_output.put_line('key2=' || pKey2) ; end if ;
	  if pKey3 is not null then dbms_output.put_line('key3=' || pKey3) ; end if ;
	  if pKey4 is not null then dbms_output.put_line('key4=' || pKey4) ; end if ;
	  if pComments is not null then dbms_output.put_line('pComments=' || pComments) ; end if ;
	  raise ;
	END ErrorMsg;
	
	
	PROCEDURE UpdateAmdLocPartOverride (
	  		  pPartNo 			   		AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			  pLocSid 					AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			  pTslOverrideQty			AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE,
			  pTslOverrideUser			AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE,
			  pActionCode				AMD_LOCATION_PART_OVERRIDE.action_code%TYPE,
			  pLastUpdateDt				AMD_LOCATION_PART_OVERRIDE.last_update_dt%TYPE) IS
	BEGIN
		 	  UPDATE AMD_LOCATION_PART_OVERRIDE
			  SET
			  	  tsl_override_qty 			= pTslOverrideQty,
				  tsl_override_user  		= pTslOverrideUser,
				  action_code				= pActionCode,
				  last_update_dt			= pLastUpdateDt
			  WHERE
			  	  part_no = pPartNo AND
				  loc_sid = pLocSid ;
	exception when others then			  
		 ErrorMsg(
				   pSqlfunction 	  => 'UpdateAmdLocPartOverride',
				   pTableName  	  	  => 'amd_location_part_override',
				   pError_location => 10) ;
		 raise ;	
	END UpdateAmdLocPartOverride ;
	
	PROCEDURE UpdateTmpAmdLocPartOverride (
	  		  pPartNo 			   		AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			  pLocSid 					AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			  pTslOverrideQty			AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE,
			  pTslOverrideUser			AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE,
			  pActionCode				AMD_LOCATION_PART_OVERRIDE.action_code%TYPE,
			  pLastUpdateDt				AMD_LOCATION_PART_OVERRIDE.last_update_dt%TYPE) IS
	BEGIN
		 	  UPDATE TMP_AMD_LOCATION_PART_OVERRIDE
			  SET
			  	  tsl_override_qty 			= pTslOverrideQty,
				  tsl_override_user  		= pTslOverrideUser,
				  action_code				= pActionCode,
				  last_update_dt			= pLastUpdateDt
			  WHERE
			  	  part_no = pPartNo AND
				  loc_sid = pLocSid ;
		 exception when others then			  
		 ErrorMsg(
				   pSqlfunction 	  => 'UpdateTmpAmdLocPartOverride',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 20) ;
		 raise ;	
		 END UpdateTmpAmdLocPartOverride ;
	
	
	PROCEDURE InsertTmpAmdLocPartOverride (
			  pPartNo 			   		AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			  pLocSid 					AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			  pTslOverrideQty			AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE,
			  pTslOverrideUser			AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE,
			  pActionCode				AMD_LOCATION_PART_OVERRIDE.action_code%TYPE,
			  pLastUpdateDt				AMD_LOCATION_PART_OVERRIDE.last_update_dt%TYPE) IS
	BEGIN
		 INSERT INTO TMP_AMD_LOCATION_PART_OVERRIDE
		 (
		  		part_no,
				loc_sid,
				tsl_override_qty,
				tsl_override_user,
				action_code,
				last_update_dt
		 )
		 VALUES
		 (
		  		pPartNo,
				pLocSid,
				pTslOverrideQty,
				pTslOverrideUser,
				pActionCode,
				pLastUpdateDt
		 ) ;
	EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
		 	  UpdateTmpAmdLocPartOverride (
		   		  pPartNo,
		 		  pLocSid,
		 		  pTslOverrideQty,
		 		  pTslOverrideUser,
		 		  pActionCode,
		 		  SYSDATE ) ;
	  when others then			  
		 ErrorMsg(
				   pSqlfunction 	  => 'InsertTmpAmdLocPartOverride',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 30) ;
		raise ;
	END InsertTmpAmdLocPartOverride ;
	
	PROCEDURE InsertAmdLocPartOverride (
			  pPartNo 			   		AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			  pLocSid 					AMD_SPARE_NETWORKS.loc_sid%TYPE,
			  pTslOverrideQty			NUMBER,
			  pTslOverrideUser			VARCHAR2,
			  pActionCode				VARCHAR2,
			  pLastUpdateDt				DATE) IS
	BEGIN
		 INSERT INTO AMD_LOCATION_PART_OVERRIDE
		 (
		  		part_no,
				loc_sid,
				tsl_override_qty,
				tsl_override_user,
				action_code,
				last_update_dt
		 )
		 VALUES
		 (
		  		pPartNo,
				pLocSid,
				pTslOverrideQty,
				pTslOverrideUser,
				pActionCode,
				pLastUpdateDt
		 ) ;
	EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
		 	  UpdateAmdLocPartOverride (
		   		  pPartNo,
		 		  pLocSid,
		 		  pTslOverrideQty,
		 		  pTslOverrideUser,
		 		  pActionCode,
		 		  SYSDATE ) ;
	 when others then			  
		 ErrorMsg(
				   pSqlfunction 	  => 'InsertAmdLocPartOverride',
				   pTableName  	  	  => 'amd_location_part_override',
				   pError_location => 40) ;
		 raise ;
	END InsertAmdLocPartOverride ;
	
				  
	FUNCTION insertedTmpA2ALPO(rec IN TMP_A2A_LOC_PART_OVERRIDE%ROWTYPE) RETURN BOOLEAN IS
			 rc number ;
	BEGIN
		 RETURN insertedTmpA2ALPO(
				  rec.part_no,
				  rec.site_location,
				  rec.override_type,
				  rec.override_quantity,
				  rec.override_reason,
				  rec.override_user,
				  rec.begin_date,
				  rec.action_code,
				  rec.last_update_dt) ;
	exception when others then
			  
		 ErrorMsg(
				   pSqlfunction 	  => 'insertedTmpA2ALPO',
				   pTableName  	  	  => 'tmp_a2a_loc_part_override',
				   pError_location => 50,
				   pKey1			  => rec.part_no,
	   			   pKey2			  => rec.site_location,
				   pKey3			  => rec.action_code,
				   pComments		  => PKGNAME) ;
		RAISE ;
	END insertedTmpA2ALPO ;
	
	FUNCTION insertedTmpA2ALPO (
				  pPartNo			TMP_A2A_LOC_PART_OVERRIDE.part_no%TYPE,
				  pBaseName			TMP_A2A_LOC_PART_OVERRIDE.site_location%TYPE,
				  pOverrideType		TMP_A2A_LOC_PART_OVERRIDE.override_type%TYPE,
				  pTslOverrideQty	TMP_A2A_LOC_PART_OVERRIDE.override_quantity%TYPE,
				  pOverrideReason	TMP_A2A_LOC_PART_OVERRIDE.override_reason%TYPE,
				  pTslOverrideUser	TMP_A2A_LOC_PART_OVERRIDE.override_user%TYPE,
				  pBeginDate		TMP_A2A_LOC_PART_OVERRIDE.begin_date%TYPE,
				  pActionCode		TMP_A2A_LOC_PART_OVERRIDE.action_code%TYPE,
				  pLastUpdateDt		TMP_A2A_LOC_PART_OVERRIDE.last_update_dt%TYPE
				  ) RETURN BOOLEAN IS
				  
			rc number ;
			
	BEGIN
		BEGIN
			 IF A2a_Pkg.wasPartSent(pPartNo) AND pBaseName IS NOT NULL  THEN
				 INSERT INTO TMP_A2A_LOC_PART_OVERRIDE (
					  part_no,
					  site_location,
					  override_type,
					  override_quantity,
					  override_reason,
					  override_user,
					  begin_date,
					  action_code,
					  last_update_dt
				 )
				 VALUES
				 (
				 	  pPartNo,
					  pBaseName,
					  pOverrideType,
					  pTslOverrideQty,
					  pOverrideReason,
					  pTslOverrideUser,
					  pBeginDate,
					  pActionCode,
					  pLastUpdateDt
				 ) ;
			  RETURN TRUE ;
			ELSE
			  RETURN FALSE ;
			END IF ;
		EXCEPTION 
		  WHEN DUP_VAL_ON_INDEX THEN
			 IF pTslOverrideQty > 0 THEN
				 UPDATE TMP_A2A_LOC_PART_OVERRIDE
			 		SET
						  override_type		 = pOverrideType,
						  override_quantity	 = pTslOverrideQty,
						  override_reason	 = pOverrideReason,
						  override_user		 = pTslOverrideUser,
						  begin_date		 = pBeginDate,
						  action_code		 = pActionCode,
						  last_update_dt	 = pLastUpdateDt
					WHERE
						  part_no 			 = pPartNo AND
						  site_location		 = pBaseName ;
				RETURN TRUE ;
			ELSE
				RETURN FALSE ;
			END IF ;
		  WHEN others THEN
		  	   ErrorMsg(
				   pSqlfunction 	  	  => 'insertedTmpA2ALPO',
				   pTableName  	  	  => 'tmp_a2a_loc_part_override',
				   pError_location => 60,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pBaseName,
				   pKey3			  => pActionCode,
				   pComments		  => PKGNAME) ;
			RAISE ;
	
		END ;
	END insertedTmpA2ALPO ;
	
	
	
	FUNCTION InsertRow(
			pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			pTslOverrideQty				 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
			pTslOverrideUser			 AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
			RETURN NUMBER IS
		 returnCode NUMBER ;
	BEGIN
		 BEGIN
		    InsertAmdLocPartOverride (
		 	  pPartNo,
			  pLocSid,
			  pTslOverrideQty,
			  pTslOverrideUser,
			  Amd_Defaults.INSERT_ACTION,
			  SYSDATE ) ;
	
		 EXCEPTION WHEN OTHERS THEN
		 ErrorMsg(
				   pSqlfunction 	  	  => 'InsertRow.InsertAmdLocPartOverride',
				   pTableName  	  	  => 'amd_location_part_override',
				   pError_location => 70,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pComments		  => PKGNAME) ;
		 RAISE ;
	
		 END ;
		 BEGIN
		  	   IF insertedTmpA2ALPO(
				  pPartNo,
				  Amd_Utils.GetSpoLocation(pLocSid),
				  OVERRIDE_TYPE,
				  pTslOverrideQty,
				  OVERRIDE_REASON,
				  pTslOverrideUser,
				  SYSDATE,
				  Amd_Defaults.INSERT_ACTION,
				  SYSDATE
			    ) THEN
				 insertCnt := insertCnt + 1 ;
			END IF ;
	
	
		  END ;
		  RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		 ErrorMsg(
				   pSqlfunction => 'InsertRow.InsertTmpA2A_LPO',
				   pTableName  	  	  => 'tmp_a2a_loc_part_override',
				   pError_location => 80,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid) ;
		RAISE ;
	END InsertRow ;
	
	
	FUNCTION UpdateRow(
			pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			pTslOverrideQty				 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
			pTslOverrideUser			 AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
			RETURN NUMBER IS
			returnCode NUMBER ;
	BEGIN
		 BEGIN
		 	UpdateAmdLocPartOverride (
	  		  pPartNo,
			  pLocSid,
			  pTslOverrideQty,
			  pTslOverrideUser,
			  Amd_Defaults.UPDATE_ACTION,
			  SYSDATE ) ;
		 EXCEPTION WHEN OTHERS THEN
		 ErrorMsg(
				   pSqlfunction 	  	  => 'UpdateRow.InsertTmpA2A_LPO',
				   pTableName  	  	  => 'amd_location_part_override',
				   pError_location => 90,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid) ;
		 RAISE ;
		 END ;
		 BEGIN
			IF insertedTmpA2ALPO (
				  pPartNo,
				  Amd_Utils.GetSpoLocation(pLocSid),
				  OVERRIDE_TYPE,
				  pTslOverrideQty,
				  OVERRIDE_REASON,
				  pTslOverrideUser,
				  SYSDATE,
				  Amd_Defaults.UPDATE_ACTION,
				  SYSDATE
		   ) THEN
		   	 updateCnt := updateCnt + 1 ;
		 END IF ;
		 END ;
		 RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		 ErrorMsg(
				   pSqlfunction 	  	  => 'UpdateRow.InsertTmpA2A_LPO',
				   pTableName  	  	  => 'tmp_a2a_loc_part_override',
				   pError_location => 100,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid) ;
		RAISE ;
	END UpdateRow ;
	
	
	
	FUNCTION DeleteRow(
			pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
			pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
			pTslOverrideQty				 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
			pTslOverrideUser			 AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
			RETURN NUMBER IS
			returnCode NUMBER ;
	BEGIN
		 BEGIN
			 UpdateAmdLocPartOverride (
		  		  pPartNo,
				  pLocSid,
				  pTslOverrideQty,
				  pTslOverrideUser,
				  Amd_Defaults.DELETE_ACTION,
				  SYSDATE ) ;
		 EXCEPTION WHEN OTHERS THEN
		 ErrorMsg(
				   pSqlfunction 	  	  => 'DeleteRow.UpdateAmdLocPartOverride',
				   pTableName  	  	  => 'amd_location_part_override',
				   pError_location => 110,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid) ;
		 RAISE ;
		 END ;
		 BEGIN
		 	  -- deletion of parts handled by part info delete
		 	--IF (NOT amd_location_part_leadtime_pkg.IsPartDeleted(pPartNo)) THEN
		 		IF insertedTmpA2ALPO (
		 			  pPartNo,
		 			  Amd_Utils.GetSpoLocation(pLocSid),
		 			  OVERRIDE_TYPE,
		 			  pTslOverrideQty,
		 			  OVERRIDE_REASON,
		 			  pTslOverrideUser,
		 			  SYSDATE,
		 			  Amd_Defaults.DELETE_ACTION,
		 			  SYSDATE
		 	   ) THEN
			   deleteCnt := deleteCnt + 1 ;
			 END IF ;
			--END IF ;
		 END ;
	  	RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		 ErrorMsg(
				   pSqlfunction 	  	  => 'DeleteRow',
				   pTableName  	  	  => 'tmp_a2a_loc_part_override',
				   pError_location => 120,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid) ;
		RAISE ;
	END DeleteRow ;
	
	FUNCTION IsNumeric(pString VARCHAR2) RETURN VARCHAR2 IS
			 ret VARCHAR2(1) ;
			 I NUMBER ;
	BEGIN
		 BEGIN
		 	  IF pString IS NULL THEN
			  	 ret := 'N' ;
			  ELSE
			     I := TO_NUMBER(pString) ;
			     ret := 'Y' ;
			  END IF ;
		 EXCEPTION WHEN OTHERS THEN
		 	  ret := 'N' ;
		 END ;
		 RETURN ret ;
	END ;
	
	PROCEDURE LoadUK IS
	
		CURSOR cur_cand IS
			SELECT spo_prime_part_no part_no,
				  loc_sid
				  FROM AMD_SENT_TO_A2A asta, AMD_SPARE_NETWORKS asn
				  WHERE asta.part_no = asta.spo_prime_part_no
				  AND asn.loc_id = Amd_Defaults.AMD_UK_LOC_ID
				  AND asta.action_code != Amd_Defaults.DELETE_ACTION ;
	
	 	CURSOR cur_stock IS
			SELECT Amd_Partprime_Pkg.getSuperPrimePart(asp.part_no) part_no,
				   SUM(NVL(stock_level, 0)) tsl_override_qty
				  FROM WHSE w, AMD_SPARE_PARTS asp
				  WHERE w.part = asp.part_no
				  AND w.sc LIKE 'C17%CODUKBG'
		 	      AND asp.action_code != Amd_Defaults.DELETE_ACTION
				  GROUP BY	Amd_Partprime_Pkg.getSuperPrimePart(asp.part_no) ;
	
		returnCode NUMBER ;
		TYPE partNo_stock IS TABLE OF NUMBER INDEX BY AMD_SPARE_PARTS.part_no%TYPE  ;
		partNo_stockLevel partNo_stock ;
		tslOverrideQty AMD_LOCATION_PART_OVERRIDE.TSL_OVERRIDE_QTY%TYPE ;
		I NUMBER := 0 ;
		stock_cnt NUMBER := 0 ;
		cand_cnt NUMBER := 0 ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 130,
				pKey1 => 'LoadUK',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		BEGIN
			FOR rec IN cur_stock
			LOOP
				BEGIN
					 IF ( rec.part_no IS NOT NULL ) THEN
					 	partNo_stockLevel(rec.part_no) := rec.tsl_override_qty ;
					 END IF ;
				EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
				   	   pSqlfunction 	  	  => 'LoadUk',
					   pTableName  	  	  => 'tmp_amd_location_part_override',
					   pError_location => 140,
					   pKey1			  => 'partNo: ' || rec.part_no,
		   			   pKey2			  => 'qty: ' || rec.tsl_override_qty) ;
					RAISE ;
			   	END ;
				stock_cnt := stock_cnt + 1 ;
			END LOOP ;
			FOR rec IN cur_cand
			LOOP
				tslOverrideQty := 0 ;
				BEGIN
					tslOverrideQty := partNo_stockLevel(rec.part_no) ;
				EXCEPTION WHEN NO_DATA_FOUND THEN
					tslOverrideQty := 0 ;
				END ;
				BEGIN
					 InsertTmpAmdLocPartOverride(
					 	rec.part_no,
						rec.loc_sid,
						tslOverrideQty,
						NULL,
						Amd_Defaults.INSERT_ACTION,
						SYSDATE
					 ) ;
				EXCEPTION WHEN OTHERS THEN
				  ErrorMsg(
				   pSqlfunction	  	  => 'LoadUk',
					   pTableName  	  	  => 'tmp_amd_location_part_override',
					   pError_location => 150,
					   pKey1			  => 'partNo: ' || rec.part_no,
		   			   pKey2			  => 'locSid: ' || rec.loc_sid) ;
					   RAISE ;
			   	END ;
				IF (I > COMMITAFTER) THEN
				   I := 0 ;
				   COMMIT ;
				END IF ;
				I := I + 1 ;
				cand_cnt := cand_cnt + 1 ;
			END LOOP ;
		END ;
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 160,
				pKey1 => 'LoadUK',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'stock_cnt=' || stock_cnt, 
				pKey4 => 'cand_cnt=' || cand_cnt ) ;
	EXCEPTION WHEN OTHERS THEN
		 ErrorMsg(pSqlfunction => 'LoadUk',pTableName => 'tmp_amd_location_part_override',
					   pError_location => 170 ) ;
		RAISE ;
	END LoadUk ;
	
	
	PROCEDURE LoadBasc IS
		CURSOR cur_cand IS
			SELECT spo_prime_part_no part_no,
				  loc_sid
				  FROM AMD_SENT_TO_A2A asta, AMD_SPARE_NETWORKS asn
				  WHERE asta.part_no = asta.spo_prime_part_no
				  AND asn.loc_id = Amd_Defaults.AMD_BASC_LOC_ID
				  AND asta.action_code != Amd_Defaults.DELETE_ACTION ;
	
	 	CURSOR cur_stock IS
			SELECT Amd_Partprime_Pkg.getSuperPrimePart(asp.part_no) part_no,
				   SUM(NVL(stock_level, 0)) tsl_override_qty
				  FROM WHSE w, AMD_SPARE_PARTS asp
				  WHERE w.part = asp.part_no
				  AND sc = 'C17PCAG'
		 	      AND asp.action_code != Amd_Defaults.DELETE_ACTION
	 			  GROUP BY	Amd_Partprime_Pkg.getSuperPrimePart(asp.part_no) ;
	
		returnCode NUMBER ;
		TYPE partNo_stock IS TABLE OF NUMBER INDEX BY AMD_SPARE_PARTS.part_no%TYPE  ;
		partNo_stockLevel partNo_stock ;
		tslOverrideQty AMD_LOCATION_PART_OVERRIDE.TSL_OVERRIDE_QTY%TYPE ;
		I NUMBER := 0 ;
		stock_cnt NUMBER := 0 ;
		cand_cnt NUMBER := 0 ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 180,
				pKey1 => 'LoadBasc',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		BEGIN
			FOR rec IN cur_stock
			LOOP
				BEGIN
					 IF ( rec.part_no IS NOT NULL ) THEN
					 	 partNo_stockLevel(rec.part_no) := rec.tsl_override_qty ;
					 END IF ;
				EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'LoadBasc',
					   pTableName  	  	  => 'tmp_amd_location_part_override',
					   pError_location => 190,
					   pKey1			  => 'partNo: ' || rec.part_no,
		   			   pKey2			  => 'qty: ' || rec.tsl_override_qty) ;
					   RAISE ;
			   	END ;
				stock_cnt := stock_cnt + 1 ;
			END LOOP ;
			FOR rec IN cur_cand
			LOOP
				tslOverrideQty := 0 ;
				BEGIN
					tslOverrideQty := partNo_stockLevel(rec.part_no) ;
				EXCEPTION WHEN NO_DATA_FOUND THEN
					tslOverrideQty := 0 ;
				END ;
				BEGIN
					 InsertTmpAmdLocPartOverride(
					 	rec.part_no,
						rec.loc_sid,
						tslOverrideQty,
						NULL,
						Amd_Defaults.INSERT_ACTION,
						SYSDATE
					 ) ;
				EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'LoadBasc',
					   pTableName  	  	  => 'tmp_amd_location_part_override',
					   pError_location => 200,
					   pKey1			  => 'partNo: ' || rec.part_no,
		   			   pKey2			  => 'locSid: ' || rec.loc_sid) ;
					RAISE ;
			   	END ;
				IF (I > COMMITAFTER) THEN
				   I := 0 ;
				   COMMIT ;
				END IF ;
				I := I + 1 ;
				cand_cnt := cand_cnt + 1 ;
			END LOOP ;
		END ;
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 210,
				pKey1 => 'LoadBasc',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'stock_cnt=' || stock_cnt,
				pKey4 => 'cand_cnt=' || cand_cnt) ;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(
		   pSqlfunction 	  	  => 'LoadBasc',
		   pTableName  	  	  => 'tmp_amd_location_part_override',
		   pError_location => 220) ;
		RAISE ;
	END LoadBasc ;
	
	/*
		INSERT INTO tmp_amd_location_part_override
		SELECT amd_utils.GetNsiSidFromPartNo(spo_prime_part_no) nsi_sid,
			   locSid loc_sid, sum(nvl(stock_level, 0)) tsl_override_qty,
			   null tsl_overrid_user,
			   'A' action_code,
			   sysdate last_update_dt
		 	   FROM amd_sent_to_a2a asta
		 	   LEFT OUTER JOIN whse w
		 	   ON asta.part_no = w.part
		 	   AND sc = 'C17PCAG'
		 	   AND asta.action_code != Amd_Defaults.DELETE_ACTION;
			    GROUP BY amd_utils.GetNsiSidFromPartNo(spo_prime_part_no) ;
		commit ;
	*/
	
	/*
	EXCEPTION WHEN OTHERS THEN
		null ;
	*/
	
	
	PROCEDURE LoadFslMob IS
		CURSOR cur IS
			SELECT spo_prime_part_no part_no,
				   loc_sid,
				   0,
				   NULL,
				   Amd_Defaults.INSERT_ACTION,
				   SYSDATE
				   FROM AMD_SENT_TO_A2A asta, AMD_SPARE_NETWORKS asn
				   WHERE asta.spo_prime_part_no = asta.part_no
				   AND asn.loc_type IN ('MOB', 'FSL')
				   AND asta.action_code != Amd_Defaults.DELETE_ACTION
				   AND asn.action_code != Amd_Defaults.DELETE_ACTION;
	
		CURSOR cur_req IS
			SELECT Amd_Partprime_Pkg.getSuperPrimePart(ansi.prime_part_no) part_no,
				   loc_sid,
				   SUM(NVL(r.demand_level,0)) demand_level
				   FROM RAMP r, AMD_NATIONAL_STOCK_ITEMS ansi, AMD_SENT_TO_A2A asta, AMD_SPARE_NETWORKS asn
				   WHERE r.sc LIKE 'C170008%'
				   AND SUBSTR(r.sc, 8, 6) = asn.loc_id
				   AND asn.loc_type IN ('MOB', 'FSL')
				   AND REPLACE(r.current_stock_number, '-') = ansi.nsn
				   AND ansi.prime_part_no = asta.part_no
				   AND Amd_Location_Part_Override_Pkg.IsNumeric(ansi.nsn) = 'Y'
				   AND ansi.action_code != Amd_Defaults.DELETE_ACTION
				   AND asta.action_code != Amd_Defaults.DELETE_ACTION
				   AND asn.action_code != Amd_Defaults.DELETE_ACTION
				   GROUP BY  Amd_Partprime_Pkg.getSuperPrimePart(ansi.prime_part_no) , loc_sid
				   HAVING SUM(NVL(r.demand_level,0))  > 0 ;
	
		TYPE ARRAY IS TABLE OF TMP_AMD_LOCATION_PART_OVERRIDE%ROWTYPE;
		l_data ARRAY;
		returnCode NUMBER ;
		I NUMBER := 0 ;
		cur_cnt NUMBER := 0 ;
		req_cnt NUMBER := 0 ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 230,
				pKey1 => 'LoadFslMod',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		BEGIN
			OPEN cur ;
	    	LOOP
			    FETCH cur BULK COLLECT INTO l_data LIMIT BULKLIMIT ;
				cur_cnt := cur_cnt + l_data.COUNT ;
		    	FORALL i IN 1..l_data.COUNT
		    	   INSERT INTO TMP_AMD_LOCATION_PART_OVERRIDE VALUES l_data(i);
				   COMMIT ;
		    	EXIT WHEN cur%NOTFOUND;			
		    END LOOP;
	    	CLOSE cur;
			COMMIT ;
	
		EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'LoadFslMob',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 240) ;
				   RAISE ;
	  	END ;
		I := 0 ;
		FOR rec IN cur_req
		LOOP
	
			BEGIN
				UPDATE TMP_AMD_LOCATION_PART_OVERRIDE
					SET	   tsl_override_qty = rec.demand_level
					WHERE part_no = rec.part_no
							  AND loc_sid = rec.loc_sid ;
			EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'LoadFslMob',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 250,
				   pKey1			  => rec.part_no,
	   			   pKey2			  => rec.loc_sid) ;
				   RAISE ;
	  		END ;
			IF (I > COMMITAFTER) THEN
			   COMMIT ;
			   I := 0 ;
			END IF ;
			I := I + 1 ;
			req_cnt := req_cnt + 1 ;
		END LOOP ;
		COMMIT ;
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 260,
				pKey1 => 'LoadFslMod',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'cur_cnt=' || cur_cnt,
				pKey4 => 'req_cnt=' || req_cnt) ;
	exception when others then			  
		 ErrorMsg(
				   pSqlfunction 	  => 'LoadFslMob',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 270) ;
		 raise ;	
	END LoadFslMob ;
	
	
	PROCEDURE LoadWhse IS
		TYPE ARRAY IS TABLE OF TMP_AMD_LOCATION_PART_OVERRIDE%ROWTYPE;
		l_data ARRAY;
	
		CURSOR cursor_warehouse_parts IS
			   SELECT spo_prime_part_no part_no,
			   		  loc_sid,
					  0 tsl_override_qty,
					  NULL tsl_override_user,
					  'A' action_code,
					  SYSDATE last_update_dt
				   FROM AMD_SENT_TO_A2A asta, AMD_SPARE_NETWORKS asn
				   WHERE asta.spo_prime_part_no = asta.part_no
				   AND asn.loc_id = Amd_Defaults.AMD_WAREHOUSE_LOCID
				   AND asta.action_code != Amd_Defaults.DELETE_ACTION
				   AND asn.action_code != Amd_Defaults.DELETE_ACTION
				   and asn.SPO_LOCATION is not null ;
	
			 -- get all those whse where the rbl run had 0 value for and
			 --	1) sum all the tsls where FSL, MOB, UAB
			 --	2) from Total Spo Inventory, subtract out those from 1)
	
	
			-- tmp_amd_location_part_override is already by spo prime, no need to determine
		CURSOR cursor_peacetimeBasesSum IS
			  SELECT part_no, SUM(NVL(tsl_override_qty,0)) qty
			  	   FROM TMP_AMD_LOCATION_PART_OVERRIDE t, AMD_SPARE_NETWORKS asn
				   WHERE t.loc_sid = asn.loc_sid
				   AND t.action_code != Amd_Defaults.DELETE_ACTION
				   AND asn.action_code != Amd_Defaults.DELETE_ACTION
				   AND ( loc_type IN ('MOB', 'FSL', 'UAB', 'COD')
				   	     OR
						 loc_id IN (Amd_Defaults.AMD_BASC_LOC_ID, Amd_Defaults.AMD_UK_LOC_ID )
					   )
				   and asn.SPO_LOCATION is not null
				   GROUP BY part_no ;
		
		Cursor cursor_wartimeRspSum is
			   select part_no, sum(nvl(rsp_level,0)) qty
			   from amd_rsp_sum
			   group by part_no ;
	
		Cursor cursor_peacetimeBO_Spo_Sum is
			   select spo_prime_part_no,  qty
			   from amd_backorder_spo_sum
			   order by spo_prime_part_no ;
			   
				  -- get the whole list and the sum to spo prime
		CURSOR cursor_peacetimeSpoInv IS
			  SELECT spo_prime_part_no part_no,
			  		 SUM(NVL(spo_total_inventory,0)) qty
					  FROM AMD_SENT_TO_A2A asta, AMD_NATIONAL_STOCK_ITEMS ansi
					  WHERE asta.part_no = ansi.prime_part_no
					  AND asta.action_code != Amd_Defaults.DELETE_ACTION
					  AND ansi.action_code != Amd_Defaults.DELETE_ACTION
					  GROUP BY spo_prime_part_no ;
	
		TYPE partNo_sum IS TABLE OF NUMBER INDEX BY AMD_SPARE_PARTS.part_no%TYPE  ;
		-- arrays where index is nsi_sid, and the values are the sums
		partNoCandidates_sum partNo_sum ;
		partNoBases_sum partNo_sum ;
		partNoSpoInv_sum partNo_sum ;
		wareHouseLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE ;
		basesTsl_Rsp_Backorder_sum NUMBER ;
		sumOfSpoTotalInv NUMBER ;
		AtlantaWarehouseQty NUMBER ;
		returnCode NUMBER ;
		I NUMBER := 0 ;
		cur_cnt NUMBER := 0 ;
		baseSum_cnt NUMBER := 0 ;
		spoInv_cnt NUMBER := 0 ;
		rsp_cnt number := 0 ;
		spoSum_cnt number := 0 ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 280,
				pKey1 => 'LoadWhse',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
			-- Calculation WareHouse TSLs
	
		BEGIN
			 -- load partNoBases_sum array where each partNo index has the sum for the bases
			FOR rec IN cursor_peacetimeBasesSum
			LOOP
				partNoBases_sum(rec.part_no) := rec.qty ;
				baseSum_cnt := baseSum_cnt + 1 ;
			END LOOP ;
			
			for rec in cursor_wartimeRspSum
			loop
				begin
					 partNoBases_sum(rec.part_no) := partNoBases_sum(rec.part_no) + rec.qty ;
				exception when standard.no_data_found then
					 partNoBases_sum(rec.part_no) := rec.qty ;
				end ;
				rsp_cnt := rsp_cnt + 1 ;
			end loop ;
	
			for rec in cursor_peacetimeBO_Spo_Sum
			loop
				begin
					 partNoBases_sum(rec.spo_prime_part_no) := partNoBases_sum(rec.spo_prime_part_no) + rec.qty ;
				exception when standard.no_data_found then
					 partNoBases_sum(rec.spo_prime_part_no) := rec.qty ;
				end ;
				spoSum_cnt := spoSum_cnt + 1 ;
			end loop ;
			 -- load partNoSpoInv_sum array where each partNo index has the total_spo_inventory
			FOR rec IN cursor_peacetimeSpoInv
			LOOP
				partNoSpoInv_sum(rec.part_no) := rec.qty ;
				spoInv_cnt := spoInv_cnt + 1 ;
			END LOOP ;
	
	--		wareHouseLocSid := amd_utils.GetLocSid(amd_defaults.AMD_WAREHOUSE_LOCID) ;
	
			-- cycle thru each of the zero candidates
			-- line up the partNo and do the necessary calculation.
			-- per each partNo
			-- 	   total_spo_inventory minus bases sum
			-- 	   if result negative, make result zero
			I := 0 ;
			FOR rec IN cursor_warehouse_parts
			LOOP
				BEGIN
					BEGIN
						 basesTsl_Rsp_Backorder_sum := partNoBases_sum(rec.part_no) ;
					EXCEPTION WHEN NO_DATA_FOUND THEN
						 basesTsl_Rsp_Backorder_sum := 0 ;
					END ;
					BEGIN
						 sumOfSpoTotalInv := partNoSpoInv_sum(rec.part_no) ;
					EXCEPTION WHEN NO_DATA_FOUND THEN
						 sumOfSpoTotalInv := 0 ;
					END ;
					AtlantaWarehouseQty := sumOfSpoTotalInv - basesTsl_Rsp_Backorder_sum ;
					IF (AtlantaWarehouseQty < 0) THEN
					   AtlantaWarehouseQty := 0 ;
					END IF ;
				    INSERT INTO TMP_AMD_LOCATION_PART_OVERRIDE
		 			    (
						  part_no,
						  loc_sid,
						  tsl_override_qty,
						  tsl_override_user,
						  action_code,
						  last_update_dt
		 				)
		 				VALUES
		 				(
		 				  rec.part_no,
						  rec.loc_sid,
						  AtlantaWarehouseQty,
						  NULL,
						  Amd_Defaults.INSERT_ACTION,
						  SYSDATE
		 				) ;
					   /*
						UPDATE tmp_amd_location_part_override
							SET tsl_override_AtlantaWarehouseQty = AtlantaWarehouseQty
							WHERE part_no = rec.part_no
							AND loc_sid = wareHouseLocSid ;
						*/
				EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'LoadWhse',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 290,
				   pKey1			  => 'partNo: ' || rec.part_no) ;
				   RAISE ;
			    END ;
				IF (I > COMMITAFTER) THEN
			   	   COMMIT ;
			   	   I := 0 ;
				END IF ;
				I := I + 1 ;
				cur_cnt := cur_cnt + 1 ;
			END LOOP ;
	
		EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'LoadWhse',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 300) ;
				   RAISE ;
		END ;
	
		COMMIT ;
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 310,
				pKey1 => 'LoadWhse',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'cur_cnt=' || to_char(cur_cnt),
				pKey4 => 'baseSum_cnt=' || to_char(baseSum_cnt),
				pData => 'spoInv_cnt=' || to_char(spoInv_cnt) || ' rsp_cnt=' || to_char(rsp_cnt) || ' spoSum_cnt=' || to_char(spoSum_cnt)) ;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(
		   pSqlfunction 	  	  => 'LoadWhse',
	   pTableName  	  	  => 'tmp_amd_location_part_override',
	   pError_location => 320) ;
	   RAISE ;
	END LoadWhse ;
	
	
	FUNCTION GetFirstLogonIdForPart(pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE) RETURN AMD_PLANNER_LOGONS.logon_id%TYPE IS
		CURSOR cur( pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE ) IS
			SELECT apl.*
				FROM AMD_PLANNER_LOGONS apl, AMD_PLANNERS ap, AMD_NATIONAL_STOCK_ITEMS ansi
				WHERE ansi.nsi_sid = pNsiSid
				AND Amd_Preferred_Pkg.GetPreferredValue(ansi.planner_code_cleaned, ansi.planner_code) = ap.planner_code
				AND ap.planner_code = apl.planner_code
				AND ap.action_code != Amd_Defaults.DELETE_ACTION
				AND apl.action_code != Amd_Defaults.DELETE_ACTION
				AND ansi.action_code != Amd_Defaults.DELETE_ACTION
				ORDER BY apl.planner_code, data_source, logon_id ;
		 retLogonId AMD_PLANNER_LOGONS%ROWTYPE := NULL ;
	BEGIN
		 IF NOT cur%ISOPEN
		 THEN
		 	OPEN cur(pNsiSid) ;
		 END IF ;
		 FETCH cur INTO retLogonId ;
		 IF cur%NOTFOUND THEN
		 	retLogonId.logon_id := NULL ;
		 END IF ;
		 CLOSE cur ;
		 RETURN retLogonId.logon_id ;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(
		   pSqlfunction 	  	  => 'GetFirstLogonIdForPart',
	   pTableName  	  	  => 'amd_planner_logons',
	   pError_location => 330) ;
	   RAISE ;
	END GetFirstLogonIdForPart ;
	
	PROCEDURE LoadOverrideUsers IS
		CURSOR cur IS
			 SELECT part_no, nsi_sid, nsn
			 FROM TMP_AMD_LOCATION_PART_OVERRIDE talpo, AMD_NATIONAL_STOCK_ITEMS ansi
			 WHERE talpo.part_no = ansi.prime_part_no AND
			 	   talpo.action_code != Amd_Defaults.DELETE_ACTION AND
			 	   ansi.action_code != Amd_Defaults.DELETE_ACTION
			 ORDER BY nsi_sid;
		lastNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE := -9993 ;
		-- TYPE partNo_logonId_tab IS TABLE OF amd_planner_logons.logon_id%TYPE INDEX BY amd_spare_parts.part_no%TYPE  ;
		-- partNo_logonId partNo_logonId_tab ;
		-- rowPartNo amd_spare_parts.part_no%TYPE  ;
		-- defaultUser amd_location_part_override.tsl_override_user%TYPE := Amd_Defaults.GetParamValue('override_user_default');
		tslOverrideUser AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE ;
		returnCode NUMBER ;
		cur_cnt NUMBER := 0 ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 340,
				pKey1 => 'LoadOverrideUsers',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
		 FOR rec IN cur
		 LOOP
		 	 BEGIN
			 	 IF (lastNsiSid != rec.nsi_sid) THEN
				 	-- partNo_logonId(rec.part_no) := nvl(GetFirstLogonIdForPart(rec.nsi_sid), amd_defaults.GetLogonId(rec.nsn) ) ;
					tslOverrideUser := NVL( GetFirstLogonIdForPart(rec.nsi_sid), Amd_Defaults.GetLogonId(rec.nsn) ) ;
					UPDATE TMP_AMD_LOCATION_PART_OVERRIDE
			 	 	   SET 	tsl_override_user = tslOverrideUser
			 	 	   WHERE	part_no = rec.part_no ;
				 END IF ;
				 lastNsiSid := rec.nsi_sid ;
			 EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'LoadOverrideUsers',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 350,
				   pKey1			  => 'nsiSid: ' || rec.nsi_sid,
	   			   pKey2			  => 'partNo: ' || rec.part_no) ;
				   RAISE ;
			END ;
			cur_cnt := cur_cnt + 1 ;
		 END LOOP ;
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 360,
				pKey1 => 'LoadOverrideUsers',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'cur_cnt=' || cur_cnt) ;
		COMMIT ;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(
		   pSqlfunction 	  	  => 'LoadOverrideUsers',
	   pTableName  	  	  => 'tmp_amd_location_part_override',
	   pError_location => 370) ;
	   RAISE ;
	END LoadOverrideUsers ;
	
	PROCEDURE processTsl(tsl IN tslCur, pDoAllA2A IN BOOLEAN) IS
		tslOverrideUser TMP_A2A_LOC_PART_OVERRIDE.OVERRIDE_USER%TYPE ;
		delete_cnt NUMBER := 0 ;
		batch_cnt NUMBER := 0 ;
		insert_cnt NUMBER := 0 ;
		rec_cnt NUMBER := 0 ;
		rec tslRec ;
		batchStart DATE := NVL(Amd_Batch_Pkg.getLastStartTime, TO_DATE('01/01/2100', 'MM/DD/YYYY') );
		returnCode NUMBER ;
		
		FUNCTION insertTmpA2A(spo_prime_part_no IN AMD_SENT_TO_A2A.SPO_PRIME_PART_NO%TYPE,
						  	  site_location IN TMP_A2A_LOC_PART_OVERRIDE.SITE_LOCATION%TYPE,
							  override_user IN TMP_A2A_LOC_PART_OVERRIDE.OVERRIDE_USER%TYPE) RETURN BOOLEAN IS
			
			action_code tmp_a2a_loc_part_override.action_code%type ;
			
			function getActionCode return varchar2 is
					 theActionCode amd_sent_to_a2a.action_code%type ;
			begin
				 select action_code into theActionCode 
				 from amd_sent_to_a2a sent
				 where insertTmpA2A.spo_prime_part_no = sent.PART_NO
				 and sent.part_no = sent.spo_prime_part_no ;
				 return theActionCode ;
			end getActionCode ;
			
		BEGIN
			if a2a_pkg.wasPartSent(spo_prime_part_no) and site_location IS NOT NULL  THEN
			
			     action_code := getActionCode ;
				 
				 INSERT INTO TMP_A2A_LOC_PART_OVERRIDE (
					  part_no,
					  site_location,
					  override_type,
					  override_quantity,
					  override_reason,
					  override_user,
					  begin_date,
					  action_code,
					  last_update_dt
				 )
				 VALUES
				 (
				 	  insertTmpA2A.spo_prime_part_no,
					  insertTmpA2A.site_location,
					  OVERRIDE_TYPE,
					  0,
					  OVERRIDE_REASON,
					  insertTmpA2A.override_user,
					  SYSDATE,
					  insertTmpA2A.action_code,
					  SYSDATE
				 ) ;
				 RETURN TRUE ;
			END IF ;
			RETURN FALSE ;		
			
		EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
		    -- a zero tsl quantity should not update an existing AtlantaWarehouseQty
			RETURN FALSE ;
			
		END insertTmpA2A ;
		
	BEGIN
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 380,
				pKey1 => 'processTsl',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
		 LOOP
		 	 FETCH tsl INTO rec ;
			 EXIT WHEN tsl%NOTFOUND ;
			 rec_cnt := rec_cnt + 1 ;
			 IF MOD(insert_cnt + delete_cnt + batch_cnt,  COMMIT_THRESHOLD) = 0 THEN
			 	COMMIT ;
			 END IF  ;
			 BEGIN
				tslOverrideUser := NVL(GetFirstLogonIdForPart(rec.nsi_sid), Amd_Defaults.GetLogonId(rec.nsn) ) ;
				IF ( pDoAllA2A AND rec.action_code != Amd_Defaults.DELETE_ACTION) THEN
				    IF rec.override_quantity > 0 THEN 
				   		IF insertedTmpA2ALPO (
						  rec.spo_prime_part_no,
						  rec.spo_location,
						  OVERRIDE_TYPE,
						  rec.override_quantity,
						  OVERRIDE_REASON,
						  tslOverrideUser,
						  SYSDATE,
						  rec.action_code,
						  SYSDATE
						)	THEN
							insert_cnt := insert_cnt + 1 ;
					    END IF ;
					ELSE
						IF insertTmpA2A(rec.spo_prime_part_no,
						  				rec.spo_location,
						  				tslOverrideUser) THEN
							insert_cnt := insert_cnt + 1 ;
						END IF ;
					END IF ;
					-- do change only
				ELSIF ( rec.action_code = Amd_Defaults.INSERT_ACTION
					    AND ( rec.transaction_date >= batchStart ) )THEN
				   IF rec.override_quantity > 0 THEN
					   IF insertedTmpA2ALPO (
						  rec.spo_prime_part_no,
						  rec.spo_location,
						  OVERRIDE_TYPE,
						  rec.override_quantity,
						  OVERRIDE_REASON,
						  tslOverrideUser,
						  SYSDATE,
						  Amd_Defaults.INSERT_ACTION,
						  SYSDATE
						)	THEN
						batch_cnt := batch_cnt + 1 ;
					   END IF ;
					ELSE
						IF insertTmpA2A(rec.spo_prime_part_no,
						  				rec.spo_location,
						  				tslOverrideUser) THEN
							batch_cnt := batch_cnt + 1 ;
						END IF ;
					END IF ;
				ELSIF ( rec.action_code = Amd_Defaults.DELETE_ACTION
					   AND ( rec.transaction_date >= batchStart ) )THEN
					-- if action_code deleted, do nothing since part info deletes part
	
					 IF insertedTmpA2ALPO (
					  rec.spo_prime_part_no,
					  rec.spo_location,
					  OVERRIDE_TYPE,
					  rec.override_quantity,
					  OVERRIDE_REASON,
					  tslOverrideUser,
					  SYSDATE,
					  Amd_Defaults.DELETE_ACTION,
					  SYSDATE
					)	THEN
					  delete_cnt := delete_cnt + 1 ;
				    END IF ;
				ELSE
					-- if action_code changed, do nothing since always default to zero
				   NULL ;
				END IF ;
			EXCEPTION WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'processTsl',
				   pTableName  	  	  => 'tmp_amd_location_part_override',
				   pError_location => 390,
				   pKey1			  => 'spo_prime_part: ' || rec.spo_prime_part_no,
	   			   pKey2			  => 'action_code: ' || rec.action_code,
				   pKey3			  => 'spo_location: ' || rec.spo_location,
				   pKey4			  => 'icnt:' || insert_cnt || ' dcnt:' || delete_cnt || ' bcnt: ' || batch_cnt) ;

				   RAISE ;
			END ;
			 
		 END LOOP ;
		 
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 400,
				pKey1 => 'processTsl',
				pKey2 => 'rec_cnt=' || rec_cnt,
				pKey3 => 'insert_cnt=' || insert_cnt,
				pKey4 => 'delete_cnt=' || delete_cnt, 
				pData => 'batch_cnt=' || batch_cnt,
				pComments => 'processTsl ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	    COMMIT ;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(
		   pSqlfunction 	  	  => 'processTsl',
	   pTableName  	  	  => 'tmp_a2a_loc_part_override',
	   pError_location => 410) ;
	   RAISE ;
	END processTsl ;
	
	PROCEDURE loadZeroTslA2AByDate(pDoAllA2A IN BOOLEAN, 
			  from_dt IN DATE, to_dt IN DATE, pSpolocation IN VARCHAR2) IS
		tsl tslCur ;
			
	BEGIN
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 420,
				pKey1 => 'LoadZeroTslA2AByDate', 
				pKey2 => 'from_dt=' || to_char(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' ||  to_char(to_dt,'MM/DD/YYYY'),
				pKey4 => 'pDoAllA2A=' || amd_utils.boolean2Varchar2(pDoAllA2A) || ' pSpoLocation=' || pSpoLocation,
				pData => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
		loadZeroTslA2A(pDoAllA2A, pSpoLocation, from_dt, to_dt) ;
	
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 430,
				pKey1 => 'LoadZeroTslA2AByDate',
				pKey2 => 'from_dt=' || to_char(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt=' || to_char(to_dt,'MM/DD/YYYY'),
				pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(
		   pSqlfunction 	  	  => 'loadZeroTslA2AByDate',
	   pTableName  	  	  => 'tmp_a2a_loc_part_override',
	   pError_location => 440) ;
	   RAISE ;
	END loadZeroTslA2AByDate ;
	
	PROCEDURE  LoadZeroTslA2A(pDoAllA2A BOOLEAN, pSpoLocation VARCHAR2,from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE)   IS
		
		tsl tslCur ;
		rc number ;
		
		procedure openTestData is
		begin
			   OPEN tsl FOR
			   SELECT distinct sent.spo_prime_part_no,
			   sent.action_code action_code,
			   sysdate,
			   pSpoLocation spo_location,
			   ansi.nsn,
			   ansi.nsi_sid,
			   0 override_AtlantaWarehouseQty
			   FROM  AMD_NATIONAL_STOCK_ITEMS ansi, amd_sent_to_a2a sent, amd_test_parts testParts
			   WHERE ansi.prime_part_no = sent.spo_prime_part_no
			   and sent.part_no = sent.spo_prime_part_no
			   and not exists (
					 SELECT null 
					 FROM TMP_A2A_LOC_PART_OVERRIDE
					 WHERE part_no = sent.spo_prime_part_no
					 AND site_location = pSpoLocation) 
			   AND ansi.action_code != Amd_Defaults.getDELETE_ACTION
			   AND sent.spo_prime_part_no = testParts.PART_NO ; 
		end openTestData ;
	BEGIN
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 450,
				pKey1 => 'LoadZeroTslA2A',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'pDoAllA2A=' || amd_utils.boolean2Varchar2(pDoAllA2A),
				pKey4 => 'pSpoLocation=' || pSpoLocation,
				pData => 'from_dt=' || to_char(from_dt,'MM/DD/YYYY'),
				pComments => 'to_dt=' || to_char(to_dt,'MM/DD/YYYY') 
					  || ' useTestData=' || amd_utils.boolean2Varchar2(useTestData) ) ;
	    COMMIT ;
		-- pDoAllA2A has the highest priority
		IF pDoAllA2A THEN
		   IF useTestData THEN
		   	  openTestData ;
			ELSE
			   OPEN tsl FOR
			   SELECT distinct sent.spo_prime_part_no,
			   sent.action_code action_code,
			   sysdate,
			   pSpoLocation spo_location,
			   ansi.nsn,
			   ansi.nsi_sid,
			   0 override_AtlantaWarehouseQty
			   FROM  AMD_NATIONAL_STOCK_ITEMS ansi, amd_sent_to_a2a sent
			   WHERE ansi.prime_part_no = sent.spo_prime_part_no
			   and sent.part_no = sent.spo_prime_part_no
			   and not exists (
					 SELECT null 
					 FROM TMP_A2A_LOC_PART_OVERRIDE
					 WHERE part_no = sent.spo_prime_part_no
					 AND site_location = pSpoLocation) 
			   AND ansi.action_code != Amd_Defaults.getDELETE_ACTION ;
			END IF ;
		ELSE
			-- then by date range
			IF TRUNC(from_dt) <> TRUNC(A2a_Pkg.start_dt) OR TRUNC(to_dt) <> TRUNC(SYSDATE) THEN
				OPEN tsl FOR
				   SELECT distinct sent.spo_prime_part_no,
				   sent.action_code action_code,
				   sysdate,
				   pSpoLocation spo_location,
				   ansi.nsn,
				   ansi.nsi_sid,
				   0 override_AtlantaWarehouseQty
				   FROM  AMD_NATIONAL_STOCK_ITEMS ansi, amd_sent_to_a2a sent, amd_spare_parts parts
				   WHERE ansi.prime_part_no = sent.spo_prime_part_no
				   and sent.part_no = sent.spo_prime_part_no
				   and ansi.action_code != Amd_Defaults.getDELETE_ACTION			   
				   and parts.part_no = sent.spo_prime_part_no
				   and not exists (
						 SELECT null 
						 FROM TMP_A2A_LOC_PART_OVERRIDE
						 WHERE part_no = sent.spo_prime_part_no
						 AND site_location = pSpoLocation) 
				   and parts.action_code <> amd_defaults.getDELETE_ACTION
				   and ( trunc(ansi.last_update_dt) between trunc(from_dt) and trunc(to_dt)
				   	   or trunc(parts.last_update_dt) between trunc(from_dt) and trunc(to_dt) ) ;
			ELSIF useTestData THEN
				  openTestData ;
			ELSE
				-- and then transaction_date >= amd_batch_jobs.start_time
			   OPEN tsl FOR
				   SELECT distinct sent.spo_prime_part_no,
				   sent.action_code action_code,
				   sysdate,
				   pSpoLocation spo_location,
				   ansi.nsn,
				   ansi.nsi_sid,
				   0 override_AtlantaWarehouseQty
				   FROM  AMD_NATIONAL_STOCK_ITEMS ansi, amd_sent_to_a2a sent, amd_spare_parts parts
				   where ansi.prime_part_no = sent.spo_prime_part_no
				   and sent.part_no = sent.spo_prime_part_no
				   AND ansi.action_code != Amd_Defaults.getDELETE_ACTION
				   and parts.part_no = sent.spo_prime_part_no
				   and not exists (
						 SELECT null 
						 FROM TMP_A2A_LOC_PART_OVERRIDE
						 WHERE part_no = sent.spo_prime_part_no
						 AND site_location = pSpoLocation) 
				   and parts.action_code != amd_defaults.getDELETE_ACTION
				   and  (  trunc(ansi.last_update_dt) >= TRUNC(Amd_Batch_Pkg.getLastStartTime)
				   	    or trunc(parts.last_update_dt) >= TRUNC(Amd_Batch_Pkg.getLastStartTime) ) ;
			END IF ;
		END IF ;
		processTsl(tsl, pDoAllA2A) ;
		CLOSE tsl ;
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 460,
				pKey1 => 'LoadZeroTslA2A',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'pSpoLocation=' || pSpoLocation) ;
	    COMMIT ;
    exception when others then
		ErrorMsg(
		   pSqlfunction	  	  => 'LoadZeroTslA2A',
	   pTableName  	  	  => 'tmp_a2a_loc_part_override',
	   pError_location => 470) ;
		RAISE ;

	END LoadZeroTslA2A ;
	
	PROCEDURE LoadTmpAmdLocPartOverride IS
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 480,
				pKey1 => 'LoadTmpAmdLocPartOverride',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
		 Mta_Truncate_Table('tmp_amd_location_part_override','reuse storage');
		 Amd_Batch_Pkg.truncateIfOld('tmp_a2a_loc_part_override') ; 	 
		 COMMIT ;
		 LoadFslMob ;
		 LoadUk ;
		 LoadBasc ;
		 LoadWhse ;
		 LoadOverrideUsers ;
		 
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 490,
				pKey1 => 'LoadTmpAmdLocPartOverride',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
    exception when others then
		ErrorMsg(
		   pSqlfunction	  	  => 'LoadTmpAmdLocPartOverride',
	   pTableName  	  	  => 'tmp_amd_location_part_override',
	   pError_location => 500) ;
		RAISE ;

	END LoadTmpAmdLocPartOverride;
	
	PROCEDURE LoadZeroTslA2A(doAllA2A IN BOOLEAN := FALSE, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE) IS
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 510,
				pKey1 => 'LoadZeroTslA2A',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey4 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pData => 'usesTestData=' || Amd_Utils.boolean2Varchar2(useTestData),
				pComments => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
			-- do Inserts/Deletes only, i.e. not initial load
		loadZeroTslA2APartsWithNoTsls(doAllA2A => doAllA2A, useTestData => useTestData) ;
		loadZeroTslA2A4DelSpoPrimParts(doAllA2A => doAllA2A, useTestData => useTestData) ;
		loadRspZeroTslA2A(doAllA2A => doAllA2A, useTestData => useTestData) ;
		LoadZeroTslA2A( doAllA2A, Amd_Location_Part_Leadtime_Pkg.VIRTUAL_COD_SPO_LOCATION, from_dt, to_dt, useTestData ) ;
		LoadZeroTslA2A( doAllA2A, Amd_Location_Part_Leadtime_Pkg.VIRTUAL_UAB_SPO_LOCATION, from_dt, to_dt, useTestData ) ;
		loadZeroTslA2A( doAllA2A, amd_location_part_override_pkg.THE_WAREHOUSE, from_dt, to_dt, useTestData) ;
	
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 520,
				pKey1 => 'LoadZeroTslA2A',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'from_dt=' ||  TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey4 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pData =>  'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
    exception when others then
		ErrorMsg(
		   pSqlfunction	 => 'LoadZeroTslA2A',
	   pTableName  	  	  => 'tmp_amd_location_part_override',
	   pError_location => 530) ;
		RAISE ;

	END LoadZeroTslA2A ;
	
	PROCEDURE loadA2AByDate( from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE) IS
		returnCode NUMBER ;
		doAllA2A BOOLEAN := TRUE ;
		cnt NUMBER := 0 ;
		lpo TMP_A2A_LOC_PART_OVERRIDE%ROWTYPE ;
		rc NUMBER ;
		dataByDate locPartOverrideCur ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 540,
				pKey1 => 'loadA2AByDate',
				pKey2 => 'from_dt=' || to_char(from_dt,'MM/DD/YYYY'),
				pKey3 => 'to_dt='  || to_char(to_dt,'MM/DD/YYYY'),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
		 Amd_Batch_Pkg.truncateIfOld('tmp_a2a_loc_part_override') ;
		 OPEN dataByDate FOR
		 	 SELECT alpo.part_no,
			 		spo_location AS site_location,
					OVERRIDE_TYPE AS override_type,
					tsl_override_qty AS override_quantity,
					OVERRIDE_REASON AS override_reason,
					tsl_override_user,
					SYSDATE AS begin_date,
					NULL AS end_date,
					alpo.action_code AS action_code,
					SYSDATE AS last_update_dt
			 FROM AMD_LOCATION_PART_OVERRIDE alpo, AMD_SPARE_NETWORKS asn
			 WHERE alpo.loc_sid = asn.loc_sid
			 	   AND alpo.action_code != Amd_Defaults.DELETE_ACTION
				   AND TRUNC(alpo.last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt)
				   AND alpo.part_no IN 
				   	   (SELECT DISTINCT spo_prime_part_no 
					    FROM AMD_SENT_TO_A2A 
					    WHERE action_code != Amd_Defaults.DELETE_ACTION) ;
		 processLocPartOverride(dataByDate) ;
		 CLOSE dataByDate ;
		 LoadZeroTslA2A( doAllA2A, from_dt, to_dt ) ;
	
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 550,
				pKey1 => 'loadA2AByDate',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
    exception when others then
		ErrorMsg(
		   pSqlfunction	 => 'LoadA2AByDate',
	   pTableName  	  	  => 'tmp_amd_location_part_override',
	   pError_location => 560) ;
		RAISE ;

	END loadA2AByDate ;
	
	PROCEDURE processLocPartOverride(locPartOverride IN locPartOverrideCur) IS
		cnt NUMBER := 0 ;
		lpo TMP_A2A_LOC_PART_OVERRIDE%ROWTYPE ;
		rec locPartOverrideRec ;
		rc number ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 570,
				pKey1 => 'processLocPartOverride',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
		 LOOP
		 	 FETCH locPartOverride INTO rec ;
			 EXIT WHEN locPartOverride%NOTFOUND ;
			 	 lpo.part_no := rec.part_no ;
				 lpo.site_location := rec.site_location ;
				 lpo.override_type := rec.override_type ;
				 lpo.override_quantity := rec.override_quantity ;
				 lpo.override_reason := rec.override_reason ;
				 lpo.override_user := rec.tsl_override_user ;
				 lpo.begin_date := rec.begin_date ;
				 lpo.end_date := rec.end_date ;
				 lpo.action_code := rec.action_code ;
				 lpo.last_update_dt := rec.last_update_dt ;
			 	 IF insertedTmpA2ALPO(lpo) THEN
			 	 	cnt := cnt + 1 ;
					IF MOD(cnt,COMMIT_THRESHOLD) = 0 THEN
					   COMMIT ;
					END IF ;
				 ELSE
				   Amd_Utils.debugMsg(pMsg => 'Part/site_location was not loaded to tmp_a2a_loc_part_override',
				   	  pPackage => 'amd_location_part_override_pkg.processLocPartOverride',
					  pLocation => 60,
					  pMsg2 =>rec.part_no, 
					  pMsg4 => rec.site_location) ;
				 END IF ;		 
		 END LOOP ;	 
		 writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 580,
				pKey1 => 'processLocPartOverride',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
		 		pKey3 => 'cnt=' || cnt) ;
		 COMMIT ;
	exception when others then
		ErrorMsg(pSqlfunction => 'processLocPartOverride',pTableName => 'tmp_a2a_loc_part_override',
			   pError_location => 590) ;
		RAISE ;
	END processLocPartOverride ;
	
	PROCEDURE LoadAllA2A( useTestData IN BOOLEAN := FALSE, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE) IS
		returnCode NUMBER ;
		doAllA2A BOOLEAN := TRUE ;
		overrides locPartOverrideCur ;
		rc NUMBER ;
	BEGIN
		 writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 600,
		 		pKey1 => 'LoadAllA2A',
				pKey2 => 'useTestData=' || Amd_Utils.boolean2Varchar2(useTestData),
				pKey3 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey4 => 'to_dt='  || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pData => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
		 Mta_Truncate_Table('tmp_a2a_loc_part_override','reuse storage');
		 a2a_pkg.setSendAllData(true) ;
		 IF useTestData THEN
			writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 610,
			 		pKey1 => 'LoadAllA2A', pKey2 => 'useTestData cursor') ;
		 	OPEN overrides FOR
			 	 SELECT alpo.part_no,
				 		spo_location AS site_location,
						OVERRIDE_TYPE AS override_type,
						tsl_override_qty AS override_quantity,
						OVERRIDE_REASON AS override_reason,
						tsl_override_user,
						SYSDATE AS begin_date,
						NULL AS end_date,
						sent.action_code AS action_code,
						SYSDATE AS last_update_dt
				 FROM AMD_LOCATION_PART_OVERRIDE alpo, AMD_SPARE_NETWORKS asn, amd_sent_to_a2a sent
				 WHERE alpo.loc_sid = asn.loc_sid
					   AND alpo.part_no = sent.part_no
					   and sent.SPO_PRIME_PART_NO is not null 
					   AND alpo.part_no IN (SELECT part_no FROM AMD_TEST_PARTS)
				union
				select rsp.part_no,
				rsp_location,
				OVERRIDE_TYPE as override_type,
				rsp_level,
				OVERRIDE_REASON as override_reason,
				Amd_Location_Part_Override_Pkg.GetFirstLogonIdForPart(Amd_Utils.GetNsiSidFromPartNo(rsp.part_no)),
				sysdate as begin_date,
				null as end_date,
				sent.action_code action_code,
				sysdate as last_update_dt
				from amd_rsp_sum rsp, amd_sent_to_a2a sent
				where rsp.part_no = sent.part_no
				and sent.SPO_PRIME_PART_NO is not null
				and rsp.part_no in (select part_no from amd_test_parts) ;			
				
		ELSE
			IF TRUNC(from_dt) <> TRUNC(A2a_Pkg.start_dt) OR TRUNC(to_dt) <> TRUNC(SYSDATE) THEN
			    writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 620,
			 		pKey1 => 'LoadAllA2A', pKey2 => 'by Date cursor') ;
				OPEN overrides FOR
			 	 SELECT alpo.part_no,
				 		spo_location AS site_location,
						OVERRIDE_TYPE AS override_type,
						tsl_override_qty AS override_quantity,
						OVERRIDE_REASON AS override_reason,
						tsl_override_user,
						SYSDATE AS begin_date,
						NULL AS end_date,
						sent.action_code AS action_code,
						SYSDATE AS last_update_dt
				 FROM AMD_LOCATION_PART_OVERRIDE alpo, AMD_SPARE_NETWORKS asn, amd_sent_to_a2a sent
				 WHERE alpo.loc_sid = asn.loc_sid
					   AND TRUNC(alpo.last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt)
					   AND alpo.part_no = sent.part_no
					   and sent.SPO_PRIME_PART_NO is not null 
				union
				select rsp.part_no,
				rsp_location,
				OVERRIDE_TYPE as override_type,
				rsp_level,
				OVERRIDE_REASON as override_reason,
				Amd_Location_Part_Override_Pkg.GetFirstLogonIdForPart(Amd_Utils.GetNsiSidFromPartNo(rsp.part_no)),
				sysdate as begin_date,
				null as end_date,
				sent.action_code action_code,
				sysdate as last_update_dt
				from amd_rsp_sum rsp, amd_sent_to_a2a sent
				where trunc(last_update_dt) between trunc(from_dt) and trunc(to_dt) 
				and rsp.part_no = sent.part_no
				and sent.SPO_PRIME_PART_NO is not null ;						
			ELSE
			    writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 630,
			 		pKey1 => 'LoadAllA2A', pKey2 => 'loadAll cursor') ;
				OPEN overrides FOR
			 	 SELECT sent.spo_prime_part_no,
				 		spo_location AS site_location,
						OVERRIDE_TYPE AS override_type,
						tsl_override_qty AS override_quantity,
						OVERRIDE_REASON AS override_reason,
						tsl_override_user,
						SYSDATE AS begin_date,
						NULL AS end_date,
						sent.action_code AS action_code,
						SYSDATE AS last_update_dt
				 FROM AMD_LOCATION_PART_OVERRIDE alpo, AMD_SPARE_NETWORKS asn, amd_sent_to_a2a sent
				 WHERE alpo.loc_sid = asn.loc_sid
				 	   AND alpo.part_no = sent.part_no 
				 	   and sent.SPO_PRIME_PART_NO is not null 
				union
				select sent.spo_prime_part_no,
				rsp_location,
				OVERRIDE_TYPE as override_type,
				rsp_level,
				OVERRIDE_REASON as override_reason,
				Amd_Location_Part_Override_Pkg.GetFirstLogonIdForPart(Amd_Utils.GetNsiSidFromPartNo(rsp.part_no)),
				sysdate as begin_date,
				null as end_date,
                sent.action_code action_code,
				sysdate as last_update_dt
				from amd_rsp_sum rsp, 
				amd_sent_to_a2a sent
				where  rsp.part_no = sent.part_no 
				and sent.SPO_PRIME_PART_NO is not null ;
			END IF ;
		END IF ;
		processLocPartOverride(overrides) ;
		CLOSE overrides ;
		loadZeroTslA2A(doAllA2A => TRUE, from_dt => from_dt, to_dt => to_dt, useTestData => useTestData) ;
		
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 640,
		 		pKey1 => 'LoadAllA2A',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
				pKey4 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
				pData => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(
		   pSqlfunction 	  	  => 'LoadAllA2A',
		   pTableName  	  	  => 'tmp_a2a_loc_part_override',
		   pError_location => 650,
		   pKey1			  => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
  		   pKey2			  => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
		   pKey3			  => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
		   pKey4  		      => 'useTestData=' || Amd_Utils.boolean2Varchar2(useTestData)) ;
		RAISE ;
	END LoadAllA2A ;
	
	PROCEDURE LoadInitial IS
		 returnCode NUMBER ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 660,
		 		pKey1 => 'LoadInitial',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		 
		 LoadTmpAmdLocPartOverride ;
	 	 Mta_Truncate_Table('amd_location_part_override','reuse storage');
		 COMMIT ;
		 INSERT INTO AMD_LOCATION_PART_OVERRIDE
		 	SELECT * FROM TMP_AMD_LOCATION_PART_OVERRIDE ;
		 COMMIT ;
		 LoadAllA2A ;
		 dbms_output.put_line('LoadInitial ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(pSqlfunction => 'LoadInitial', pTableName => 'tmp_amd_location_part_override',
				   pError_location => 670 ) ;
		RAISE ;
	END LoadInitial ;
	
	PROCEDURE loadZeroTslA2APartsWithNoTsls(doAllA2A IN BOOLEAN := FALSE, useTestData IN BOOLEAN := FALSE) IS
			  tsl tslCur ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 680,
		 		pKey1 => 'loadZeroTslA2APartsWithNoTsls',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'useTestData=' || Amd_Utils.boolean2Varchar2(useTestData),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	    COMMIT ;
		IF doAllA2A THEN
		   IF useTestData THEN
			   OPEN tsl FOR
				SELECT spo_prime_part_no,
				sent.action_code action_code, 
				transaction_date, 
				loc_id spo_location,
				items.nsn,
				nsi_sid,
				0 override_quantity 
				FROM AMD_SENT_TO_A2A sent, AMD_NATIONAL_STOCK_ITEMS items, 
					   ( 
					   SELECT loc_id FROM AMD_SPARE_NETWORKS n 
					   WHERE (n.LOC_TYPE IN ('FSL','MOB') AND n.SPO_LOCATION IS NOT NULL) 
					   OR loc_id IN (amd_location_part_leadtime_pkg.BASC_LOCATION, 
					   	  		     amd_location_part_leadtime_pkg.UK_LOCATION) 
					   ) spo_locations, amd_test_parts testParts 
				WHERE sent.part_no NOT IN (SELECT DISTINCT part_no FROM AMD_LOCATION_PART_OVERRIDE WHERE action_code <> 'D')
				AND not exists (
					 SELECT null 
					 FROM TMP_A2A_LOC_PART_OVERRIDE
					 WHERE part_no = spo_prime_part_no
					 AND site_location = spo_locations.loc_id) 
				AND sent.part_no = testParts.PART_NO
				AND spo_prime_part_no = items.prime_part_no ;
		   ELSE
			   OPEN tsl FOR
				SELECT spo_prime_part_no,
				sent.action_code action_code, 
				transaction_date, 
				loc_id spo_location,
				nsn,
				nsi_sid,
				0 override_quantity 
				FROM AMD_SENT_TO_A2A sent, AMD_NATIONAL_STOCK_ITEMS items,  
					   ( 
					   SELECT loc_id FROM AMD_SPARE_NETWORKS n 
					   WHERE (n.LOC_TYPE IN ('FSL','MOB') AND n.SPO_LOCATION IS NOT NULL) 
					   OR loc_id IN ('EY1746', 'EY8780') 
					   ) spo_locations 
				WHERE part_no NOT IN (SELECT DISTINCT part_no FROM AMD_LOCATION_PART_OVERRIDE WHERE action_code <> 'D')
				AND not exists (
					 SELECT null 
					 FROM TMP_A2A_LOC_PART_OVERRIDE
					 WHERE part_no = spo_prime_part_no
					 AND site_location = spo_locations.loc_id) 
				AND spo_prime_part_no = items.prime_part_no ; 
			END IF ;
		ELSE
			IF useTestData THEN
			 	OPEN tsl FOR
					SELECT spo_prime_part_no,
					sent.action_code action_code, 
					transaction_date, 
					loc_id spo_location,
					items.nsn,
					nsi_sid,
					0 override_quantity 
					FROM AMD_SENT_TO_A2A sent, AMD_NATIONAL_STOCK_ITEMS items,  
						   ( 
						   SELECT loc_id FROM AMD_SPARE_NETWORKS n 
						   WHERE (n.LOC_TYPE IN ('FSL','MOB') AND n.SPO_LOCATION IS NOT NULL) 
						   OR loc_id IN ('EY1746', 'EY8780') 
						   ) spo_locations, amd_test_parts testParts 
					WHERE sent.part_no NOT IN (SELECT DISTINCT part_no FROM AMD_LOCATION_PART_OVERRIDE WHERE action_code <> 'D') 
					AND not exists (
						 SELECT null 
						 FROM TMP_A2A_LOC_PART_OVERRIDE
						 WHERE part_no = spo_prime_part_no
						 AND site_location = spo_locations.loc_id) 
					AND sent.part_no = testParts.PART_NO 
					and sent.ACTION_CODE <> amd_defaults.getDELETE_ACTION 
					AND spo_prime_part_no = items.prime_part_no
					AND TRUNC(transaction_date) >= TRUNC(Amd_Batch_Pkg.getLastStartTime) ;
			ELSE
			 	OPEN tsl FOR
					SELECT spo_prime_part_no,
					sent.action_code action_code, 
					transaction_date, 
					loc_id spo_location,
					nsn,
					nsi_sid,
					0 override_quantity 
					FROM AMD_SENT_TO_A2A sent, AMD_NATIONAL_STOCK_ITEMS items,  
						   ( 
						   SELECT loc_id FROM AMD_SPARE_NETWORKS n 
						   WHERE (n.LOC_TYPE IN ('FSL','MOB') AND n.SPO_LOCATION IS NOT NULL) 
						   OR loc_id IN ('EY1746', 'EY8780') 
						   ) spo_locations 
					WHERE part_no NOT IN (SELECT DISTINCT part_no FROM AMD_LOCATION_PART_OVERRIDE WHERE action_code <> 'D') 
					AND not exists (
						 SELECT null 
						 FROM TMP_A2A_LOC_PART_OVERRIDE
						 WHERE part_no = spo_prime_part_no
						 AND site_location = spo_locations.loc_id) 
					AND spo_prime_part_no = items.prime_part_no
					and sent.ACTION_CODE <> amd_defaults.getDELETE_ACTION 
					AND TRUNC(transaction_date) >= TRUNC(Amd_Batch_Pkg.getLastStartTime) ;
			END IF ;
		END IF ;
			
		processTsl(tsl, doAllA2A) ;
		CLOSE tsl ;
	
		writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 690,
		 		pKey1 => 'loadZeroTslA2APartsWithNoTsls',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	    COMMIT ;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(pSqlfunction => 'loadZeroTslA2APartsWithNoTsls',pTableName => 'tmp_amd_location_part_override',
				   pError_location => 700 ) ;
		RAISE ;
	END loadZeroTslA2APartsWithNoTsls ;
	
	PROCEDURE loadRspZeroTslA2A(doAllA2A IN BOOLEAN := FALSE, useTestData in boolean := false ) IS 
			  rspTsl tslCur ;
	BEGIN
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 710,
		 		pKey1 => 'loadRspZeroTslA2A',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
	   if useTestData then
	       -- send all the test data and do NOT filter on the last_update_dt
	       OPEN rspTsl FOR
			 	SELECT DISTINCT spo_prime_part_no, 
					   Amd_Defaults.INSERT_ACTION action_code , 
					   SYSDATE, 
					   mob,
					   nsn,
					   nsi_sid,
					   0 override_quantity   
				FROM 
					 (
				 	 SELECT  distinct spo_prime_part_no , mob || '_RSP' mob, 0 quantity
					 from (SELECT  DISTINCT spo_prime_part_no
					 	   FROM AMD_SENT_TO_A2A 
						   where part_no = spo_prime_part_no 
						   and action_code <> amd_defaults.getDelete_ACTION) primes,
					 AMD_SPARE_NETWORKS net
					 where mob is not null
					 AND not exists (
							 SELECT null 
							 FROM TMP_A2A_LOC_PART_OVERRIDE
							 WHERE part_no = spo_prime_part_no
							 AND site_location = mob || '_RSP') 
				 )  tsl,
				 AMD_NATIONAL_STOCK_ITEMS items 
				 where spo_prime_part_no = items.prime_part_no
				 and spo_prime_part_no in (select part_no from amd_test_parts)
				 AND items.action_code <> amd_defaults.getDelete_ACTION ;
	   else
	   	   if doAllA2A then
		       OPEN rspTsl FOR
				 	SELECT DISTINCT spo_prime_part_no, 
						   tsl.action_code , 
						   SYSDATE, 
						   mob,
						   nsn,
						   nsi_sid,
						   0 override_quantity   
					FROM 
						 (
					 	 SELECT  distinct spo_prime_part_no , mob || '_RSP' mob, 0 quantity, primes.action_code
						 from (SELECT  DISTINCT spo_prime_part_no, action_code
						       FROM AMD_SENT_TO_A2A
							   where part_no = spo_prime_part_no) primes,
						      AMD_SPARE_NETWORKS net
						 where mob is not null
						 AND not exists (
								 SELECT null 
								 FROM TMP_A2A_LOC_PART_OVERRIDE
								 WHERE part_no = spo_prime_part_no
								 AND site_location = mob || '_RSP') 
					 )  tsl,
					 AMD_NATIONAL_STOCK_ITEMS items 
				     where spo_prime_part_no = items.prime_part_no ;
		   else
		   	   -- send all data whose last_update_dt >= amd_batch_pkg.getLastStartTime - ie all the 
			   -- data that has been processed by the diff for the lastest batch job  
		       OPEN rspTsl FOR
				 	SELECT DISTINCT spo_prime_part_no, 
						   tsl.action_code action_code , 
						   SYSDATE, 
						   mob,
						   items.nsn,
						   nsi_sid,
						   0 override_quantity   
					FROM 
						 (
						 	 SELECT  distinct spo_prime_part_no , mob || '_RSP' mob, 0 quantity, primes.last_update_dt last_update_dt, primes.action_code action_code
							 from (SELECT  DISTINCT spo_prime_part_no, transaction_date last_update_dt, action_code
							       FROM AMD_SENT_TO_A2A 
								   where part_no = spo_prime_part_no 
								   and action_code <> amd_defaults.getDELETE_ACTION) primes,
							 AMD_SPARE_NETWORKS net
							 where mob is not null
							 AND not exists (
									 SELECT null 
									 FROM TMP_A2A_LOC_PART_OVERRIDE
									 WHERE part_no = spo_prime_part_no
									 AND site_location = mob || '_RSP') 
					 	 )  tsl,
					 	 AMD_NATIONAL_STOCK_ITEMS items,
						 amd_spare_parts parts 
						 where spo_prime_part_no = items.prime_part_no
						 and spo_prime_part_no = parts.part_no
						 and items.action_code <> amd_defaults.getDELETE_ACTION
						 and parts.action_code <> amd_defaults.getDELETE_ACTION					
					 	 and (trunc(tsl.last_update_dt) >= trunc(amd_batch_pkg.getLastStartTime)
						 	 or trunc(items.last_update_dt) >= trunc(amd_batch_pkg.getLastStartTime)
							 or trunc(parts.last_update_dt) >= trunc(amd_batch_pkg.getLastStartTime)) ;
			END IF ;
		end if ;
		processTsl(tsl => rspTsl, pDoAllA2A => doAllA2A) ;
		CLOSE rspTsl;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(pSqlfunction => 'loadRspZeroTslA2A',pTableName => 'tmp_amd_location_part_override',
				   pError_location => 720 ) ;
		RAISE ;
	END loadRspZeroTslA2A;
					 		
	
	PROCEDURE loadZeroTslA2A4DelSpoPrimParts(doAllA2A IN BOOLEAN := FALSE, useTestData IN BOOLEAN := FALSE) IS
			  tsl tslCur ;
	BEGIN
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 730,
		 		pKey1 => 'loadZeroTslA2A4DelSpoPrimParts',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'useTestData=' ||  Amd_Utils.boolean2Varchar2(useTestData),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
		 IF doAllA2A THEN
		 	 IF useTestData THEN
				 OPEN tsl FOR
				 	SELECT DISTINCT sent.spo_prime_part_no, 
						Amd_Defaults.INSERT_ACTION action_code, 
						sent.transaction_date, 
						net.SPO_LOCATION spo_location, 
						i.nsn,
						i.nsi_sid,
						0 override_AtlantaWarehouseQty
					FROM AMD_LOCATION_PART_OVERRIDE o, AMD_SPARE_NETWORKS net, AMD_SENT_TO_A2A sent, AMD_NATIONAL_STOCK_ITEMS i,
					amd_test_parts testParts 
					WHERE o.action_code = Amd_Defaults.DELETE_ACTION
					AND not exists (
							 SELECT null 
							 FROM TMP_A2A_LOC_PART_OVERRIDE
							 WHERE part_no = sent.spo_prime_part_no
							 AND site_location = net.spo_location) 
					AND sent.spo_prime_part_no = testParts.PART_NO 
					AND o.loc_sid = net.LOC_SID
					AND o.part_no = sent.spo_prime_part_no
					AND o.part_no = i.PRIME_PART_NO ;
			 ELSE
				 OPEN tsl FOR
				 	SELECT DISTINCT sent.spo_prime_part_no, 
						Amd_Defaults.INSERT_ACTION action_code, 
						sent.transaction_date, 
						net.SPO_LOCATION spo_location, 
						i.nsn,
						i.nsi_sid,
						0 override_AtlantaWarehouseQty
					FROM AMD_LOCATION_PART_OVERRIDE o, AMD_SPARE_NETWORKS net, AMD_SENT_TO_A2A sent, AMD_NATIONAL_STOCK_ITEMS i 
					WHERE o.action_code = Amd_Defaults.DELETE_ACTION
					AND not exists (
							 SELECT null 
							 FROM TMP_A2A_LOC_PART_OVERRIDE
							 WHERE part_no = sent.spo_prime_part_no
							 AND site_location = net.spo_location) 
					AND o.loc_sid = net.LOC_SID
					AND o.part_no = sent.spo_prime_part_no
					AND o.part_no = i.PRIME_PART_NO ;
			END IF ;
		ELSE
			IF useTestData THEN
				 OPEN tsl FOR
				 	SELECT DISTINCT sent.spo_prime_part_no, 
						Amd_Defaults.INSERT_ACTION action_code, 
						sent.transaction_date, 
						net.SPO_LOCATION spo_location, 
						i.nsn,
						i.nsi_sid,
						0 override_AtlantaWarehouseQty
					FROM AMD_LOCATION_PART_OVERRIDE o, AMD_SPARE_NETWORKS net, AMD_SENT_TO_A2A sent, AMD_NATIONAL_STOCK_ITEMS i,
						 amd_test_parts testParts 
					WHERE o.action_code = Amd_Defaults.DELETE_ACTION
					AND not exists (
							 SELECT null 
							 FROM TMP_A2A_LOC_PART_OVERRIDE
							 WHERE part_no = sent.spo_prime_part_no
							 AND site_location = net.spo_location) 
					AND sent.spo_prime_part_no = testParts.part_no 
					AND o.loc_sid = net.LOC_SID
					AND o.part_no = sent.spo_prime_part_no
					AND o.part_no = i.PRIME_PART_NO
					AND TRUNC(sent.TRANSACTION_DATE) >= TRUNC(Amd_Batch_Pkg.getLastStartTime) ;
	 		ELSE
				 OPEN tsl FOR
				 	SELECT DISTINCT sent.spo_prime_part_no, 
						Amd_Defaults.INSERT_ACTION action_code, 
						sent.transaction_date, 
						net.SPO_LOCATION spo_location, 
						i.nsn,
						i.nsi_sid,
						0 override_AtlantaWarehouseQty
					FROM AMD_LOCATION_PART_OVERRIDE o, AMD_SPARE_NETWORKS net, AMD_SENT_TO_A2A sent, AMD_NATIONAL_STOCK_ITEMS i 
					WHERE o.action_code = Amd_Defaults.DELETE_ACTION
					AND not exists (
							 SELECT null 
							 FROM TMP_A2A_LOC_PART_OVERRIDE
							 WHERE part_no = sent.spo_prime_part_no
							 AND site_location = net.spo_location) 
					AND o.loc_sid = net.LOC_SID
					AND o.part_no = sent.spo_prime_part_no
					AND o.part_no = i.PRIME_PART_NO
					AND TRUNC(sent.TRANSACTION_DATE) >= TRUNC(Amd_Batch_Pkg.getLastStartTime) ;
			END IF ;
		END IF ;
		
		processTsl(tsl, doAllA2A) ;
		CLOSE tsl ;
	
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 740,
		 		pKey1 => 'loadZeroTslA2A4DelSpoPrimParts',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	    COMMIT ;
	
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(pSqlfunction => 'loadZeroTslA2A4DelSpoPrimParts',pTableName => 'tmp_amd_location_part_override',
				   pError_location => 750 ) ;
		RAISE ;
	END loadZeroTslA2A4DelSpoPrimParts ;
	
	PROCEDURE loadTslA2AWarehouseParts(doAllA2A IN BOOLEAN := FALSE, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE) IS
			  tsl tslCur ;		  
	BEGIN
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 760,
		 		pKey1 => 'loadTslA2AWarehouseParts',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 => 'useTestData=' || Amd_Utils.boolean2Varchar2(useTestData),
				pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	
		IF useTestData THEN
		 	OPEN tsl FOR
				SELECT 
					spo_prime_part_no,
					spoPrimes.action_code,
					spoPrimes.transaction_date,
					spo_location,
					items.nsn,
					items.nsi_sid,
					override_quantity
				FROM (
					SELECT sent.spo_prime_part_no,
						THE_WAREHOUSE spo_location,
						SUM(NVL(i.SPO_TOTAL_INVENTORY,0)) override_quantity,
						Amd_Defaults.INSERT_ACTION action_code,
						SYSDATE transaction_date
					FROM AMD_SENT_TO_A2A sent, AMD_SPARE_PARTS p, AMD_NATIONAL_STOCK_ITEMS i
					WHERE
					sent.ACTION_CODE <> Amd_Defaults.DELETE_ACTION
					AND not exists (
							 SELECT null 
							 FROM TMP_A2A_LOC_PART_OVERRIDE
							 WHERE part_no = sent.spo_prime_part_no
							 AND site_location = THE_WAREHOUSE) 
					AND spo_prime_part_no IN (SELECT part_no FROM AMD_TEST_PARTS)
					AND p.ACTION_CODE <> Amd_Defaults.DELETE_ACTION
					AND sent.part_no = p.part_no
					AND p.nsn = i.NSN
					GROUP BY sent.spo_prime_part_no
					) spoPrimes, 
					AMD_NATIONAL_STOCK_ITEMS items
				WHERE spo_prime_part_no = items.PRIME_PART_NO ;
		 ELSE
		 	OPEN tsl FOR
				SELECT 
					spo_prime_part_no,
					spoPrimes.action_code,
					spoPrimes.transaction_date,
					spo_location,
					items.nsn,
					items.nsi_sid,
					override_quantity
				FROM (
					SELECT sent.spo_prime_part_no,
						THE_WAREHOUSE spo_location,
						SUM(NVL(i.SPO_TOTAL_INVENTORY,0)) override_quantity,
						Amd_Defaults.INSERT_ACTION action_code,
						SYSDATE transaction_date
					FROM AMD_SENT_TO_A2A sent, AMD_SPARE_PARTS p, AMD_NATIONAL_STOCK_ITEMS i
					WHERE
					sent.ACTION_CODE <> Amd_Defaults.DELETE_ACTION
					AND not exists (
							 SELECT null 
							 FROM TMP_A2A_LOC_PART_OVERRIDE
							 WHERE part_no = sent.spo_prime_part_no
							 AND site_location = THE_WAREHOUSE) 
					AND p.ACTION_CODE <> Amd_Defaults.DELETE_ACTION
					AND sent.part_no = p.part_no
					AND p.nsn = i.NSN
					GROUP BY sent.spo_prime_part_no
					) spoPrimes, 
					AMD_NATIONAL_STOCK_ITEMS items
				WHERE spo_prime_part_no = items.PRIME_PART_NO ;
		 END IF ; 
		 processTsl(tsl, doAllA2A) ;
		 CLOSE tsl ;
	
		writeMsg(pTableName => 'tmp_a2a_loc_part_override', pError_location => 770,
		 		pKey1 => 'loadTslA2AWarehouseParts',
				pKey2 => 'doAllA2A=' || Amd_Utils.boolean2Varchar2(doAllA2A),
				pKey3 =>  'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	EXCEPTION WHEN OTHERS THEN
		ErrorMsg(pSqlfunction => 'loadTslA2AWarehouseParts',pTableName => 'tmp_amd_location_part_override',
				   pError_location => 780 ) ;
		RAISE ;
	END loadTslA2AWarehouseParts ;
	
	FUNCTION isInTmpA2AYorN(part_no IN TMP_A2A_LOC_PART_OVERRIDE.part_no%TYPE, site_location IN TMP_A2A_LOC_PART_OVERRIDE.SITE_LOCATION%TYPE) RETURN VARCHAR2 IS
	BEGIN
		 IF isInTmpA2A(part_no, site_location) THEN
		 	RETURN 'Y' ;
		 ELSE
		 	RETURN 'N' ;
		 END IF ; 
	END isInTmpA2AYorN ;
	
	FUNCTION isInTmpA2A(part_no IN TMP_A2A_LOC_PART_OVERRIDE.part_no%TYPE, site_location IN TMP_A2A_LOC_PART_OVERRIDE.SITE_LOCATION%TYPE) RETURN BOOLEAN IS
			 thePartNo TMP_A2A_LOC_PART_OVERRIDE.part_no%TYPE ;
			 rc NUMBER ;
	BEGIN
		 SELECT part_no INTO thePartNo
		 FROM TMP_A2A_LOC_PART_OVERRIDE
		 WHERE part_no = isInTmpA2A.part_no
		 AND site_location = isInTmpA2A.site_location ;
		 RETURN TRUE ;
	EXCEPTION
			 WHEN standard.NO_DATA_FOUND THEN
			 	  RETURN FALSE ;
			 WHEN OTHERS THEN
					ErrorMsg(
					   pSqlfunction 	  	  => 'isInTmpA2A',
				   pTableName  	  	  => 'tmp_a2a_loc_part_override',
				   pError_location => 790,
				   pKey1			  => part_no,
	   			   pKey2			  => site_location) ;
				   RAISE ;
	END isInTmpA2A ;
	-- added 11/7/05 dse
	FUNCTION getInsertCnt RETURN NUMBER IS 
	BEGIN
		 RETURN insertCnt ;
	END getInsertCnt ;
	
	FUNCTION getUpdateCnt RETURN NUMBER IS
	BEGIN
		 RETURN updateCnt ;
	END getUpdateCnt ;
	
	FUNCTION getDeleteCnt RETURN NUMBER IS
	BEGIN
		 RETURN deleteCnt ;
	END getDeleteCnt ;
	
	FUNCTION getOVERRIDE_TYPE RETURN VARCHAR2 IS
	BEGIN
		 RETURN OVERRIDE_TYPE ;
	END getOVERRIDE_TYPE ;
	
	FUNCTION getOVERRIDE_REASON RETURN VARCHAR2 IS
	BEGIN
		 RETURN OVERRIDE_REASON ;
	END getOVERRIDE_REASON ;
	
	FUNCTION getBULKLIMIT RETURN NUMBER IS
	BEGIN
		 RETURN BULKLIMIT ;
	END getBULKLIMIT ;
	
	FUNCTION getCOMMITAFTER RETURN NUMBER IS
	BEGIN
		 RETURN COMMITAFTER ;
	END getCOMMITAFTER ;
	
	FUNCTION getSUCCESS RETURN NUMBER IS
	BEGIN
		 RETURN SUCCESS ;
	END getSUCCESS ;
	
	FUNCTION getFAILURE RETURN NUMBER IS
	BEGIN
		 RETURN FAILURE ;
	END getFAILURE ;
	
	FUNCTION getTHE_WAREHOUSE RETURN VARCHAR2 IS
	BEGIN
		 RETURN THE_WAREHOUSE ;
	END getTHE_WAREHOUSE ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_location_part_override_pkg', 
		 		pError_location => 800, pKey1 => 'amd_location_part_override_pkg', pKey2 => '$Revision:   1.38  $') ;
		 dbms_output.put_line('amd_location_part_override_pkg: $Revision:   1.38  $') ;
	end version ;
	
END Amd_Location_Part_Override_Pkg ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.13  $
	    $Date:   Jun 09 2006 11:51:06  $
    $Workfile:   AMD_LOCATION_PART_LEADTIME_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_LOCATION_PART_LEADTIME_PKG.pkb.-arc  $
/*   
/*      Rev 1.13   Jun 09 2006 11:51:06   zf297a
/*   implemented version
/*   
/*      Rev 1.12   Jun 01 2006 12:13:10   zf297a
/*   switched from dbms_output to amd_utils.writeMsg and from executed immediate to Mta_Truncate_Table
/*   
/*      Rev 1.11   May 12 2006 14:47:24   zf297a
/*   For the loadAll routines use all the action_codes and use the SendAllData property of the a2a_pkg in conjunction with the isPartValid and wasPartSent functions to determine if a part is sent as an A2A transaction.
/*   
/*      Rev 1.10   Mar 05 2006 14:14:38   zf297a
/*   Added amd_utils.debugMsg to record counts and procedure completion.
/*   
/*      Rev 1.9   Mar 03 2006 12:27:48   zf297a
/*   Removed function getBatchRunStart which has been replaced by amd_batch_pkg.getLastStartTime.  This will always return the last start time of the last job that has been run or is currently running.  This was data that has changed since the job started can always be sent as an A2A transaction even though it may have already been sent.  The small amount of repeat data should not be great.
/*   
/*      Rev 1.8   Feb 15 2006 14:00:46   zf297a
/*   Added cur ref, record type and a common process routine so that the data gets loaded the same no matter what selection criteria is used.
/*   
/*   
/*      Rev 1.7   Jan 04 2006 10:07:38   zf297a
/*   Made loadAllA2A and loadA2AByDate conform to the a2a_pkg.initA2A procedures.
/*   
/*      Rev 1.6   Jan 03 2006 12:45:50   zf297a
/*   Added date range to procedure loadA2AByDate
/*   
/*      Rev 1.5   Dec 29 2005 16:29:56   zf297a
/*   Added loadA2AByDate procedure
/*   
/*      Rev 1.4   Dec 15 2005 12:18:32   zf297a
/*   Added truncate of table tmp_a2a_loc_part_lead_time to LoadTmpAmdLocPartLeadtime
/*   
/*      Rev 1.3   Dec 07 2005 09:17:44   zf297a
/*   Added checks for isPartValid and wasPartSent.
/*   
/*      Rev 1.2   Dec 07 2005 08:37:56   zf297a
/*   Simplified errorMsg by making it a procedure with default values for most parameters.  Fixed loadAllA2A to ignore dup_value_on_index.
/*   
/*      Rev 1.1   Dec 06 2005 09:49:40   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*   
/*      Rev 1.0   Nov 30 2005 12:40:00   zf297a
/*   Initial revision.
/*   
/*      Rev 1.0   Nov 30 2005 12:31:04   zf297a
/*   Initial revision.
*/	

	   
	PKGNAME CONSTANT VARCHAR2(50) := 'AMD_LOCATION_PART_LEADTIME_PKG' ;
	COMMIT_THRESHOLD     CONSTANT NUMBER := 250 ;
		 /* cursor used for data load */	
		 /* previous spec, 0 and null same for avgRepairCycleTime from ramp */
		 /* appears for BULK COLLECT to work, cursor needs to be 
		 in column id order (i.e. cannot just qualify by field name) 
		 and all columns have to be accounted for */			
		 -- decode(nvl(GetAvgRepairCycleTime(ansi.nsn, loc_id), 0), 0, decode(IsPartRepairable(nsi_sid), 'Y', Amd_Defaults.TIME_TO_REPAIR_ONBASE, someOtherDefault ), GetAvgRepairCycleTime(ansi.nsn, loc_id)) time_to_repair,
	CURSOR locPartLeadtime_cur IS
		  	SELECT spo_prime_part_no part_no, 
				   loc_sid, 
				   decode(nvl(GetAvgRepairCycleTime(asp.nsn, loc_id), 0), 0, Amd_Defaults.TIME_TO_REPAIR_ONBASE, GetAvgRepairCycleTime(asp.nsn, loc_id)) time_to_repair,
				   amd_defaults.INSERT_ACTION action_code,
				   sysdate last_update_dt  
		 		FROM amd_spare_parts asp, amd_sent_to_a2a asta,
					 amd_spare_networks asn
		 		WHERE asta.part_no = asta.spo_prime_part_no 
				AND asta.spo_prime_part_no = asp.part_no
				AND asta.action_code != Amd_Defaults.DELETE_ACTION
				AND asp.action_code != Amd_Defaults.DELETE_ACTION
				AND asn.action_code != Amd_Defaults.DELETE_ACTION
				AND asn.loc_type in ('MOB', 'FSL') ;
	
	
	FUNCTION IsPartRepairable(pPartNo amd_spare_parts.part_no%TYPE ) RETURN VARCHAR2 IS
	BEGIN
		RETURN IsPartRepairable(amd_utils.GetNsiSidFromPartNo(pPartNo)) ;
	EXCEPTION WHEN OTHERS THEN
		 RETURN null ;	
	END ;
	
	FUNCTION IsPartRepairable(pNsiSid amd_national_stock_items.nsi_sid%TYPE ) RETURN VARCHAR2 IS
		 ansiRow amd_national_stock_items%ROWTYPE ;
		 smr amd_national_stock_items.SMR_CODE%TYPE ; 
	BEGIN
		 SELECT * INTO ansiRow
			FROM amd_national_stock_items
		 	WHERE nsi_sid = pNsiSid ;
		 IF (ansiRow.smr_code_cleaned IS NOT NULL) THEN
		 	smr := ansiRow.smr_code_cleaned ;
		 ELSIF (ansiRow.smr_code IS NOT NULL ) THEN
		 	smr := ansiRow.smr_code ;
		 ELSE	  
		 	smr := ansiRow.smr_code_defaulted ;
		 END IF ;	
		 IF (substr(smr, 6, 1) = 'T') THEN
		 	RETURN 'Y';
		 ELSE
		 	RETURN 'N' ;
		 END IF ; 	
	EXCEPTION WHEN NO_DATA_FOUND THEN
		 RETURN null ;
	END ;			
	
	FUNCTION IsPartDeleted(pPartNo amd_sent_to_a2a.part_no%TYPE) RETURN BOOLEAN IS
		 actionCode amd_sent_to_a2a.action_code%TYPE ;
	BEGIN
		 SELECT action_code INTO actionCode
		 	 FROM amd_sent_to_a2a
		 	 WHERE  part_no = pPartNo ;
		 IF actionCode = Amd_Defaults.DELETE_ACTION THEN
		 	 RETURN true ;
		 END IF ;
		 RETURN false ;	 
	EXCEPTION WHEN NO_DATA_FOUND THEN
		 RETURN NULL ;
	END ; 			
		procedure writeMsg(
					pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
					pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
					pKey1 IN VARCHAR2 := '',
					pKey2 IN VARCHAR2 := '',
					pKey3 IN VARCHAR2 := '',
					pKey4 in varchar2 := '',
					pData IN VARCHAR2 := '',
					pComments IN VARCHAR2 := '')  IS
		BEGIN
			Amd_Utils.writeMsg (
					pSourceName => 'amd_location_part_leadtime_pkg',	
					pTableName  => pTableName,
					pError_location => pError_location,
					pKey1 => pKey1,
					pKey2 => pKey2,
					pKey3 => pKey3,
					pKey4 => pKey4,
					pData    => pData,
					pComments => pComments);
		end writeMsg ;
				
	 PROCEDURE ErrorMsg(
	     pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
	     pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
	     pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
	     pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE,
	     pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
	     pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
	     pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
	     pKeywordValuePairs IN VARCHAR2 := '') IS
	  result NUMBER ;
	  key5 amd_load_details.KEY_5%type := pKeywordValuePairs ;
	 BEGIN
	  ROLLBACK;
	  IF key5 = '' THEN
	     key5 := pSqlFunction || '/' || pTableName ;
	  ELSE
	   key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
	  END IF ;
	  -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
	  -- do not exceed the length of the column's that the data gets inserted into
	  -- This is for debugging and logging, so efforts to make it not be the source of more
	  -- errors is VERY important
	  Amd_Utils.InsertErrorMsg (
	    pLoad_no => Amd_Utils.GetLoadNo(
	      pSourceName => SUBSTR(pSqlfunction,1,20),
	      pTableName  => SUBSTR(pTableName,1,20)),
	    pData_line_no => pError_location,
	    pData_line    => 'amd_location_part_leadtime_pkg',
	    pKey_1 => SUBSTR(pKey_1,1,50),
	    pKey_2 => SUBSTR(pKey_2,1,50),
	    pKey_3 => SUBSTR(pKey_3,1,50),
	    pKey_4 => SUBSTR(pKey_4,1,50),
	    pKey_5 =>  TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ||
	         ' ' || substr(key5,1,50),
	    pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
	  COMMIT;
	 END ErrorMsg;
				
	FUNCTION GetRampData(pNsn amd_nsns.nsn%TYPE, pLocSid amd_spare_networks.loc_sid%TYPE) RETURN ramp%ROWTYPE IS
		rampData ramp%ROWTYPE := null;
		locId amd_spare_networks.loc_id%TYPE;
	BEGIN
		locId := amd_utils.GetLocId(pLocSid);
		IF (locId IS null) THEN
		    RETURN rampData;
		ELSE
			RETURN GetRampData(pNsn, locId);
		END IF;
	EXCEPTION WHEN OTHERS THEN
		RETURN null ;	
	END GetRampData;
	
	
	FUNCTION GetRampData(pNsn amd_nsns.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) RETURN ramp%ROWTYPE IS
	    CURSOR rampData_cur (pNsn ramp.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) IS
			SELECT * 
			FROM
			   ramp
			WHERE
			   replace(current_stock_number, '-') = pNsn AND
			   substr(sc, 8, 6) = pLocId;
		
		rampData rampData_cur%ROWTYPE := null;
		-- though currently ramp does not RETURN more than one record, design
		-- of ramp table allows. current_stock_number IS not part of key.
		-- use explicit CURSOR just in case.
	
		BEGIN
			 IF (NOT rampData_cur%isopen) THEN
		   	 	OPEN rampData_cur(pNsn, pLocId);
			 END IF;
			 FETCH rampData_cur INTO
			    rampData;
		     CLOSE rampData_cur;
		RETURN rampData;
	END GetRampData;
	
	FUNCTION GetAvgRepairCycleTime(pNsn amd_nsns.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) RETURN ramp.AVG_REPAIR_CYCLE_TIME%TYPE IS
		rampData ramp%ROWTYPE ;
	BEGIN
		rampData := GetRampData(pNsn, pLocId);
		RETURN rampData.avg_repair_cycle_time ;
	END GetAvgRepairCycleTime ; 
	
	
	
	PROCEDURE UpdateAmdLocPartLeadtime (
	  		  pPartNo 			   		amd_location_part_leadtime.part_no%TYPE,
			  pLocSid 					amd_spare_networks.loc_sid%TYPE, 
			  pTimeToRepair				amd_location_part_leadtime.time_to_repair%TYPE,
			  pActionCode				amd_location_part_leadtime.action_code%TYPE,
			  pLastUpdateDt				amd_location_part_leadtime.last_update_dt%TYPE ) IS
			  returnCode NUMBER ;
	BEGIN
		 	  UPDATE amd_location_part_leadtime
			  SET 
			  	  time_to_repair 			= pTimeToRepair,
				  action_code				= pActionCode,
				  last_update_dt			= pLastUpdateDt
			  WHERE
			  	  part_no = pPartNo AND
				  loc_sid = pLocSid ;
	exception when others then
			  errorMsg(pSqlFunction => 'update',
			  		pTablename => 'amd_location_part_leadtime',
					pError_location => 10,
					pKey_1 => pPartNo, pKey_2 => to_char(pLocSid) ) ;			  
	END UpdateAmdLocPartLeadtime ;		  					   
	
	
	
	PROCEDURE InsertAmdLocPartLeadtime (
			  pPartNo 			   		amd_location_part_leadtime.part_no%TYPE,
			  pLocSid 					amd_spare_networks.loc_sid%TYPE, 
			  pTimeToRepair				amd_location_part_leadtime.time_to_repair%TYPE,
			  pActionCode				amd_location_part_leadtime.action_code%TYPE,
			  pLastUpdateDt				amd_location_part_leadtime.last_update_dt%TYPE ) IS
	BEGIN
		 INSERT INTO amd_location_part_leadtime 
		 (
		  		part_no,
				loc_sid,
				time_to_repair,
				action_code,
				last_update_dt
		 )
		 VALUES 
		 (
		  		pPartNo,
				pLocSid,
				pTimeToRepair,
				pActionCode,
				pLastUpdateDt	 
		 ) ;	
	EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
		 	  UpdateAmdLocPartLeadtime
		 	  (
	  		    pPartNo,
				pLocSid,
				pTimeToRepair,
				pActionCode,
				sysdate
		 	  ) ;	 
		  
	END InsertAmdLocPartLeadtime ;
	
	PROCEDURE InsertTmpA2A_LPLT (
				  pPartNo			VARCHAR2,
				  pBaseName			VARCHAR2,
				  pLeadtimetype		VARCHAR2, 
				  pLeadTime			NUMBER,
				  pActionCode		VARCHAR2,
				  pLastUpdateDt		DATE
				  ) IS
		returnCode NUMBER ;		  
	BEGIN
		BEGIN
			 if a2a_pkg.isPartValid(pPartNo) and a2a_pkg.wasPartSent(pPartNo) then
				 INSERT INTO tmp_a2a_loc_part_lead_time (
					  part_no,
					  site_location,
					  lead_time_type,
					  lead_time,
					  action_code,
					  last_update_dt
				 )	  
				 VALUES
				 (	
				 	  pPartNo,
					  pBaseName,
					  pLeadtimetype,
					  pLeadTime,
					  pActionCode,
					  pLastUpdateDt		 	
				 ) ;
			end if ;
		EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
				begin
					UPDATE tmp_a2a_loc_part_lead_time
					SET	   lead_time_type = pLeadtimetype,
						   lead_time	  = pLeadTime,
						   action_code	  = pActionCode,
					   	   last_update_dt = pLastUpdateDt 
					WHERE
						   part_no 		  = pPartNo AND
						   site_location  = pBaseName ;
				exception when others then
						  errorMsg(pSqlFunction => 'update', pTablename => 'tmp_a2a_loc_part_lead_time', 
						  		pError_location => 20, pKey_1 => pPartNo, pKey_2 => pBaseName) ;
				end ;
		END ;	 
	 
	END InsertTmpA2A_LPLT ;
	
	/*  
		-------------------------------------------------------------
		InsertRow, UpdateRow, DeleteRow called From Java diff program
		-------------------------------------------------------------	 
	*/
	
	FUNCTION InsertRow(
			pPartNo                      amd_location_part_leadtime.part_no%TYPE,
			pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
			pTimeToRepair				 amd_location_part_leadtime.time_to_repair%TYPE)
			RETURN NUMBER IS
			returnCode NUMBER ;		
	BEGIN
		 BEGIN
		 	  InsertAmdLocPartLeadtime
			  (
		  	   	pPartNo,
				pLocSid,
				pTimeToRepair,
				Amd_Defaults.INSERT_ACTION,
				sysdate
		 	  ) ;	
		 EXCEPTION WHEN OTHERS THEN
		 		   ErrorMsg( pSqlfunction => 'insert',
					   pTableName  	  	  => 'amd_location_part_leadtime',
					   pError_location 	  => 20,
					   pKey_1			  => pPartNo,
		   			   pKey_2			  => pLocSid) ;
				   RAISE ;	  
		 END ;	  	
		 
		 BEGIN
		 	  --
		 	  -- decode(IsPartRepairable(pPartNo),'Y', LEADTIMETYPE, LEADTIMETYPE_CONSUM) 
			  --  	
		 	  InsertTmpA2A_LPLT 
			  (
			      pPartNo,
				  amd_utils.GetSpoLocation(pLocSid),
				  LEADTIMETYPE, 
				  pTimeToRepair,
				  Amd_Defaults.INSERT_ACTION,
				  sysdate
			  ) ;
		 EXCEPTION WHEN OTHERS THEN
		 		ErrorMsg(pSqlfunction 	  => 'insert',
					   pTableName  	  	  =>'tmp_a2a_loc_part_lead_time',
					   pError_location 	  => 30,
					   pKey_1			  => pPartNo,
		   			   pKey_2			  => pLocSid) ;
			  	RAISE ;		   					  			  
		 END ;
	 	 RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		 RETURN FAILURE ;
	END InsertRow ;		
			
	
			
	FUNCTION UpdateRow(
			pPartNo                      amd_location_part_leadtime.part_no%TYPE,
			pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
			pTimeToRepair				 amd_location_part_leadtime.time_to_repair%TYPE)		RETURN NUMBER IS
			returnCode NUMBER ;
	BEGIN
		 BEGIN
		 	  UpdateAmdLocPartLeadtime
		 	  (
	  		    pPartNo,
				pLocSid,
				pTimeToRepair,
				Amd_Defaults.UPDATE_ACTION,
				sysdate 
		 	  ) ;
			 
		EXCEPTION WHEN OTHERS THEN
				  ErrorMsg(
				   pSqlfunction 	  	  => 'update',
				   pTableName  	  	  =>'amd_location_part_leadtime',
				   pError_location 	  => 40,
				   pKey_1			  => pPartNo,
	   			   pKey_2			  => pLocSid) ;
				   RAISE ;		
		 END ;
		 BEGIN
	 	  InsertTmpA2A_LPLT 
			  (
			      pPartNo,
				  amd_utils.GetSpoLocation(pLocSid),
				  LEADTIMETYPE, 
				  pTimeToRepair,
				  Amd_Defaults.UPDATE_ACTION,
				  sysdate
			  ) ;
		 EXCEPTION WHEN OTHERS THEN
		 		 ErrorMsg(
				   pSqlfunction 	  	  => 'insert',
				   pTableName  	  	  =>'tmp_a2a_loc_part_lead_time',
				   pError_location 	  => 50,
				   pKey_1			  => pPartNo,
	   			   pKey_2			  => pLocSid) ;
			  	RAISE ;	
		 END ;	  
		 RETURN SUCCESS ; 	  
	EXCEPTION WHEN OTHERS THEN
		 RETURN FAILURE ;		   
	END UpdateRow ;		
	
	
	
	FUNCTION DeleteRow(
			pPartNo                      amd_location_part_leadtime.part_no%TYPE,
			pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
			pTimeToRepair				 amd_location_part_leadtime.time_to_repair%TYPE)		RETURN NUMBER IS
			returnCode NUMBER ;
	BEGIN
		 BEGIN
		 	  UpdateAmdLocPartLeadtime
			  (
		  	   	pPartNo,
				pLocSid,
				pTimeToRepair,
				Amd_Defaults.DELETE_ACTION,
				sysdate
		 	  ) ;
		 EXCEPTION WHEN OTHERS THEN
		 		 ErrorMsg(pSqlFunction => 'update',
				   pTableName  	  	  =>'amd_location_part_leadtime',
				   pError_location 	  => 60,
				   pKey_1			  => pPartNo,
	   			   pKey_2			  => pLocSid) ;
				   RAISE ;		
		 END ;	  	
		 
		 BEGIN
		 /*
		 	  "Deletion of Parts,  No parts are physically deleted from the data system or SPO, it is all logically deleted.  
			  In that case the only thing you have to do is send a delete  transaction in for the part 
			  and we will set the end_date and set the planned_flag to 'F'
	
			  All child records for the deleted part will not be used because the parent is "logically deleted".
	
			  -- multi deletes can cause error and a delete action when the part is already deleted.
			  -- only send when location has been deleted.
		 */	  
		-- 	  IF (NOT IsPartDeleted(pPartNo) ) THEN
		 	 	  InsertTmpA2A_LPLT 
		 		  (
		 		      pPartNo,
		 			  amd_utils.GetSpoLocation(pLocSid),
		 			  LEADTIMETYPE, 
		 			  pTimeToRepair,
		 			  Amd_Defaults.DELETE_ACTION,
		 			  sysdate
		 		  ) ;
		--	  END IF ;		  
		 EXCEPTION WHEN OTHERS THEN
		 		 ErrorMsg(
				   pSqlFunction 	  => 'InsertTmpA2A_LPLT',
				   pTableName  	  	  =>'tmp_a2a_loc_part_lead_time',
				   pError_location 	  => 70,
				   pKey_1			  => pPartNo,
	   			   pKey_2			  => pLocSid) ;
			  	RAISE ;	
		 END ;
		 RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN	 
	   	 RETURN FAILURE ;
	END DeleteRow ;		
	
		procedure processData(rec in locationPartLeadTimeRec) is
				  procedure doUpdate is
				  begin
				  	   update tmp_a2a_loc_part_lead_time
					   set lead_time_type = rec.lead_time_type,
					   lead_time = rec.time_to_repair,
					   action_code = rec.action_code,
					   last_update_dt = sysdate
					   where part_no = rec.part_no
					   and site_location = rec.site_location ;
				  exception when others then
				       ErrorMsg(pSqlfunction => 'update',
					     pTableName => 'tmp_a2a_loc_part_lead_time', pError_location => 80,
					     pKey_1 => rec.part_no, pKey_2 => rec.site_location) ;
				       RAISE ;
				  end doUpdate ;
		begin
		 	insert into tmp_a2a_loc_part_lead_time
			 	 		(part_no,lead_time_type, lead_time, action_code, 
						 last_update_dt,site_location )
			values (rec.part_no, rec.lead_time_type, rec.time_to_repair, rec.action_code, 
				   sysdate, rec.site_location) ;
			
		   exception 
			  when standard.DUP_VAL_ON_INDEX then
			   doUpdate ;
			  when others then
		       ErrorMsg(pSqlfunction => 'insert',
		     pTableName => 'tmp_a2a_loc_part_lead_time',
		     pError_location => 90,
		     pKey_1 => rec.part_no, pKey_2 => rec.site_location) ;
		       RAISE ;
		end processData ;
		
		procedure processLocPartLeadtime(locPartLeadTime in locPartLeadTimeCur) is
				  cnt number := 0 ;
				  rec locationPartLeadTimeRec ;
		begin
			 writeMsg(pTableName => 'tmp_a2a_loc_part_lead_time', pError_location => 100,
					pKey1 => 'processLocPartLeadTime started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
			 loop
			 	 fetch locPartLeadTime into rec ;
				 exit when locPartLeadTime%NOTFOUND ;
			 	 processData(rec);
				 if mod(cnt,COMMIT_THRESHOLD) = 0 then
				 	commit ;
				 end if ; 
				 cnt := cnt + 1 ;			 
			 end loop ;
	
			 writeMsg(pTableName => 'tmp_a2a_loc_part_lead_time', pError_location => 110,
					pKey1 => 'Rows processed = ' || cnt,
					pKey2 => 'processLocPartLeadTime ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
			 commit ;
		end ;
		
		procedure loadA2AByDate (from_dt in date := a2a_pkg.start_dt, to_dt in date := sysdate) is
			dataByDate locPartLeadTimeCur ;
		begin
			 writeMsg(pTableName => 'tmp_a2a_loc_part_lead_time', pError_location => 120,
					pKey1 => 'loadA2AByDate(' || from_dt || ',' || to_dt || ') started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
					
			 Mta_Truncate_Table('tmp_a2a_loc_part_lead_time','reuse storage');
			 a2a_pkg.setSendAllData(true) ;
			 open dataByDate for
			 	 SELECT
				 	  distinct	 
			 	      part_no,			  
					  LEADTIMETYPE lead_time_type, 
					  time_to_repair,
					  action_code,
					  sysdate,
					  amd_utils.GetSpoLocation(loc_sid) site_location
				 FROM
				 	  amd_location_part_leadtime 
				 WHERE 
					  trunc(last_update_dt) between trunc(from_dt) and trunc(to_dt) 
		  			  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A where spo_prime_part_no is not null);
			 processLocPartLeadTime(dataByDate) ;
			 close dataByDate ;
	
			 writeMsg(pTableName => 'tmp_a2a_loc_part_lead_time', pError_location => 130,
					pKey1 => 'loadA2AByDate(' || from_dt || ',' || to_dt || ') ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
		end loadA2AByDate ;
		
		PROCEDURE LoadAllA2A(useTestParts in boolean := false) IS
			locPartLeadTime locPartLeadTimeCur ;		  		   		
			
			useTestPartsString varchar2(5) := 'False' ;
			
			
		begin
			 writeMsg(pTableName => 'tmp_a2a_loc_part_lead_time', pError_location => 140,
					pKey1 => 'loadAllA2A(' || useTestPartsString || ') started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
	
			 Mta_Truncate_Table('tmp_a2a_loc_part_lead_time','reuse storage');
			 a2a_pkg.setSendAllData(true) ;
			 if useTestParts then
			 	useTestPartsString := 'True' ;
			    open locPartLeadTime for
			 	 SELECT
				 	  distinct	 
			 	      part_no,			  
					  LEADTIMETYPE lead_time_type, 
					  time_to_repair,
					  action_code,
					  sysdate,
					  amd_utils.GetSpoLocation(loc_sid) site_location
				 FROM
				 	  amd_location_part_leadtime 
				 WHERE 
					  part_no in (select part_no from amd_test_parts)
		  			  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A where spo_prime_part_no is not null) ;
			 else
			 	 open locPartLeadTime for
				 	 SELECT
					 	  distinct	 
				 	      part_no,			  
						  LEADTIMETYPE lead_time_type, 
						  time_to_repair,
						  action_code,
						  sysdate,
						  amd_utils.GetSpoLocation(loc_sid) site_location
					 FROM
					 	  amd_location_part_leadtime 
					 WHERE 
			  			  part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A where spo_prime_part_no is not null);
				 
			 end if ;
			 processLocPartLeadTime(locPartLeadTime) ;
			 close locPartLeadTime ;
	
			 writeMsg(pTableName => 'tmp_a2a_loc_part_lead_time', pError_location => 150,
					pKey1 => 'loadAllA2A(' || useTestPartsString || ') ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
		     commit ;
		end loadAllA2a ;		  	
					
	PROCEDURE LoadTmpAmdLocPartLeadtime IS
		 TYPE ARRAY IS TABLE OF tmp_amd_location_part_leadtime%ROWTYPE;
		 l_data ARRAY;
		  returnCode NUMBER ;
	BEGIN
		mta_truncate_table('tmp_amd_location_part_leadtime','reuse storage');
		mta_truncate_table('tmp_a2a_loc_part_lead_time','reuse storage');
		COMMIT ;
		OPEN locPartLeadtime_cur ;
	    LOOP
		    FETCH locPartLeadtime_cur BULK COLLECT INTO l_data LIMIT BULKLIMIT ;
	
	    	FORALL i IN 1..l_data.COUNT -- SAVE EXCEPTIONS
		    	   INSERT INTO tmp_amd_location_part_leadtime
				   VALUES l_data(i) ;
		   COMMIT ;
		   EXIT WHEN locPartLeadtime_cur%NOTFOUND;
	    END LOOP;
	    CLOSE locPartLeadtime_cur;	
		COMMIT ;
	EXCEPTION WHEN OTHERS THEN
			  ErrorMsg(
				   pSqlFunction 	  	  => 'forall insert',
				   pTableName  	  	  =>'tmp_amd_location_part_leadtime',
				   pError_location 	  => 160,
				   pKey_1 => 'failed') ;
			 raise ;
	END ;	
	
	PROCEDURE LoadAmdLocPartLeadtime IS
		-- defaultTimeToRepair tmp_amd_location_part_leadtime.time_to_repair_defaulted%TYPE := amd_defaults.TIME_TO_REPAIR_ONBASE ;
		 TYPE ARRAY IS TABLE OF amd_location_part_leadtime%ROWTYPE;
		 l_data ARRAY;
		 returnCode NUMBER ;
	BEGIN
		mta_truncate_table('amd_location_part_leadtime','reuse storage');
		COMMIT ;
		
		OPEN locPartLeadtime_cur;
	    LOOP
		    FETCH locPartLeadtime_cur BULK COLLECT INTO l_data LIMIT BULKLIMIT ;
	
	    	FORALL i IN 1..l_data.COUNT -- SAVE EXCEPTIONS
	    	   INSERT INTO amd_location_part_leadtime
			   VALUES l_data(i) ;
			   COMMIT;
			   EXIT WHEN locPartLeadtime_cur%NOTFOUND;		   
	    END LOOP;
	    CLOSE locPartLeadtime_cur;	
		COMMIT ;
	EXCEPTION WHEN OTHERS THEN
			  ErrorMsg(
				   pSqlFunction 	=> 'forall insert',
				   pTableName  	  	  =>'amd_location_part_leadtime',
				   pError_location 	  => 170,
				   pKey_1		  => 'load bulk insert') ;
			 raise ;
	END ;	  		
	  		
	
	PROCEDURE LoadInitial IS
	BEGIN
		 LoadTmpAmdLocPartLeadtime ;
		 LoadAmdLocPartLeadtime ;
		 LoadAllA2A(false) ;
	END ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_location_part_leadtime_pkg', 
		 		pError_location => 180, pKey1 => 'amd_location_part_leadtime_pkg', pKey2 => '$Revision:   1.13  $') ;
	end version ;
	
END AMD_LOCATION_PART_LEADTIME_PKG ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_LOAD AS

    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.40  $
         $Date:   Sep 18 2006 10:16:24  $
     $Workfile:   amd_load.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_load.pkb-arc  $
   
      Rev 1.40   Sep 18 2006 10:16:24   zf297a
   Removed infoMsg.  Added writeMsg at the start and the end of loadGold, loadPsms, and loadMain.  Changed all execute immediates to use mta_truncate_table.  Changed errorMsg to have default values for all args and changed error_location to pError_Location.   Added dbms_output.put_line to version.  Fixed 2nd select of bssm data to use only the part and verify that it has an nsn_type of C for current.
   
      Rev 1.39   Sep 15 2006 14:49:44   zf297a
   Added data_source to insertSiteRespAssetMgr
   
      Rev 1.38   Jul 11 2006 11:23:34   zf297a
   Removed quotes from package name
   
      Rev 1.37   Jun 09 2006 11:44:56   zf297a
   implemented version
   
      Rev 1.36   Jun 04 2006 13:27:26   zf297a
   Fixed createSiteRespAssetMgrA2Atran to use a cursor.

      Rev 1.35   Mar 20 2006 08:57:00   zf297a
   Added  "Future use" comments

      Rev 1.34   Mar 19 2006 01:50:50   zf297a
   Used didStepComplete to conditionally execute a batch step only once for a given job.

      Rev 1.33   Mar 17 2006 09:06:00   zf297a
   Eliminated rudundant step ending code.

      Rev 1.32   Mar 16 2006 15:24:18   zf297a
   Add steps to PrepAmdDatabase

      Rev 1.31   Mar 16 2006 15:08:20   zf297a
   Added step info to preProcess and LoadGoldPsmsMain

      Rev 1.30   Mar 16 2006 10:37:40   zf297a
   Fixed retrieval of bssm data: try to retrieve the data using nsn and if the data is not found, use the part_no.  Write separate procedures for the routinese that gather rmads data and bssm data to enable easy unit testing.

      Rev 1.29   Mar 08 2006 12:01:04   zf297a
   Added mtbdr_computed

      Rev 1.28   Mar 05 2006 21:19:50   zf297a
   Implemented  loadGoldPsmsMain, preProcess, postProcess, postDiffProcess, prepAmdDatabase, disableAmdConstraints, truncateAmdTables, and enableAmdConstraints to simplify the amd_loader.ksh script.

      Rev 1.27   Dec 15 2005 12:12:52   zf297a
   Added truncate table for tmp_a2a_bom_detail and tmp_a2a_part_effectivity to loadGold

      Rev 1.26   Dec 07 2005 13:18:18   zf297a
   Fixed insertUsersRow by returning SUCCESS after a doUpdate is invoked without an error.

      Rev 1.25   Dec 07 2005 12:22:48   zf297a
   fixed insertUsersRow by adding a doUpdate routine for a user that has been

      Rev 1.24   Dec 06 2005 09:46:24   zf297a
   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS

      Rev 1.23   Nov 23 2005 07:39:02   zf297a
   Fixed routine getBssmData, the getOriginalData begin block, added an additional qualification for the subselect getting data from amd_nsns so that only one row of data is returned by this query: added "and nsn_type = 'C', which checks for the "current" nsn being used - there can only be one of these per nsi_sid.

      Rev 1.22   Aug 26 2005 14:50:26   zf297a
   updated getOffBaseTurnAroundTime to use an action taken of 'F' (modification/repair) and changed interface for amd_clean_data to use both nsn and part_no

      Rev 1.23   Aug 23 2005 12:16:08   zf297a
   Used new interface, which uses nsn and part_no, for the best spares cleaned data

      Rev 1.22   Aug 19 2005 12:45:24   zf297a
   Converted time_to_repair_off_base_cleand and order_lead_time_cleaned from months to calendar days.  Converted order_lead_time from business days to calendar days.

      Rev 1.21   Aug 16 2005 14:12:30   zf297a
   removed loadCurrentBackorder

      Rev 1.20   Aug 09 2005 09:52:26   zf297a
   Added the ability to dynamically use debugMsg via the amd_param_changes table having a param debugAmdLoad with a value of 1.

      Rev 1.19   Aug 05 2005 12:28:12   zf297a
   Fixed insertRow for amd_planners to handle changing of a logically deleted planner to an added planner.  Added return SUCCESS to insertUsersRow, updateUsersRow, and deleteUsersRow.

      Rev 1.18   Aug 04 2005 14:43:54   zf297a
   Implemented insertUsersRow, updateUsersRow, and deleteUsersRow for the amd_users diff java application.

      Rev 1.17   Jul 28 2005 08:42:08   zf297a
   Qualified cursors currentUsers, newUsers, and deleteUsers with action_codes not equal to amd_defaults.DELETE_ACTION.

      Rev 1.16   Jul 27 2005 14:56:38   zf297a
   Refined newUsers and deleteUsers cursors for loadUsers

      Rev 1.15   Jul 27 2005 11:48:32   zf297a
   Fixed getBemsId by transforming the employeeNo into a work field before it is used in a query.  Fixed loadUsers by refering to the besm_id via the rec variable for the insert statement and the invocation of the spo routines.

      Rev 1.14   Jul 26 2005 12:32:22   zf297a
   Enhanced the loadUsers procedure to use the getBemsId function.

      Rev 1.13   Jul 20 2005 07:47:00   zf297a
   using only bems_id for amd_users

      Rev 1.12   Jul 19 2005 14:22:48   zf297a
   added procedure loadUsers - populates the amd_users table and sends inserts, updates, and deletes via the a2a_pgk.spoUser procedure.

      Rev 1.11   Jun 10 2005 11:23:32   c970183
   using new version of insertSiteRespAssetMgr with the additional param of action_code

      Rev 1.10   Jun 09 2005 14:58:58   c970183
   Added insert, update, and delete routines for the amd_planners diff and the amd_planner_logons diff.

      Rev 1.9   May 17 2005 14:24:12   c970183
   Modified getCleaned block to use the amd_clean_data package functions.

      Rev 1.8   May 17 2005 10:18:24   c970183
   Update InsertErrorMessage to new interface

      Rev 1.7   May 16 2005 12:02:12   c970183
   Moved time_to_repair_off_base and cost_to_repair_off_base from amd_part_locs to be part of tmp_amd_spare_parts.

      Rev 1.5   Apr 27 2005 09:19:28   c970183
   added infoMsg, which is almost the same as ErrorMsg, but it does not do a Rollback or a commit.
		  **/
	--
	-- Local Declarations
	--
	THIS_PACKAGE 		   constant varchar2(8) := 'amd_load' ;
	THE_AMD_INVENTORY_PKG  constant varchar2(13) := 'amd_inventory' ;

	mDebug	 			   BOOLEAN := FALSE ;
	PROCEDURE performLogicalDelete(
							pPartNo VARCHAR2);

	PROCEDURE debugMsg(pMsg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE) IS
	BEGIN
	  IF mDebug THEN
	        Amd_Utils.debugMsg(pMsg) ;
			commit ;
	  END IF ;
	END debugMsg ;



	--
	-- procedure/Function bodies
	--

	 FUNCTION getBemsId(employeeNo IN AMD_USE1.EMPLOYEE_NO%TYPE) RETURN AMD_USERS.BEMS_ID%TYPE IS
	 		   bems_id amd_people_all_v.BEMS_ID%TYPE ;

		   wk_employeeNo AMD_USE1.employee_no%TYPE := UPPER(trim(REPLACE(employeeNo,';',''))) ;

		   FUNCTION isNumber(txt IN VARCHAR2) RETURN BOOLEAN IS
		   			theNumber NUMBER ;
		   BEGIN
		        <<testForNumber>>
		   		BEGIN
					 theNumber := TO_NUMBER(txt) ;
				EXCEPTION WHEN VALUE_ERROR THEN
						  theNumber := NULL ;
				END testForNumber ;
				RETURN (theNumber IS NOT NULL) ;
		   END isNumber ;
	 BEGIN
	   IF SUBSTR(wk_employeeNo,LENGTH(wk_employeeNo),1) NOT IN ('1','2','3','4','5','6','7','8','9','0') THEN
	   	  wk_employeeNo := SUBSTR(wk_employeeNo,1,LENGTH(wk_employeeNo) - 1) ; -- strip non-numeric suffix
	   END IF ;

	   IF SUBSTR(wk_employeeNo,1,1) = 'C' THEN
	   	  SELECT bems_id INTO getBemsId.bems_id
		  FROM amd_people_all_v
		  WHERE UPPER(emp_id) = wk_employeeNo ;
	   ELSE
	   	   IF isNumber(wk_employeeNo) AND LENGTH(wk_employeeNo) = 6 THEN
		   	  getBemsId.bems_id := '0' || wk_employeeNo ;
		   ELSE
		   	  getBemsId.bems_id := wk_employeeNo ;
		   END IF ;
	  	   SELECT bems_id INTO getBemsId.bems_id
		   FROM amd_people_all_v
		   WHERE bems_id = getBemsId.bems_id ;
	  END IF ;

	  RETURN getBemsId.bems_id ;

	 EXCEPTION WHEN standard.NO_DATA_FOUND THEN
	 			dbms_output.put_line('bems_id not found for ' || wk_employeeNo) ;
	 			RETURN NULL ;
	 END getBemsId ;

	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_load',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	

	PROCEDURE errorMsg(
					sqlFunction IN VARCHAR2 := 'errorMsg',
					tableName IN VARCHAR2 := 'noname',
					pErrorLocation IN NUMBER := -100,
					key1 IN VARCHAR2 := '',
			 		key2 IN VARCHAR2 := '',
					key3 IN VARCHAR2 := '',
					key4 IN VARCHAR2 := '',
					key5 IN VARCHAR2 := '',
					keywordValuePairs IN VARCHAR2 := '')  IS
	BEGIN
		ROLLBACK;
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => sqlFunction,
						pTableName  => tableName),
				pData_line_no => pErrorLocation,
				pData_line    => THIS_PACKAGE,
				pKey_1 => key1,
				pKey_2 => key2,
				pKey_3 => key3,
				pKey_4 => key4,
				pKey_5 => key5 || ' ' || TO_CHAR(SYSDATE,'MM/DD/YY HH:MM:SS') ||
						   ' ' || keywordValuePairs,
				pComments => 'sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')');
		COMMIT;
		RETURN ;
	END ErrorMsg;

	/* function GetOffBaseRepairCost, logic same as previous load version */
	FUNCTION  GetOffBaseRepairCost(pPartNo CHAR) RETURN AMD_PART_LOCS.cost_to_repair%TYPE IS
		offBaseRepairCost   AMD_PART_LOCS.cost_to_repair%TYPE := NULL;
		--
		--    Use only PART   number because POI1 does not have Cage Code.
		--
	BEGIN
		SELECT
			SUM(NVL(ext_price,0))/COUNT(*)
		INTO offBaseRepairCost
		FROM POI1
		WHERE
			part = pPartNo
			AND SUBSTR(ccn,1,5) IN ( SELECT ccn_prefix FROM AMD_CCN_PREFIX )
			AND NVL(ext_price,0) > 0;
		RETURN(offBaseRepairCost);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			 RETURN NULL;
	END GetOffBaseRepairCost;

	/* function get_off_base_tat, logic same as previous load version
	   removed offbasediag time from previous version */
	FUNCTION GetOffBaseTurnAround (pPartno CHAR) RETURN AMD_PART_LOCS.time_to_repair%TYPE IS
		-- goldpart      char(50);
		offBaseTurnAroundTime AMD_PART_LOCS.time_to_repair%TYPE;

	BEGIN
		SELECT
			AVG( completed_docdate  - created_docdate)
		INTO offBaseTurnAroundTime
		FROM ORD1
		WHERE
			part = pPartNo
			AND NVL(action_taken,'*') IN ('A', 'B', 'E', 'G', 'F', '*' )
			AND order_type = 'J'
			AND completed_docdate IS NOT NULL
		GROUP BY part;
		RETURN offBaseTurnAroundTime;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN NULL;
	END GetOffBaseTurnAround;

	FUNCTION  getUnitCost(
							pPartNo VARCHAR2) RETURN NUMBER IS
		CURSOR costCur IS
			SELECT cap_price
			FROM PRC1
			WHERE
				part = pPartNo
			ORDER BY
				sc DESC;

		unitCost     NUMBER;
	BEGIN
		FOR rec IN costCur LOOP
			unitCost := rec.cap_price;
			EXIT;
		END LOOP;

		RETURN unitCost;
	END;


	FUNCTION getMmac(
			 		 				  pNsn  VARCHAR2) RETURN VARCHAR2 IS
			CURSOR macCur IS
				   SELECT nsn_smic
				   FROM NSN1
				   WHERE
				    	 nsn = pNsn;

		mMac			 VARCHAR2(2);
		BEGIN
			 FOR rec IN macCur LOOP
			 	 mMac :=rec.nsn_smic;
				 EXIT;
			END LOOP;

		RETURN mMac;
	END;


	PROCEDURE performLogicalDelete(
							pPartNo VARCHAR2) IS
		nsiSid    AMD_NSNS.nsi_sid%TYPE;
		nsnCnt    NUMBER;
	BEGIN

		UPDATE AMD_SPARE_PARTS SET
			nsn            = NULL,
			action_code    = Amd_Defaults.DELETE_ACTION,
			last_update_dt = SYSDATE
		WHERE part_no = pPartNo;

		BEGIN
			SELECT nsi_sid
			INTO nsiSid
			FROM AMD_NSI_PARTS
			WHERE part_no = pPartNo
				AND unassignment_date IS NULL;

			UPDATE AMD_NSI_PARTS SET
				unassignment_date = SYSDATE
			WHERE part_no = pPartNo
				AND nsi_sid = nsiSid;

			SELECT COUNT(*)
			INTO nsnCnt
			FROM AMD_NSI_PARTS
			WHERE nsi_sid = nsiSid
				AND unassignment_date IS NULL;

			IF (nsnCnt = 0) THEN
				UPDATE AMD_NATIONAL_STOCK_ITEMS SET
					action_code    = Amd_Defaults.DELETE_ACTION,
					last_update_dt = SYSDATE
				WHERE nsi_sid = nsiSid;
			END IF;

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				NULL;
		END;

	END;


	FUNCTION onNsl(
							pPartNo VARCHAR2) RETURN BOOLEAN IS
		recCnt     NUMBER;
	BEGIN

		SELECT COUNT(*)
		INTO recCnt
		FROM AMD_NSNS an
		WHERE nsi_sid IN
				(SELECT nsi_sid
				FROM AMD_NSI_PARTS
				WHERE part_no = pPartNo
					AND unassignment_date IS NULL)
			AND nsn_type = 'C'
			AND nsn LIKE 'NSL%';

		IF (recCnt != 0) THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END;


	FUNCTION  GetSmr(
							pPsmsInst VARCHAR2,
							pPart VARCHAR2,
							pCage VARCHAR2) RETURN VARCHAR2 IS

		/* -------------------------------------------------- */
		/* 1) if there is only one smr code found in PSMS,    */
		/*    use that smr Code.                              */
		/* 2) if more than one smr code found:                */
		/*    2.1) Use the most occurrences in HG table which */
		/*         have length of six characters.             */
		/*    2.2) if there is equal   number of occurrences of */
		/*         smr with length of six characters, select  */
		/*         one smr(anyone).                           */
		/*    2.3) if no smr code with length of six char.    */
		/*         found, use the most occurrences in hg.     */
		/* -------------------------------------------------- */

		CURSOR sel_psmsprod_smr IS
			SELECT
				hg.smrcodhg,
				COUNT(*),
				MAX(NVL(LENGTH(hg.smrcodhg),0))
			FROM
				amd_psms_ldmhg hg,
				amd_psms_ldmha ha
			WHERE
				hg.ipn          = ha.ipn
				AND ha.refnumha = pPart
				AND ha.cagecdxh = pCage
				AND HG.smrcodhg IS NOT NULL
			GROUP BY
				hg.smrcodhg
			ORDER BY
				MAX(NVL(LENGTH(hg.smrcodhg),0)) DESC,
				COUNT(*) DESC;

		CURSOR sel_psmsvend_smr IS
			SELECT
				hg.smrcodhg,
				COUNT(*),
				MAX(NVL(LENGTH(hg.smrcodhg),0))
			FROM
				amd_psmv_ldmhg hg,
				amd_psmv_ldmha ha
			WHERE
				hg.ipn          = ha.ipn
				AND ha.refnumha = pPart
				AND ha.cagecdxh = pCage
				AND hg.smrcodhg IS NOT NULL
			GROUP BY
				HG.smrcodhg
			ORDER BY
				MAX(NVL(LENGTH(HG.smrcodhg),0)) DESC,
				COUNT(*) DESC;

		smr   VARCHAR2(6);
		cnt   NUMBER;
		len   NUMBER;
	BEGIN

		IF pPsmsInst = 'PSMSPROD' THEN
			OPEN sel_psmsprod_smr;
			FETCH sel_psmsprod_smr INTO smr, cnt, len;
			CLOSE sel_psmsprod_smr;
		ELSE
			OPEN sel_psmsvend_smr;
			FETCH sel_psmsvend_smr INTO smr, cnt, len;
			CLOSE sel_psmsvend_smr;
		END IF;

		RETURN smr;

	END GetSmr;




	/* ------------------------------------------------------------------- */
	/*  This procedure returns PSMS Instance to be used: */
	/*                                                                     */
	/*  - PSMSVend Instance keeps Generic Engine Parts.(Pratt and Whitneys)*/
	/*             Per Dan Manigavlt.  if we find parts in PSMSVend,      */
	/*             data is more up to date than in PSMSPROD instance      */
	/*  - PSMSPROD Instance keeps other Quick Engine Change Kit Parts      */
	/*                                                                     */
	/* ------------------------------------------------------------------- */
	FUNCTION GetPsmsInstance (
							pPart VARCHAR2,
							pCage VARCHAR2) RETURN VARCHAR2 IS

		cnt        NUMBER;
		psmsInst   VARCHAR2(8);
	BEGIN

		SELECT COUNT(*)
		INTO cnt
		FROM
			amd_psmv_ldmha ha,
			TMP_AMD_SPARE_PARTS s
		WHERE
			ha.cagecdxh     = s.mfgr
			AND ha.refnumha = s.part_no
			AND ha.cagecdxh = pCage
			AND ha.refnumha = pPart;

		IF cnt > 0 THEN
			psmsInst := 'PSMSVEND';
		ELSE

			SELECT COUNT(*)
			INTO cnt
			FROM
				amd_psms_ldmha ha,
				TMP_AMD_SPARE_PARTS s
			WHERE
				ha.cagecdxh     = s.mfgr
				AND ha.refnumha = s.part_no
				AND ha.cagecdxh = pCage
				AND ha.refnumha = pPart;

			IF cnt > 0 THEN
				psmsInst := 'PSMSPROD';
			ELSE
				psmsInst := NULL;
			END IF;

		END IF;

		RETURN psmsInst;

	END GetPsmsInstance;


	PROCEDURE GetPsmsData (
							pPartNo VARCHAR2,
							pCage VARCHAR2,
							pPsmsInst VARCHAR2,
							pSlifeDay OUT NUMBER,
							pUnitVol  OUT NUMBER,
							pSmrCode  OUT VARCHAR2) IS

		/* ------------------------------------------------------------------- */
		/*  This procedure returns PSMS data for the Part and Cage Code from   */
		/*  the specified PSMS instance. Any integer indicates Shelf Life in Days          */
		/* ------------------------------------------------------------------- */

		sLife   VARCHAR2(2);
	BEGIN

		IF (pPsmsInst = 'PSMSVEND') THEN

			SELECT
				shlifeha,
				(ulengtha * uwidthha * uheighha) / 1728
			INTO sLife, pUnitVol
			FROM
				amd_psmv_ldmha ha,
				TMP_AMD_SPARE_PARTS s
			WHERE
				ha.cagecdxh     = s.mfgr
				AND ha.refnumha = s.part_no
				AND ha.cagecdxh = pCage
				AND ha.refnumha = pPartNo;

			IF (sLife IS NOT NULL) THEN
				SELECT storage_days
				INTO pSlifeDay
				FROM AMD_SHELF_LIFE_CODES
				WHERE sl_code = sLife;
			END IF;

		ELSIF (pPsmsInst = 'PSMSPROD') THEN

			SELECT
				shlifeha,
				(ulengtha * uwidthha * uheighha) / 1728
			INTO sLife, pUnitVol
			FROM
				amd_psms_ldmha ha,
				TMP_AMD_SPARE_PARTS s
			WHERE
				ha.cagecdxh     = s.mfgr
				AND ha.refnumha = s.part_no
				AND ha.cagecdxh = pCage
				AND ha.refnumha = pPartNo;

			IF (slife IS NOT NULL) THEN
				SELECT storage_days
				INTO pSlifeDay
				FROM AMD_SHELF_LIFE_CODES
				WHERE sl_code = sLife;
			END IF;

		END IF;

		pSmrCode := GetSmr(pPsmsInst, pPartNo, pCage);

	END GetPsmsData;


	FUNCTION  IsValidSmr(
							pSmrCode VARCHAR2) RETURN BOOLEAN IS
	BEGIN

		IF (SUBSTR(pSmrCode,6,1) IN ('T','P','N')) THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;

	END IsValidSmr;


	FUNCTION GetPrime(
							pNsn CHAR) RETURN VARCHAR2 IS
		--
		-- Cursor selects primes w/matching part on same or other rec UNION with
		-- ONE record to use as default if no records satisfy above portion
		--
		CURSOR primeCur IS
			SELECT DISTINCT
				1 qNo,
				DECODE(part,prime,'1 - Prime','2 - Equivalent') partType,
				RTRIM(part) part,
				RTRIM(prime) prime,
				RTRIM(manuf_cage) manuf_cage
			FROM CAT1 c1
			WHERE c1.nsn = pNsn
				AND EXISTS
				(SELECT 'x'
				FROM CAT1 c2
				WHERE c2.nsn = c1.nsn
					AND c2.part = c1.prime)
			UNION
			SELECT DISTINCT
				2 qNo,
				DECODE(part,prime,'1 - Prime','2 - Equivalent') partType,
				RTRIM(part) part,
				RTRIM(prime) prime,
				RTRIM(manuf_cage) manuf_cage
			FROM CAT1
			WHERE nsn = pNsn
				AND ROWNUM =1
			ORDER BY
				qNo,
				partType,
				prime,
				part;


		goodPrime   VARCHAR2(50);
		firstPass   BOOLEAN:=TRUE;
		primePrefix  VARCHAR2(3);
		char1       VARCHAR2(1);
		char2       VARCHAR2(1);
		char3       VARCHAR2(1);
		priority    NUMBER:=0;
	BEGIN

		FOR rec IN primeCur LOOP
			--
			-- Set part of first rec as good prime in case good prime never shows.
			-- Funky logic used in Best Spares to determine good prime compares
			-- first 3 characters to determine good prime.
			--
			IF (firstPass) THEN
				goodPrime := rec.part;
				firstPass := FALSE;
			END IF;

			primePrefix := SUBSTR(rec.prime,1,3);
			char1       := SUBSTR(rec.prime,1,1);
			char2       := SUBSTR(rec.prime,2,1);
			char3       := SUBSTR(rec.prime,3,1);

			IF (rec.qNo = 1) THEN
				IF (rec.part = rec.prime AND rec.manuf_cage = '88277') THEN
					goodPrime := rec.prime;
					priority := 6;
				END IF;

				IF (priority < 6 AND rec.part = rec.prime) THEN
					goodPrime := rec.prime;
					priority := 5;
				END IF;

				IF (priority < 5 AND primePrefix = '17B') THEN
					goodPrime := rec.prime;
					priority  := 4;
				END IF;

				IF (priority < 4 AND primePrefix = '17P') THEN
					goodPrime := rec.prime;
					priority  := 3;
				END IF;

				IF (priority < 3 AND ((char1 != '1' OR char2 != '7' OR
							(char3 NOT IN ('P','B')))
							AND (char1> '9' OR char1< '1' OR char2 != 'D'))) THEN
					goodPrime := rec.prime;
				END IF;
			END IF;

		END LOOP;

		RETURN goodPrime;

	END GetPrime;


	FUNCTION  GetItemType(
							pSmrCode VARCHAR2) RETURN VARCHAR2 IS
		itemType   VARCHAR2(1);
		char1      VARCHAR2(1);
		char6      VARCHAR2(1);
	BEGIN

		char1 := SUBSTR(pSmrCode,1,1);
		char6 := SUBSTR(pSmrCode,6,1);

		-- Consumable when smr is P____N
		-- Repairable when smr is P____P
		--              or smr is P____T
		--
		IF (char1 = 'P') THEN

			IF (char6 = 'N') THEN
				itemType := 'C';
			ELSIF (char6 IN ('P','T'))  THEN
				itemType := 'R';
			END IF;

		END IF;

		RETURN itemType;

	END GetItemType;


	FUNCTION getMic(
							pNsn VARCHAR2) RETURN VARCHAR2 IS
		l67Mic   VARCHAR2(1);
	BEGIN
		SELECT MIN(mic)
		INTO l67Mic
		FROM AMD_L67_SOURCE
		WHERE
			nsn = pNsn
			AND mic != '*';

		RETURN l67Mic;
	END;


	 procedure getOriginalBssmData(nsn in amd_nsns.nsn%type,
		 part_no in bssm_owner.bssm_parts.PART_NO%type,
		 condemn_avg out amd_national_stock_items.condemn_avg%type,
		 criticality out amd_national_stock_items.criticality%type,
		 mtbdr_computed out amd_national_stock_items.mtbdr_computed%type,
		 nrts_avg out amd_national_stock_items.nrts_avg%type,
		 rts_avg out amd_national_stock_items.rts_avg%type) IS

		 CURRENT_NSN constant varchar2(1) := 'C' ;
		 ORIGINAL_DATA constant varchar2(1) := '0' ;

	begin
	 		SELECT condemn, criticality, mtbdr_computed, nrts, rts
	INTO condemn_avg, criticality, mtbdr_computed, nrts_avg, rts_avg
	FROM bssm_owner.bssm_parts bp, AMD_NSNS nsns
	WHERE
	nsns.nsn = getOriginalBssmData.nsn
	AND bp.nsn IN (SELECT nsn FROM AMD_NSNS WHERE nsi_sid = nsns.nsi_sid AND nsn_type = CURRENT_NSN)
	AND lock_sid = ORIGINAL_DATA ;
	EXCEPTION
		  WHEN standard.NO_DATA_FOUND THEN
		    <<getByPart>>
		    begin
				SELECT condemn, criticality, mtbdr_computed,  nrts, rts
				INTO condemn_avg, criticality, mtbdr_computed,  nrts_avg, rts_avg
				FROM bssm_owner.bssm_parts bp, amd_spare_parts parts, amd_nsns nsns
				WHERE
				bp.PART_NO = getOriginalBssmData.part_no
				and bp.part_no = parts.part_no
				and parts.nsn = nsns.nsn
				and nsn_type = CURRENT_NSN
				AND lock_sid = ORIGINAL_DATA ;
			exception
				  when standard.no_data_found then
				  	   condemn_avg := NULL ;
					   criticality := NULL ;
				       mtbdr_computed := null ;
					   nrts_avg := NULL ;
					   rts_avg := NULL ;
				  WHEN OTHERS THEN
						ErrorMsg(sqlFunction => 'select',
							tableName => 'bssm_parts',
							pErrorLocation => 10,
							key1 => getOriginalBssmData.part_no,
							key2 => 'locksid=' || ORIGINAL_DATA);
						RAISE ;
			end getByPart ;

		  WHEN OTHERS THEN
				ErrorMsg(sqlFunction => 'select',
					tableName => 'bssm_parts and amd_nsns',
					pErrorLocation => 20,
					key1 => getOriginalBssmData.part_no,
					key2 => 'locksid=' || ORIGINAL_DATA);
				RAISE ;
	end getOriginalBssmData ;

	procedure getCleanedBssmData(nsn in amd_nsns.nsn%type,
		part_no 				in bssm_owner.bssm_parts.part_no%type,
		condemn_avg_cleaned 	out amd_national_stock_items.condemn_avg_cleaned%type,
		criticality_cleaned 	out amd_national_stock_items.criticality_cleaned%type,
		mtbdr_cleaned 			out amd_national_stock_items.mtbdr_cleaned%type,
		nrts_avg_cleaned 		out amd_national_stock_items.nrts_avg_cleaned%type,
		rts_avg_cleaned 		out amd_national_stock_items.rts_avg_cleaned%type,
		order_lead_time_cleaned out amd_national_stock_items.order_lead_time_cleaned%type,
		planner_code_cleaned 	out amd_national_stock_items.planner_code_cleaned%type,
		smr_code_cleaned 		out amd_national_stock_items.smr_code_cleaned%type,
		unit_cost_cleaned 		out amd_national_stock_items.unit_cost_cleaned%type,
		cost_to_repair_off_base_cleand out amd_national_stock_items.cost_to_repair_off_base_cleand%type,
		time_to_repair_off_base_cleand out amd_national_stock_items.time_to_repair_off_base_cleand%type) is

	begin
		condemn_avg_cleaned := Amd_Clean_Data.GetCondemnAvg(nsn, part_no) ;
		criticality_cleaned := Amd_Clean_Data.GetCriticality(nsn, part_no ) ;
		mtbdr_cleaned := Amd_Clean_Data.GetMtbdr(nsn, part_no) ;
		nrts_avg_cleaned := Amd_Clean_Data.GetNrtsAvg(nsn, part_no) ;
		rts_avg_cleaned := Amd_Clean_Data.GetRtsAvg(nsn, part_no) ;
		order_lead_time_cleaned := Amd_Utils.months2CalendarDays(Amd_Clean_Data.GetOrderLeadTime(nsn, part_no)) ;
		planner_code_cleaned := Amd_Clean_Data.GetPlannerCode(nsn, part_no) ;
		smr_code_cleaned := Amd_Clean_Data.GetSmrCode(nsn, part_no) ;
		unit_cost_cleaned := Amd_Clean_Data.GetUnitCost(nsn, part_no) ;
		cost_to_repair_off_base_cleand := Amd_Clean_Data.GetCostToRepairOffBase(nsn, part_no) ;
		time_to_repair_off_base_cleand := Amd_Utils.months2CalendarDays(Amd_Clean_Data.GetTimeToRepairOffBase(nsn, part_no)) ;
	end getCleanedBssmData ;

	PROCEDURE getBssmData(nsn in amd_nsns.nsn%type,
		part_no 		 in bssm_owner.bssm_parts.part_no%type,

		condemn_avg 	 out amd_national_stock_items.condemn_avg%type,
		criticality 	 out amd_national_stock_items.criticality%type,
		mtbdr_computed  out amd_national_stock_items.mtbdr_computed%type,
		nrts_avg 		 out amd_national_stock_items.nrts_avg%type,
		rts_avg 		 out amd_national_stock_items.rts_avg%type,

		condemn_avg_cleaned   out AMD_NATIONAL_STOCK_ITEMS.condemn_avg_cleaned%TYPE,
		criticality_cleaned   out AMD_NATIONAL_STOCK_ITEMS.criticality_cleaned%TYPE,
		mtbdr_cleaned         out AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE,
		nrts_avg_cleaned      out AMD_NATIONAL_STOCK_ITEMS.nrts_avg_cleaned%TYPE,
		rts_avg_cleaned       out AMD_NATIONAL_STOCK_ITEMS.rts_avg_cleaned%TYPE,
		order_lead_time_cleaned out AMD_NATIONAL_STOCK_ITEMS.order_lead_time_cleaned%TYPE,
		planner_code_cleaned  	 out AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE,
		smr_code_cleaned      	 out AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE,
		unit_cost_cleaned     	 out AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE,
		cost_to_repair_off_base_cleand  out AMD_NATIONAL_STOCK_ITEMS.cost_to_repair_off_base_cleand%TYPE,
		time_to_repair_off_base_cleand  out AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base_cleand%TYPE) is

	BEGIN
		getOriginalBssmData(nsn => nsn, part_no => part_no, condemn_avg => condemn_avg,
		criticality => criticality, mtbdr_computed => mtbdr_computed, nrts_avg => nrts_avg, rts_avg => rts_avg) ;

		getCleanedBssmData( nsn => nsn, part_no => part_no,
		condemn_avg_cleaned => condemn_avg_cleaned,
		criticality_cleaned => criticality_cleaned, mtbdr_cleaned => mtbdr_cleaned,
		nrts_avg_cleaned => nrts_avg_cleaned, rts_avg_cleaned => rts_avg_cleaned,
		order_lead_time_cleaned => order_lead_time_cleaned,
		planner_code_cleaned => planner_code_cleaned, smr_code_cleaned => smr_code_cleaned,
		unit_cost_cleaned => unit_cost_cleaned,
		cost_to_repair_off_base_cleand => cost_to_repair_off_base_cleand,
		time_to_repair_off_base_cleand => time_to_repair_off_base_cleand) ;

	END getBssmData ;

	PROCEDURE getRmadsData (part_no in amd_rmads_source_tmp.part_no%type, qpei_weighted out amd_rmads_source_tmp.QPEI_WEIGHTED%type,
		mtbdr out amd_rmads_source_tmp.MTBDR%type) is
	BEGIN
		SELECT qpei_weighted, mtbdr INTO qpei_weighted, mtbdr
		FROM AMD_RMADS_SOURCE_TMP
		WHERE part_no = getRmadsData.part_no ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			qpei_weighted := NULL ;
			mtbdr := null ;
		WHEN OTHERS THEN
			ErrorMsg(sqlFunction => 'select',
			tableName => 'amd_rmads_source_tmp',
			pErrorLocation => 30,
			key1 => getRmadsData.part_no) ;
			RAISE ;
	END getRmadsData ;

	PROCEDURE LoadGold IS
		CURSOR catCur IS
			SELECT
				RTRIM(nsn) nsn,
				DECODE(prime,part,'PRIME','EQUIVALENT') partType,
				RTRIM(part) part,
				RTRIM(prime) prime,
				RTRIM(manuf_cage) manuf_cage,
				RTRIM(source_code) source_code,
				RTRIM(noun) noun,
				RTRIM(serial_mandatory_b) serial_mandatory_b,
				RTRIM(ims_designator_code) ims_designator_code,
				RTRIM(smrc) smrc,
				RTRIM(um_cap_code) um_cap_code,
				RTRIM(user_ref7) user_ref7,
				RTRIM(um_show_code) um_show_code
			FROM CAT1
			WHERE
				source_code = 'F77'
				AND nsn NOT LIKE 'N%'
			UNION
			SELECT
				RTRIM(nsn) nsn,
				DECODE(prime,part,'PRIME','EQUIVALENT') partType,
				RTRIM(part) part,
				RTRIM(prime) prime,
				RTRIM(manuf_cage) manuf_cage,
				RTRIM(source_code) source_code,
				RTRIM(noun) noun,
				RTRIM(serial_mandatory_b) serial_mandatory_b,
				RTRIM(ims_designator_code) ims_designator_code,
				RTRIM(smrc) smrc,
				RTRIM(um_cap_code) um_cap_code,
				RTRIM(user_ref7) user_ref7,
				RTRIM(um_show_code) um_show_code
			FROM CAT1
			WHERE
				source_code = 'F77'
				AND nsn LIKE 'NSL%'
				AND part = prime
			ORDER BY
				nsn,
				partType DESC,
				part;

		loadNo        NUMBER;
		nsn           VARCHAR2(50);
		prevNsn       VARCHAR2(50):='prevNsn';
		nsnStripped   VARCHAR2(50);
		goodPrime     VARCHAR2(50);
		primeInd      VARCHAR2(1);
		itemType      VARCHAR2(1);
		smrCode       VARCHAR2(6);
		orderUom	  VARCHAR2(2);
		plannerCode   VARCHAR2(8);
		nsnType       VARCHAR2(1);
		hasPrimeRec   BOOLEAN;
		sequenced     BOOLEAN;
		l67Mic        VARCHAR2(1);
		unitCost      NUMBER;
		unitOfIssue	  VARCHAR2(2);
		mMac		  VARCHAR2(2);
		rowsInserted NUMBER := 0 ;
		commitThreshold CONSTANT NUMBER := 1000 ;
	BEGIN
	    writeMsg(pTableName => 'tmp_amd_spare_parts', pError_location => 10,
				pKey1 => 'loadGold',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		Mta_Truncate_Table('tmp_amd_spare_parts','reuse storage');
		Mta_Truncate_Table('tmp_a2a_part_info','reuse storage');
		Mta_Truncate_Table('tmp_a2a_part_lead_time','reuse storage');
		Mta_Truncate_Table('tmp_a2a_part_pricing','reuse storage');
		Mta_Truncate_Table('tmp_a2a_bom_detail','reuse storage');
		Mta_Truncate_Table('tmp_a2a_part_effectivity','reuse storage');

		loadNo := Amd_Utils.GetLoadNo('GOLD','TMP_AMD_SPARE_PARTS');

		FOR rec IN catCur LOOP

			IF (rec.nsn LIKE 'NSL%') THEN
				sequenced := TRUE;
				nsn := Amd_Nsl_Sequence_Pkg.SequenceTheNsl(rec.prime);
			ELSE
				sequenced := FALSE;
				nsn := rec.nsn;
			END IF;

			IF (nsn != prevNsn) THEN
				prevNsn     := nsn;
				nsnStripped := Amd_Utils.FormatNsn(nsn);

				-- If sequenceTheNsl() returned an NSL$ then it is assumed to be
				-- the prime, otherwise, run it through the getPrime() logic.
				--
				IF (nsn LIKE 'NSL%') THEN
					IF (NOT onNsl(rec.part)) THEN
						-- An NSL starts the part/nsn process so 'delete' the part
						-- so the diff will think it's a brand new part and
						-- assign it its own nsi_sid.
						--
						performLogicalDelete(rec.part);
					END IF;
					goodPrime := rec.part;
				ELSE
					goodPrime := GetPrime(nsn);
				END IF;

				nsnType     := 'C';
				plannerCode := rec.ims_designator_code;
				itemType    := NULL;
				smrCode     := rec.smrc;
				unitOfIssue := rec.um_show_code;
				orderUom := rec.um_cap_code;

				IF (IsValidSmr(smrCode)) THEN
					itemType := GetItemType(smrCode);
				END IF;

			END IF;

			-- if GetPrime() returned a null that means that the nsn no longer
			-- exists in Gold. This happens when a part goes from an NCZ to an NSL
			--
			IF (goodPrime IS NULL OR rec.part = goodPrime) THEN
				primeInd := 'Y';
			ELSE
				primeInd := 'N';
			END IF;

			l67Mic   := getMic(nsnStripped);
			unitCost := getUnitCost(rec.part);
			mMac := getMmac(rec.nsn);
			-- 4/13/05 DSE created insertTmpAmdSpareParts block of code
			<<insertTmpAmdSpareParts>>
			DECLARE
				   mtbdr                           AMD_NATIONAL_STOCK_ITEMS.mtbdr%TYPE ;
  				   mtbdr_cleaned                   AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE ;
  				   qpei_weighted                   AMD_NATIONAL_STOCK_ITEMS.qpei_weighted%TYPE ;
  				   condemn_avg					   AMD_NATIONAL_STOCK_ITEMS.condemn_avg%TYPE ;
  				   condemn_avg_cleaned             AMD_NATIONAL_STOCK_ITEMS.condemn_avg_cleaned%TYPE ;
  				   criticality                     AMD_NATIONAL_STOCK_ITEMS.criticality%TYPE ;
  				   criticality_cleaned             AMD_NATIONAL_STOCK_ITEMS.criticality_cleaned%TYPE ;
  				   nrts_avg                        AMD_NATIONAL_STOCK_ITEMS.nrts_avg%TYPE ;
  				   nrts_avg_cleaned                AMD_NATIONAL_STOCK_ITEMS.nrts_avg_cleaned%TYPE ;
  				   cost_to_repair_off_base_cleand  AMD_NATIONAL_STOCK_ITEMS.cost_to_repair_off_base_cleand%TYPE ;
  				   time_to_repair_off_base_cleand  AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base_cleand%TYPE ;
  				   order_lead_time_cleaned         AMD_NATIONAL_STOCK_ITEMS.order_lead_time_cleaned%TYPE ;
  				   planner_code_cleaned            AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE ;
  				   rts_avg                         AMD_NATIONAL_STOCK_ITEMS.rts_avg%TYPE ;
  				   rts_avg_cleaned                 AMD_NATIONAL_STOCK_ITEMS.rts_avg_cleaned%TYPE ;
  				   smr_code_cleaned                AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE ;
  				   unit_cost_cleaned               AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE ;
				   cost_to_repair_off_base 		   AMD_NATIONAL_STOCK_ITEMS.cost_to_repair_off_base%TYPE ;
				   time_to_repair_off_base         AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base%TYPE ;
				   mtbdr_computed				   amd_national_stock_items.mtbdr_computed%type ;






			BEGIN

				 getBssmData(nsn => nsnStripped, part_no => rec.part,
				 	condemn_avg => condemn_avg, criticality => criticality,  mtbdr_computed => mtbdr_computed,
					nrts_avg => nrts_avg, rts_avg => rts_avg,

			  		condemn_avg_cleaned => condemn_avg_cleaned, criticality_cleaned => criticality_cleaned,
					mtbdr_cleaned => mtbdr_cleaned, nrts_avg_cleaned => nrts_avg_cleaned,
					rts_avg_cleaned => rts_avg_cleaned, order_lead_time_cleaned => order_lead_time_cleaned,
					planner_code_cleaned => planner_code_cleaned, smr_code_cleaned => smr_code_cleaned,
					unit_cost_cleaned => unit_cost_cleaned,
					cost_to_repair_off_base_cleand => cost_to_repair_off_base_cleand,
					time_to_repair_off_base_cleand => time_to_repair_off_base_cleand) ;

				 getRmadsData(part_no => rec.part, qpei_weighted => qpei_weighted, mtbdr=> mtbdr) ;

				 IF primeInd = 'Y' THEN
				 	cost_to_repair_off_base := GetOffBaseRepairCost(rec.part);
					time_to_repair_off_base := GetOffBaseTurnAround(rec.part);
				 END IF ;

				INSERT INTO TMP_AMD_SPARE_PARTS (	part_no,	mfgr,
					icp_ind,	item_type,
					nomenclature, nsn,
					nsn_type,
					planner_code,
					order_uom,
					prime_ind,
					serial_flag,
					smr_code,
					acquisition_advice_code,
					unit_cost,
					mic,
					mmac,
					unit_of_issue,
				   mtbdr,
				   mtbdr_computed,
  				   mtbdr_cleaned,
  				   qpei_weighted,
  				   condemn_avg,
  				   condemn_avg_cleaned,
  				   criticality,
  				   criticality_cleaned,
  				   nrts_avg_cleaned,
  				   nrts_avg,
  				   cost_to_repair_off_base_cleand,
  				   time_to_repair_off_base_cleand,
  				   order_lead_time_cleaned,
  				   planner_code_cleaned,
  				   rts_avg,
  				   rts_avg_cleaned,
  				   smr_code_cleaned,
  				   unit_cost_cleaned,
				   cost_to_repair_off_base,
				   time_to_repair_off_base
				)
				VALUES
				(	rec.part, rec.manuf_cage,
					rec.source_code,
					itemType,
					rec.noun,			nsnStripped,
					nsnType,			plannerCode,
					rec.um_cap_code,
					primeInd, 	rec.serial_mandatory_b,
					smrCode, 	rec.user_ref7,
					unitCost,
					l67Mic,
					mMac,
					unitOfIssue,
				   mtbdr,
				   mtbdr_computed,
  				   mtbdr_cleaned,
  				   qpei_weighted,
  				   condemn_avg,
  				   condemn_avg_cleaned,
  				   criticality,
  				   criticality_cleaned,
  				   nrts_avg_cleaned,
  				   nrts_avg,
  				   cost_to_repair_off_base_cleand,
  				   time_to_repair_off_base_cleand,
  				   order_lead_time_cleaned,
  				   planner_code_cleaned,
  				   rts_avg,
  				   rts_avg_cleaned,
  				   smr_code_cleaned,
  				   unit_cost_cleaned,
				   cost_to_repair_off_base,
				   time_to_repair_off_base 		) ;

			EXCEPTION
				 WHEN OTHERS THEN
							ErrorMsg(sqlFunction => 'insert',
								tableName => 'tmp_amd_spare_parts',
								pErrorLocation => 40,
								key1 => nsnStripped,
								key2 => rec.part,
								key3 => rec.manuf_cage,
								key4 => nsnType) ;
						RAISE ;

			END insertTmpAmdSpareParts ;

			rowsInserted := rowsInserted + 1 ;
			IF MOD(rowsInserted,commitThreshold) = 0 THEN
			   COMMIT ;
			   dbms_output.put_line('committed last ' || commitThreshold || ' inserts.') ;
			END IF ;
		END LOOP;
	    writeMsg(pTableName => 'tmp_amd_spare_parts', pError_location => 20,
				pKey1 => 'loadGold',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'rowsInserted=' || to_char(rowsInserted)) ;

		COMMIT ;

	EXCEPTION
		 WHEN OTHERS THEN
					ErrorMsg(sqlFunction => 'loadGold',
						tableName => 'tmp_amd_spare_parts',
						pErrorLocation => 60) ;
					dbms_output.put_line('loadGold had an error - check amd_load_details. rowsInserted=' || rowsInserted) ;
				RAISE ;
	END LoadGold;



	PROCEDURE LoadPsms IS
		CURSOR F77 IS
			SELECT
				part_no,
				mfgr,
				smr_code,
				item_type
			FROM TMP_AMD_SPARE_PARTS;

		loadNo        NUMBER;
		psmsInstance  VARCHAR2(10);
		SLIFEDAY      NUMBER;
		UNITVOL       NUMBER;
		smrCode       VARCHAR2(6);
		itemType      VARCHAR2(1);
		cnt			  number := 0 ;
	BEGIN

	    writeMsg(pTableName => 'tmp_amd_spare_parts', pError_location => 30,
				pKey1 => 'loadPsms',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		--
		--     Get the load_no for insert into amd_load_status table
		--
		loadNo := Amd_Utils.GetLoadNo('PSMS','TMP_AMD_SPARE_PARTS');

		--
		-- select ICP Part/CAGE and check to see if the part is existing in PSMS.
		--
		FOR rec IN F77 LOOP

			psmsInstance := GetPsmsInstance(rec.part_no,rec.mfgr);

			IF (psmsInstance IS NOT NULL) THEN

				GetPsmsData(rec.part_no,rec.mfgr,psmsInstance,
									sLifeDay,unitVol,smrCode);

				IF (IsValidSmr(smrCode)) THEN
					itemType := GetItemType(smrCode);
				ELSE
					smrCode  := rec.smr_code;
					itemType := rec.item_type;
				END IF;

				UPDATE TMP_AMD_SPARE_PARTS SET
					shelf_life     = sLifeDay,
					unit_volume    = unitVol,
					smr_code	= smrCode,
					item_type      = itemType
				WHERE
					part_no  = rec.part_no
					AND smr_code IS NULL;
					
				 cnt := cnt + 1 ;

			END IF;

		END LOOP;
		
	    writeMsg(pTableName => 'tmp_amd_spare_parts', pError_location => 40,
				pKey1 => 'loadPsms',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'rowsUpdated=' || to_char(cnt) ) ;
				
		commit ;

	END LoadPsms;



	PROCEDURE LoadMain IS
		CURSOR f77Cur IS
			SELECT
				nsn,
				part_no,
				prime_ind,
				SUBSTR(smr_code,6,1) smrCode6
			FROM TMP_AMD_SPARE_PARTS
			ORDER BY
				nsn,
				prime_ind DESC;


		loadNo         NUMBER;
		cnt            NUMBER := 0;
		maxPoDate      DATE;
		maxPo          VARCHAR2(20);
		leadTime       NUMBER;
		orderUom       VARCHAR2(2);
		orderQuantity  NUMBER;
		orderQty       NUMBER;
		poAge          NUMBER;
		prevNsn        VARCHAR2(15):='prevNsn';
		
		
	BEGIN

	    writeMsg(pTableName => 'tmp_amd_spare_parts', pError_location => 50,
				pKey1 => 'loadMain',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		--
		--     Get the load_no for insert into amd_load_status table
		--
		loadNo := Amd_Utils.GetLoadNo('MAIN','TMP_AMD_SPARE_PARTS');

		FOR aspRec IN f77Cur LOOP

			--
			-- Attempt to get some values from tmp_main.(Only look at po's that
			-- have a length of 9.)
			--
			BEGIN
				--
				-- select the latest PO date.
				--
				SELECT
					MAX(TO_DATE(po_date,'RRMMDD')) po_date,
					(TRUNC(SYSDATE) - MAX(TO_DATE(po_date,'RRMMDD'))) po_age
				INTO
					maxPoDate,
					poAge
				FROM TMP_MAIN
				WHERE
					part_no = aspRec.part_no
					AND LENGTH(SUBSTR(po_no,1,INSTR(po_no,' ')-1)) = 9;

				--
				-- get latest PO
				--
				SELECT
					MAX(po_no)
				INTO maxPo
				FROM TMP_MAIN
				WHERE
					part_no     = aspRec.part_no
					AND po_date = TO_CHAR(maxPoDate,'RRMMDD')
					AND LENGTH(SUBSTR(po_no,1,INSTR(po_no,' ')-1)) = 9;

				SELECT
					total_lead_time,
					order_qty
				INTO
					leadTime,
					orderQuantity
				FROM TMP_MAIN
				WHERE
					part_no     = aspRec.part_no
					AND po_date = TO_CHAR(maxPoDate,'RRMMDD')
					AND po_no   = maxPo
					AND LENGTH(SUBSTR(po_no,1,INSTR(po_no,' ')-1)) = 9;



					-- We apply the order_quantity we got from the prime part
				-- to all the equivalent parts so we only set it here when the
				-- prime rec comes in.  The prime rec is the first rec in the
				-- nsn series due to the sort order of the cursor.
				--
				IF (aspRec.nsn != prevNsn) THEN
					prevNsn := aspRec.nsn;
					orderQty := orderQuantity;
				END IF;

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					orderQuantity := NULL;
					leadTime      := NULL;
	--				orderUom      := NULL;
			END;

			UPDATE TMP_AMD_SPARE_PARTS SET
				order_lead_time = Amd_Utils.bizDays2CalendarDays(leadTime),
	--			order_uom = orderUom,
				order_quantity  = orderQty
			WHERE
				part_no       = aspRec.part_no;
			
			cnt := cnt + 1 ;

		END LOOP;

	    writeMsg(pTableName => 'tmp_amd_spare_parts', pError_location => 60,
		pKey1 => 'loadMain',
		pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
		pKey3 => 'rowsUpdated=' || to_char(cnt) ) ;
		
		commit ;

	END LoadMain;



	PROCEDURE LoadTempNsns IS
		RAW_DATA  NUMBER:=0;

		CURSOR tempNsnCur IS
			-- From MILS table
			SELECT DISTINCT
				asp.part_no part,
				RTRIM(SUBSTR(m.status_line,8,15)) nsnTemp,
				'MILS' dataSource
			FROM
				AMD_SPARE_PARTS asp,
				MILS m
			WHERE
				m.default_name  = 'A0E'
				AND asp.part_no = RTRIM(SUBSTR(m.status_line,81,30))
				AND asp.nsn    != RTRIM(SUBSTR(m.status_line,8,15))
				AND 'NSL'      != RTRIM(SUBSTR(m.status_line,8,15))
			UNION
			-- From CHGH table, "FROM" column
			SELECT DISTINCT
				asp.part_no part,
				RTRIM(REPLACE(m."FROM",'-',NULL)) nsnTemp,
				'CHGH' dataSource
			FROM
				AMD_SPARE_PARTS asp,
				CHGH m
			WHERE
				m.field         = 'NSN'
				AND asp.part_no = m.key_value1
				AND asp.nsn    != RTRIM(REPLACE(m."FROM",'-',NULL))
				AND 'NSL'      != RTRIM(REPLACE(m."FROM",'-',NULL))
			UNION
			-- From CHGH table, "TO" column
			SELECT DISTINCT
				asp.part_no part,
				RTRIM(REPLACE(m."TO",'-',NULL)) nsnTemp,
				'CHGH' dataSource
			FROM
				AMD_SPARE_PARTS asp,
				CHGH m
			WHERE
				m.field         = 'NSN'
				AND asp.part_no = m.key_value1
				AND asp.nsn    != RTRIM(REPLACE(m."TO",'-',NULL))
				AND 'NSL'      != RTRIM(REPLACE(m."TO",'-',NULL))
			UNION
			-- From BSSM_PARTS table
			SELECT DISTINCT
				bp.part_no,
				bp.nsn nsnTemp,
				'BSSM' dataSource
			FROM
				bssm_parts bp,
				(SELECT nsn
				FROM bssm_parts
				WHERE nsn LIKE 'NSL#%'
					AND lock_sid = RAW_DATA
				MINUS
				SELECT nsn
				FROM AMD_NSNS
				WHERE nsn LIKE 'NSL#%') nslQ
			WHERE
				bp.nsn = nslQ.nsn
				AND bp.lock_sid = RAW_DATA
				AND bp.part_no IS NOT NULL
			ORDER BY 1;

		nsn       VARCHAR2(16);
		nsiSid    NUMBER;
		loadNo    NUMBER;
		mmacCode  NUMBER;
	BEGIN
		loadNo := Amd_Utils.GetLoadNo('MILS','AMD_NSNS');

		FOR rec IN tempNsnCur LOOP
			BEGIN

				IF (rec.nsnTemp = 'NSL') THEN
					nsn := Amd_Nsl_Sequence_Pkg.SequenceTheNsl(rec.part);
				ELSIF (rec.nsnTemp LIKE 'NSL#%') THEN
					nsn := rec.nsnTemp;
				ELSE
					-- Need to ignore last 2 char's of nsn from MILS if not numeric.
					-- So if last 2 characters are not numeric an exception will
					-- occur and the nsn will be truncated to 13 characters.
					--
					nsn := rec.nsnTemp;
					IF (rec.dataSource = 'MILS') THEN
						BEGIN
							mmacCode := SUBSTR(nsn,14,2);
						EXCEPTION
							WHEN OTHERS THEN
								nsn := SUBSTR(nsn,1,13);
						END;
					END IF;
				END IF;

				nsiSid := Amd_Utils.GetNsiSid(pPart_no=>rec.part);

				INSERT INTO AMD_NSNS
				(
					nsn,
					nsn_type,
					nsi_sid,
					creation_date
				)
				VALUES
				(
					nsn,
					'T',
					nsiSid,
					SYSDATE
				);

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					NULL;     -- nsiSid not found generates this, just ignore
				WHEN DUP_VAL_ON_INDEX THEN
					NULL;     -- we don't care if nsn is already there
				WHEN OTHERS THEN
					Amd_Utils.InsertErrorMsg(pLoad_no => loadNo,pKey_1 => 'amd_load.LoadTempNsns',
							pKey_2 => 'Exception: OTHERS',pKey_3 => 'insert into amd_nsns');
			END;

		END LOOP;

	END loadTempNsns ;


	FUNCTION insertRow(planner_code IN VARCHAR2) RETURN NUMBER IS
			 PROCEDURE doUpdate IS
			 BEGIN
			 	  UPDATE AMD_PLANNERS
				  SET planner_description = insertRow.planner_code,
				  action_code = Amd_Defaults.INSERT_ACTION,
				  last_update_dt = SYSDATE
				  WHERE planner_code = insertRow.planner_code ;
			 EXCEPTION WHEN OTHERS THEN
			    errorMsg(sqlFunction => 'update', tableName => 'amd_planners', pErrorLocation => 70,
			   		key1 => insertRow.planner_code) ;
			   RAISE ;
			 END doUpdate ;
	BEGIN
		 <<insertAmdPlanners>>
		 BEGIN
			 INSERT INTO AMD_PLANNERS
			 (planner_code, planner_description, action_code, last_update_dt)
			 VALUES (insertRow.planner_code, insertRow.planner_code, Amd_Defaults.INSERT_ACTION, SYSDATE) ;
		 EXCEPTION
		  WHEN standard.DUP_VAL_ON_INDEX THEN
		  	   doUpdate ;
		  WHEN OTHERS THEN
		    errorMsg(sqlFunction => 'insert', tableName => 'amd_planners', pErrorLocation => 80,
		   		key1 => insertRow.planner_code) ;
		   RAISE ;

	 	 END insertAmdPlanners ;

		 RETURN SUCCESS ;

	EXCEPTION WHEN OTHERS THEN
		 RETURN FAILURE ;
	END insertRow ;

	FUNCTION updateRow(planner_code IN VARCHAR2) RETURN NUMBER IS
	BEGIN
		 <<updateAmdPlanners>>
		 BEGIN
			 UPDATE AMD_PLANNERS
			 SET
			 planner_description = updateRow.planner_code,
			 last_update_dt = SYSDATE,
			 action_code = Amd_Defaults.UPDATE_ACTION
			 WHERE planner_code = updateRow.planner_code ;
		 EXCEPTION WHEN OTHERS THEN
		   errorMsg(sqlFunction => 'update', tableName => 'amd_planners', pErrorLocation => 90,
		   		key1 => updateRow.planner_code) ;
		   RAISE ;

	 	 END updateAmdPlanners ;

		 RETURN SUCCESS ;

	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;
	END updateRow ;

	FUNCTION deleteRow(planner_code IN VARCHAR2) RETURN NUMBER IS
	BEGIN
		 <<deleteAmdPlanners>>
		 BEGIN
			 UPDATE AMD_PLANNERS
			 SET last_update_dt = SYSDATE,
			 action_code = Amd_Defaults.DELETE_ACTION
			 WHERE planner_code = deleteRow.planner_code ;
		 EXCEPTION WHEN OTHERS THEN
		   errorMsg(sqlFunction => 'update', tableName => 'amd_planners', pErrorLocation => 100,
		   		key1 => deleteRow.planner_code) ;
		   RAISE ;

	 	 END deleteAmdPlanners ;

		 RETURN SUCCESS ;

	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;
	END deleteRow ;

	FUNCTION getNewUsers RETURN resultSetCursor IS
			 newUsers resultSetCursor ;
	BEGIN
		 OPEN newUsers FOR
		 SELECT
		 Amd_Load.getBemsId(employee_NO) bems_id,
		 stable_email,
		 last_name,
		 first_name
		 FROM AMD_USE1, amd_people_all_v
		 WHERE employee_status = 'A'
		 AND ims_designator_code IS NOT NULL
		 AND LENGTH(ims_designator_code) = 3
		 AND Amd_Load.getBemsId(employee_no) = amd_people_all_v.bems_id
		 ORDER BY bems_id ;
		 RETURN newUsers ;
	END getNewUsers ;

	FUNCTION insertUsersRow(bems_id IN VARCHAR2, stable_email IN VARCHAR2, last_name IN VARCHAR2, first_name IN VARCHAR2) RETURN NUMBER IS

			 procedure doUpdate is
			 begin
			 	  update amd_users
				  set stable_email = insertUsersRow.stable_email,
				  last_name = insertUsersRow.last_name,
				  first_name = insertUsersRow.first_name,
				  action_code = amd_defaults.INSERT_ACTION,
				  last_update_dt = sysdate
				  where bems_id = insertUsersRow.bems_id ;
			 exception when others then
			   errorMsg(sqlFunction => 'update', tableName => 'amd_users', pErrorLocation => 110,
			   		key1 => bems_id) ;
			   RAISE ;
			 end doUpdate ;
	BEGIN
		 INSERT INTO AMD_USERS
		 (bems_id, stable_email, last_name, first_name, action_code, last_update_dt)
		 VALUES (bems_id, stable_email, last_name, first_name,  Amd_Defaults.INSERT_ACTION, SYSDATE) ;
 		 A2a_Pkg.insertTmpA2ASpoUsers(bems_id, stable_email, last_name, first_name, Amd_Defaults.INSERT_ACTION) ;
		 RETURN SUCCESS ;
	EXCEPTION
		when standard.dup_val_on_index then
			 doUpdate ;
			 return success ;
		WHEN OTHERS THEN
		   errorMsg(sqlFunction => 'insert', tableName => 'amd_users', pErrorLocation => 120,
		   		key1 => bems_id) ;
		   RAISE ;
	END insertUsersRow ;

	FUNCTION updateUsersRow(bems_id IN VARCHAR2, stable_email IN VARCHAR2, last_name IN VARCHAR2, first_name IN VARCHAR2) RETURN NUMBER IS
	BEGIN
		 UPDATE AMD_USERS
		 SET stable_email = updateUsersRow.stable_email,
		 last_name = updateUsersRow.last_name,
		 first_name = updateUsersRow.first_name,
		 action_code = Amd_Defaults.UPDATE_ACTION,
		 last_update_dt = SYSDATE
		 WHERE bems_id = updateUsersRow.bems_id ;
 		 A2a_Pkg.insertTmpA2ASpoUsers(bems_id, stable_email, last_name, first_name, Amd_Defaults.UPDATE_ACTION) ;
		 RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		   errorMsg(sqlFunction => 'update', tableName => 'amd_users', pErrorLocation => 130,
		   		key1 => bems_id) ;
		   RAISE ;
	END updateUsersRow ;

	FUNCTION deleteUsersRow(bems_id IN VARCHAR2) RETURN NUMBER IS
			 last_name AMD_USERS.last_name%TYPE ;
			 first_name AMD_USERS.first_name%TYPE ;
			 stable_email AMD_USERS.stable_email%TYPE ;
	BEGIN
		 UPDATE AMD_USERS
		 SET action_code = Amd_Defaults.DELETE_ACTION,
		 last_update_dt = SYSDATE
		 WHERE bems_id = deleteUsersRow.bems_id ;

		 <<getData>>
		 BEGIN
			 SELECT stable_email, last_name, first_name INTO stable_email, last_name, first_name
			 FROM AMD_USERS
			 WHERE bems_id = deleteUsersRow.bems_id ;
		 EXCEPTION WHEN OTHERS THEN
		   errorMsg(sqlFunction => 'select', tableName => 'amd_users', pErrorLocation => 140,
		   		key1 => bems_id) ;
		   RAISE ;
		 END getData ;

 		 A2a_Pkg.insertTmpA2ASpoUsers(bems_id, stable_email, last_name, first_name, Amd_Defaults.DELETE_ACTION) ;
		 RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		   errorMsg(sqlFunction => 'update', tableName => 'amd_users', pErrorLocation => 150,
		   		key1 => bems_id) ;
		   RAISE ;
	END deleteUsersRow ;

	PROCEDURE loadUsers IS
			  CURSOR currentUsers IS
			  SELECT bems_id FROM AMD_USERS
			  WHERE action_code != Amd_Defaults.DELETE_ACTION ;

			  CURSOR newUsers IS
				SELECT Amd_Load.getBemsId(employee_NO) bems_id
				FROM AMD_USE1
				WHERE employee_status = 'A'
				AND  Amd_Load.getBemsId(employee_no) NOT IN (
					 SELECT bems_id
					 FROM AMD_USERS
					 WHERE action_code != Amd_Defaults.DELETE_ACTION)
				AND ims_designator_code IS NOT NULL
				AND LENGTH(ims_designator_code) = 3 ;

			  CURSOR deletedUsers IS
			  SELECT bems_id
			  FROM AMD_USERS
			  WHERE bems_id NOT IN (
			  		SELECT Amd_Load.getBemsId(employee_no) bems_id
					FROM AMD_USE1
					WHERE employee_status = 'A'
					AND ims_designator_code IS NOT NULL
					AND LENGTH(ims_designator_code) = 3)
			 AND action_code != Amd_Defaults.DELETE_ACTION ;

			  bems_id AMD_USERS.BEMS_ID%TYPE ;

			  inserted NUMBER := 0 ;
			  deleted NUMBER := 0 ;


	BEGIN
	    writeMsg(pTableName => 'amd_users', pError_location => 70,
				pKey1 => 'loadUsers',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
		Mta_Truncate_Table('tmp_a2a_spo_users','reuse storage');

		 FOR rec IN newUsers LOOP
		 	 IF rec.bems_id IS NOT NULL THEN
			   <<insertAmdUsers>>
			   BEGIN
			 	 INSERT INTO AMD_USERS
				 (bems_id, action_code, last_update_dt)
				 VALUES (rec.bems_id,  Amd_Defaults.INSERT_ACTION, SYSDATE) ;
				 inserted := inserted + 1 ;
			     A2a_Pkg.spoUser(rec.bems_id,  Amd_Defaults.INSERT_ACTION) ;
			   EXCEPTION WHEN standard.DUP_VAL_ON_INDEX THEN
			     NULL ; -- ignore because some users have multiple planner codes
			   END insertAmdUsers ;
			END IF ;
		 END LOOP ;

		 FOR rec IN deletedUsers LOOP
		 	 UPDATE AMD_USERS
			 SET action_code = Amd_Defaults.DELETE_ACTION,
			 last_update_dt = SYSDATE
			 WHERE bems_id = rec.bems_id ;
			 deleted := deleted + 1 ;
			 A2a_Pkg.spoUser(rec.bems_id,  Amd_Defaults.DELETE_ACTION) ;
		 END LOOP ;

	    writeMsg(pTableName => 'amd_users', pError_location => 80,
				pKey1 => 'loadUsers',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pKey3 => 'inserted=' || to_char(inserted),
				pKey4 => 'deleted=' || to_char(deleted) ) ;
				
		commit ;
	END loadUsers ;

	procedure createSiteRespAssetMgrA2ATran(planner_code in varchar2, logon_id in varchar2, data_source in varchar2) is
			 cursor planners is
			 		select data_source, logon_id  
			  		from amd_planner_logons 
			  		where planner_code = createSiteRespAssetMgrA2ATran.planner_code 
			  		order by data_source ;
	begin
		 begin
		 	  for rec in planners loop
				 A2a_Pkg.insertSiteRespAssetMgr(assetMgr => createSiteRespAssetMgrA2ATran.planner_code, 
				        logonId => rec.logon_id,
				 		data_source => rec.data_source,
				 		action_code => Amd_Defaults.INSERT_ACTION) ;
				 exit when 1 = 1 ;			  	  
			  end loop ;
		 end ;
		
	end createSiteRespAssetMgrA2Atran ;
	
	FUNCTION insertPlannerLogons(planner_code IN VARCHAR2, logon_id IN VARCHAR2, data_source in varchar2) RETURN NUMBER IS
	
			 
			 PROCEDURE doUpdate IS
			 BEGIN
			 	  UPDATE AMD_PLANNER_LOGONS
				  SET
				  action_code = Amd_Defaults.INSERT_ACTION,
				  last_update_dt = SYSDATE
				  WHERE planner_code = insertPlannerLogons.planner_code
				  AND logon_id = insertPlannerLogons.logon_id
				  and data_source = insertPlannerLogons.data_source ;
			 EXCEPTION WHEN OTHERS THEN
			   errorMsg(sqlFunction => 'update', tableName => 'amd_planner_logons', pErrorLocation => 160,
			   		key1 => insertPlannerLogons.planner_code,
					key2 => insertPlannerLogons.logon_id,
					key3 => insertPlannerLogons.data_source) ;
			   RAISE ;

			 END doUpdate ;
	BEGIN
		 debugMsg('planner_code=' || planner_code || ' logon_id=' || logon_id || ' data_source=' || data_source) ;
		 <<insertAmdPlannerLogons>>
		 BEGIN
			 INSERT INTO AMD_PLANNER_LOGONS
			 (planner_code, logon_id, data_source, action_code, last_update_dt)
			 VALUES (insertPlannerLogons.planner_code, insertPlannerLogons.logon_id, insertPlannerLogons.data_source, Amd_Defaults.INSERT_ACTION, SYSDATE) ;
		 EXCEPTION
		   WHEN standard.DUP_VAL_ON_INDEX THEN
		   		doUpdate ;
		   WHEN OTHERS THEN
			   errorMsg(sqlFunction => 'insert', tableName => 'amd_planner_logons', pErrorLocation => 170,
			   		key1 => insertPlannerLogons.planner_code,
					key2 => insertPlannerLogons.logon_id,
					key3 => insertPlannerLogons.data_source) ;
			   RAISE ;

	 	 END insertAmdPlannerLogons ;

 		createSiteRespAssetMgrA2Atran(insertPlannerLogons.planner_code, insertPlannerLogons.logon_id, insertPlannerLogons.data_source) ;
		 
		RETURN SUCCESS ;

	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;
	END insertPlannerLogons ;

	FUNCTION updatePlannerLogons(planner_code IN VARCHAR2, logon_id IN VARCHAR2, data_source in varchar2) RETURN NUMBER IS
	BEGIN
		 <<updateAmdPlannerLogons>>
		 BEGIN
		 	UPDATE AMD_PLANNER_LOGONS
			SET
			last_update_dt = SYSDATE,
			action_code = Amd_Defaults.UPDATE_ACTION
			WHERE planner_code = updatePlannerLogons.planner_code
			AND logon_id = updatePlannerLogons.logon_id
			and data_source = updatePlannerLogons.data_source ;
		 EXCEPTION WHEN OTHERS THEN
		   errorMsg(sqlFunction => 'update', tableName => 'amd_planner_logons', pErrorLocation => 180,
		   		key1 => updatePlannerLogons.planner_code,
				key2 => updatePlannerLogons.logon_id,
				key3 => updatePlannerLogons.data_source) ;
		   RAISE ;

	 	 END updateAmdPlannerLogons ;

		createSiteRespAssetMgrA2Atran(updatePlannerLogons.planner_code, updatePlannerLogons.logon_id, updatePlannerLogons.data_source) ;
		
		RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;
	END updatePlannerLogons ;

	FUNCTION deletePlannerLogons(planner_code IN VARCHAR2, logon_id IN VARCHAR2, data_source in varchar2) RETURN NUMBER IS
	BEGIN
		 <<deleteAmdPlannerLogons>>
		 BEGIN
		 	UPDATE AMD_PLANNER_LOGONS
			SET
			last_update_dt = SYSDATE,
			action_code = Amd_Defaults.DELETE_ACTION
			WHERE planner_code = deletePlannerLogons.planner_code
			AND logon_id = deletePlannerLogons.logon_id
			and data_source = deletePlannerLogons.data_source ;
		 EXCEPTION WHEN OTHERS THEN
		   errorMsg(sqlFunction => 'update', tableName => 'amd_planner_logons', pErrorLocation => 190,
		   		key1 => deletePlannerLogons.planner_code, key2 => deletePlannerLogons.logon_id, key3 => deletePlannerLogons.data_source) ;
		   RAISE ;

	 	 END deleteAmdPlanners ;

		A2a_Pkg.insertSiteRespAssetMgr(deletePlannerLogons.planner_code, deletePlannerLogons.logon_id,		  
		  Amd_Defaults.DELETE_ACTION,
		  deletePlannerLogons.data_source) ;

		RETURN SUCCESS ;

	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;
	END deletePlannerLogons ;

	-- For future use
	-- The following procedures: loadGoldPsmsMain, preProcess, postProcess, & postDiffProcess,
	-- may be used to replace the bulky sql scripts currently used by amd_loader.ksh
	procedure loadGoldPsmsMain(startStep in number := 1, endStep in number := 3) is
			  batch_job_number amd_batch_jobs.BATCH_JOB_NUMBER%type := amd_batch_pkg.getActiveJob ;
			  batch_step_number amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
			  LOAD_GOLD constant varchar2(8) := 'loadGold' ;
			  LOAD_PSMS constant varchar2(8) := 'loadPsms' ;
			  LOAD_MAIN constant varchar2(8) := 'loadMain' ;
	begin
		 if batch_job_number is null then
		 	raise no_active_job ;
		 end if ;

		 for step in startStep..endStep loop
		 	 if step = 1 then
			 	if not amd_batch_pkg.isStepComplete(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
				   	   					description => LOAD_GOLD) then
				 	amd_batch_pkg.start_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
						description => LOAD_GOLD, package_name => THIS_PACKAGE, procedure_name => LOAD_GOLD) ;

				 	loadGold ;
				end if ;

			 elsif step = 2 then
			 	if not amd_batch_pkg.isStepComplete(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
				   	   					description => LOAD_PSMS) then
				 	amd_batch_pkg.start_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
						description => LOAD_PSMS, package_name => THIS_PACKAGE, procedure_name => LOAD_PSMS) ;

				 	loadPsms ;
				end if ;

			 elsif step = 3 then
			 	if not amd_batch_pkg.isStepComplete(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
				   	   					description => LOAD_MAIN) then
				 	amd_batch_pkg.start_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
						description => LOAD_MAIN, package_name => THIS_PACKAGE, procedure_name => LOAD_MAIN) ;

				    loadMain ;
				end if ;

			 end if ;
			 debugMsg('loadGoldPsmsMain: completed step ' || step) ;
			 batch_step_number := amd_batch_pkg.getActiveStep(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
			 if batch_step_number is not null then
			 	 amd_batch_pkg.end_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					batch_step_number => batch_step_number) ;
			 end if ;
			 commit ;
		 end loop ;
	end loadGoldPsmsMain ;

	procedure preProcess(startStep in number := 1, endStep in number := 3) is
	begin
		 loadGoldPsmsMain(startStep, endStep) ;
	end preProcess ;

	procedure postProcess(startStep in number := 1, endStep in number := 18) is
			  batch_job_number amd_batch_jobs.BATCH_JOB_NUMBER%type := amd_batch_pkg.getActiveJob(system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
			  batch_step_number amd_batch_job_steps.BATCH_STEP_NUMBER%type ;

			  THE_A2A_PKG 					 constant varchar2(7)  := 'a2a_pkg' ;
			  THE_AMD_PARTPRIME_PKG 		 constant varchar2(17) := 'amd_partprime_pkg' ;
			  THE_AMD_PART_LOC_FORECASTS_PKG constant varchar2(26) := 'amd_part_loc_forecasts_pkg' ;
			  THE_AMD_SPARE_PARTS_PKG 	  	 constant varchar2(19) := 'amd_spare_parts_pkg' ;
			  THE_AMD_SPARE_NETWORKS_PKG  	 constant varchar2(22) :=  'amd_spare_networks_pkg' ;
			  THE_AMD_DEMAND_PKG 		  	 constant varchar2(10) := 'amd_demand' ;
			  THE_AMD_PART_LOCS_LOAD_PKG  	 constant varchar2(22) := 'amd_part_locs_load_pkg' ;
			  THE_AMD_FROM_BSSM_PKG			 constant varchar2(17) := 'amd_from_bssm_pkg' ;
			  THE_AMD_CLEANED_FROM_BSSM_PKG  constant varchar2(25) := 'amd_cleaned_from_bssm_pkg' ;

			  DELETE_INVALID_PARTS 	   constant varchar2(18) := 'deleteinvalidParts' ;
			  DIFF_PART_TO_PRIME 	   constant varchar2(15) := 'DiffPartToPrime' ;
			  LOAD_LATEST_RBL_RUN 	   constant varchar2(16) := 'LoadLatestRblRun' ;
			  LOAD_CURRENT_BACKORDER   constant varchar2(20) := 'loadCurrentBackOrder' ;
			  LOAD_TEMP_NSNS 		   constant varchar2(12) := 'loadtempnsns' ;
			  AUTO_LOAD_SPARE_NETWORKS constant varchar2(24) := 'auto_load_spare_networks' ;
			  LOAD_AMD_DEMANDS 		   constant varchar2(14) := 'loadamddemands' ;
			  LOAD_BASC_UK_DEMANDS 	   constant varchar2(17) := 'loadBascUkdemands' ;
			  AMD_DEMAND_A2A 		   constant varchar2(14) := 'amd_demand_a2a' ;
			  LOAD_GOLD_INVENTORY 	   constant varchar2(17) := 'loadGoldInventory' ;
			  LOAD_AMD_PART_LOCATIONS  	  constant varchar2(20) := 'LoadAmdPartLocations' ;
			  LOAD_AMD_BASE_FROM_BSSM_RAW constant varchar2(22) := 'LoadAmdBaseFromBssmRaw' ;

	begin
		if batch_job_number is null then
		 	raise amd_load.no_active_job ;
		end if ;
		for step in startStep..endStep loop
			if step = 1 then
				if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
						description => DELETE_INVALID_PARTS, package_name => THE_A2A_PKG, procedure_name => DELETE_INVALID_PARTS) then

					  a2a_pkg.deleteinvalidparts;
				end if ;

			elsif step = 2 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => DIFF_PART_TO_PRIME, package_name => THE_AMD_PARTPRIME_PKG, procedure_name => DIFF_PART_TO_PRIME) then

				  amd_partprime_pkg.DiffPartToPrime;
				end if ;

			elsif step = 3 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => LOAD_LATEST_RBL_RUN, package_name => THE_AMD_PART_LOC_FORECASTS_PKG, procedure_name => LOAD_LATEST_RBL_RUN) then

				  amd_part_loc_forecasts_pkg.LoadLatestRblRun;
				end if ;

			elsif step = 4 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => LOAD_CURRENT_BACKORDER, package_name => THE_AMD_SPARE_PARTS_PKG, procedure_name => LOAD_CURRENT_BACKORDER) then

				  amd_spare_parts_pkg.loadCurrentBackOrder;
				end if ;

			elsif step = 5 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => LOAD_TEMP_NSNS, package_name => THIS_PACKAGE, procedure_name => LOAD_TEMP_NSNS) then

				  amd_load.loadtempnsns;
				end if ;

			elsif step = 6 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => AUTO_LOAD_SPARE_NETWORKS, package_name => THE_AMD_SPARE_NETWORKS_PKG, procedure_name => AUTO_LOAD_SPARE_NETWORKS) then

				  amd_spare_networks_pkg.auto_load_spare_networks;
				end if ;

			elsif step = 7 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => LOAD_AMD_DEMANDS, package_name => THE_AMD_DEMAND_PKG, procedure_name => LOAD_AMD_DEMANDS) then

				  amd_demand.loadamddemands;
				end if ;

			elsif step = 8 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => LOAD_BASC_UK_DEMANDS, package_name => THE_AMD_DEMAND_PKG, procedure_name => LOAD_BASC_UK_DEMANDS) then

				  amd_demand.loadBascUkdemands;
				end if ;

			elsif step = 9 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => AMD_DEMAND_A2A, package_name => THE_AMD_DEMAND_PKG, procedure_name => AMD_DEMAND_A2A) then

				  amd_demand.amd_demand_a2a;
				end if ;

			elsif step = 10 then
			 	if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => LOAD_GOLD_INVENTORY, package_name => THE_AMD_INVENTORY_PKG, procedure_name => LOAD_GOLD_INVENTORY) then

				  amd_inventory.loadGoldInventory;
				end if ;

			elsif step = 11 then
				  if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => LOAD_AMD_PART_LOCATIONS, package_name => THE_AMD_PART_LOCS_LOAD_PKG, procedure_name => LOAD_AMD_PART_LOCATIONS) then

				  	amd_part_locs_load_pkg.LoadAmdPartLocations;
				  end if ;

			elsif step = 12 then
			 	  if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => LOAD_AMD_BASE_FROM_BSSM_RAW, package_name => THE_AMD_FROM_BSSM_PKG, procedure_name => LOAD_AMD_BASE_FROM_BSSM_RAW) then

				    amd_from_bssm_pkg.LoadAmdBaseFromBssmRaw;
				  end if ;

			elsif step = 13 then
			 	  if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => 'UpdateAmdAllBaseCleaned', package_name => THE_AMD_CLEANED_FROM_BSSM_PKG, procedure_name => 'UpdateAmdAllBaseCleaned') then

				    amd_cleaned_from_bssm_pkg.UpdateAmdAllBaseCleaned;
				  end if ;

			elsif step = 14 then
			 	  if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => 'LoadAmdReqs', package_name => THIS_PACKAGE, procedure_name => 'LoadAmdReqs') then

				    amd_reqs_pkg.LoadAmdReqs;
				 end if ;

			elsif step = 15 then
			 	  if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => 'LoadTmpAmdPartFactors', package_name => THIS_PACKAGE, procedure_name => 'LoadTmpAmdPartFactors') then

				   amd_part_factors_pkg.LoadTmpAmdPartFactors;
				 end if ;

			elsif step = 16 then
			 	  if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => 'ProcessA2AVirtualLocs', package_name => THIS_PACKAGE, procedure_name => 'ProcessA2AVirtualLocs') then

				    amd_part_factors_pkg.ProcessA2AVirtualLocs;
				 end if ;

			elsif step = 17 then
			 	  if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => 'LoadTmpAmdPartLocForecasts_Add', package_name => THIS_PACKAGE, procedure_name => 'LoadTmpAmdPartLocForecasts_Add') then

				    amd_part_loc_forecasts_pkg.LoadTmpAmdPartLocForecasts_Add;
				 end if ;

			elsif step = 18 then
			 	  if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					description => 'LoadTmpAmdLocPartLeadtime', package_name => THIS_PACKAGE, procedure_name => 'LoadTmpAmdLocPartLeadtime') then

				    amd_location_part_leadtime_pkg.LoadTmpAmdLocPartLeadtime;
				 end if ;

			end if ;
			debugMsg('postProcess: completed step ' || step) ;
		    batch_step_number := amd_batch_pkg.getActiveStep(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
			if batch_step_number is not null then
		 	    amd_batch_pkg.end_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
				  batch_step_number => batch_step_number) ;
		    end if ;
			commit;
		end loop ;
	end postProcess ;

	procedure postDiffProcess(startStep in number := 1, endStep in number := 3) is
			  batch_job_number amd_batch_jobs.BATCH_JOB_NUMBER%type := amd_batch_pkg.getActiveJob(system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
			  batch_step_number amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
	begin
		 if batch_job_number is null then
		 	raise amd_load.no_active_job ;
		 end if ;
		 for step in startStep..endStep loop
		 	 if step = 1 then
		 	    if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
				  description => 'UpdateSpoTotalInventory', package_name => THE_AMD_INVENTORY_PKG, procedure_name => 'UpdateSpoTotalInventory') then

			 	  amd_inventory.UpdateSpoTotalInventory;
			   end if ;

			 elsif step = 2 then
		 	    if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
				  description => 'LoadTmpAmdLocPartOverride', package_name => THIS_PACKAGE, procedure_name => 'LoadTmpAmdLocPartOverride') then

			 	  amd_location_part_override_pkg.LoadTmpAmdLocPartOverride;
			   end if ;

			 elsif step = 3 then
		 	    if amd_batch_pkg.didStepStart(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
				  description => 'LoadZeroTslA2A', package_name => THIS_PACKAGE, procedure_name => 'LoadZeroTslA2A') then

			      amd_location_part_override_pkg.LoadZeroTslA2A;
			    end if ;

			 end if ;
			 debugMsg('postDiffProcess: completed step ' || step) ;
			 batch_step_number := amd_batch_pkg.getActiveStep(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
			 if batch_step_number is not null then
			 	 amd_batch_pkg.end_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
					batch_step_number => batch_step_number) ;
			 end if ;
			 commit ;
		 end loop ;
	end postDiffProcess ;

	procedure disableAmdConstraints is
	begin
		 debugMsg('start disableAmdContraints') ;
		 mta_disable_constraint('amd_part_loc_time_periods','amd_part_loc_time_periods_fk01');
		 mta_disable_constraint('amd_part_locs','amd_part_locs_fk01');
		 mta_disable_constraint('amd_part_locs','amd_part_locs_fk02');
		 mta_disable_constraint('amd_maint_task_distribs','amd_maint_task_distribs_fk01');
		 mta_disable_constraint('amd_bods','amd_bods_fk02');
		 mta_disable_constraint('amd_part_next_assemblies','amd_part_next_assemblies_fk01');
		 mta_disable_constraint('amd_demands','amd_demands_fk01');
		 mta_disable_constraint('amd_demands','amd_demands_fk02');
		 mta_disable_constraint('amd_demands','amd_demands_pk');
		 debugMsg('end disableAmdContraints') ;
		 commit ;
	end disableAmdConstraints ;

	procedure truncateAmdTables is
	begin
		 debugMsg('start truncateAmdTables') ;
		 mta_truncate_table('tmp_a2a_bom_detail','reuse storage');
		 mta_truncate_table('tmp_a2a_demands','reuse storage');
		 mta_truncate_table('tmp_a2a_org_flight_acty','reuse storage');
		 mta_truncate_table('tmp_a2a_org_flight_acty_frecst','reuse storage');
		 mta_truncate_table('tmp_a2a_site_resp_asset_mgr','reuse storage');
		 mta_truncate_table('tmp_a2a_spo_users','reuse storage');
		 mta_truncate_table('tmp_a2a_part_effectivity','reuse storage');
		 mta_truncate_table('tmp_amd_demands','reuse storage');
		 mta_truncate_table('tmp_amd_part_locs','reuse storage');
		 mta_truncate_table('tmp_amd_spare_parts','reuse storage');
		 mta_truncate_table('tmp_lcf_icp','reuse storage');
		 mta_truncate_table('amd_bssm_source','reuse storage');
		 mta_truncate_table('amd_maint_task_distribs','reuse storage');
		 mta_truncate_table('amd_part_loc_time_periods','reuse storage');
		 mta_truncate_table('amd_flight_stats','reuse storage');
		 mta_truncate_table('tmp_a2a_ext_forecast','reuse storage') ;
		 debugMsg('end truncateAmdTables') ;
		 commit ;
	end truncateAmdTables ;

	procedure enableAmdConstraints is
	begin
		 debugMsg('start enableAmdConstraints') ;
		 mta_enable_constraint('amd_part_loc_time_periods','amd_part_loc_time_periods_fk01');
		 mta_enable_constraint('amd_part_locs','amd_part_locs_fk01');
		 mta_enable_constraint('amd_part_locs','amd_part_locs_fk02');
		 mta_enable_constraint('amd_maint_task_distribs','amd_maint_task_distribs_fk01');
		 mta_enable_constraint('amd_bods','amd_bods_fk02');
		 mta_enable_constraint('amd_part_next_assemblies','amd_part_next_assemblies_fk01');
		 mta_enable_constraint('amd_demands','amd_demands_fk01');
		 mta_enable_constraint('amd_demands','amd_demands_fk02');
		 mta_enable_constraint('amd_demands','amd_demands_pk');
		 debugMsg('end enableAmdConstraints') ;
		 commit ;
	end enableAmdConstraints ;

	procedure prepAmdDatabase is
		  batch_job_number amd_batch_jobs.BATCH_JOB_NUMBER%type := amd_batch_pkg.getActiveJob(system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
		  batch_step_number amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
	begin
		 debugMsg('start prepAmdDatabase') ;
		 if batch_job_number is null then
		 	raise amd_load.no_active_job ;
		 end if ;
 	     amd_batch_pkg.start_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
		   description => 'disableAmdConstraints', package_name => THIS_PACKAGE, procedure_name => 'disableAmdConstraints') ;
		 disableAmdConstraints ;
		 batch_step_number := amd_batch_pkg.getActiveStep(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
	 	 amd_batch_pkg.end_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
			batch_step_number => batch_step_number) ;

 	     amd_batch_pkg.start_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
		   description => 'truncateAmdTables', package_name => THIS_PACKAGE, procedure_name => 'truncateAmdTables') ;
		 truncateAmdTables ;
		 batch_step_number := amd_batch_pkg.getActiveStep(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
	 	 amd_batch_pkg.end_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
			batch_step_number => batch_step_number) ;

 	     amd_batch_pkg.start_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
		   description => 'enableAmdConstraints', package_name => THIS_PACKAGE, procedure_name => 'enableAmdConstraints') ;
		 enableAmdConstraints ;
		 batch_step_number := amd_batch_pkg.getActiveStep(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP) ;
	 	 amd_batch_pkg.end_step(batch_job_number => batch_job_number, system_id => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
			batch_step_number => batch_step_number) ;

		 debugMsg('end prepAmdDatabase') ;
		 commit ;
	end prepAmdDatabase ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_load', 
		 		pError_location => 90, pKey1 => 'amd_load', pKey2 => '$Revision:   1.40  $') ;
		 dbms_output.put_line('amd_load: $Revision:   1.40  $') ;
	end version ;

BEGIN

  <<getDebugParam>>
  DECLARE
  	 param AMD_PARAM_CHANGES.PARAM_VALUE%TYPE ;
  BEGIN
     SELECT param_value INTO param FROM AMD_PARAM_CHANGES WHERE param_key = 'debugAmdLoad' ;
     mDebug := (param = '1');
  EXCEPTION WHEN OTHERS THEN
     mDebug := FALSE ;
  END getDebugParam;

END Amd_Load;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Inventory AS

	/* ------------------------------------------------------------------- */
	/*  this program extracts data from gold and generate records for the  */
	/*  amd_spare_invs table for the boeing icp parts which have been      */
	/*  loaded in the amd_spare_parts.                                     */
	/*                                                                     */
	/*  this program also generates data for amd_repair_levels and         */
	/*  amd_main_task_distribs table.                                      */
	/* ------------------------------------------------------------------- */
	/* 
	    PVCS Keywords
		
       $Author:   zf297a  $
     $Revision:   1.71  $
         $Date:   Jun 09 2006 11:39:30  $
     $Workfile:   AMD_INVENTORY.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_inventory.pkb-arc  $
   
      Rev 1.71   Jun 09 2006 11:39:30   zf297a
   implemented interface version
   
      Rev 1.70   Jun 05 2006 08:59:06   zf297a
   Fixed errorMsg - changed literal from amd_load to amd_inventory
   
      Rev 1.69   May 16 2006 12:08:00   zf297a
   Fixed doRspSumDiff to invoke A2a_Pkg.insertInvInfo with the qty_on_hand or zero if it is null
   
      Rev 1.68   Apr 28 2006 12:51:28   c402417
   Added tmp_a2a_loc_part_override to truncate .
   
      Rev 1.67   Apr 28 2006 12:42:32   c402417
   Added AMD Inventory Mofication for SPO - including new process for amd_rsp, removed Order Type of M from amd_on_order, removed HPMSK_BALANCE+ SPRAM_BALANCE+WRM_BALANCE from amd_on_hand_inv.
   
      Rev 1.66   Jan 20 2006 12:01:38   c402417
   Need to exclude part_no w/out spo_location for spo_total_inventory.
   
      Rev 1.65   Dec 15 2005 12:20:44   zf297a
   Added truncate of table tmp_a2a_repair_inv_info to loadInRepair
   
      Rev 1.64   Dec 06 2005 14:25:44   zf297a
   Fixed the doUpdate of the insertOnOrderRow routine when it checks for a Deleted order qualify the select with the order_date and also fixed the update by adding the order_date in its where clause.
   
      Rev 1.63   Dec 06 2005 14:04:36   zf297a
   Fixed deleteRow - passed an qty_ordered of 0 and sysdate for the A2A transaction.
   
      Rev 1.62   Dec 06 2005 12:29:20   zf297a
   Implemented new version of deleteRow for amd_on_order diff.  The code has been streamlined since all the necessary data is being passed in from the java diff application.
   
      Rev 1.61   Dec 06 2005 10:20:20   zf297a
   Fixed update of amd_on_order: qualified the where clause with  gold_order_number and order_date.  Order_date was missing and caused a unique constraint error.
   
      Rev 1.60   Nov 03 2005 09:33:18   c402417
   Changed sequence of procedure so the SpoTotalInventory get update after all inventory tables get loaded.
   
      Rev 1.59   Oct 27 2005 15:47:54   c402417
   Added repair_need_date to A2a_pkg.insertRepairInfo.
   
      Rev 1.58   Oct 20 2005 16:35:58   c402417
   Added Cursor RampCurUAB. This cursor feeds data from table ramp with SC = UAB to amd_on_hand_invs.
   
      Rev 1.57   Oct 19 2005 11:37:42   zf297a
   removed invocation of insertTmpA2AOrderInfoLine and update the arg list for insertTmpA2AOrderInfo, which now inserts both the tmp_a2a_order_info and the tmp_a2a_order_info_line.
   
   Thuy, added code for rampCurUAB.
   
      Rev 1.56   Oct 13 2005 11:12:14   c402417
   Added Repair Inventory Sum diff function . This to sum parts which have doc_no like 'R' and 'II' and send them to table amd_repair_invs_sum and these data consider DEFECTIVE as on_hand_type in SPO - Inventory.
   
      Rev 1.55   Oct 04 2005 13:05:12   c402417
   Add goldsa for amd_on_hand_invs.(This added for SPO 5.0)
   
      Rev 1.54   Oct 04 2005 11:51:26   c402417
   minor fixed in in_repair update statement .
   
      Rev 1.53   Sep 26 2005 09:31:20   zf297a
   Fixed deleteRow for doOnHandInvsSumDiff: it was trying to update amd_on_hand_invs instead of amd_on_hand_invs_sum
   
      Rev 1.52   Sep 13 2005 12:44:24   zf297a
   Implemented the isVoucher boolean function and modified the getOnOrderParams procedure to check if from/to dates not null and have a length > 0 before returning them.
   
      Rev 1.51   Sep 12 2005 11:36:40   zf297a
   implemented interfaces for one get and one set procedure for all the on order date parameters for a given voucher.
   
      Rev 1.50   Sep 09 2005 10:56:34   zf297a
   For amd_on_hand_inv_sums changed the site_location column to be the spo_location column.  The spo_location comes from amd_spare_networks.spo_location.
   
      Rev 1.49   Sep 07 2005 21:01:24   zf297a
   raised sched_receipt_date_exception in setScheduledReceiptDate when the from_date argument is > than the to_date argument.
   
      Rev 1.48   Sep 07 2005 15:17:32   zf297a
   Added orderdates subtype.   Implemented gets and sets for create_order_date, scheduled_receipt_date_from, scheduled_receipt_date_to, and number_of_calander days.
   
      Rev 1.47   Sep 02 2005 15:50:24   zf297a
   Started implementing interfaces for getOrderCreateDate, setOrderCreateDate, getScdeduledReceiptDateFrom, getScdeduledReceiptDateTo, setScheduledReceiptDate, and setScheduledReceiptDateCalDays using empty functions and procedures.
   
      Rev 1.46   Aug 30 2005 10:40:38   zf297a
   Moved cursors outside of loadGoldInventory.  Implemented loadOnHandInvs and loadInRepair as separate procedures.  Updated loadGoldInventory to use these new procedures.
   
      Rev 1.45   12 Aug 2005 09:42:18   c402417
   Added FC to order_no on ORD1 for amd_on_onder
   
      Rev 1.44   Aug 04 2005 08:12:52   zf297a
   Made insertRow and updateRow unique for the jdbc interface by renaming them to insertOnOrderRow and updateOnOrderRow.
   
      Rev 1.43   03 Aug 2005 17:43:14   b1013683
   Added Accountable_YN in  amd_in_repair.
   Added sched_receipt_date & changed in order_date in amd_on_order.
   Made modification in getting spo_total_inventory in table ansi.
   
      Rev 1.41   Jul 15 2005 10:59:08   zf297a
   Fixed updateRow for amd_inv_on_hand and insertRow for amd_in_transits
   
      Rev 1.39   Jul 11 2005 11:49:12   zf297a
   used procedure a2a_pkg.insertTmpA2AInTransits
   
      Rev 1.38   Jul 11 2005 10:39:22   zf297a
   used a2a_pkg to insertTmpA2AOrderInfo and insertTmpA2AOrderInfoLine
   
      Rev 1.37   Jul 11 2005 09:49:02   zf297a
   updated pErrorLocation numbers (10, 20, 30,.........400)
   
      Rev 1.36   Jul 11 2005 09:30:36   zf297a
   made the loading of tmp_amd_in_transits a separate procedure
   
      Rev 1.35   Jul 11 2005 09:17:42   zf297a
   made the loading of tmp_amd_on_order a separate procedure
   
      Rev 1.34   Jul 06 2005 09:28:14   zf297a
   Enhanced amd_in_repair and added spo inventory total
   
      Rev 1.33   Jun 17 2005 06:52:50   c970183
   removed insertInvInfo, updateInvInfo, and deleteInvInfo from routine dealing with amd_in_repair
   
      Rev 1.32   May 17 2005 10:06:08   c970183
   Updated InsertErrorMessage to new interface
   
      Rev 1.31   May 04 2005 10:26:04   c970183
   added logical insert (update) for AMD_IN_TRANSITS which had previously been logically deleted.
   
      Rev 1.30   May 04 2005 10:14:30   c970183
   added logical insert (update) for AMD_ON_HAND_INVS which has been previously logically deleted.
   
      Rev 1.29   May 04 2005 10:05:50   c970183
   added a logical insert (update) for amd_in_repair for a row that has been previously logically deleted.
   
      Rev 1.28   May 04 2005 09:50:14   c970183
   truncated all tmp_a2a tables when loadGoldInventory is executed
   
      Rev 1.27   May 04 2005 09:16:00   c970183
   Added logical insert of amd_on_order when it has been previously marked as deleted.
   
      Rev 1.26   Apr 27 2005 09:21:42   c970183
   aded counters of rows inserted for loadGoldInventory.  Added info messages using dbms_output and amd_load_details.
   
      Rev 1.25   20 Sep 2004 10:17:42   c970183
   Fixed site_location for insertRow of in_transits - it must be varchar(20)
   
      Rev 1.24   20 Aug 2004 16:51:46   c402417
   Added tmp_amd_in_repairs
   
      Rev 1.23   09 Aug 2004 14:48:22   c970183
   fixed deleteRow for tmp_a2a_on_hand_invs: the qty_on_hand is required, so set it to zero.
   
      Rev 1.22   09 Aug 2004 14:40:02   c970183
   fixed deleteRow (insert of tmp_a2a_on_hand_invs) the site_location field was NOT being inserted.
   
      Rev 1.21   09 Aug 2004 14:23:46   c970183
   added insertion of tmp_a2a_order_info for inserts and updates
   
      Rev 1.16   05 Aug 2004 07:47:26   c970183
   changed parameter from using p prefix to the same namje as used by the colum.  Added function or procedure qualification for all parameters used in SQL where clauses and UPDATE set clauses
   
      Rev 1.13   03 Aug 2004 10:15:02   c402417
   Added the amd_in_repair diff function.
   
      Rev 1.12   02 Aug 2004 14:14:34   c970183
   accomodate insert/update of detail rows for amd_on_hand_invs
   
      Rev 1.11   Aug 02 2004 08:47:10   c970183
   changed case of plocSid to pLocSid
   
      Rev 1.9   Jul 30 2004 12:02:18   c970183
   added comments to document changes made 
		  
	 */
   	-- DSE 7/23/04 added InsertRow, DeleteRow, and UpdateRow stubs
	-- TL  7/26/04 added ErrorMsg and code for amd_on_order InsertRow, DeleteRow, and UpdateRow
	-- DSE 7/27/04 added tmp prefix to all amd tables created by LoadGoldInventory
	-- DSE 7/29/04 Added InsertRow, UpdateRow, and DeleteRow for the amd_on_order table
	-- TL  7/30/04 Enhanced the ErrorMsg Function and implemented the InsertRow, UpdateRow,
	-- 	   		   and DeleteRow functions for the amd_on_hand_invs table
	-- TP	 8/2/04  Added InsertRow, UpdateRow, and DeleteRow for the amd_in_repair table.
	-- TP    8/18/04 Added InsertRow, UpdateRow, and DeleteRow for the amd_in_transits table.
	-- 

	ON_ORDER_DATE CONSTANT AMD_PARAMS.PARAM_KEY%TYPE := 'on_order_date_' ;
		
	SUBTYPE orderdates IS NUMBER ;
	ORDER_CREATE_DATE CONSTANT orderdates := 1 ;
	SCHEDULED_RECEIPT_DATE_FROM CONSTANT orderdates := 2 ;
	SCHEDULED_RECEIPT_DATE_TO CONSTANT orderdates := 3 ;
	NUMBER_OF_CALANDER_DAYS CONSTANT orderdates := 4 ;
	
	
	CURSOR partCur IS
		SELECT DISTINCT
			asp.part_no,
			asp.nsn
		FROM
			AMD_SPARE_PARTS asp,
			AMD_NATIONAL_STOCK_ITEMS ansi,
			AMD_NSI_PARTS anp
		WHERE
			icp_ind = 'F77'
			AND asp.part_no   = anp.part_no
			AND anp.prime_ind = 'Y'
			AND anp.unassignment_date IS NULL
			AND asp.nsn = ansi.nsn
			AND asp.action_code != 'D';
				
	-- Type 1,2 Retail
	CURSOR rampCur(pNsn VARCHAR2) IS
		SELECT
			DECODE(n.loc_type,'TMP',asn2.loc_sid,n.loc_sid) loc_sid,
			NVL(r.serviceable_balance,0) serviceable_balance,
			NVL(r.spram_balance,0) spram_balance,
			NVL(r.wrm_balance,0) wrm_balance,
			NVL(r.hpmsk_balance,0) hpmsk_balance,
			NVL(r.total_inaccessible_qty,0) total_inaccessible_qty,
			NVL(r.difm_balance,0) difm_balance,
			NVL(r.unserviceable_balance,0) unserviceable_balance,
			NVL(r.spram_level,0) spram_level,
			NVL(r.wrm_level,0) wrm_level,
			NVL(r.hpmsk_level_qty,0) hpmsk_level_qty,
			NVL(r.suspended_in_stock,0) suspended_in_stock,
			TRUNC(NVL(r.date_processed,SYSDATE)) inv_date,
			TRUNC((r.date_processed) + NVL(avg_repair_cycle_time,0)) repair_need_date
		FROM
			(SELECT * FROM RAMP
			WHERE current_stock_number = pNsn ) r,
			--AMD_SPARE_PARTS asp,
			AMD_SPARE_NETWORKS n,
			AMD_SPARE_NETWORKS asn2
		WHERE
			n.loc_id = SUBSTR(r.sc(+),8,6)
			--AND asp.nsn = pNsn
			AND n.loc_type IN ('MOB', 'FSL')
			AND n.mob = asn2.loc_id(+);
					
			
	CURSOR rampCurUAB(pNsn VARCHAR2) IS
		SELECT
			DECODE(n.loc_type,'TMP',asn2.loc_sid,n.loc_sid) loc_sid,
			NVL(r.serviceable_balance,0) serviceable_balance,
			NVL(r.spram_balance,0) spram_balance,
			NVL(r.hpmsk_balance,0) hpmsk_balance,
			NVL(r.wrm_balance,0) wrm_balance,
			NVL(r.total_inaccessible_qty,0) total_inaccessible_qty,
			NVL(r.difm_balance,0) difm_balance,
			NVL(r.spram_level,0) spram_level,
			NVL(r.wrm_level,0) wrm_level,
			NVL(r.hpmsk_level_qty,0) hpmsk_level_qty,
			TRUNC(NVL(r.date_processed,SYSDATE)) inv_date,
			TRUNC((r.date_processed) + NVL(avg_repair_cycle_time,0)) repair_need_date
		FROM
			(SELECT * FROM RAMP
			WHERE current_stock_number = pNsn ) r,
			--AMD_SPARE_PARTS asp,
			AMD_SPARE_NETWORKS n,
			AMD_SPARE_NETWORKS asn2
		WHERE
			n.loc_id = SUBSTR(r.sc(+),8,6)
			AND SUBSTR(r.sc,8,2) = 'FB'
			--AND asp.nsn = pNsn
			AND n.loc_type = 'UAB'
			AND n.mob = asn2.loc_id(+);
			
			
		CURSOR rampCurFB(pNsn VARCHAR2) IS
		SELECT
			DECODE(n.loc_type,'TMP',asn2.loc_sid,n.loc_sid) loc_sid,
			NVL(r.serviceable_balance,0) serviceable_balance,
			NVL(r.spram_balance,0) spram_balance,
			NVL(r.hpmsk_balance,0) hpmsk_balance,
			NVL(r.wrm_balance,0) wrm_balance,
			NVL(r.total_inaccessible_qty,0) total_inaccessible_qty,
			NVL(r.difm_balance,0) difm_balance,
			NVL(r.spram_level,0) spram_level,
			NVL(r.wrm_level,0) wrm_level,
			NVL(r.hpmsk_level_qty,0) hpmsk_level_qty,
			TRUNC(NVL(r.date_processed,SYSDATE)) inv_date,
			TRUNC((r.date_processed) + NVL(avg_repair_cycle_time,0)) repair_need_date
		FROM
			(SELECT * FROM RAMP
			WHERE current_stock_number = pNsn ) r,
			--AMD_SPARE_PARTS asp,
			AMD_SPARE_NETWORKS n,
			AMD_SPARE_NETWORKS asn2
		WHERE
			n.loc_id = SUBSTR(r.sc(+),8,6)
			AND SUBSTR(r.sc,8,2) = 'FB'
			--AND asp.nsn = pNsn
			AND n.mob = asn2.loc_id(+);
			
				
	-- Type 1 Wholesale from ITEM and TMP1
	CURSOR itemType1Cur IS
		SELECT
			asp.part_no,
			DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid) loc_sid,
			invQ.inv_date inv_date,
			'1' inv_type,
			SUM(invQ.inv_qty) inv_qty
		FROM
			(SELECT
				RTRIM(part) part_no,
				SUBSTR(i.sc,8,6) loc_id,
				TRUNC(DECODE(i.created_datetime, NULL, i.last_changed_datetime,i.created_datetime)) inv_date,
				'1' inv_type,
				SUM(NVL(i.qty,0)) inv_qty
			FROM
				ITEM i
			WHERE
				i.status_3 != 'I'
				AND i.status_servicable = 'Y'
				AND i.status_new_order = 'N'
				AND i.status_accountable = 'Y'
				AND i.status_active = 'Y'
				AND i.status_mai = 'N'
				AND i.condition != 'B170-ATL'
				AND NOT EXISTS (SELECT 1 FROM ITEM ii
							    WHERE ii.status_avail = 'N' 
								AND   ii.receipt_order_no IS NULL
								AND   ii.item_id = i.item_id)
				GROUP BY 
					  RTRIM(part),
					  SUBSTR(i.sc,8,6) ,
					  TRUNC(DECODE(i.created_datetime, NULL, i.last_changed_datetime,i.created_datetime))  
				UNION 
			(SELECT
				RTRIM(part) part_no,
				DECODE(i.sc,'C17PCAG','EY1746') loc_id,
				TRUNC(DECODE(i.created_datetime, NULL, i.last_changed_datetime,i.created_datetime)) inv_date,
				'1' inv_type,
				SUM(NVL(i.qty,0)) inv_qty
			FROM
				ITEMSA i
			WHERE
				i.status_3 != 'I'
				AND i.status_servicable = 'Y'
				AND i.status_new_order = 'N'
				AND i.status_accountable = 'Y'
				AND i.status_active = 'Y'
				AND i.status_mai = 'N'
				AND i.condition != 'B170-ATL'
				AND NOT EXISTS (SELECT 1 FROM ITEMSA ii
							    WHERE ii.status_avail = 'N' 
								AND   ii.receipt_order_no IS NULL
								AND   ii.item_id = i.item_id)
				GROUP BY 
				 	  RTRIM(part),
					  DECODE(i.sc,'C17PCAG','EY1746') ,
					  TRUNC(DECODE(i.created_datetime, NULL, i.last_changed_datetime,i.created_datetime)) )) invQ,
			AMD_SPARE_NETWORKS asn,
			AMD_SPARE_PARTS asp,
			AMD_SPARE_NETWORKS asnLink
		WHERE
			asp.part_no = invQ.part_no
			AND asn.loc_id = invQ.loc_id
			AND asp.action_code != 'D'
			AND asn.mob = asnLink.loc_id(+)
	 GROUP BY  asp.part_no,
	 DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid) ,
	 invQ.inv_date;

		-- Type 4 Wholesale
	CURSOR itemMCur IS
		SELECT
			asp.part_no,
			DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid) loc_sid,
			'4' inv_type,
			RTRIM(i.item_id) item_id,
			DECODE(i.created_datetime,NULL,TRUNC(i.last_changed_datetime),
			      TRUNC(i.created_datetime)) inv_date,
			TRUNC(i.created_datetime) repair_date,
			TRUNC(i.created_datetime + ansi.time_to_repair_off_base) repair_need_date,
			SUM(NVL(i.qty,0)) inv_qty
		FROM
			ITEM i,
			AMD_NATIONAL_STOCK_ITEMS ansi,
			AMD_SPARE_NETWORKS asn,
			AMD_SPARE_PARTS asp,
			AMD_SPARE_NETWORKS asnLink
		WHERE
			asp.part_no = RTRIM(i.part)
			AND RTRIM(i.prime) = RTRIM(ansi.prime_part_no)
			AND i.status_3 != 'I'
			AND i.status_servicable = 'N'
			AND i.status_new_order = 'N'
			AND i.status_accountable = 'Y'
			AND i.status_active = 'Y'
			AND i.status_mai = 'N'
			AND asn.loc_id = SUBSTR(i.sc,8,6)
			AND asp.action_code != 'D'
			AND asn.mob = asnLink.loc_id(+)
		GROUP BY
			asp.part_no,
			DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid),
			RTRIM(i.item_id),
			DECODE(i.created_datetime,NULL,TRUNC(i.last_changed_datetime),
			      TRUNC(i.created_datetime)),
			TRUNC(i.created_datetime),
			TRUNC(i.created_datetime + ansi.time_to_repair_off_base);
	 
		CURSOR itemACur IS
		SELECT
			asp.part_no,
			DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid) loc_sid,
			'4' inv_type,
			RTRIM(i.item_id) item_id,
			DECODE(i.created_datetime, NULL, TRUNC(i.last_changed_datetime), TRUNC(i.created_datetime)) inv_date,
			TRUNC(i.created_datetime) repair_date,
			TRUNC(i.created_datetime + NVL(ansi.time_to_repair_off_base,0)) repair_need_date,
			SUM(NVL(i.qty,0)) inv_qty
		FROM
			ITEMSA i,
			AMD_NATIONAL_STOCK_ITEMS ansi,
			AMD_SPARE_NETWORKS asn,
			AMD_SPARE_PARTS asp,
			AMD_SPARE_NETWORKS asnLink
		WHERE
			RTRIM(asp.part_no) = RTRIM(i.part)
			AND RTRIM(i.prime) = RTRIM(ansi.prime_part_no)
			AND i.status_3 != 'I'
			AND i.status_servicable = 'N'
			AND i.status_new_order = 'N'
			AND i.status_accountable = 'Y'
			AND i.status_active = 'Y'
			AND i.status_mai = 'N'
			AND asn.loc_id = 'EY1746'
			AND asp.action_code != 'D'
			AND asn.mob = asnLink.loc_id(+)
		GROUP BY
			asp.part_no,
			DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid),
			RTRIM(i.item_id),
			DECODE(i.created_datetime, NULL, TRUNC(i.last_changed_datetime), TRUNC(i.created_datetime)),
			TRUNC(i.created_datetime),
			TRUNC(i.created_datetime + NVL(ansi.time_to_repair_off_base,0));
				
	CURSOR itemType5Cur IS	
	SELECT
		asp.part_no,
		DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid) loc_sid,
		'3' inv_type,
		o.created_datetime inv_date,
		NVL(o.qty_due,0) inv_qty,
		RTRIM(o.order_no) order_no,
		DECODE(ov.vendor_est_ret_date,NULL, o.ecd, ov.vendor_est_ret_date) repair_need_date
	FROM
		ORD1 o,
		ORDV ov,
		AMD_SPARE_NETWORKS asn,
		AMD_SPARE_PARTS asp,
		AMD_SPARE_NETWORKS asnLink
	WHERE
		RTRIM(o.order_no) = RTRIM(ov.order_no)
		AND asp.part_no  = RTRIM(o.part)
		AND o.status IN ('O', 'U')
		AND o.order_type = 'J'
		AND o.accountable_yn = 'Y'
		AND asn.loc_id = SUBSTR(o.sc,8,6)
		AND asp.action_code != 'D'
		AND asn.mob = asnLink.loc_id(+);
				
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_inventory',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	PROCEDURE infoMsg(
					sqlFunction IN VARCHAR2,
					tableName IN VARCHAR2,
					pErrorLocation IN NUMBER,
					key1 IN VARCHAR2 := '',
			 		key2 IN VARCHAR2 := '',
					key3 IN VARCHAR2 := '',
					key4 IN VARCHAR2 := '',
					key5 IN VARCHAR2 := '',					
					keywordValuePairs IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => sqlFunction,
						pTableName  => tableName),
				pData_line_no => pErrorLocation,
				pData_line    => 'amd_inventory',
				pKey_1 => key1,
				pKey_2 => key2,
				pKey_3 => key3,
				pKey_4 => key4,
				pKey_5 => key5 || ' ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ||
						   ' ' || keywordValuePairs,
				pComments => 'sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')');
	END infoMsg ;

	PROCEDURE errorMsg(
					sqlFunction IN VARCHAR2,
					tableName IN VARCHAR2,
					pErrorLocation IN NUMBER,
					key1 IN VARCHAR2 := '',
			 		key2 IN VARCHAR2 := '',
					key3 IN VARCHAR2 := '',
					key4 IN VARCHAR2 := '',
					key5 IN VARCHAR2 := '',					
					keywordValuePairs IN VARCHAR2 := '') IS
	BEGIN
		ROLLBACK;
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => sqlFunction,
						pTableName  => tableName),
				pData_line_no => pErrorLocation,
				pData_line    => 'amd_inventory',
				pKey_1 => key1,
				pKey_2 => key2,
				pKey_3 => key3,
				pKey_4 => key4,
				pKey_5 => key5 || ' ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ||
						   ' ' || keywordValuePairs,
				pComments => SqlFunction || '/' || TableName || ' sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')');
		COMMIT;
		RETURN ;
	END ErrorMsg;
	
	FUNCTION ErrorMsg(
					pSqlFunction IN VARCHAR2,
					pTableName IN VARCHAR2,
					pErrorLocation IN NUMBER,
					pReturn_code IN NUMBER,
					pKey_1 IN VARCHAR2,
			 		pKey_2 IN VARCHAR2 := '',
					pKey_3 IN VARCHAR2 := '',
					pKey_4 IN VARCHAR2 := '',					
					pKeywordValuePairs IN VARCHAR2 := '') RETURN NUMBER IS
	BEGIN
		ROLLBACK;
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => pSqlFunction,
						pTableName  => pTableName),
				pData_line_no => pErrorLocation,
				pData_line    => 'amd_inventory',
				pKey_1 => pKey_1,
				pKey_2 => pKey_2,
				pKey_3 => pKey_3,
				pKey_4 => pKey_4,
				pKey_5 => 'rc=' || TO_CHAR(pReturn_code) ||
					       ' ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ||
						   ' ' || pKeywordValuePairs,
				pComments => pSqlFunction || '/' || pTableName || ' sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')');
		COMMIT;
		RETURN pReturn_code;
	END ErrorMsg;
	

	PROCEDURE LoadGoldInventory IS

		nsnDashed      VARCHAR2(16);
		orderSid       NUMBER;

		pn          VARCHAR2(50);
		loc_sid     NUMBER;
		inv_date    DATE;
		invQty      NUMBER;

		result NUMBER ;
		cntOnHandInvs NUMBER := 0 ;
		cntInRepair   NUMBER := 0 ;
		cntOnOrder NUMBER := 0 ;
		cntInTransits NUMBER := 0 ;
		cntlnRsp  NUMBER := 0;
		
	
	
	BEGIN

		dbms_output.put_line('loadGoldInventory started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;

		loadOnHandInvs ;
		SELECT COUNT(*) INTO cntOnHandInvs FROM TMP_AMD_ON_HAND_INVS ;

		loadInRepair ;
		SELECT COUNT(*) INTO cntInRepair FROM TMP_AMD_IN_REPAIR ;

		loadOnOrder ;
		SELECT COUNT(*) INTO cntOnOrder FROM TMP_AMD_ON_ORDER ;
		
		loadInTransits ;
		SELECT COUNT(*) INTO cntInTransits FROM TMP_AMD_IN_TRANSITS ;
		
		loadRsp;
		SELECT COUNT(*) INTO cntlnRsp FROM TMP_AMD_RSP ;			

		dbms_output.put_line('loadGoldInventory ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ) ;
		dbms_output.put_line('cntOnHandInvs=' || cntOnHandInvs) ;
		dbms_output.put_line('cntInRepair=' || cntInRepair) ;
		dbms_output.put_line('cntOnOrder=' || cntOnOrder) ;
		dbms_output.put_line('cntInTransits=' || cntInTransits) ;
		dbms_output.put_line('cntInRsp=' || cntlnRsp) ;
		
		infoMsg(sqlFunction => 'end of proc',
			tableName => 'tmp_amd_spare_parts',
			pErrorLocation => 10, 
			key1 => TO_CHAR(cntOnHandInvs),
			key2 => TO_CHAR(cntInRepair),
			key3 => TO_CHAR(cntOnOrder),
			key4 => TO_CHAR(cntInTransits),
			key5 => TO_CHAR(cntlnRsp)) ;
			
	EXCEPTION
		 WHEN OTHERS THEN 
					ErrorMsg(sqlFunction => 'loadGoldInventory',
						tableName => 'inventory tables',
						pErrorLocation => 20) ; 
					dbms_output.put_line('loadGoldIntentory had an error - check amd_load_details. cntOnHandInvs=' || cntOnHandInvs || ' cntInRepair=' || cntInRepair || ' cntInTransits=' || cntInTransits) ;
				RAISE ;
	END LoadGoldInventory;
	

	PROCEDURE loadOnOrder IS
		-- Type 3 Wholesale
			   		  			
		CURSOR itemType3aCur IS
		SELECT 
	   		   RTRIM(asp.part_no) part_no,
	  		    DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid) loc_sid,
	   			invQ.inv_date inv_date,
	  			SUM(invQ.inv_qty) inv_qty,
	  			invQ.order_no order_no,
				TRUNC(invQ.receipt_date) receipt_date	  
		FROM (				
			 /*SELECT
				   RTRIM(o.part) part_no,
				   SUBSTR(sc,8,6) loc_id,
				   TRUNC(o.created_datetime) inv_date,
				   NVL(o.qty_due,0) inv_qty,
				   RTRIM(o.order_no) order_no,
				   DECODE(ecd, NULL, need_date, ecd) receipt_date
			FROM
				   ORD1 o
			WHERE
				   o.status = 'O'
				   AND o.order_type = 'M'
			UNION ALL */
			SELECT
				  RTRIM(part) part_no,
				  SUBSTR(sc,8,6) loc_id,
				  TRUNC(o.created_datetime) inv_date,
				  NVL(o.qty_due,0) inv_qty,
				  RTRIM(o.order_no) order_no,
				  DECODE(o.ecd, NULL, o.need_date, o.ecd) receipt_date
			FROM
				  ORD1 o
			WHERE
				   o.status = 'O'
				   AND o.order_type = 'C'
				   AND SUBSTR(o.order_no,1,2) IN ('FC','BA','AM','RS','SE','BR','BN','LB')) invQ,
			    AMD_SPARE_NETWORKS  asn,
				AMD_SPARE_PARTS  asp,
				AMD_SPARE_NETWORKS  asnLink
		WHERE
	 		 RTRIM(asp.part_no) = invQ.part_no
			 AND asn.loc_id = invQ.loc_id
			 AND asp.action_code != 'D'
			 AND asn.mob = asnLink.loc_id(+)
		GROUP BY 
	  	 	RTRIM(asp.part_no),
			DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid),
			invQ.inv_date,
			invQ.order_no,
			TRUNC(invQ.receipt_date);
						   
				   
			CURSOR itemType3bCur IS	   
			SELECT 
				  RTRIM(i.part) part_no,
				  DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid) loc_sid,
				  TRUNC(i.created_datetime) inv_date,
				  SUM(i.qty) inv_qty,
				  RTRIM(i.receipt_order_no) order_no,
				  DECODE(TRUNC(o.ecd), NULL, SYSDATE, TRUNC(o.ecd))  receipt_date
			FROM
				  ITEM i,
				  ORD1 o,
				  AMD_SPARE_NETWORKS  asn,
				  AMD_SPARE_PARTS  asp,
				  AMD_SPARE_NETWORKS asnLink
			WHERE
				  RTRIM(i.receipt_order_no) = RTRIM(o.order_no)
				  AND i.condition = 'B170-ATL' 
				  AND RTRIM(asp.part_no) = RTRIM(i.part)
			      AND asn.loc_id = SUBSTR(i.sc,8,6) 
			      AND asp.action_code != 'D'
				  AND asn.mob = asnLink.loc_id(+)
		    GROUP BY 
				  RTRIM(i.part),
				  DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid),
				  TRUNC(i.created_datetime),
				  RTRIM(i.receipt_order_no),
				  DECODE(TRUNC(o.ecd), NULL, SYSDATE, TRUNC(o.ecd));
				  
			
			CURSOR itemType3cCur IS
			SELECT
				 RTRIM(from_part) part_no,
				 DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid) loc_sid,
				 TRUNC(from_datetime) inv_date,
				 SUM(qty_due) inv_qty,
				 RTRIM(temp_out_id) order_no,
				DECODE(est_return_date, NULL, NULL,est_return_date) receipt_date            
			FROM
				 TMP1,
				 AMD_SPARE_NETWORKS  asn,
				 AMD_SPARE_PARTS  asp,
				 AMD_SPARE_NETWORKS asnLink
			WHERE
				  returned_voucher IS NULL
				  AND status = 'O'
				  AND tcn = 'LNI'
	 			  AND  RTRIM(asp.part_no) = RTRIM(from_part)
			 	  AND asn.loc_id = SUBSTR(from_sc,8,6)
			 	  AND asp.action_code != 'D'
				  AND asn.mob = asnLink.loc_id(+)
		GROUP BY 
	  	 	RTRIM(from_part),
			DECODE(asn.loc_type,'TMP',asnLink.loc_sid,asn.loc_sid),
			TRUNC(from_datetime),
			RTRIM(temp_out_id),
			est_return_date; 
			
		cntOnOrdera	  NUMBER := 0 ;
		cntOnOrderb	  NUMBER := 0;
		cntOnOrderc   NUMBER := 0;
		
	BEGIN
		dbms_output.put_line('loadOnOrder started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ) ;
		EXECUTE IMMEDIATE 'truncate table TMP_AMD_ON_ORDER' ;
		EXECUTE IMMEDIATE 'truncate table TMP_A2A_ORDER_INFO_LINE' ;
		EXECUTE IMMEDIATE 'truncate table tmp_a2a_order_info' ;
		
		<<type3aWholeSale>>
		FOR iRec3a IN itemType3aCur LOOP

			IF (iRec3a.inv_date IS NULL) THEN
				Amd_Utils.InsertErrorMsg(pLoad_no => Amd_Utils.GetLoadNo('GOLD/RAMP/ITEM','AMD_SPARE_INVS'),pKey_1 => iRec3a.part_no,pKey_2 => iRec3a.loc_sid,
						pKey_3 => 'GOLD/SPAREINV',
						pKey_4 => 'No inventory date found' );
			ELSE

				IF iRec3a.inv_qty > 0 THEN

				<<Type_3a>>
				BEGIN
					INSERT INTO TMP_AMD_ON_ORDER
					(
						part_no,
						loc_sid,
						order_date,
						order_qty,
						gold_order_number,
						action_code,
						last_update_dt,
						sched_receipt_date
					)
					VALUES
					(
						iRec3a.part_no,
						iRec3a.loc_sid,
						iRec3a.inv_date,
						iRec3a.inv_qty,
						iRec3a.order_no,
						Amd_Defaults.INSERT_ACTION,
						SYSDATE,
						iRec3a.receipt_date
					);
					cntOnOrdera := cntOnOrdera + 1 ;
				EXCEPTION
					WHEN DUP_VAL_ON_INDEX THEN
						DECLARE
							   result NUMBER := 0 ;
						BEGIN
							result := ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'tmp_amd_on_order',
									pErrorLocation => 30, 
									pReturn_code => FAILURE,
									pKey_1 => iRec3a.part_no,
									pKey_2 => iRec3a.loc_sid,
									pKey_3 => iRec3a.inv_date,
									pKey_4 => iRec3a.order_no,
									pKeywordValuePairs => 'inv_qty=' || iRec3a.inv_qty) ;
						END ;
						RAISE ;
				END Type_3a;			
			END IF;
			END IF;
		END LOOP type3aWholeSale; 
	
		<<type3bWholesale>>
		FOR iRec3b IN itemType3bCur LOOP

			IF (iRec3b.inv_date IS NULL) THEN
				Amd_Utils.InsertErrorMsg(pLoad_no => Amd_Utils.GetLoadNo('GOLD/RAMP/ITEM','AMD_SPARE_INVS'),pKey_1 => iRec3b.part_no,pKey_2 => iRec3b.loc_sid,
						pKey_3 => 'GOLD/SPAREINV',
						pKey_4 => 'No inventory date found' );
			ELSE
             
				IF iRec3b.inv_qty > 0 THEN
				<<Type_3b>>
				BEGIN
					INSERT INTO TMP_AMD_ON_ORDER
					(
						part_no,
						loc_sid,
						order_date,
						order_qty,
						gold_order_number,
						action_code,
						last_update_dt,
						sched_receipt_date
					)
					VALUES
					(
						iRec3b.part_no,
						iRec3b.loc_sid,
						iRec3b.inv_date,
						iRec3b.inv_qty,
						iRec3b.order_no,
						Amd_Defaults.INSERT_ACTION,
						SYSDATE,
						iRec3b.receipt_date
					);
					cntOnOrderb := cntOnOrderb + 1 ;
				EXCEPTION
					WHEN DUP_VAL_ON_INDEX THEN
						DECLARE
							   result NUMBER := 0 ;
						BEGIN
							result := ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'tmp_amd_on_order',
									pErrorLocation => 40, 
									pReturn_code => FAILURE,
									pKey_1 => iRec3b.part_no,
									pKey_2 => iRec3b.loc_sid,
									pKey_3 => iRec3b.inv_date,
									pKey_4 => iRec3b.order_no,
									pKeywordValuePairs => 'inv_qty=' || iRec3b.inv_qty) ;
						END ;
						RAISE ;
				END Type_3b;			
				END IF;
			END IF;
		END LOOP type3bWholeSale;
		
		<<type3cWholeSale>>
		FOR iRec3c IN itemType3cCur LOOP

			IF (iRec3c.inv_date IS NULL) THEN
				Amd_Utils.InsertErrorMsg(pLoad_no => Amd_Utils.GetLoadNo('GOLD/RAMP/ITEM','AMD_SPARE_INVS'),pKey_1 => iRec3c.part_no,pKey_2 => iRec3c.loc_sid,
						pKey_3 => 'GOLD/SPAREINV',
						pKey_4 => 'No inventory date found' );
			ELSE

				IF iRec3c.inv_qty > 0 THEN
				<<Type_3c>>
				BEGIN
					INSERT INTO TMP_AMD_ON_ORDER
					(
						part_no,
						loc_sid,
						order_date,
						order_qty,
						gold_order_number,
						action_code,
						last_update_dt,
						sched_receipt_date
					)
					VALUES
					(
						iRec3c.part_no,
						iRec3c.loc_sid,
						iRec3c.inv_date,
						iRec3c.inv_qty,
						iRec3c.order_no,
						Amd_Defaults.INSERT_ACTION,
						SYSDATE,
						iRec3c.receipt_date
					);
					cntOnOrderc := cntOnOrderc + 1 ;
				EXCEPTION
					WHEN DUP_VAL_ON_INDEX THEN
						DECLARE
							   result NUMBER := 0 ;
						BEGIN
							result := ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'tmp_amd_on_order',
									pErrorLocation => 50, 
									pReturn_code => FAILURE,
									pKey_1 => iRec3c.part_no,
									pKey_2 => iRec3c.loc_sid,
									pKey_3 => iRec3c.inv_date,
									pKey_4 => iRec3c.order_no,
									pKeywordValuePairs => 'inv_qty=' || iRec3c.inv_qty) ;
						END ;
						RAISE ;
				END Type_3c;			
				END IF;
			END IF;
		END LOOP type3cWholeSale;  

		dbms_output.put_line('loadOnOrder ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ) ;	
		dbms_output.put_line('cntOnOrdera=' || cntOnOrdera) ;
		
	END loadOnOrder ;
	
	
	
	PROCEDURE loadInTransits IS
	BEGIN
		
		dbms_output.put_line('loadInTransits started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ) ;
		EXECUTE IMMEDIATE 'truncate table TMP_AMD_IN_TRANSITS' ; 
		EXECUTE IMMEDIATE 'truncate table TMP_A2A_IN_TRANSITS' ;
		
		-- Populate data into table amd_in_transits
		<<insertInTransits1>>
		BEGIN 
			INSERT INTO TMP_AMD_IN_TRANSITS
			(
				   to_loc_sid,
				   quantity,
				   action_code,
				   last_update_dt,
				   document_id,
				   part_no,
				   from_location,
				   in_transit_date,
				   serviceable_flag
			)
			SELECT 
				   loc_sid,
				   (NVL(m.ship_qty,0) - NVL(m.receipt_qty,0)) quantity,
				   'A',
				   SYSDATE,
				   m.document_id,
				   RTRIM(m.part),
				   m.in_tran_from,
				   TO_DATE(m.create_date),
				   DECODE(m.mils_condition,'A','Y','B','Y','C','Y','D','Y','N') mils_condition
			FROM
				MLIT m,
				AMD_SPARE_NETWORKS a
			WHERE
				 (NVL(m.ship_qty,0) - NVL(m.receipt_qty,0)) > 0 
				 AND m.in_tran_to NOT LIKE 'FE%'
				 AND (DECODE(m.in_tran_to,'FD2090','CTLATL','FB' || SUBSTR(in_tran_to,3)) = a.loc_id
				 OR DECODE(m.in_tran_to,'EY3571','CODALT','FB' || SUBSTR(in_tran_to,3)) = a.loc_id
				 OR DECODE(m.in_tran_to,'EY7739','CODCHS','FB' || SUBSTR(in_tran_to,3)) = a.loc_id
				 OR DECODE(m.in_tran_to,'EY8388','CODMCD','FB' || SUBSTR(in_tran_to,3)) = a.loc_id);
			COMMIT;
		END insertInTransits1 ;
		
		<<insertInTransits2>>
		BEGIN
			 INSERT INTO TMP_AMD_IN_TRANSITS
			 (
			  		to_loc_sid,
					quantity,
					action_code,
					last_update_dt,
					document_id,
					part_no,
					from_location,
					in_transit_date,
					serviceable_flag
			)
			SELECT
				  a.loc_sid,
				  i.qty,
				  'A',
				  SYSDATE,
				  i.item_id,
				  RTRIM(i.part),
				  SUBSTR(i.sc,8,6),
				  r.created_docdate,
				  i.status_servicable
			FROM
				ITEM i, RSV1 r, AMD_SPARE_NETWORKS a
				WHERE i.status_3 = 'I'
				AND i.condition != 'B170-ATL'
				AND i.status_servicable = 'Y'
				AND i.status_new_order = 'N'
				AND i.status_accountable = 'Y'
				AND i.status_active = 'Y'
				AND i.status_mai = 'N'
				AND NOT EXISTS (SELECT 1 FROM ITEM i2 
								    WHERE i2.status_avail = 'N' 
									AND   i2.receipt_order_no IS NULL
									AND   i2.item_id = i.item_id)
				AND r.status = 'O'
				AND i.item_id = r.item_id
				AND SUBSTR(r.to_sc,8,6) = a.loc_id
				AND i.qty IS NOT NULL;			
			COMMIT;
		END insertInTransits2 ;
		
		<<insertInTransits3>>
		BEGIN
			 INSERT INTO TMP_AMD_IN_TRANSITS
			 (
			  		to_loc_sid,
					quantity,
					action_code,
					last_update_dt,
					document_id,
					part_no,
					from_location,
					in_transit_date,
					serviceable_flag
			)
			SELECT
				  a.loc_sid,
				  i.qty,
				  'A',
				  SYSDATE,
				  i.item_id,
				  RTRIM(i.part),
				  SUBSTR(i.sc,8,6),
				  r.created_docdate,
				  i.status_servicable
			FROM
				ITEM i, RSV1 r, AMD_SPARE_NETWORKS a
				WHERE i.status_3 = 'I'
				AND i.condition != 'B170-ATL'
				AND i.status_servicable = 'N'
				AND i.status_new_order = 'N'
				AND i.status_accountable = 'Y'
				AND i.status_active = 'Y'
				AND i.status_mai = 'N'
				AND r.status = 'O'
				AND i.item_id = r.item_id
				AND SUBSTR(r.to_sc,8,6) = a.loc_id
				AND i.qty IS NOT NULL;			
			COMMIT;
		END insertInTransits3;

		dbms_output.put_line('loadInTransits ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ) ;
	END loadInTransits ;
	
	
	PROCEDURE loadRsp IS
			  nsnDashed					VARCHAR2(16) := NULL;
			  RspQty  						 NUMBER := 0;
			  RspLevel					   NUMBER := 0;
			  cntRsp						  NUMBER := 0;
			  cntType1						  NUMBER := 0;
			  cntType2						  NUMBER := 0;
			  result						  NUMBER := 0;
			  
	
	BEGIN
		
		dbms_output.put_line('loadRsp started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ) ;
		EXECUTE IMMEDIATE 'truncate table TMP_AMD_RSP' ; 
		Amd_Batch_Pkg.truncateIfOld('tmp_a2a_loc_part_override') ;
		COMMIT;
		
		
		
		-- Populate data into table tmp_amd_rsp
		   FOR rec IN partCur LOOP
		   
		   	   	   nsnDashed := Amd_Utils.FormatNsn(rec.nsn, 'GOLD');
				   
				   --
				   -- For each part, extract inventory data from ramp and item tables.
				   --
				   FOR rRec IN rampCur (nsnDashed) LOOP
				   	   		RspQty := rRec.spram_balance + rRec.hpmsk_balance + rRec.wrm_balance + rRec.total_inaccessible_qty;
				 	   		RspLevel := rRec.spram_level+ rRec.wrm_level + rRec.hpmsk_level_qty ;
				 
				 IF RspQty > 0 THEN
				 <<insertRsp>>
				 			  BEGIN 
							  		INSERT INTO TMP_AMD_RSP
									(
									 	   part_no,
										   loc_sid,
										   rsp_inv,
										   rsp_level,
										   action_code,
										   last_update_dt
									)
									VALUES
									(
									 	  rec.part_no,
										  rRec.loc_sid,
										  RspQty,
										  RspLevel,
										  Amd_Defaults.INSERT_ACTION,
										  SYSDATE
									);
									cntType1 := cntType1 + 1;
									cntRsp := cntRsp + 1;
							EXCEPTION
									 	   WHEN	DUP_VAL_ON_INDEX THEN
										   result := ErrorMsg(pSqlFunction => 'insert',
										   		  	 						pTableName => 'tmp_amd_rsp',
																			pErrorLocation => 60,
																			pReturn_code => FAILURE,
																			pKey_1 => rec.part_no,
																			pKey_2 => rRec.loc_sid,
																			pKey_3 => nsnDashed);
											RAISE;
									END TYPE_1;
						END IF ;
					END LOOP;
			END LOOP f77PartLoop;
			
	FOR rec IN partCur LOOP
		
				nsnDashed := Amd_Utils.FormatNsn(rec.nsn, 'GOLD');
				<<rspUABRampLoop>>
				FOR uRec IN rampCurFB(nsnDashed) LOOP
				
							RspQty := uRec.spram_balance + uRec.hpmsk_balance + uRec.wrm_balance + uRec.total_inaccessible_qty ;
				 	   		RspLevel := uRec.spram_level+ uRec.wrm_level + uRec.hpmsk_level_qty ;
							
							IF RspQty > 0 OR RspLevel > 0 THEN
							   BEGIN
							   		  	INSERT INTO TMP_AMD_RSP
											   (
											   		part_no, 
													loc_sid,
										   			rsp_inv,
										  			rsp_level,
										   			action_code,
										   			last_update_dt
												)
												VALUES
												(
									 	 		 	  rec.part_no,
													  uRec.loc_sid,
										  			  RspQty,
										 			  RspLevel,
										  			   Amd_Defaults.INSERT_ACTION,
										 			    SYSDATE
									);
									cntType2 := cntType2 + 1;
									cntRsp := cntRsp + 1;
							EXCEPTION
									 	   WHEN	DUP_VAL_ON_INDEX THEN
										   result := ErrorMsg(pSqlFunction => 'insert',
										   		  	 						pTableName => 'tmp_amd_rsp',
																			pErrorLocation => 70,
																			pReturn_code => FAILURE,
																			pKey_1 => rec.part_no,
																			pKey_2 => uRec.loc_sid,
																			pKey_3 => nsnDashed);
											RAISE;
								END Type_2;
							END IF;
						END LOOP rspUABRampLoop;
				END LOOP f77PartLoop; 
			
	END loadRsp;
										  
	
	FUNCTION getSiteLocation(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN
			 AMD_SPARE_NETWORKS.loc_id%TYPE IS
			 
			 loc_id AMD_SPARE_NETWORKS.loc_id%TYPE ;
			 result NUMBER ;
	BEGIN
		SELECT loc_id INTO loc_id 
		FROM AMD_SPARE_NETWORKS
		WHERE loc_sid = getSiteLocation.loc_sid ;
		
		RETURN loc_id ;
	EXCEPTION WHEN OTHERS THEN
		result := ErrorMsg(pSqlFunction => 'select',
		pTableName => 'amd_spare_networks',
		pErrorLocation => 80 , 
		pReturn_code => FAILURE,
		pKey_1 => 'loc_sid') ;
		RAISE ;
	END getSiteLocation ;
	
	
	FUNCTION doRepairInvsSumDiff(
			 part_no IN VARCHAR2, 
			 site_location IN VARCHAR2,
			 qty_on_hand IN NUMBER, 
			 action_code IN VARCHAR2) RETURN NUMBER IS

		badActionCode EXCEPTION ;
		
		FUNCTION InsertRow RETURN NUMBER IS
	
		BEGIN
		  	<<insertAmdRepairInvsSums>> 
			DECLARE
				   PROCEDURE doUpdate IS
				   BEGIN
				   		<<getActionCode>>
						DECLARE
							   action_code AMD_IN_REPAIR.action_code%TYPE ;
							   badInsert EXCEPTION ;
						BEGIN
							 SELECT action_code 
							 INTO action_code 
							 FROM AMD_REPAIR_INVS_SUM 
							 WHERE part_no = doRepairInvsSumDiff.part_no 
							 AND site_location = doRepairInvsSumDiff.site_location ;
							 
							 IF action_code != Amd_Defaults.DELETE_ACTION THEN
							 	RAISE badInsert ;
							 END IF ;
						EXCEPTION WHEN OTHERS THEN
							errorMsg(SqlFunction => 'select',
										TableName => 'amd_repair_invs_sum',
										pErrorLocation => 90, 
										key1 => doRepairInvsSumDiff.part_no,
										key2 => doRepairInvsSumDiff.site_location);
						
						END getActionCode ;
						UPDATE AMD_REPAIR_INVS_SUM
						SET qty_on_hand = doRepairInvsSumDiff.qty_on_hand,
						action_code = Amd_Defaults.INSERT_ACTION,
						last_update_dt = SYSDATE
						WHERE part_no = doRepairInvsSumDiff.part_no AND site_location = doRepairInvsSumDiff.site_location ;
				   END doUpdate ;
			BEGIN
				 INSERT INTO AMD_REPAIR_INVS_SUM
				(
					part_no,
					site_location,
					qty_on_hand,
					action_code,
					last_update_dt
				)
				VALUES
				(
				    part_no,
					site_location,
					qty_on_hand,
					Amd_Defaults.INSERT_ACTION,
					SYSDATE
				);
				
				EXCEPTION
						WHEN standard.DUP_VAL_ON_INDEX THEN
							 doUpdate ;
						WHEN OTHERS THEN
							RETURN ErrorMsg(pSqlFunction => 'insert',
										pTableName => 'amd_repair_invs_sum',
										pErrorLocation => 100, 
										pReturn_code => FAILURE,
										pKey_1 => part_no,
										pKey_2 => site_location ) ;
		     END insertAmdRepairInvs ;
			 
			A2a_Pkg.insertRepairInvInfo(part_no, site_location, qty_on_hand, Amd_Defaults.INSERT_ACTION);
			 
			 RETURN SUCCESS;
		END InsertRow ;
		
		FUNCTION UpdateRow RETURN NUMBER IS
			-- get the detail for the summarized inv_qty
			result NUMBER ;
			 
		BEGIN
			<<updateAmdRepairInvs>> 
			BEGIN
				UPDATE AMD_REPAIR_INVS_SUM SET
		            qty_on_hand 	   = doRepairInvsSumDiff.qty_on_hand,
					action_code    = Amd_Defaults.UPDATE_ACTION,
					last_update_dt = SYSDATE
				WHERE part_no  = doRepairInvsSumDiff.part_no
				      AND site_location  = doRepairInvsSumDiff.site_location ;
				EXCEPTION
						WHEN OTHERS THEN
							RETURN ErrorMsg(pSqlFunction => 'update',
										pTableName => 'amd_repair_invs_sum',
										pErrorLocation => 110, 
										pReturn_code => FAILURE,
										pKey_1 => part_no,
										pKey_2 => site_location) ;
			END updateAmdRepairInvs ;
			
			
			A2a_Pkg.insertRepairInvInfo(part_no,site_location,qty_on_hand, Amd_Defaults.UPDATE_ACTION) ;
			RETURN SUCCESS;
	
		END UpdateRow ;
	
		FUNCTION DeleteRow RETURN NUMBER IS
		BEGIN
		     
			<<updateAmdRepairInvs>> -- logically delete all records for the part_no and loc_sid
			BEGIN
			 UPDATE AMD_REPAIR_INVS_SUM SET
				action_code    = Amd_Defaults.DELETE_ACTION,
				last_update_dt = SYSDATE
			WHERE    part_no  = doRepairInvsSumDiff.part_no
				 AND site_location  = doRepairInvsSumDiff.site_location ;
			
			
			EXCEPTION
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'update',
									pTableName => 'amd_repair_invs_sum',
									pErrorLocation => 120, 
									pReturn_code => FAILURE,
									pKey_1 => part_no,
									pKey_2 => site_location) ;
			 END updateAmdRepairInvs;
			 
			
			A2a_Pkg.insertRepairInvInfo(part_no, site_location,0, Amd_Defaults.DELETE_ACTION) ;
			RETURN SUCCESS;
			
		END DeleteRow ;
	BEGIN
		 IF action_code = Amd_Defaults.INSERT_ACTION THEN
		 	RETURN insertRow ;
		ELSIF action_code = Amd_Defaults.UPDATE_ACTION THEN
			RETURN updateRow ;
		ELSIF action_code = Amd_Defaults.DELETE_ACTION THEN
			RETURN deleteRow ;
		ELSE
			errorMsg(action_code,'amd_repair_invs_sum',68,part_no, site_location) ;
			RAISE badActionCode ;
			RETURN FAILURE ;
		END IF ;
	END doRepairInvsSumDiff ;
		
	
	/* amd_in_repair diff functions */
	FUNCTION InsertRow(
							PART_NO             IN VARCHAR2,
  							LOC_SID             IN NUMBER,
							REPAIR_DATE		  IN DATE,
  							REPAIR_QTY          IN NUMBER,
  							ORDER_NO		  IN VARCHAR2,
							REPAIR_NEED_DATE  IN DATE) RETURN NUMBER IS
			
	BEGIN
		 <<insertAmdInRepair>>
		 DECLARE
		 		PROCEDURE doUpdate IS
				BEGIN
					 <<getActionCode>>
					 DECLARE
					 		action_code AMD_IN_REPAIR.action_code%TYPE ;
							badInsert EXCEPTION ;
					 BEGIN
					 	  SELECT action_code 
						  INTO action_code 
						  FROM AMD_IN_REPAIR 
						  WHERE part_no = insertRow.part_no 
						  AND loc_sid = insertRow.loc_sid 
						  AND order_no = insertRow.order_no ;
						  IF action_code != Amd_Defaults.DELETE_ACTION THEN
						  	 RAISE badInsert ;
						  END IF ;
					 EXCEPTION WHEN OTHERS THEN 
						errorMsg(sqlFunction => 'select',
							     tableName => 'amd_in_repair',
								 pErrorLocation => 130, 
								 key1 => part_no,
								 key2 => loc_sid,
								 key3 => order_no);
					 END getActionCode ;
					 
					 UPDATE AMD_IN_REPAIR
					 SET
					 		     part_no = insertRow.part_no,
					 			 loc_sid = insertRow.loc_sid, 
					  			repair_date = insertRow.repair_date,
					 			repair_qty = insertRow.repair_qty,
					 			order_no= insertRow.order_no,
					 			repair_need_date = insertRow.repair_need_date,
								 action_code = Amd_Defaults.INSERT_ACTION,
								  last_update_dt = SYSDATE
					 WHERE part_no = insertRow.part_no 
					 AND loc_sid = insertRow.loc_sid 
					 AND order_no = insertRow.order_no ;
				END doUpdate ;
		 BEGIN
			 INSERT INTO AMD_IN_REPAIR
			(
				part_no,
				loc_sid,
				repair_date,
				repair_qty,
				order_no,
				repair_need_date,
				action_code,
				last_update_dt
			)
			VALUES
			(
				part_no,
				loc_sid,
				repair_date,
				repair_qty,
				order_no,
				repair_need_date,
				Amd_Defaults.INSERT_ACTION,
				SYSDATE
			);
			
			EXCEPTION
					WHEN standard.DUP_VAL_ON_INDEX THEN
						 doUpdate ;
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'amd_in_repair',
									pErrorLocation => 140, 
									pReturn_code => FAILURE,
									pKey_1 => part_no,
									pKey_2 => loc_sid,
									pKey_3 => order_no);
	     END insertAmdInRepair ;
		 
		 A2a_Pkg.insertRepairInfo(part_no,loc_sid,order_no,repair_date,A2a_Pkg.OPEN_STATUS,repair_qty,
              repair_need_date, Amd_Defaults.INSERT_ACTION) ;		 																							
		 
		 RETURN SUCCESS;
	END InsertRow ;

	FUNCTION UpdateRow(
							PART_NO             IN VARCHAR2,
  							LOC_SID             IN NUMBER,
							REPAIR_DATE		  IN DATE,
							REPAIR_QTY		  IN NUMBER,
  							ORDER_NO		  IN VARCHAR2,
							REPAIR_NEED_DATE  IN DATE) RETURN NUMBER IS
	BEGIN
		<<updateAmdInRepair>>  
		BEGIN
			UPDATE AMD_IN_REPAIR SET
					repair_date		=	UpdateRow.repair_date,
					repair_qty 		= 	UpdateRow.repair_qty,
					repair_need_date =  UpdateRow.repair_need_date,
					action_code    = Amd_Defaults.UPDATE_ACTION,
					last_update_dt = SYSDATE
			WHERE part_no = part_no
			AND loc_sid = UpdateRow.loc_sid
			AND order_no = UpdateRow.order_no;

			EXCEPTION
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'update',
									pTableName => 'amd_in_repair',
									pErrorLocation => 150, 
									pReturn_code => FAILURE,
									pKey_1 => part_no,
									pKey_2 => loc_sid,
									pKey_3 => order_no);
		END updateAmdInRepair;
		
		 A2a_Pkg.insertRepairInfo(part_no,loc_sid,order_no,repair_date,A2a_Pkg.OPEN_STATUS,repair_qty,
               repair_need_date,Amd_Defaults.UPDATE_ACTION) ;		 																							
		RETURN SUCCESS ;
	END UpdateRow ;

	FUNCTION inRepairDeleteRow(
				 		   			PART_NO	  IN VARCHAR2,
									LOC_SID	  IN NUMBER,
									ORDER_NO  IN VARCHAR2) RETURN NUMBER IS
			repair_qty AMD_IN_REPAIR.repair_qty%TYPE;
			repair_date AMD_IN_REPAIR.repair_date%TYPE;
			repair_need_date AMD_IN_REPAIR. repair_need_date%TYPE ;
	BEGIN
		 <<updateAmdInRepair>>		 
		 BEGIN
			 UPDATE AMD_IN_REPAIR SET
				action_code    = Amd_Defaults.DELETE_ACTION,
				last_update_dt = SYSDATE
			WHERE PART_NO = inRepairDeleteRow.part_no
			AND LOC_SID = inRepairDeleteRow.LOC_SID
			AND ORDER_NO = inRepairDeleteRow.ORDER_NO ;
	
			EXCEPTION
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'update',
									pTableName => 'amd_in_repair',
									pErrorLocation => 160, 
									pReturn_code => FAILURE,
									pKey_1 => part_no,
									pKey_2 => loc_sid,
									pKey_3 => order_no);
		 END updateAmdInRepair;
		 <<selectAmdInRepair>>
		 BEGIN
			SELECT repair_qty, repair_date, repair_need_date  INTO repair_qty, repair_date, repair_need_date
			FROM AMD_IN_REPAIR
			WHERE part_no = inRepairDeleteRow.part_no
			AND loc_sid = inRepairDeleteRow.loc_sid
			AND order_no = inRepairDeleteRow.order_no;
	
			EXCEPTION
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'select',
									pTableName => 'amd_in_repair',
									pErrorLocation => 170, 
									pReturn_code => FAILURE,
									pKey_1 => part_no,
									pKey_2 => loc_sid,
									pKey_3 => order_no);
		 END selectAmdInRepair; 
		 
		 A2a_Pkg.insertRepairInfo(part_no,loc_sid,order_no,repair_date,A2a_Pkg.OPEN_STATUS,repair_qty,
               repair_need_date,Amd_Defaults.DELETE_ACTION) ;		 																							
		RETURN SUCCESS ;
	END inRepairDeleteRow ;


	/* amd_on_order diff functions */
	FUNCTION insertOnOrderRow(
							PART_NO             IN VARCHAR2,
  							LOC_SID             IN NUMBER,
							ORDER_DATE          IN DATE,
  							ORDER_QTY           IN NUMBER,
  							GOLD_ORDER_NUMBER   IN VARCHAR2,
							SCHED_RECEIPT_DATE IN  DATE) RETURN NUMBER IS
	
 		site_location TMP_A2A_ORDER_INFO_LINE.SITE_LOCATION%TYPE := getSiteLocation(loc_sid) ;
		
		PROCEDURE doUpdate IS
		BEGIN
			 <<getActionCode>>
			 DECLARE
				  action_code AMD_ON_ORDER.action_code%TYPE ;
				  badInsert EXCEPTION ;
			 BEGIN
			 	  SELECT action_code INTO action_code FROM AMD_ON_ORDER 
				  WHERE gold_order_number = insertOnOrderRow.gold_order_number
				  AND order_date = insertOnOrderRow.order_date ;
				  
				  IF action_code != Amd_Defaults.DELETE_ACTION THEN
				  	 RAISE badInsert ;
				  END IF ;
			 EXCEPTION
			 		  WHEN OTHERS THEN				
						errorMsg(sqlFunction => 'select',
								 tableName => 'amd_on_order',
								 pErrorLocation => 180,
								 key1 => gold_order_number,
								 key2 => TO_CHAR(order_date,'MM/DD/YYYY')) ;
					  	RAISE ;
			 END getActionCode ;
			 
			 UPDATE AMD_ON_ORDER
				 SET part_no = insertOnOrderRow.part_no,
				 loc_sid = insertOnOrderRow.loc_sid,
				 order_qty = insertOnOrderRow.order_qty,
				 action_code = Amd_Defaults.INSERT_ACTION,
				 last_update_dt = SYSDATE
			 WHERE gold_order_number = insertOnOrderRow.gold_order_number
			 AND order_date = insertOnOrderRow.order_date ;
	    EXCEPTION WHEN OTHERS THEN
				errorMsg(sqlFunction => 'update',
						 tableName => 'amd_on_order',
						 pErrorLocation => 190,
						 key1 => gold_order_number,
						 key2 => TO_CHAR(order_date,'MM/DD/YYYY')) ;
			 
		END doUpdate ;
		
	BEGIN
		 <<insertAmdOnOrder>>
		 BEGIN
			 INSERT INTO AMD_ON_ORDER
			(
				part_no,
				loc_sid,
				order_date,
				order_qty,
				gold_order_number,
				action_code,
				last_update_dt,
				sched_receipt_date
			)
			VALUES
			(
				part_no,
				loc_sid,
				order_date,
				order_qty,
				gold_order_number,
				Amd_Defaults.INSERT_ACTION,
				SYSDATE,
				sched_receipt_date
			);
			
			EXCEPTION
					WHEN standard.DUP_VAL_ON_INDEX THEN
						 doUpdate ;
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'amd_on_order',
									pErrorLocation => 200, 
									pReturn_code => FAILURE,
									pKey_1 => gold_order_number,
									pKey_2 => TO_CHAR(order_date,'MM/DD/YYYY HH:MM:SS'));
	     END insertAmdOnOrder ;
		 
		 A2a_Pkg.insertTmpA2AOrderInfo(insertOnOrderRow.gold_order_number,
			  insertOnOrderRow.loc_sid,
			  insertOnOrderRow.order_date,
			  insertOnOrderRow.part_no,
	 		  insertOnOrderRow.order_qty,
			  insertOnOrderRow.sched_receipt_date,
			  Amd_Defaults.INSERT_ACTION) ;
		 
		 RETURN SUCCESS ;
	END insertOnOrderRow ;

	FUNCTION updateOnOrderRow(
							PART_NO             IN VARCHAR2,
  							LOC_SID             IN NUMBER,
							ORDER_DATE          IN DATE,
  							ORDER_QTY           IN NUMBER,
  							GOLD_ORDER_NUMBER   IN VARCHAR2,
							SCHED_RECEIPT_DATE IN  DATE) RETURN NUMBER IS
							
	   site_location TMP_A2A_ORDER_INFO_LINE.site_location%TYPE := getSiteLocation(loc_sid) ;
	   
	BEGIN
		<<updateAmdOnOrder>> 
		BEGIN
			UPDATE AMD_ON_ORDER SET
				part_no        		= 	UpdateOnOrderRow.part_no,
				loc_sid    			= 	UpdateOnOrderRow.loc_sid,
	            order_qty 			= 	UpdateOnOrderRow.order_qty,
				action_code         = Amd_Defaults.UPDATE_ACTION,
				last_update_dt      = SYSDATE
			WHERE gold_order_number = UpdateOnOrderRow.gold_order_number
			AND order_date = UpdateOnOrderRow.order_date;
	
			EXCEPTION
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'update',
									pTableName => 'amd_on_order',
									pErrorLocation => 210, 
									pReturn_code => FAILURE,
									pKey_1 => UpdateOnOrderRow.gold_order_number,
									pKey_2 => TO_CHAR(UpdateOnOrderRow.order_date,'MM/DD/YYYY HH:MM:SS'));
		END updateAmdOnOrder;
		
		A2a_Pkg.insertTmpA2AOrderInfo(updateOnOrderRow.gold_order_number,
			  updateOnOrderRow.loc_sid,
			  updateOnOrderRow.order_date,
			  updateOnOrderRow.part_no,
	 		  updateOnOrderRow.order_qty,
			  updateOnOrderRow.sched_receipt_date,
			  Amd_Defaults.UPDATE_ACTION) ;

		
		RETURN SUCCESS ;
	END updateOnOrderRow ;

	FUNCTION deleterow(part_no IN VARCHAR2, loc_sid IN NUMBER, gold_order_number IN VARCHAR2, order_date IN DATE) RETURN NUMBER IS
	BEGIN
		 <<updateAmdOnOrder>>
		 BEGIN
			 UPDATE AMD_ON_ORDER SET
				action_code    = Amd_Defaults.DELETE_ACTION,
				last_update_dt = SYSDATE
			WHERE GOLD_ORDER_NUMBER = DeleteRow.gold_order_number
			AND order_date = DeleteRow.order_date ;
	
			EXCEPTION WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'update',
									pTableName => 'amd_on_order',
									pErrorLocation => 220, 
									pReturn_code => FAILURE,
									pKey_1 => gold_order_number,
									pKey_2 => TO_CHAR(order_date,'MM/DD/YYYY HH:MM:SS'));
		 END updateAmdOnOrder;
		
				
		A2a_Pkg.insertTmpA2AOrderInfo(deleteRow.gold_order_number,
			  deleteRow.loc_sid,
			  deleteRow.order_date,
			  deleteRow.part_no,
			  0,
			  SYSDATE,
			  Amd_Defaults.DELETE_ACTION) ;
		
		RETURN SUCCESS ;
	END DeleteRow ;
	
	FUNCTION doOnHandInvsSumDiff(
			 part_no IN VARCHAR2, 
			 spo_location IN VARCHAR2,
			 qty_on_hand IN NUMBER, 
			 action_code IN VARCHAR2) RETURN NUMBER IS

		badActionCode EXCEPTION ;
		
		FUNCTION InsertRow RETURN NUMBER IS
	
		BEGIN
		  	<<insertAmdOnHandInvsSums>> 
			DECLARE
				   PROCEDURE doUpdate IS
				   BEGIN
				   		<<getActionCode>>
						DECLARE
							   action_code AMD_ON_HAND_INVS.action_code%TYPE ;
							   badInsert EXCEPTION ;
						BEGIN
							 SELECT action_code 
							 INTO action_code 
							 FROM AMD_ON_HAND_INVS_SUM 
							 WHERE part_no = doOnHandInvsSumDiff.part_no 
							 AND spo_location = doOnHandInvsSumDiff.spo_location ;
							 
							 IF action_code != Amd_Defaults.DELETE_ACTION THEN
							 	RAISE badInsert ;
							 END IF ;
						EXCEPTION WHEN OTHERS THEN
							errorMsg(SqlFunction => 'select',
										TableName => 'amd_on_hand_invs_sum',
										pErrorLocation => 230, 
										key1 => doOnHandInvsSumDiff.part_no,
										key2 => doOnHandInvsSumDiff.spo_location);
						
						END getActionCode ;
						UPDATE AMD_ON_HAND_INVS_SUM
						SET qty_on_hand = doOnHandInvsSumDiff.qty_on_hand,
						action_code = Amd_Defaults.INSERT_ACTION,
						last_update_dt = SYSDATE
						WHERE part_no = doOnHandInvsSumDiff.part_no 
						AND spo_location = doOnHandInvsSumDiff.spo_location ;
				   END doUpdate ;
			BEGIN
				 INSERT INTO AMD_ON_HAND_INVS_SUM
				(
					part_no,
					spo_location,
					qty_on_hand,
					action_code,
					last_update_dt
				)
				VALUES
				(
				    part_no,
					spo_location,
					qty_on_hand,
					Amd_Defaults.INSERT_ACTION,
					SYSDATE
				);
				
				EXCEPTION
						WHEN standard.DUP_VAL_ON_INDEX THEN
							 doUpdate ;
						WHEN OTHERS THEN
							RETURN ErrorMsg(pSqlFunction => 'insert',
										pTableName => 'amd_on_hand_invs_sum',
										pErrorLocation => 240, 
										pReturn_code => FAILURE,
										pKey_1 => part_no,
										pKey_2 => spo_location ) ;
		     END insertAmdOnHandInvs ;
			 				 
			 A2a_Pkg.insertInvInfo(part_no, spo_location,qty_on_hand, Amd_Defaults.INSERT_ACTION) ;
			 
	         RETURN SUCCESS ;
		END InsertRow ;
	
		FUNCTION UpdateRow RETURN NUMBER IS
			-- get the detail for the summarized inv_qty
			result NUMBER ;
			 
		BEGIN
			<<updateAmdOnHandInvs>> 
			BEGIN
				UPDATE AMD_ON_HAND_INVS_SUM SET
		            qty_on_hand 	   = doOnHandInvsSumDiff.qty_on_hand,
					action_code    = Amd_Defaults.UPDATE_ACTION,
					last_update_dt = SYSDATE
				WHERE part_no  = doOnHandInvsSumDiff.part_no
				      AND spo_location  = doOnHandInvsSumDiff.spo_location ;
				EXCEPTION
						WHEN OTHERS THEN
							RETURN ErrorMsg(pSqlFunction => 'update',
										pTableName => 'amd_on_hand_invs_sum',
										pErrorLocation => 250, 
										pReturn_code => FAILURE,
										pKey_1 => part_no,
										pKey_2 => spo_location) ;
			END updateAmdOnHandInvs ;
			
			
			A2a_Pkg.insertInvInfo(part_no,spo_location,qty_on_hand, Amd_Defaults.UPDATE_ACTION) ;
			RETURN SUCCESS;
	
		END UpdateRow ;
	
		FUNCTION DeleteRow RETURN NUMBER IS
		BEGIN
		     
			<<updateAmdOnHandInvs>> -- logically delete all records for the part_no and loc_sid
			BEGIN
			 UPDATE AMD_ON_HAND_INVS_SUM SET
				action_code    = Amd_Defaults.DELETE_ACTION,
				last_update_dt = SYSDATE
			WHERE    part_no  = doOnHandInvsSumDiff.part_no
				 AND spo_location  = doOnHandInvsSumDiff.spo_location ;
			
			
			EXCEPTION
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'update',
									pTableName => 'amd_on_hand_invs_sum',
									pErrorLocation => 260, 
									pReturn_code => FAILURE,
									pKey_1 => part_no,
									pKey_2 => spo_location) ;
			 END updateAmdOnHandInvs;
			 
			
			A2a_Pkg.insertInvInfo(part_no, spo_location,0, Amd_Defaults.DELETE_ACTION) ;
			RETURN SUCCESS;
			
		END DeleteRow ;
	BEGIN
		 IF action_code = Amd_Defaults.INSERT_ACTION THEN
		 	RETURN insertRow ;
		ELSIF action_code = Amd_Defaults.UPDATE_ACTION THEN
			RETURN updateRow ;
		ELSIF action_code = Amd_Defaults.DELETE_ACTION THEN
			RETURN deleteRow ;
		ELSE
			errorMsg(action_code,'amd_on_hand_invs_sum',330,part_no, spo_location) ;
			RAISE badActionCode ;
			RETURN FAILURE ;
		END IF ;
	END doOnHandInvsSumDiff ;
	
		/* amd_on_hand_invs diff functions */
	FUNCTION InsertRow(
			 		   		 part_no        IN VARCHAR2,
  							 loc_sid        IN NUMBER,
  							 inv_qty        IN NUMBER) RETURN NUMBER IS
		

	BEGIN
	  	<<insertAmdOnHandInvs>> 
		DECLARE
			   PROCEDURE doUpdate IS
			   BEGIN
			   		<<getActionCode>>
					DECLARE
						   action_code AMD_ON_HAND_INVS.action_code%TYPE ;
						   badInsert EXCEPTION ;
					BEGIN
						 SELECT action_code INTO action_code FROM AMD_ON_HAND_INVS WHERE part_no = insertRow.part_no AND loc_sid = insertRow.loc_sid ;
						 IF action_code != Amd_Defaults.DELETE_ACTION THEN
						 	RAISE badInsert ;
						 END IF ;
					EXCEPTION WHEN OTHERS THEN
						errorMsg(SqlFunction => 'select',
									TableName => 'amd_on_hand_invs',
									pErrorLocation => 270, 
									key1 => insertRow.part_no,
									key2 => insertRow.loc_sid);
					
					END getActionCode ;
					UPDATE AMD_ON_HAND_INVS
					SET inv_qty = insertRow.inv_qty,
					action_code = Amd_Defaults.INSERT_ACTION,
					last_update_dt = SYSDATE
					WHERE part_no = insertRow.part_no AND loc_sid = insertRow.loc_sid ;
			   END doUpdate ;
		BEGIN
			 INSERT INTO AMD_ON_HAND_INVS
			(
				part_no,
				loc_sid,
				inv_qty,
				action_code,
				last_update_dt
			)
			VALUES
			(
			    part_no,
				InsertRow.loc_sid,
				inv_qty,
				Amd_Defaults.INSERT_ACTION,
				SYSDATE
			);
			
			EXCEPTION
					WHEN standard.DUP_VAL_ON_INDEX THEN
						 doUpdate ;
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'amd_on_hand_invs',
									pErrorLocation => 280, 
									pReturn_code => FAILURE,
									pKey_1 => part_no,
									pKey_2 => TO_CHAR(InsertRow.loc_sid) ) ;
	     END insertAmdOnHandInvs ;
		 				 
		 
         RETURN SUCCESS ;
	END InsertRow ;

	FUNCTION UpdateRow(
			 		   		 part_no         IN VARCHAR2,
  							 loc_sid         IN NUMBER,
  							 inv_qty         IN NUMBER) RETURN NUMBER IS                       
		-- get the detail for the summarized inv_qty
		result NUMBER ;
		 
	BEGIN
		<<updateAmdOnHandInvs>> 
		BEGIN
			UPDATE AMD_ON_HAND_INVS SET
	            inv_qty 	   = UpdateRow.inv_qty,
				action_code    = Amd_Defaults.UPDATE_ACTION,
				last_update_dt = SYSDATE
			WHERE part_no  = UpdateRow.part_no
			      AND loc_sid  = UpdateRow.loc_sid ;
			EXCEPTION
					WHEN OTHERS THEN
						RETURN ErrorMsg(pSqlFunction => 'update',
									pTableName => 'amd_on_hand_invs',
									pErrorLocation => 290, 
									pReturn_code => FAILURE,
									pKey_1 => part_no,
									pKey_2 => TO_CHAR(loc_sid)) ;
		END updateAmdOnHandInvs ;
		
		
		RETURN SUCCESS;

	END UpdateRow ;

	FUNCTION DeleteRow(
			 		   		 part_no         IN VARCHAR2,
  							 loc_sid         IN NUMBER) RETURN NUMBER IS
	BEGIN
	     
		<<updateAmdOnHandInvs>> -- logically delete all records for the part_no and loc_sid
		BEGIN
		 UPDATE AMD_ON_HAND_INVS SET
			action_code    = Amd_Defaults.DELETE_ACTION,
			last_update_dt = SYSDATE
		WHERE    part_no  = DeleteRow.part_no
			 AND loc_sid  = DeleteRow.loc_sid ;
		
		
		EXCEPTION
				WHEN OTHERS THEN
					RETURN ErrorMsg(pSqlFunction => 'update',
								pTableName => 'amd_on_hand_invs',
								pErrorLocation => 300, 
								pReturn_code => FAILURE,
								pKey_1 => part_no,
								pKey_2 => TO_CHAR(loc_sid)) ;
		 END updateAmdOnHandInvs;
		 
		
		RETURN SUCCESS;
		
	END DeleteRow ;	
	
	/*amd_rsp diff functions */
	
	FUNCTION RspInsertRow(		 
			 				   	 	part_no		IN VARCHAR2,
									loc_sid		IN NUMBER,
									rsp_inv		IN NUMBER,
									rsp_level	   IN NUMBER) RETURN NUMBER IS
									
						PROCEDURE doUpdate IS	
						BEGIN
							 	  <<getActionCode>>
							  	  DECLARE
						   		  		 		   action_code AMD_RSP.action_code%TYPE;
								  				   badInsert EXCEPTION;
								  BEGIN
								  	   			   SELECT action_code INTO action_code 
												   FROM AMD_RSP 
								 				   WHERE part_no = RspInsertRow.part_no 
								 				   AND loc_sid = RspInsertRow.loc_sid ;
															   
														 IF action_code != Amd_Defaults.DELETE_ACTION THEN
								 						 	RAISE badInsert ;
														 END IF ;
							   					
								  EXCEPTION 
								  						 	 WHEN OTHERS THEN
									  	   		  	  		 	  		 errorMsg(SqlFunction => 'select',
										   					 			 TableName => 'amd_rsp',
																		  pErrorLocation => 310,
																		  key1 => RspInsertRow.part_no,
																		  key2 => RspInsertRow.loc_sid );
															RAISE ;
								  END getActionCode ;
													
								  UPDATE AMD_RSP
								  		 		SET rsp_inv = RspInsertRow.rsp_inv,
									  			rsp_level = RspInsertRow.rsp_level,
									  			action_code = Amd_Defaults.INSERT_ACTION,
									  			last_update_dt = SYSDATE
												WHERE part_no = RspInsertRow.part_no 
												AND loc_sid = RspInsertRow.loc_sid ;
								  EXCEPTION WHEN OTHERS THEN
											  	   		  	  					   errorMsg(sqlFunction => 'update',
																				   tableName => 'amd_rsp',
																				   pErrorLocation => 320,
																				   key1 => RspInsertRow.part_no,
																				   key2 => RspInsertRow.loc_sid );																			   
							
						END doUpdate ;
	
				 		BEGIN
							 		 <<insertAmdRsp>>
									 BEGIN
			 	 	  				 	  			 INSERT INTO AMD_RSP
					  								 (	  
					  	  							 	  part_no,
					  	 								  loc_sid,
					 	  								  rsp_inv,
					  	  								  rsp_level,
					  	  								  action_code,
					  	  								  last_update_dt
													 )
													 VALUES
					 								 (
				 	  	   							  	   part_no,
					  	   								   RspInsertRow.loc_sid,
					  	   								   rsp_inv,
					  	   								   rsp_level,
					  	   								   Amd_Defaults.INSERT_ACTION,
					  	   								   SYSDATE
													  );
				 
		 		 									 EXCEPTION 
				 		   	 					 	 		   WHEN standard.DUP_VAL_ON_INDEX THEN
												 	  						doUpdate ;
																WHEN OTHERS THEN
													 				 			RETURN ErrorMsg(pSqlFunction => 'insert',
																				pTableName => 'amd_rsp',
																				pErrorLocation => 330,
																				pReturn_code => FAILURE,
																				pKey_1 => part_no,
																				pkey_2 => TO_CHAR(RspInsertRow.loc_sid)) ;
															
									 END insertAmdRsp;											
									RETURN SUCCESS;
				        END RspInsertRow;
						
		
						FUNCTION RspUpdateRow(
				 		   	   	 							part_no								   IN VARCHAR2,
						   									loc_sid								   IN NUMBER,
						   									rsp_inv								   IN NUMBER,
						  									rsp_level							 IN NUMBER) RETURN NUMBER IS
															 
								result  NUMBER ;
					
						BEGIN
					 			<<updateAmdRsp>>
								BEGIN
									 			UPDATE AMD_RSP SET
													   		   rsp_inv		= RspUpdateRow.rsp_inv,
															   rsp_level  = RspUpdateRow.rsp_level,
															   action_code = Amd_Defaults.UPDATE_ACTION,
															   last_update_dt = SYSDATE
												WHERE		   
															   part_no = RspUpdateRow.part_no
															   AND loc_sid = RspUpdateRow.loc_sid ;
												EXCEPTION
														 	   WHEN OTHERS THEN
															   			   RETURN ErrorMsg(pSqlFunction => 'update',
																		   		  						pTableName => 'amd_rsp',
																										pErrorLocation => 340,
																										pReturn_code => FAILURE,
																										pKey_1 => RspUpdateRow.part_no,
																										pKey_2 => TO_CHAR(RspUpdateRow.loc_sid));
								END updateAmdRsp ;
								RETURN SUCCESS;
						END RspUpdateRow ;
		
						FUNCTION RspDeleteRow(
				 		   				   	   	  					part_no			IN VARCHAR2,
																	loc_sid			IN NUMBER) RETURN NUMBER IS
						BEGIN
							 		<<updateAmdRsp>> -- logically delete all records for the part_no and loc_sid
									BEGIN
										 UPDATE AMD_RSP SET
										 		action_code = Amd_Defaults.DELETE_ACTION,
												last_update_dt = SYSDATE
										WHERE
											 	part_no = RspDeleteRow.part_no
												AND loc_sid = RspDeleteRow.loc_sid ;
												
								        EXCEPTION 
												  			  			WHEN OTHERS THEN
																			 			RETURN ErrorMsg(pSqlFunction => 'update',
																							   						pTableName => 'amd_rsp',
																													pErrorLocation => 350,
																													pReturn_code => FAILURE,
																													pKey_1 => part_no,
																													pKey_2 => TO_CHAR(loc_sid)) ;
									END updateAmdRsp ;									
									RETURN SUCCESS ;
					    END RspDeleteRow ;
																											
	/* amd_rsp_sum diff functions */
	
	FUNCTION doRspSumDiff (
			 part_no IN VARCHAR2, 
			 rsp_location IN VARCHAR2,
			 qty_on_hand IN NUMBER, 
			 rsp_level	 	IN NUMBER,
			 action_code IN VARCHAR2) RETURN NUMBER IS

		badActionCode EXCEPTION ;
		
		PROCEDURE InsertRow IS
		
				   PROCEDURE doUpdate IS
							   action_code AMD_RSP_SUM.action_code%TYPE ;
							   badInsert EXCEPTION ;
				   BEGIN
				   		<<getActionCode>>
						BEGIN
							 SELECT action_code 
							 INTO action_code 
							 FROM AMD_RSP_SUM 
							 WHERE part_no = doRspSumDiff.part_no 
							 AND rsp_location = doRspSumDiff.rsp_location ;
							 
							 IF action_code != Amd_Defaults.DELETE_ACTION THEN
							 	RAISE badInsert ;
							 END IF ;
						EXCEPTION WHEN OTHERS THEN
							errorMsg(SqlFunction => 'select',
										TableName => 'amd_rsp_sum',
										pErrorLocation => 360, 
										key1 => doRspSumDiff.part_no,
										key2 => doRspSumDiff.rsp_location);
										RAISE ;						
						END getActionCode ;
						
						UPDATE AMD_RSP_SUM
						SET qty_on_hand = doRspSumDiff.qty_on_hand,
							rsp_level = doRspSumDiff.rsp_level,
							action_code = Amd_Defaults.INSERT_ACTION,
							last_update_dt = SYSDATE
						WHERE part_no = doRspSumDiff.part_no AND rsp_location = doRspSumDiff.rsp_location ;
						
				   END doUpdate ;
				   
		BEGIN
		
					  <<insertAmdRspSum>>
					   BEGIN
							 INSERT INTO AMD_RSP_SUM
							(
								part_no,
								rsp_location,
								qty_on_hand,
								rsp_level,
								action_code,
								last_update_dt
							)
							VALUES
							(
							    part_no,
								rsp_location,
								qty_on_hand,
								rsp_level,
								Amd_Defaults.INSERT_ACTION,
								SYSDATE
							);
					
					EXCEPTION
									WHEN standard.DUP_VAL_ON_INDEX THEN
										 doUpdate ;
									WHEN OTHERS THEN
										 ErrorMsg(sqlFunction => 'insert',
													tableName => 'amd_rsp_sum',
													pErrorLocation => 370, 
													key1 => part_no,
													key2 => rsp_location ) ;
										 RAISE; 
													
					END insertAmdRspSum;
		END InsertRow ;
	
		PROCEDURE UpdateRow IS
			-- get the detail for the summarized inv_qty
			result NUMBER ;
			 
		BEGIN
			<<updateAmdRspSum>> 
			BEGIN
				UPDATE AMD_RSP_SUM SET
		            qty_on_hand 	   = doRspSumDiff.qty_on_hand,
					rsp_level  = doRspSumDiff.rsp_level,
					action_code    = Amd_Defaults.UPDATE_ACTION,
					last_update_dt = SYSDATE
				WHERE part_no  = doRspSumDiff.part_no
				      AND rsp_location  = doRspSumDiff.rsp_location ;
				EXCEPTION
						WHEN OTHERS THEN
							 ErrorMsg(SqlFunction => 'update',
										TableName => 'amd_rsp_sum',
										pErrorLocation => 380, 
									     key1 => part_no,
										key2 => rsp_location) ;
							 RAISE ;
			END updateAmdRspSum ;
					

		END UpdateRow ;
	
		PROCEDURE DeleteRow IS
		BEGIN
		     
			<<updateAmdRspSum>> -- logically delete all records for the part_no and loc_sid
			BEGIN
			 UPDATE AMD_RSP_SUM SET
				action_code    = Amd_Defaults.DELETE_ACTION,
				last_update_dt = SYSDATE
			WHERE    part_no  = doRspSumDiff.part_no
				 AND rsp_location  = doRspSumDiff.rsp_location ;
					
			EXCEPTION
					WHEN OTHERS THEN
						   ErrorMsg(SqlFunction => 'update',
									TableName => 'amd_rsp_sum',
									pErrorLocation => 390, 
									key1 => part_no,
									key2 => rsp_location) ;
							RAISE ;
			 END updateAmdRspSum;
			 
			
			
			
		END DeleteRow ;
	BEGIN
		 IF action_code = Amd_Defaults.INSERT_ACTION THEN
		     insertRow ;
		ELSIF action_code = Amd_Defaults.UPDATE_ACTION THEN
		 	  updateRow ;
		ELSIF action_code = Amd_Defaults.DELETE_ACTION THEN
			 deleteRow ;
		ELSE
			 errorMsg(action_code,'rsp_sum',331,part_no, rsp_location) ;
			 RAISE badActionCode ;
		END IF ;
		
		A2a_Pkg.insertInvInfo(part_no, rsp_location,Nvl(qty_on_hand,0), action_code) ;
			
		IF Amd_Location_Part_Override_Pkg.insertedTmpA2ALPO(part_no, rsp_location,
					                                     'TSL Fixed', rsp_level, 
														 'Fixed TSL Load',
														  Amd_Location_Part_Override_Pkg.GetFirstLogonIdForPart(Amd_Utils.GetNsiSidFromPartNo(part_no)),
														   SYSDATE,
														  action_code,
														   SYSDATE)  THEN							
						NULL ; -- do nothing
		 END IF ;
		RETURN SUCCESS;
	 EXCEPTION WHEN OTHERS THEN
			   ErrorMsg(SqlFunction => 'doRspSumDiff(' || action_code || ')',
									TableName => 'amd_rsp_sum / tmp_a2a_loc_part_override',
									pErrorLocation => 400) ; 
	 		   RETURN FAILURE ;
	END doRspSumDiff ;
	
	
	
	
	
	/* amd_in_transits diff functions */
	FUNCTION InsertRow(
			 		   		to_loc_sid	   	  IN NUMBER,
							quantity		  IN NUMBER,
							document_id		  IN VARCHAR2,
							part_no				 	IN VARCHAR2,
							from_location 			IN VARCHAR2,
							in_transit_date			IN DATE,
							serviceable_flag		IN VARCHAR2) RETURN NUMBER IS 
			result NUMBER;
			
			--site_location TMP_IN_TRANSITS_DIFF.site_location%TYPE := getSiteLocation(to_loc_sid) ;
			
	PROCEDURE doUpdate IS
	BEGIN
	     <<GetActionCode>>
		 DECLARE
		   action_code AMD_IN_TRANSITS.action_code%TYPE ;
		   badInsert EXCEPTION ;
		 BEGIN
			SELECT action_code INTO action_code
			FROM AMD_IN_TRANSITS 
			WHERE document_id = insertRow.document_id ;
			IF action_code != Amd_Defaults.DELETE_ACTION THEN
				RAISE badInsert ;
			END IF ;
		 EXCEPTION WHEN OTHERS THEN
							ErrorMsg(sqlFunction => 'select',
									tableName => 'amd_in_transits',
									pErrorLocation => 410, 
									key1 => insertRow.document_id) ;
		END getActionCode ;
					
		UPDATE AMD_IN_TRANSITS
		SET to_loc_sid = insertRow.to_loc_sid,
			quantity = insertRow.quantity,
			action_code = Amd_Defaults.INSERT_ACTION,
			last_update_dt = SYSDATE,
			part_no = insertRow.part_no,
			from_location = insertRow.from_location,
			in_transit_date = insertRow.in_transit_date,
			serviceable_flag = insertRow.serviceable_flag 
		WHERE document_id = insertRow.document_id ;
	END doUpdate ;
			  	
	BEGIN 
	  <<insertAmdInTransits>>
	  BEGIN
			INSERT INTO  AMD_IN_TRANSITS
					(
					to_loc_sid,
					quantity,
					action_code,
					last_update_dt,
					document_id,
					part_no,
					from_location,
					in_transit_date,
					serviceable_flag
					)
				VALUES
					(
					to_loc_sid,
					quantity,
					Amd_Defaults.INSERT_ACTION,
					SYSDATE,
					document_id,
					part_no,
					from_location,
					in_transit_date,
					serviceable_flag
					);
			EXCEPTION
			 	WHEN standard.DUP_VAL_ON_INDEX THEN
					 doUpdate ; 
				WHEN OTHERS THEN
					RETURN ErrorMsg(pSqlFunction => 'insert',
					pTableName => 'amd_in_transits',
					pErrorLocation => 420,
					pReturn_code => FAILURE,
					pKey_1 =>document_id,
					pKey_2 => part_no,
					pKey_3 => to_loc_sid,
					pKey_4 => in_transit_date) ;
		END insertAmdInTransits;
		RETURN SUCCESS;				
	
    END InsertRow ;
			
	FUNCTION UpdateRow(
					   TO_LOC_SID				IN NUMBER,
					   QUANTITY					IN NUMBER,
					   DOCUMENT_ID				IN VARCHAR2,
					   PART_NO					IN VARCHAR2,
					   FROM_LOCATION			IN VARCHAR2,
					   IN_TRANSIT_DATE			IN  DATE,
					   SERVICEABLE_FLAG			IN VARCHAR2) RETURN  NUMBER IS 
	BEGIN
	    <<updateAmdInTransits>>
		BEGIN
		 UPDATE AMD_IN_TRANSITS SET
					quantity		 = UpdateRow.quantity,
					action_code	 = Amd_Defaults.UPDATE_ACTION,
					last_update_dt	 = SYSDATE,
					from_location	 = UpdateRow.from_location,
					in_transit_date = UpdateRow.in_transit_date
		 WHERE document_id = UpdateRow.document_id
		 AND part_no = UpdateRow.part_no
		 AND to_loc_sid = UpdateRow.to_loc_sid;
						
		 EXCEPTION
				WHEN OTHERS THEN
					RETURN ErrorMsg(pSqlFunction =>'update',
							  		 pTableName =>'amd_in_transits',
									 pErrorLocation => 430,
									 pReturn_code => FAILURE,
									 pKey_1 => document_id,
									 pKey_2 => part_no,
									 pKey_3 => TO_CHAR(to_loc_sid));
		END updateAmdInTransit;
				
		
	    RETURN SUCCESS ;
					
		EXCEPTION WHEN OTHERS THEN
			  	   RETURN ErrorMsg(pSqlFunction => 'updateRow',
				   		  pTableName => 'amd_in_transits',
						  pErrorLocation => 440,
						  pReturn_code => FAILURE,
						  pKey_1 => part_no);
	END UpdateRow ;
				
	FUNCTION DeleteRow(
						 DOCUMENT_ID	 IN VARCHAR2,
						 PART_NO		 IN 		 VARCHAR2,
						 TO_LOC_SID	 IN NUMBER) RETURN NUMBER IS 
						 
			quantity AMD_IN_TRANSITS.quantity%TYPE;
			from_location AMD_IN_TRANSITS.from_location%TYPE;
			in_transit_date AMD_IN_TRANSITS.in_transit_date%TYPE;
	BEGIN
	  <<updateAmdInTransit>>
	  BEGIN
		UPDATE AMD_IN_TRANSITS SET
					quantity = DeleteRow.quantity,
					from_location = DeleteRow.from_location,
					in_transit_date = DeleteRow.in_transit_date,
					action_code = Amd_Defaults.DELETE_ACTION,
					last_update_dt = SYSDATE
		WHERE DOCUMENT_ID = DeleteRow.DOCUMENT_ID
		AND PART_NO = Deleterow.PART_NO
		AND TO_LOC_SID = DeleteRow.TO_LOC_SID ;
						 
		EXCEPTION
			WHEN OTHERS THEN
					RETURN ErrorMsg(pSqlFunction => 'update',
									pTableName => 'amd_in_transits',
									pErrorLocation => 450,
									pReturn_code =>FAILURE,
									pKey_1 => document_id,
									pKey_2 => part_no,
									pKey_3 => TO_CHAR(to_loc_sid)) ;														
	  END updateAmdInTransit;
	  <<selectAmdInTransit>>
	  BEGIN
			SELECT quantity, from_location, in_transit_date 
			INTO quantity, from_location, in_transit_date
			FROM AMD_IN_TRANSITS
			WHERE document_id = DeleteRow.document_id
			AND part_no = DeleteRow.part_no
			AND to_loc_sid = DeleteRow.to_loc_sid;
						
	  EXCEPTION
		 WHEN OTHERS THEN 
		      RETURN ErrorMsg(pSqlFunction => 'select',
							pTableName => 'amd_in_transits',
							pErrorLocation => 460,
							pReturn_code => FAILURE,
							pKey_1 => document_id,
							pKey_2 => part_no,
							pKey_3 => TO_CHAR(to_loc_sid) );
	  END selectAmdInTransit;
	  RETURN SUCCESS;
   END DeleteRow;
   
   FUNCTION InsertRow(
   					  part_no	   	  IN VARCHAR2,
					  site_location	  IN VARCHAR2,
					  quantity			  IN NUMBER,
					  serviceable_flag	 IN VARCHAR2) RETURN NUMBER IS
			
			result NUMBER;
		 FUNCTION doUpdate RETURN NUMBER IS
		    action_code AMD_IN_TRANSITS_SUM.action_code%TYPE;
			badInsert EXCEPTION;
		 BEGIN
		 
		    UPDATE AMD_IN_TRANSITS_SUM
			SET quantity = InsertRow.quantity,
			    serviceable_flag = InsertRow.serviceable_flag,
			    action_code = Amd_Defaults.INSERT_ACTION,
				last_update_dt = SYSDATE	
			WHERE  part_no = InsertRow.part_no 
			AND site_location = InsertRow.site_location;
			RETURN SUCCESS;
		 EXCEPTION  WHEN OTHERS THEN
		 			result := ErrorMsg(pSqlFunction => 'update',
					                   pTableName => 'amd_in_transits_sum',
									   pErrorLocation => 470,
									   pReturn_code => FAILURE,
									   pKey_1 => part_no,
									   pKey_2 => site_location) ;
					RAISE;
		 END doUpdate ;
	  BEGIN
	   IF (quantity > 0) THEN
	   BEGIN
	      INSERT INTO AMD_IN_TRANSITS_SUM
		  (
		   part_no,
		   site_location,
		   quantity,
		   serviceable_flag,
		   action_code,
		   last_update_dt
		  )
		  VALUES
		  (
		   InsertRow.part_no,
		   InsertRow.site_location,
		   quantity,
		   serviceable_flag,
		   Amd_Defaults.INSERT_ACTION,
		   SYSDATE
		  ) ;
		  EXCEPTION WHEN standard.DUP_VAL_ON_INDEX THEN
		  				 result := doUpdate ;
					WHEN OTHERS THEN
						 result := ErrorMsg(pSqlFunction => 'insert',
						 		   			  pTableName => 'amd_in_transits_sum',
											  pErrorLocation => 480,
											  pReturn_code => FAILURE,
											  pKey_1 => part_no,
											  pKey_2 => site_location,
											  pKey_3 => quantity) ;
					RAISE;
		  END insertAmdIntransitSum;
		-- END IF ;
		 
		A2a_Pkg.insertTmpA2AInTransits(
			  insertRow.part_no,
			  insertRow.site_location,
			  insertRow.quantity,
			  insertRow.serviceable_flag,
			  Amd_Defaults.INSERT_ACTION) ;
		END IF ;
		RETURN SUCCESS;
	END InsertRow;
	
	FUNCTION UpdateRow(
			 		   part_no	   		 IN VARCHAR2,
					   site_location  	   	 IN VARCHAR2,
					   quantity	   		 IN NUMBER,
					   serviceable_flag	 IN VARCHAR2) RETURN NUMBER IS
			 result NUMBER;
	BEGIN
		<<updateAmdInTransitsSum>>
		BEGIN
		  UPDATE AMD_IN_TRANSITS_SUM SET
		  		 quantity = UpdateRow.quantity,
				 action_code = Amd_Defaults.UPDATE_ACTION,
				 last_update_dt = SYSDATE
		  WHERE part_no = UpdateRow.part_no
		  AND site_location = UpdateRow.site_location;
		END updateAmdInTransitsSum ;
		
		A2a_Pkg.insertTmpA2AInTransits(
			  updateRow.part_no,
			  updateRow.site_location,
			  updateRow.quantity,
			  updateRow.serviceable_flag,
			  Amd_Defaults.UPDATE_ACTION) ;
			  RETURN SUCCESS;
			  
	END UpdateRow;
	
	FUNCTION DeleteRow(
			 		   part_no	   	IN VARCHAR2,
					   site_location	IN VARCHAR2,
					   serviceable_flag		  IN VARCHAR2) RETURN NUMBER IS
	
	BEGIN
		<<updateAmdInTransits>>
		BEGIN
			 UPDATE AMD_IN_TRANSITS_SUM SET
			 	action_code = Amd_Defaults.DELETE_ACTION,
				last_update_dt = SYSDATE
			 WHERE part_no = DeleteRow.part_no
			 AND   site_location = DeleteRow.site_location ;
		END updateAmdInTransits ;
		
		A2a_Pkg.insertTmpA2AInTransits(
			  deleteRow.part_no,
			  deleteRow.site_location,
			  0,
			  deleteRow.serviceable_flag,
			  Amd_Defaults.DELETE_ACTION) ;
			  RETURN SUCCESS;

	END DeleteRow ;	 
	
	PROCEDURE loadOnHandInvs IS
		nsnDashed      		 VARCHAR2(16) := NULL;
		invQty         		 NUMBER := 0 ;
		cntOnHandInvs 	   	 NUMBER := 0 ;
		cntType1 	  		 NUMBER := 0 ;
		cntType2			 NUMBER := 0 ;
		result 				 NUMBER := 0 ;
		cntType1WholeSale 	 NUMBER := 0 ;
	BEGIN
	   dbms_output.put_line('loadOnHandInvs started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
	   EXECUTE IMMEDIATE 'truncate table TMP_AMD_ON_HAND_INVS';
	   EXECUTE IMMEDIATE 'truncate table TMP_A2A_INV_INFO' ;
		
		FOR rec IN partCur LOOP

			nsnDashed := Amd_Utils.FormatNsn(rec.nsn,'GOLD');

			--
			-- For each part, extract inventory data from ramp and item tables.
			--
			<<invRampLoop>> 
			FOR rRec IN rampCur(nsnDashed) LOOP

				invQty := rRec.serviceable_balance +  rRec.difm_balance ;

				IF invQty > 0 THEN
				    <<Type_1>>					
					BEGIN
						INSERT INTO TMP_AMD_ON_HAND_INVS
						(
							part_no,
							loc_sid,
							inv_date,
							inv_qty,
							action_code,
							last_update_dt
						)
						VALUES
						(
							rec.part_no,
							rRec.loc_sid,
							rRec.inv_date,
							invQty,
							Amd_Defaults.INSERT_ACTION,
							SYSDATE
						);
						cntType1 := cntType1 + 1 ;
						cntOnhandInvs := cntOnHandInvs + 1 ;
					EXCEPTION
						WHEN DUP_VAL_ON_INDEX THEN
						 result := ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'tmp_amd_on_hand_invs',
									pErrorLocation => 490, 
									pReturn_code => FAILURE,
									pKey_1 => rec.part_no,
									pKey_2 => rRec.loc_sid,
									pKey_3 => rRec.inv_date,
									pKey_4 => nsnDashed);
							RAISE ;
					END Type_1;
				END IF;
			END LOOP invRampLoop ;
		END LOOP f77PartLoop;
		
	
		
		<<type1WholeSale>>
		FOR iRec IN itemType1Cur LOOP

			IF (iRec.inv_date IS NULL) THEN
				Amd_Utils.InsertErrorMsg(pLoad_no => Amd_Utils.GetLoadNo('GOLD/RAMP/ITEM','AMD_SPARE_INVS'),pKey_1 => iRec.part_no,
						pKey_2 => iRec.loc_sid, pKey_3 => 'GOLD/SPAREINV',
						pKey_4 => 'No inventory date found' );
			ELSE

				-- Type 1
				IF iRec.inv_qty > 0 THEN
                    <<insertTmpAmdOnHandInvs>>   
					BEGIN
						INSERT INTO TMP_AMD_ON_HAND_INVS
						(
							part_no,
							loc_sid,
							inv_date,
							inv_qty,
							action_code,
							last_update_dt
						)
						VALUES
						(
							iRec.part_no,
							iRec.loc_sid,
							iRec.inv_date,
							iRec.inv_qty,
							Amd_Defaults.INSERT_ACTION,
							SYSDATE
						);
						cntType1WholeSale := cntType1WholeSale + 1 ;
						cntOnHandInvs := cntOnHandInvs + 1 ;
					EXCEPTION
						WHEN OTHERS THEN
							result := ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'tmp_amd_on_hand_invs',
									pErrorLocation => 500, 
									pReturn_code => FAILURE,
									pKey_1 => iRec.part_no,
									pKey_2 => iRec.loc_sid,
									pKey_3 => iRec.inv_date) ;
							RAISE ;
					END insertTmpAmdOnHandInvs ;

				END IF;
			END IF;

		END LOOP type1WholeSale ;
		
		dbms_output.put_line('loadOnHandInvs ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ) ;
		dbms_output.put_line('cntOnHandInvs=' || cntOnHandInvs) ;
		dbms_output.put_line('cntType1=' || cntType1) ;
		dbms_output.put_line('cntType1WholeSale=' || cntType1WholeSale) ;
		
		infoMsg(sqlFunction => 'loadOnHandInvs',
			tableName => 'tmp_amd_on_hand_invs',
			pErrorLocation => 510, 
			key1 => TO_CHAR(cntOnHandInvs),
			key2 => TO_CHAR(cntType1),
			key3 => TO_CHAR(cntType1WholeSale)) ;
			
	EXCEPTION
		WHEN OTHERS THEN
			 ErrorMsg(sqlFunction => 'select',
				tableName => 'tmp_amd_on_hand_invs',
				pErrorLocation => 520) ; 
		RAISE ;
	END loadOnHandInvs ;
	
	PROCEDURE loadInRepair IS
		nsnDashed      		 VARCHAR2(16) := NULL;
		invQty         		 NUMBER := 0 ;
		cntType2 	  		 NUMBER := 0 ;
		cntInRepair   		 NUMBER := 0 ;
		result				 NUMBER := 0 ;
		cntType4WholeSale	 NUMBER :=  0 ;
		cntTypeBASCWholeSale NUMBER := 0 ;
		cntType5WholeSale	 NUMBER := 0 ;
	BEGIN
		dbms_output.put_line('loadInRepair started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS')) ;
		EXECUTE IMMEDIATE 'truncate table TMP_AMD_IN_REPAIR' ;
		EXECUTE IMMEDIATE 'truncate table TMP_A2A_REPAIR_INFO' ;
		EXECUTE IMMEDIATE 'truncate table tmp_a2a_repair_inv_info' ;
		
		<<f77PartLoop>> 
		FOR rec IN partCur LOOP

			nsnDashed := Amd_Utils.FormatNsn(rec.nsn,'GOLD');

			--
			-- For each part, extract inventory data from ramp and item tables.
			--
			<<invRampLoop>> 
			FOR rRec IN rampCur(nsnDashed) LOOP

				invQty := rRec.unserviceable_balance + rRec.suspended_in_stock;

				IF invQty > 0  THEN
					<<Type_2>>
					BEGIN
						INSERT INTO TMP_AMD_IN_REPAIR
						(
							part_no,
							loc_sid,
							repair_date,
							repair_qty,
							order_no,
							repair_need_date,
							action_code,
							last_update_dt
						)
						VALUES
						(
							rec.part_no,
							rRec.loc_sid,
							rRec.inv_date,
							invQty,
							'Retail',
							rRec.repair_need_date,
							Amd_Defaults.INSERT_ACTION,
							SYSDATE
						);
						cntType2 := cntType2 + 1 ;
						cntInRepair := cntInRepair + 1 ;
					EXCEPTION
						WHEN DUP_VAL_ON_INDEX THEN
							result := ErrorMsg(pSqlFunction => 'insert',
									pTableName => 'tmp_amd_in_repair',
									pErrorLocation => 530, 
									pReturn_code => FAILURE,
									pKey_1 => rec.part_no,
									pKey_2 => rRec.loc_sid,
									pKey_3 => rRec.inv_date,
									pKey_4 => rRec.repair_need_date) ;
							RAISE ;
								
					END Type_2;
				END IF;

			END LOOP invRampLoop ;

		END LOOP f77PartLoop;
		
		<<type4WholeSale>>
		FOR imRec IN itemMCur LOOP

			IF (imRec.inv_date IS NULL) THEN
				Amd_Utils.InsertErrorMsg(pLoad_no => Amd_Utils.GetLoadNo('GOLD/RAMP/ITEM','AMD_SPARE_INVS'),pKey_1 => imRec.part_no, pKey_2 => imRec.loc_sid,
						pKey_3 => 'GOLD/SPAREINV', pKey_4 => 'No inventory date found' );
			ELSE

				IF imRec.inv_qty > 0 THEN
				
				<<insertTmpAmdInRepair>>
				DECLARE
					   result NUMBER ;
				BEGIN
					--SELECT amd_order_sid_seq.NEXTVAL
					--INTO orderSid
					--FROM dual;

					-- Type 4
					INSERT INTO TMP_AMD_IN_REPAIR
					(
						part_no,
						loc_sid,
						repair_date,
						repair_qty,
						order_no,
						repair_need_date,
						action_code,
						last_update_dt
					)
					VALUES
					(
						imRec.part_no,
						imRec.loc_sid,
						imRec.inv_date,
						imRec.inv_qty,
						imRec.item_id,
						imRec.repair_need_date,
						Amd_Defaults.INSERT_ACTION,
						SYSDATE
					);
					cntType4WholeSale := cntType4WholeSale + 1 ;
					cntInRepair := cntInRepair + 1 ;
				EXCEPTION WHEN OTHERS THEN
					 result := ErrorMsg(
						pSqlFunction => 'insert' ,
						pTableName => 'tmp_amd_in_repair',
						pErrorLocation => 540,
						pReturn_code => FAILURE,
						pKey_1 => imRec.part_no,
						pKey_2 => TO_CHAR(imRec.loc_sid),
						pKey_3 => TO_CHAR(imRec.inv_date,'DD/MON/YYYY'),
						pKey_4 => imRec.inv_type) ;					
					
					RAISE ;

				END insertTmpAmdInRepair ;
				
				END IF;
			END IF;

		END LOOP type4WholeSale ;

		<<typeBASCWholeSale>>
		FOR iaRec IN itemACur LOOP

			IF (iaRec.repair_date IS NULL) THEN
				Amd_Utils.InsertErrorMsg(pLoad_no => Amd_Utils.GetLoadNo('GOLD/RAMP/ITEM','AMD_SPARE_INVS'),pKey_1 => iaRec.part_no, pKey_2 => iaRec.loc_sid,
						pKey_3 => 'GOLD/SPAREINV', pKey_4 => 'No inventory date found' );
			ELSE

				IF iaRec.inv_qty > 0 THEN
				
				<<insertTmpAmdInRepair>>
				DECLARE
					   result NUMBER ;
				BEGIN
					
					INSERT INTO TMP_AMD_IN_REPAIR
					(
						part_no,
						loc_sid,
						repair_date,
						repair_qty,
						order_no,
						repair_need_date,
						action_code,
						last_update_dt
					)
					VALUES
					(
						iaRec.part_no,
						iaRec.loc_sid,
						iaRec.repair_date,
						iaRec.inv_qty,
						iaRec.item_id,
						iaRec.repair_need_date,
						Amd_Defaults.INSERT_ACTION,
						SYSDATE
					);
					cntTypeBASCWholeSale := cntTypeBASCWholeSale + 1 ;
					cntInRepair := cntInRepair + 1 ;
				EXCEPTION WHEN OTHERS THEN
					 result := ErrorMsg(
						pSqlFunction => 'insert' ,
						pTableName => 'tmp_amd_in_repair',
						pErrorLocation => 550,
						pReturn_code => FAILURE,
						pKey_1 => iaRec.part_no,
						pKey_2 => TO_CHAR(iaRec.loc_sid),
						pKey_3 => TO_CHAR(iaRec.repair_date,'DD/MON/YYYY'));				
					
					RAISE ;

				END insertTmpAmdInRepair ;
				
				END IF;
			END IF;

		END LOOP typeBASCWholeSale ;
		
		<<itemType5WholeSale>>
		FOR oRec IN itemType5Cur LOOP

			IF (oRec.inv_date IS NULL) THEN
				Amd_Utils.InsertErrorMsg(pLoad_no => Amd_Utils.GetLoadNo('GOLD/RAMP/ITEM','AMD_SPARE_INVS'),pKey_1 => oRec.part_no, pKey_2 => oRec.loc_sid,
						pKey_3 => 'GOLD/SPAREINV', pKey_4 => 'No inventory date found' );
			ELSE

				IF oRec.inv_qty > 0 THEN
				
				<<insertTmpAmdInRepair>>
				DECLARE
					   result NUMBER ;
				BEGIN
					
					INSERT INTO TMP_AMD_IN_REPAIR
					(
						part_no,
						loc_sid,
						repair_date,
						repair_qty,
						order_no,
						repair_need_date,
						action_code,
						last_update_dt
					)
					VALUES
					(
						oRec.part_no,
						oRec.loc_sid,
						oRec.inv_date,
						oRec.inv_qty,
						oRec.order_no,
						oRec.repair_need_date,
						Amd_Defaults.INSERT_ACTION,
						SYSDATE
					);
					cntType5WholeSale := cntType5WholeSale + 1 ;
					cntInRepair := cntInRepair + 1 ;
				EXCEPTION WHEN OTHERS THEN
					 result := ErrorMsg(
						pSqlFunction => 'insert' ,
						pTableName => 'tmp_amd_in_repair',
						pErrorLocation => 560,
						pReturn_code => FAILURE,
						pKey_1 => oRec.part_no,
						pKey_2 => TO_CHAR(oRec.loc_sid),
						pKey_3 => TO_CHAR(oRec.inv_date,'DD/MON/YYYY'));				
					
					RAISE ;

				END insertTmpAmdInRepair ;
				
				END IF;
			END IF;

		END LOOP itemType5WholeSale ;
		
		dbms_output.put_line('loadInRepair ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ) ;
		dbms_output.put_line('cntInRepair=' || cntInRepair) ;
		dbms_output.put_line('cntType2=' || cntType2) ;
		dbms_output.put_line('cntType4WholeSale=' || cntType4WholeSale) ;
		dbms_output.put_line('cntTypeBASCWholeSale=' || cntTypeBASCWholeSale) ;
		dbms_output.put_line('cntType5WholeSale=' || cntType5WholeSale) ;
		
		infoMsg(sqlFunction => 'loadOnHandPlusInRepair',
			tableName => 'tmp_amd_in_repair',
			pErrorLocation => 570, 
			key1 => TO_CHAR(cntInRepair),
			key2 => TO_CHAR(cntType2),
			key3 => TO_CHAR(cntType4WholeSale),
			key4 => TO_CHAR(cntTypeBASCWholeSale),
			key5 => TO_CHAR(cntType5WholeSale)) ;
			
	EXCEPTION
		WHEN OTHERS THEN
			 ErrorMsg(sqlFunction => 'select',
				tableName => 'tmp_amd_in_repair',
				pErrorLocation => 580) ; 
		RAISE ;
	END loadInRepair ;
	
	
	PROCEDURE updateSpoTotalInventory IS
	
			CURSOR partCur IS
				   SELECT DISTINCT
				   		prime_part_no
				   FROM AMD_NATIONAL_STOCK_ITEMS ansi,
				    	AMD_SPARE_PARTS asp
				   WHERE 
				   		 RTRIM(ansi.nsn) = RTRIM(asp.nsn)
						 AND ansi.action_code != 'D' ;
													   
			CURSOR  totalSpoInvCur IS
					SELECT ansi.nsn,  SUM(qty) quantity 
               		 FROM
					 	 (SELECT a.part_no,quantity qty, nsn
						 FROM AMD_IN_TRANSITS a,
						 	  		   AMD_SPARE_NETWORKS asn,
						 	  		   AMD_SPARE_PARTS asp
						 WHERE asn.loc_sid = a.to_loc_sid
						 AND a.part_no = asp.part_no
						 AND asp.action_code IN ('A', 'C')
						 AND a.action_code != 'D'
						 AND asn.action_code != 'D'
						 AND asn.spo_location IS NOT NULL
						 UNION ALL
						 SELECT a.part_no,order_qty qty, asp.nsn
						 FROM AMD_ON_ORDER a, 
						 	  		   AMD_SPARE_NETWORKS asn,
			    					   AMD_SPARE_PARTS asp
				 		WHERE asn.loc_sid = a.loc_sid 
						AND a.part_no = asp.part_no
						AND asp.action_code IN ('A', 'C')
						AND a.action_code != 'D'
						AND asn.action_code != 'D'
						AND asn.spo_location IS NOT NULL				 
						UNION ALL
						SELECT a.part_no,inv_qty qty, asp.nsn
						FROM AMD_ON_HAND_INVS a, 
							 		 AMD_SPARE_NETWORKS asn,
									 AMD_SPARE_PARTS asp
						WHERE asn.loc_sid = a.loc_sid 
						AND RTRIM(a.part_no) = RTRIM(asp.part_no)
						AND asp.action_code IN ('A', 'C')
						AND a.action_code != 'D'
						AND asn.action_code != 'D'
						AND asn.spo_location IS NOT NULL
						UNION ALL 
						SELECT a.part_no, repair_qty qty, asp.nsn
						FROM AMD_IN_REPAIR a, 
							 		  AMD_SPARE_NETWORKS asn,
									  AMD_SPARE_PARTS asp 
						WHERE asn.loc_sid = a.loc_sid 
						AND a.part_no = asp.part_no
						AND asp.action_code IN ('A', 'C')
						AND a.action_code != 'D'
						AND asn.action_code != 'D'
						AND asn.spo_location IS NOT NULL
						UNION ALL 
						SELECT a.part_no, rsp_inv qty, asp.nsn
						FROM AMD_RSP a,
							 		  AMD_SPARE_NETWORKS asn,
									  AMD_SPARE_PARTS asp
						WHERE asn.loc_sid = a.loc_sid
						AND a.part_no = asp.part_no
						AND asp.action_code IN ('A','C')
						AND a.action_code != 'D'
						AND asn.action_code != 'D'
						AND asn.spo_location IS NOT NULL) qtyQ,
						AMD_NATIONAL_STOCK_ITEMS  ansi
						WHERE  ansi.nsn = qtyQ.nsn
						GROUP BY ansi.nsn ;
						
	BEGIN
		 		
		 dbms_output.put_line('updateSpoTotalInventory started at ' || TO_CHAR(SYSDATE,  'MM/DD/YYYY HH:MM:SS') ) ;	
		 
		 BEGIN
		 	  	UPDATE AMD_NATIONAL_STOCK_ITEMS
				SET spo_total_inventory = NULL
				WHERE spo_total_inventory IS NOT NULL ;
		END ;
				
		 <<primePartLoop>>
		-- FOR rec IN partCur LOOP
		 	 
			 FOR rRec IN totalSpoInvCur LOOP
			-- dbms_output.put_line('part_no=' || rRec.prime_part_no ); --' qty = ' || rRec.quantity) ;
			 	 BEGIN
				 	  UPDATE AMD_NATIONAL_STOCK_ITEMS
					  SET spo_total_inventory = rRec.quantity
					  WHERE nsn  = rRec.nsn
					  AND action_code != 'D' ;				  
				 END;
			 END LOOP totalSpoInvLoop ; 
		--END LOOP partCur ;
		 dbms_output.put_line('updateSpoTotalInventory ended at ' || TO_CHAR(SYSDATE,  'MM/DD/YYYY HH:MM:SS') ) ;	
	
	END updateSpoTotalInventory ; 
	
	-- added 9/2/2005
	FUNCTION getParamDate(rawData IN AMD_PARAM_CHANGES.PARAM_VALUE%TYPE, typeOfDate IN orderdates) RETURN DATE IS
			 paramDate DATE ;
			 params Amd_Utils.arrayOfWords := Amd_Utils.arrayOfWords() ;
			 cnt NUMBER ;
	BEGIN
		 params := Amd_Utils.splitString(rawData) ;
		 cnt := params.COUNT() ;
		 IF params.COUNT() > 0 THEN
		 	paramDate := TO_DATE(params(typeOfDate),'MM/DD/YYYY') ;
		 END IF ;		
		 RETURN paramDate ;
	END getParamDate ; 
	
	PROCEDURE setParamDate(voucher IN VARCHAR2, theDate IN DATE, typeOfDate IN orderdates) IS
			  params Amd_Utils.arrayOfwords ; 
	BEGIN
		 params := Amd_Utils.splitString(Amd_Defaults.getParamValue(ON_ORDER_DATE || voucher)) ;
		 IF params.COUNT() > 0 THEN
		 	params(typeOfDate) := theDate ;
		 END IF ;
		 Amd_Defaults.setParamValue(LOWER(ON_ORDER_DATE || voucher), Amd_Utils.joinString(params) ) ;
	EXCEPTION
			 WHEN standard.NO_DATA_FOUND THEN
			 	  Amd_Defaults.setParamValue(LOWER('on_order_date' || voucher), NULL) ;
	END setParamDate ;

	FUNCTION getOrderCreateDate(voucher IN VARCHAR2) RETURN DATE IS
	BEGIN
		 RETURN getParamDate(Amd_Defaults.GetParamValue(LOWER(ON_ORDER_DATE || voucher)), ORDER_CREATE_DATE) ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getOrderCreateDate ;
	
	
	PROCEDURE setOrderCreateDate(voucher IN VARCHAR2, orderCreateDate IN DATE) IS
			  theDate VARCHAR2(10) := TO_CHAR(orderCreateDate,'MM/DD/YYYY') ;
			  pos NUMBER ;
			  rawData AMD_PARAM_CHANGES.PARAM_VALUE%TYPE ;
			  params Amd_Utils.arrayOfWords ;
	BEGIN
		 setParamDate(voucher, orderCreateDate, ORDER_CREATE_DATE) ;
	END setOrderCreateDate ;
		 
	FUNCTION getScdeduledReceiptDateFrom(voucher IN VARCHAR2) RETURN DATE IS
	BEGIN
		 RETURN getParamDate(Amd_Defaults.GetParamValue(LOWER(ON_ORDER_DATE || voucher)), SCHEDULED_RECEIPT_DATE_FROM) ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getScdeduledReceiptDateFrom ;
	
	FUNCTION getScdeduledReceiptDateTo(voucher IN VARCHAR2) RETURN DATE IS
	BEGIN
		 RETURN getParamDate(Amd_Defaults.GetParamValue(LOWER(ON_ORDER_DATE || voucher)), SCHEDULED_RECEIPT_DATE_TO) ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getScdeduledReceiptDateTo ;

	PROCEDURE setScheduledReceiptDate(voucher IN VARCHAR2, fromDate IN DATE, toDate DATE) IS
			  params Amd_Utils.arrayOfwords ; 
	BEGIN
		 IF fromDate IS NOT NULL AND toDate IS NOT NULL THEN
			 IF fromDate > toDate THEN
			 	RAISE sched_receipt_date_exception ;
			 END IF ;
		 END IF ;
		 params := Amd_Utils.splitString(Amd_Defaults.getParamValue(ON_ORDER_DATE || voucher)) ;
		 IF params.COUNT() = 0 THEN
		 	params.extend(SCHEDULED_RECEIPT_DATE_TO) ;
		 ELSIF params.COUNT() = 1 THEN
		 	params.extend(2) ;
		 END IF ;
		 params(SCHEDULED_RECEIPT_DATE_FROM) := fromDate ;
		 params(SCHEDULED_RECEIPT_DATE_TO) := toDate ;
		 Amd_Defaults.setParamValue(LOWER(ON_ORDER_DATE || voucher), Amd_Utils.joinString(params) ) ;
	END setScheduledReceiptDate ;
	
	PROCEDURE setScheduledReceiptDateCalDays(voucher IN VARCHAR2, days IN NUMBER) IS 
			  params Amd_Utils.arrayOfwords ; 
	BEGIN
		 params := Amd_Utils.splitString(Amd_Defaults.getParamValue(ON_ORDER_DATE || voucher)) ;
		 IF params.COUNT() > 0 THEN
		 	params(NUMBER_OF_CALANDER_DAYS) := days ;
		 END IF ;
		 Amd_Defaults.setParamValue(LOWER(ON_ORDER_DATE || voucher), Amd_Utils.joinString(params,',') ) ;
	END setScheduledReceiptDateCalDays ;
	
   	FUNCTION getScheduledReceiptDateCalDays(voucher IN VARCHAR2) RETURN NUMBER IS
			 calDays NUMBER := NULL ;
			 params Amd_Utils.arrayOfWords ;
	BEGIN
		 params := Amd_Utils.splitString(Amd_Defaults.GetParamValue(ON_ORDER_DATE || voucher)) ;
		 IF params.COUNT() > 0 THEN
		 	calDays := TO_NUMBER(params(NUMBER_OF_CALANDER_DAYS)) ;
		 END IF ;		
		 RETURN calDays ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		RETURN NULL ;
	END getScheduledReceiptDateCalDays ;

	PROCEDURE getOnOrderParams(voucher IN VARCHAR2, 
		  orderCreateDate 		  OUT DATE, 
		  schedReceiptDateFrom 	  OUT DATE, 
		  schedReceiptDateTo 	  OUT DATE, 
		  schedReceiptCalDays 	  OUT NUMBER) IS
		 params Amd_Utils.arrayOfWords ;
	BEGIN
		 params := Amd_Utils.splitString(Amd_Defaults.GetParamValue(LOWER(ON_ORDER_DATE || voucher))) ;
		 IF params.COUNT() >= NUMBER_OF_CALANDER_DAYS THEN
		    IF params(NUMBER_OF_CALANDER_DAYS) IS NOT NULL THEN
		 	   schedReceiptCalDays := TO_NUMBER(params(NUMBER_OF_CALANDER_DAYS)) ;
			ELSE
			   schedReceiptCalDays := NULL ;
			END IF ;
		 ELSE
		 	schedReceiptCalDays := NULL ;
		 END IF ;		
		 IF params.COUNT() >= SCHEDULED_RECEIPT_DATE_TO THEN
		    IF params(SCHEDULED_RECEIPT_DATE_FROM) IS NOT NULL AND LENGTH(params(SCHEDULED_RECEIPT_DATE_FROM)) >= 8 THEN
			   schedReceiptDateFrom := TO_DATE(params(SCHEDULED_RECEIPT_DATE_FROM),'MM/DD/YYYY') ;
			ELSE
				schedReceiptDateFrom := NULL ;
			END IF ;
			IF params(SCHEDULED_RECEIPT_DATE_TO) IS NOT NULL AND LENGTH(params(SCHEDULED_RECEIPT_DATE_TO)) >= 8 THEN
		 	   schedReceiptDateTo   := TO_DATE(params(SCHEDULED_RECEIPT_DATE_TO),'MM/DD/YYYY') ;
			ELSE
				schedReceiptDateTo := NULL ;
			END IF ;
			
		 ELSE
		 	schedReceiptDateFrom := NULL ;
		 	schedReceiptDateTo   := NULL ;
		 END IF ;		
		 IF params.COUNT() >= ORDER_CREATE_DATE THEN
		    IF params(ORDER_CREATE_DATE) IS NOT NULL AND LENGTH(params(ORDER_CREATE_DATE)) >= 8 THEN
		 	   orderCreateDate := TO_DATE(params(ORDER_CREATE_DATE),'MM/DD/YYYY') ;
			ELSE
		 	   orderCreateDate := NULL ;
			END IF ;
		 ELSE
		 	orderCreateDate := NULL ;
		 END IF ;		
	END getOnOrderParams ;
	
	PROCEDURE setOnOrderParams(voucher IN VARCHAR2, 
		  orderCreateDate 		   IN DATE, 
		  schedReceiptDateFrom 	   IN DATE, 
		  schedReceiptDateTo 	   IN DATE, 
		  schedReceiptCalDays 	   IN NUMBER) IS
		params Amd_Utils.arrayOfWords := Amd_Utils.arrayOfWords() ; 
	BEGIN
		 params.extend(4) ;
		 params(ORDER_CREATE_DATE) := TO_CHAR(orderCreateDate,'MM/DD/YYYY') ;
		 IF schedReceiptDateFrom IS NOT NULL AND schedReceiptDateTo IS NOT NULL THEN
		 	IF schedReceiptDateFrom > schedReceiptDateTo THEN
			   RAISE sched_receipt_date_exception ;
			END IF ;
			params(SCHEDULED_RECEIPT_DATE_FROM) := TO_CHAR(schedReceiptDateFrom,'MM/DD/YYYY') ;
			params(SCHEDULED_RECEIPT_DATE_TO) := TO_CHAR(schedReceiptDateTo,'MM/DD/YYYY') ; 
		    params(NUMBER_OF_CALANDER_DAYS) := NULL ;
		ELSE
			IF schedReceiptCalDays IS NOT NULL THEN
			   params(SCHEDULED_RECEIPT_DATE_FROM) := NULL ;
			   params(SCHEDULED_RECEIPT_DATE_TO) := NULL ; 
		 	   params(NUMBER_OF_CALANDER_DAYS) := schedReceiptCalDays ; 			
			ELSE
			   params(SCHEDULED_RECEIPT_DATE_FROM) := NULL ;
			   params(SCHEDULED_RECEIPT_DATE_TO) := NULL ;
			   params(NUMBER_OF_CALANDER_DAYS) := NULL ;
			END IF ;
		END IF ;
		IF NOT Amd_Defaults.isParamKey(LOWER(ON_ORDER_DATE || voucher)) THEN
		   Amd_Defaults.addParamKey(LOWER(ON_ORDER_DATE || voucher),'The order create date and scheduled receipt date for the ' || LOWER(voucher) || ' voucher') ; 
		END IF ;
		Amd_Defaults.setParamValue(LOWER(ON_ORDER_DATE || voucher), Amd_Utils.joinString(params) ) ;	
	END setOnOrderParams ;   
   
	FUNCTION isVoucher(voucher IN VARCHAR2) RETURN BOOLEAN IS
			theVoucher VARCHAR2(2) ; 
	BEGIN
		 SELECT DISTINCT SUBSTR(gold_order_number,1,2) INTO theVoucher FROM AMD_ON_ORDER
		 WHERE LOWER(SUBSTR(gold_order_number,1,2)) = LOWER(isVoucher.voucher) ;
		 RETURN TRUE ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		 RETURN FALSE ;		 
	END isVoucher ;  

	PROCEDURE clearOnOrderParams IS
		CURSOR onOrderParams IS
			SELECT * FROM AMD_PARAM_CHANGES outer WHERE param_key LIKE ON_ORDER_DATE || '%'  
			AND effective_date = (
					SELECT MAX(effective_date)
					FROM AMD_PARAM_CHANGES
					WHERE param_key = outer.param_key) ;
	BEGIN
		 FOR rec IN onOrderParams LOOP
		 	 INSERT INTO AMD_PARAM_CHANGES
			 (param_key, param_value, effective_date, user_id)
			 VALUES (rec.param_key, ',,,', SYSDATE, USER) ;
		 END LOOP ;
	END clearOnOrderParams ;
	
	FUNCTION numberOfOnOrderParams RETURN NUMBER IS
			 cnt NUMBER ;
	BEGIN
		SELECT COUNT(*) INTO cnt FROM AMD_PARAM_CHANGES outer WHERE param_key LIKE ON_ORDER_DATE || '%'  
		AND effective_date = (
				SELECT MAX(effective_date)
				FROM AMD_PARAM_CHANGES
				WHERE param_key = outer.param_key) ;
		RETURN cnt ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		RETURN 0 ;
	END numberOfOnOrderParams ;
		
	FUNCTION getVouchers RETURN ref_cursor IS
		 vouchers_cursor ref_cursor ;
	BEGIN
		 OPEN vouchers_cursor FOR 
		 SELECT DISTINCT SUBSTR(gold_order_number,1,2) voucher 
		 FROM AMD_ON_ORDER 
		 ORDER BY voucher ;
		 RETURN vouchers_cursor ;		 	  
	END getVouchers ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_inventory', 
		 		pError_location => 590, pKey1 => 'amd_inventory', pKey2 => '$Revision:   1.71  $') ;
	end version ;
	
			 										 					    
END Amd_Inventory;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_FROM_BSSM_PKG AS
    /*   				
	    PVCS Keywords
		
       $Author:   zf297a  $
     $Revision:   1.12  $
         $Date:   Jun 09 2006 11:20:30  $
     $Workfile:   amd_from_bssm_pkg.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_from_bssm_pkg.pkb-arc  $	  *
   
      Rev 1.12   Jun 09 2006 11:20:30   zf297a
   Implemented version + used writeMsg for all loadAmd... public procedures
   
      Rev 1.11   Jun 09 2006 10:29:00   zf297a
   got rid of cannot convert message going to amd_load_details
   
      Rev 1.10   Dec 06 2005 09:42:40   zf297a
   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
   
      Rev 1.9   Aug 04 2005 14:35:44   zf297a
   Changed all queries using lock_sid to use a character string so it will search via the index.
   
      Rev 1.8   Jun 20 2005 15:11:50   c970183
   fixed update of criticality (it is a number in amd_national_stock_items)
   
      Rev 1.7   May 17 2005 10:08:20   c970183
   Updated InsertErrorMessage to new interface
   
      Rev 1.6   May 06 2005 07:31:18   c970183
   changed dla_warehouse_stcok to current_backorder fro amd_national_stock_items.  added PVCS keywords
		  */	  
	   ERRSOURCE constant varchar2(20) := 'AmdFromBssmPkg';
	   NOT_ACCEPTABLE_BSSM_PLTP_REC exception;


	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_from_bssm_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;

		procedure errorMsg(
						sqlFunction in varchar2,
						tableName in varchar2,
						errorLocation in number,
						key1 in varchar2 := '',
				 		key2 in varchar2 := '',
						key3 in varchar2 := '',
						key4 in varchar2 := '',
						key5 in varchar2 := '',					
						keywordvaluepairs in varchar2 := '') is
		begin
			rollback;
			amd_utils.inserterrormsg (
					pload_no => amd_utils.getloadno(
							psourcename => sqlfunction,
							ptablename  => tablename),
					pdata_line_no => errorlocation,
					pdata_line    => 'amd_from_bssm_pkg',
					pkey_1 => key1,
					pkey_2 => key2,
					pkey_3 => key3,
					pkey_4 => key4,
					pkey_5 => key5 || ' ' || to_char(sysdate,'MM/DD/YYYY HH:MM:SS') ||
							   ' ' || keywordvaluepairs,
					pcomments => sqlfunction || '/' || tablename || ' sqlcode('||sqlcode||') sqlerrm('||sqlerrm||')');
			commit;
			return ;
		end errorMsg;

	   function ConvertCriticality(pCriticality bssm_parts.criticality%type) return varchar2 is
	   		-- criticality is bssm is a number, criticality in amd is 1 char
			criticality varchar2(1) := null;
	   begin
	   		-- from Tony Maingot of i2 - if criticality null, then consider as 'M'.
			-- however, will do this on outbound thru tmapi and leave as null in db.
			if (pCriticality is null) then
			    criticality	:= null;
	   		elsif (pCriticality <= .33 and pCriticality >= 0) then
			   	criticality := 'M';
			elsif (pCriticality <= .67) then
				criticality := 'D';
			elsif (pCriticality <= 1.0) then
				criticality := 'C';
			else
				null ; -- if out of range return null
			end if;
			return criticality;
	   end ConvertCriticality;

	   function ConvertItemType(pItemType bssm_parts.item_type%type) return amd_national_stock_items.item_type%type is
	   		itemType varchar2(1) := null;
	   /* -- email from laurie when asked for mapping of bssm to amd
	   	 Sent:	Thursday, October 25, 2001 2:38 PM
	   	 In AMD today, T and P are Repairable, N is Consumable.  */

	   begin
	   				-- if not listed below, return as is
			if (pItemType is null) then
			   itemType := null;
	   		elsif ( pItemType in ('P', 'T') ) then
			   itemType := 'R';
			elsif (pItemType = 'N') then
			   itemType := 'C';
			else
			   itemType := pItemType; -- cannot convert return what was passed
			end if;
			return itemType;
	   end ConvertItemType;

       function GetCurrentBssmNsn(pNsn bssm_parts.nsn%type) return bssm_parts.nsn%type is
	   		cursor bssmNsn_cur(pNsiSid amd_nsns.nsi_sid%type) is
				   select bp.nsn
				   	   from bssm_parts bp, amd_nsns an
				   	   where bp.nsn = an.nsn and
					   		 bp.lock_sid = '0' and
					   		 an.nsi_sid = pNsiSid
					   order by bp.nsn;
			rNsn_rec bssmNsn_cur%rowtype;
			nsiSid amd_nsns.nsi_sid%type;
	   begin
		   		-- nsn is likely to come from amd, this function will be updated when amd_nsns.creation_date
				-- usable, bssm_nsn_revisions data available, or not important as bob eberlein noted
				-- bssm_parts will contain current only.
				-- below just in case and to handle current data situation which has all versions
				-- of the "nsn", i.e. multiple bssm_parts lock_sid 0 records relate to one nsi_sid in amd.
			nsiSid := amd_utils.GetNsiSid(pNsn => pNsn);
			if (not bssmNsn_cur%ISOPEN) then
			   open bssmNsn_cur(nsiSid);
			end if;
			fetch bssmNsn_cur into rNsn_rec;
			if (bssmNsn_cur%NOTFOUND) then
			   close bssmNsn_cur;
			   raise no_data_found;
			end if;
			close bssmNsn_cur;
			return rNsn_rec.nsn;
	   end GetCurrentBssmNsn;

	   function GetLocSid(pLocId amd_spare_networks.loc_id%type) return amd_spare_networks.loc_sid%type is
	   	    locId amd_spare_networks.loc_id%type := null;
	   begin
			if (pLocId = BSSM_WAREHOUSE_SRAN) then
		       locId := AMD_WAREHOUSE_LOCID;
			else
			   locId := pLocId;
			end if;
			return amd_utils.GetLocSid(locId);
	   end GetLocSid;

	   procedure LoadAmdBaseFromBssmRaw is
	   			 -- to get all of them
	   		cursor bssmBase_cur is
				   select
				   		bp.*
				   from
				   		bssm_base_parts bp,
						amd_nsns an
				   where
				   		 bp.nsn = an.nsn   and
						 bp.lock_sid = '0';
						 /*
						 (bp.repair_indicator is not null or
						  bp.replacement_indicator is not null or
						  );*/
				cnt number := 0 ;
	   begin
			writeMsg(pTableName => 'amd_part_locs', pError_location => 10,
					pKey1 => 'LoadAmdBaseFromBssmRaw',
					pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	   		for bssmBaseRec in bssmBase_cur
			loop
				begin
					 UpdateAmdPartLocs(bssmBaseRec);
					 cnt := cnt + 1 ;
				exception
				 	 when others then
					 	  errorMsg(sqlFunction => 'update', tablename => 'amd_part_locs', 
						  	errorLocation => 10,
						  	key1 => bssmBaseRec.nsn, key2 => bssmBaseRec.sran) ;
						  raise ;
				end;
			end loop;
			writeMsg(pTableName => 'amd_part_locs', pError_location => 20,
					pKey1 => 'LoadAmdBaseFromBssmRaw',
					pKey2 => 'cnt=' || to_char(cnt),
					pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
			commit ;
	   end LoadAmdBaseFromBssmRaw;

	   procedure LoadAmdBaseFromBssmRaw(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type) is
	   			 bssmBaseRec bssm_base_parts%rowtype;

				 -- current bssm can have not current parts in bssm_parts,
				 vNsn bssm_base_parts.nsn%type;
	   begin
					 -- nsn can come from any direction, from bssm or from amd
					 -- still assuming bob eberlein in that his is only holding latest.
				 vNsn := GetCurrentBssmNsn(pNsn);
				 select *
				 	into bssmBaseRec
				 	from bssm_base_parts
					where nsn = vNsn and
						  sran = pSran and
						  lock_sid = '0';
				 UpdateAmdPartLocs(bssmBaseRec);
	   exception
	   			when no_data_found then
					 null;
				when others then
					 errorMsg(sqlFunction => 'select', tablename => 'bssmBaseRec', 
					 	ErrorLocation => 20,
					 	key1 => vNsn, key2 => pSran) ;
					 raise ;
       end LoadAmdBaseFromBssmRaw;

	   procedure LoadAmdPartFromBssmRaw is
 	   		-- bssm_parts will only have latest part, now can
			-- go thru amd_nsns table.
			-- bob eberlein said only current part will be in bssm_parts
			-- so should not be a problem.  for foolproof, would go to
			-- bssm_nsn_revisions, but currently there is no data.
			/*
	   		 cursor bssmParts_cur is
				   select
				   		  bp.*
 				   from
				   		 bssm_parts bp,
				   		 amd_national_stock_items ansi,
						 amd_nsns an
				   where
				   		 bp.lock_sid = 0 	 and
						 bp.nsn = an.nsn	 and
						 bp.nsn = GetCurrentBssmNsn(an.nsn) and
						 an.nsi_sid = ansi.nsi_sid; */
			cursor bssmParts_cur is
				   select
				   		  bp.*
 				   from
				   		 bssm_parts bp,
				   		 amd_national_stock_items ansi,
						 amd_nsns an
				   where
				   		 bp.lock_sid = '0' 	 and
						 bp.nsn = an.nsn	 and
						 an.nsi_sid = ansi.nsi_sid;
			cnt number := 0 ;
	   begin
			writeMsg(pTableName => 'amd_national_stock_items', pError_location => 30,
					pKey1 => 'LoadAmdPartFromBssmRaw',
					pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	   		for bssmPartRec in bssmParts_cur
			loop
				begin
					 UpdateAmdNsi(bssmPartRec);
					 cnt := cnt + 1 ;
				exception
					 when others then
					 	  errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items', 
						    errorLocation => 30,
						  	key1 => bssmPartRec.nsn) ;
						  raise ;
				end;
			end loop;
			writeMsg(pTableName => 'amd_national_stock_items', pError_location => 40,
					pKey1 => 'LoadAmdPartFromBssmRaw',
					pKey2 => 'cnt=' || to_char(cnt),
					pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
			commit;
	   end LoadAmdPartFromBssmRaw;


   	   procedure LoadAmdPartFromBssmRaw(pNsn bssm_parts.nsn%type) is
	   			 bssmPartRec bssm_parts%rowtype;

				 -- current bssm can have not current parts in bssm_parts,
				 vNsn bssm_parts.nsn%type;
	   begin
					 -- nsn can come from any direction, from bssm or from amd
					 -- still assuming bob eberlein in that his is only holding latest.
				 vNsn := GetCurrentBssmNsn(pNsn);
				 select *
				 	into bssmPartRec
				 	from bssm_parts
					where nsn = vNsn
					and lock_sid = '0';
				 UpdateAmdNsi(bssmPartRec);
	   exception
	   			when no_data_found then
					 null;
       end LoadAmdPartFromBssmRaw;


	   procedure LoadAmdPartLocTimePeriods is
	   		cursor partLoc_cur is
				   select apl.nsi_sid, apl.loc_sid, bpltp.*
				   from
				   		bssm_part_loc_time_periods bpltp,
						amd_nsns an,
						amd_part_locs apl,
						amd_spare_networks asn
				   where
				   		 bpltp.nsn = an.nsn 	   and
						 an.nsi_sid = apl.nsi_sid  and
						 apl.loc_sid = asn.loc_sid and
						 asn.loc_id = decode(bpltp.sran, BSSM_WAREHOUSE_SRAN, AMD_WAREHOUSE_LOCID, bpltp.sran);
			cnt number := 0 ;
	   begin
			writeMsg(pTableName => 'amd_part_loc_time_periods', pError_location => 50,
					pKey1 => 'LoadAmdPartLocTimePeriods',
					pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	   		for partLocRec in partLoc_cur
			loop
				begin
					 -- bssm_part_loc_time_periods allows nullable fields
					 -- amd_part_loc_time_periods has no fields nullable

					 if (partLocRec.time_period_end   is null or
					 	 partLocRec.reorder_point 	  is null or
						 partLocRec.reorder_quantity  is null) then
					 	 	raise NOT_ACCEPTABLE_BSSM_PLTP_REC;
					 end if;
					 if (partLocRec.last_update_date is null) then
					 	 partLocRec.last_update_date := SYSDATE;
					 end if;
					 insert into amd_part_loc_time_periods
						 		(nsi_sid,
								 loc_sid,
								 time_period_start,
								 time_period_end,
								 reorder_point,
								 reorder_quantity,
								 se_target,
								 action_code,
								 last_update_dt)
							 values(
							 	 partLocRec.nsi_sid,
								 partLocRec.loc_sid,
						 		 partLocRec.time_period_start,
								 partLocRec.time_period_end,
								 partLocRec.reorder_point,
						 		 partLocRec.reorder_quantity,
								 partLocRec.se_target,
						 		 amd_defaults.INSERT_ACTION,
						 		 partLocRec.last_update_date);
					cnt := cnt + 1 ;
				exception
					when NOT_ACCEPTABLE_BSSM_PLTP_REC then
						 -- missing info which is not nullable for amd counterpart
						 null;
					when others then
					 	  errorMsg(sqlFunction => 'insert', tablename => 'amd_part_loc_time_periods', 
						    errorLocation => 40,
						    key1 => partLocRec.nsn, key2 => partLocRec.nsi_sid, key3 => partLocRec.loc_sid) ;
						  raise ;
				end;
			end loop;
			writeMsg(pTableName => 'amd_part_loc_time_periods', pError_location => 60,
					pKey1 => 'LoadAmdPartLocTimePeriods',
					pKey2 => 'cnt=' || to_char(cnt),
					pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
			commit;
	   end LoadAmdPartLocTimePeriods;


	   procedure UpdateAmdNsi (pBssmPartsRec bssm_parts%rowtype) is
	   		nsiSid amd_national_stock_items.nsi_sid%type;
			procedure validateData is
					  item amd_national_stock_items%rowtype ;
					  line_no number := 0 ;
			begin
				 line_no := line_no + 1; item.add_increment       := pBssmPartsRec.add_increment ;
				 line_no := line_no + 1; item.amc_base_stock      := pBssmPartsRec.amc_base_stock ;
				 line_no := line_no + 1; item.amc_days_experience := pBssmPartsRec.amc_days_experience ;
				 line_no := line_no + 1; item.amc_demand		  := pBssmPartsRec.amc_demand ;
				 line_no := line_no + 1; item.capability_requirement := pBssmPartsRec.capability_requirement ;
				 line_no := line_no + 1; item.condemn_avg 	  		 := pBssmPartsRec.condemn ;
				 line_no := line_no + 1; item.criticality 	  		 := pBssmPartsRec.criticality  ;
				 line_no := line_no + 1; item.demand_variance 	  	 := pBssmPartsRec.demand_variance ;
				 line_no := line_no + 1; item.dla_demand 	  		 := pBssmPartsRec.dla_demand ;
				 line_no := line_no + 1; item.current_backorder 	 := pBssmPartsRec.current_backorder ;
				 line_no := line_no + 1; item.min_purchase_quantity  := pBssmPartsRec.min_purchase_quantity ;
				 line_no := line_no + 1; item.nrts_avg 	 			 := pBssmPartsRec.nrts ;
				 line_no := line_no + 1; item.rts_avg 	  			 := pBssmPartsRec.rts ;
				 line_no := line_no + 1; item.ru_ind 	  			 := pBssmPartsRec.ru_ind ;
				 line_no := line_no + 1; item.time_to_repair_on_base_avg := pBssmPartsRec.on_base_turnaround ;
				 line_no := line_no + 1; item.user_comment 	  		 := pBssmPartsRec.user_comment ;
			exception when others then
					  errorMsg(sqlFunction => 'validate', tablename => 'amd_national_stock_items',
					    errorLocation => 50,
					  	key1 => to_char(line_no) ) ;
					  raise ;
			end validateData ;
			
	   begin
	   			-- will throw exception if not found
		    validateData ;
	   		nsiSid := amd_utils.GetNsiSid(pNsn => pBssmPartsRec.nsn);
	   		update amd_national_stock_items
					 set
					 		add_increment  = pBssmPartsRec.add_increment,
					 		amc_base_stock = pBssmPartsRec.amc_base_stock,
							amc_days_experience = pBssmPartsRec.amc_days_experience,
							amc_demand = pBssmPartsRec.amc_demand,
							capability_requirement = pBssmPartsRec.capability_requirement,
							condemn_avg = pBssmPartsRec.condemn,
							criticality = pBssmPartsRec.criticality,
							demand_variance = pBssmPartsRec.demand_variance,
							dla_demand = pBssmPartsRec.dla_demand,
							current_backorder = pBssmPartsRec.current_backorder,
							-- fedc_cost = pBssmPartsRec.fedc_cost,
							-- 			 now mic pulled from amd_l67_tmp directly
					 		-- mic_code_lowest = pBssmPartsRec.mic_code,
							min_purchase_quantity = pBssmPartsRec.min_purchase_quantity,
							nrts_avg = pBssmPartsRec.nrts,
							rts_avg = pBssmPartsRec.rts,
							ru_ind = pBssmPartsRec.ru_ind,
							time_to_repair_on_base_avg = pBssmPartsRec.on_base_turnaround,
							user_comment = pBssmPartsRec.user_comment,
							last_update_dt = SYSDATE
			 where  nsi_sid = nsiSid;
	   exception
	   		 when no_data_found then
			 	  -- cannot find nsiSid
			 	  null;
			 when others then
				errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items', 
				    errorLocation => 60,
					key1 => nsiSid) ;
			    raise ;

	   end UpdateAmdNsi;


	   procedure UpdateAmdPartLocs(pBssmBaseRec bssm_base_parts%rowtype) is
	   	   		nsiSid amd_national_stock_items.nsi_sid%type;
				locSid amd_spare_networks.loc_sid%type;
	   begin
	   			-- nsi_sid will throw exception if not found
	   		nsiSid := amd_utils.GetNsiSid(pNsn => pBssmBaseRec.nsn);
			locSid := GetLocSid(pBssmBaseRec.sran);
			if (locSid is not null) then
			    update amd_part_locs
					   set repair_level_code = pBssmBaseRec.repair_indicator,
					   	   removal_ind 		 = pbssmbaserec.replacement_indicator,
						  -- 		 will come from ramp
						  -- rsp_on_hand  	 = pBssmBaseRec.rsp_on_hand,
  						  -- rsp_objective 	 = pBssmBaseRec.rsp_objective,
						   order_cost 		 = pBssmBaseRec.order_cost,
						   holding_cost 	 = pBssmBaseRec.holding_cost,
						   backorder_fixed_cost = pBssmBaseRec.backorder_fixed_cost,
						   backorder_variable_cost = pBssmBaseRec.backorder_variable_cost,
						   last_update_dt = SYSDATE
				where
					   nsi_sid = nsiSid		 and
				   	   loc_sid = locSid;
			end if;
	   exception
	   		when no_data_found then
 			 	  -- cannot find nsiSid
				 null;
			when others then
				errorMsg(sqlFunction => 'update', tablename => 'amd_part_locs', 
					errorLocation => 70,
					key1 => nsiSid, key2 => locSid) ;
				raise ;
			
	   end UpdateAmdPartLocs;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_from_bssm_pkg', 
		 		pError_location => 80, pKey1 => 'amd_from_bssm_pkg', pKey2 => '$Revision:   1.12  $') ;
	end version ;

END AMD_FROM_BSSM_PKG;
/

show errors

CREATE OR REPLACE PACKAGE BODY Amd_Reqs_Pkg IS
	/* 
	    PVCS Keywords
		
       $Author:   zf297a  $
     $Revision:   1.13  $
         $Date:   Jul 07 2006 13:50:28  $
     $Workfile:   AMD_REQS_PKG.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_REQS_PKG.pkb-arc  $
/*   
/*      Rev 1.13   Jul 07 2006 13:50:28   zf297a
/*   Fixed InsertRowSpoSum to handle a logical insert of a previously deleted row.
/*   
/*      Rev 1.11   Jun 09 2006 12:25:16   zf297a
/*   implemented version
/*   
/*      Rev 1.10   Apr 28 2006 13:51:00   zf297a
/*   updated package end statment: end amd_reqs_pkg ;
/*   
/*      Rev 1.9   Mar 23 2006 15:43:22   c402417
/*   Changed the way to get site_location into tmp_a2a_backorder_info to use Amd_Utils.getSpoLocation.
/*   
/*      Rev 1.8   Feb 10 2006 12:08:40   c402417
/*   changed to use fuction getSiteLocation from the amd_reqs_pkg instead of from amd_utils_pkg.
/*   
/*      Rev 1.7   Feb 09 2006 13:39:28   c402417
/*   Emergency fix -  getting the right spo_location for site_location in table tmp_a2a_backorder_info.
/*   
/*      Rev 1.6   Dec 06 2005 09:30:10   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*   
/*      Rev 1.5   Dec 06 2005 09:10:34   zf297a
/*   Added check of isPartValid, wasPartSent, and site_location is not null for all invocations of doInsertTmpA2ABackOrderInfo.  Removed wasPartSent since it resides in the a2a_pkg.
/*   
/*      Rev 1.4   Dec 02 2005 13:50:04   zf297a
/*   Added doInsertTmpA2ABackOrderInfo and doUpdateTmpA2ABackOrderInfo.  Added errorMsg procedure. Changed insertRow, updateRow, and deleteRow to use doInsertTmpA2ABackOrderInfo
/*   
/*      Rev 1.3   Oct 05 2005 13:48:14   c402417
/*   Added function WasPartSent to make sure we sent backorder_info with part that exist in amd_sent_to_a2a.
/*   
/*      Rev 1.2   12 Aug 2005 10:43:16   c402417
/*   Changed sources for table amd_reqs .
/*   Added insert statement for table amd_backorder_sum which feeds table tmp_a2a_backorder_info for SPO .
/*   Added diff functions for table amd_reqs and amd_backorder_sum.
/*   
/*      Rev 1.1   May 06 2005 09:07:00   c970183
/*   fixed deleteRow and added PVCS keywords
   
   */
	ERRSOURCE CONSTANT VARCHAR2(20) := 'amd_req_pkg';
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_reqs_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	FUNCTION ErrorMsg(
					pSqlFunction IN VARCHAR2,
					pTableName IN VARCHAR2,
					pErrorLocation IN NUMBER,
					pReturn_code IN NUMBER,
					pKey_1 IN VARCHAR2,
			 		pKey_2 IN VARCHAR2 := '',
					pKey_3 IN VARCHAR2 := '',
					pKey_4 IN VARCHAR2 := '',					
					pKeywordValuePairs IN VARCHAR2 := '') RETURN NUMBER IS
	BEGIN
		ROLLBACK;
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => pSqlFunction,
						pTableName  => pTableName),
				pData_line_no => pErrorLocation,
				pData_line    => 'amd_reqs_pkg',
				pKey_1 => pKey_1,
				pKey_2 => pKey_2,
				pKey_3 => pKey_3,
				pKey_4 => pKey_4,
				pKey_5 => 'rc=' || TO_CHAR(pReturn_code) ||
					       ' ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ||
						   ' ' || pKeywordValuePairs,
				pComments => pSqlFunction || '/' || pTableName || ' sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')');
		COMMIT;
		RETURN pReturn_code;
	END ErrorMsg;
	-- added this procedure ...since function is not really necessary for most errors DSE 12/02/05
	 PROCEDURE ErrorMsg(
	     pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
	     pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
	     pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
	     pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE,
	      pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
	     pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
	     pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
	     pKeywordValuePairs IN VARCHAR2 := '') IS
	  result NUMBER ;
	 BEGIN
	   result := ErrorMsg(pSqlfunction => pSqlfunction,
				       pTableName => pTableName,
				       pErrorLocation => pError_location,
				       pReturn_code => FAILURE,
				       pKey_1 => pKey_1,
				       pKey_2 => pKey_2,
				       pKey_3 => pKey_3,
				       pKey_4 => pKey_4,
				       pKeywordValuePairs => pKeywordValuePairs) ;
	
	 EXCEPTION WHEN OTHERS THEN
	     COMMIT ;
	 END ErrorMsg;

	PROCEDURE LoadAmdReqs IS
	
		-- backorder from req1 table in Gold
		CURSOR req1_cur IS
			   SELECT
			   		  RTRIM(REQ1.request_id) request_id,
					  RTRIM(REQ1.select_from_part) part_no,
			   		  SUM((NVL(REQ1.qty_due,0) + NVL(REQ1.qty_reserved,0))) quantity,
					  asn.loc_sid
			   FROM
			   		  REQ1,
			   		  AMD_SPARE_PARTS asp,
					  AMD_SPARE_NETWORKS asn
			   WHERE
			   		  REQ1.status IN ('U', 'O','H', 'R') AND
					  REQ1.request_priority IN (1,2,3,4,5) AND 
					  REQ1.mils_source_dic IS NOT NULL AND
			   		  asn.loc_id = SUBSTR(REQ1.request_id, 1, 6) AND
			   		  RTRIM(asp.part_no) = RTRIM(REQ1.select_from_part) AND
					  ((NVL(REQ1.qty_due,0) + NVL(REQ1.qty_reserved,0)) > 0 ) AND 
					  asn.action_code IN (Amd_Defaults.INSERT_ACTION,Amd_Defaults.UPDATE_ACTION)
				GROUP BY RTRIM(REQ1.request_id), RTRIM(REQ1.select_from_part), asn.loc_sid ;
		nsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE;
		
		-- backorder from tmp1 table in Gold
		CURSOR tmp1_cur IS
			   SELECT
			   		  RTRIM(TMP1.temp_out_id) temp_out_id,
					  RTRIM(TMP1.from_part) part_no,
			   		  SUM(TMP1.qty_due) qty_due,
					  asn.loc_sid
			   FROM
			   		  TMP1,
					  AMD_SPARE_NETWORKS asn,
					  AMD_SPARE_PARTS asp
			   WHERE
			   		  TMP1.returned_voucher IS NULL AND 
					  TMP1.status = 'O' AND 
   					  TMP1.TCN = 'LBR' AND
					  TMP1.qty_due != 0 AND
					  asn.loc_id = SUBSTR(TMP1.to_sc,8,6) AND
					  RTRIM(asp.part_no) = RTRIM(TMP1.from_part)
			   GROUP BY RTRIM(TMP1.temp_out_id), RTRIM(TMP1.from_part),asn.loc_sid ;
					  
		  result   NUMBER ;

	BEGIN
	
		EXECUTE IMMEDIATE 'truncate table TMP_AMD_REQS';
		 EXECUTE IMMEDIATE 'truncate table TMP_A2A_BACKORDER_INFO';
		 
		 FOR req IN req1_cur
		 LOOP
		 	 BEGIN
			 --nsiSid:= Amd_Utils.GetNsiSid(pNsn => tmp.nsn);
			 	 INSERT INTO TMP_AMD_REQS
				 (
				  	req_id,
					part_no,
					loc_sid,
					quantity_due,
					action_code,
					last_update_dt
				 )
				 VALUES
				 (
				  	req.request_id,
					req.part_no,
					req.loc_sid,
					req.quantity,
					Amd_Defaults.INSERT_ACTION,
					SYSDATE
				 ) ;
			  END;
		 END LOOP;
		 COMMIT; 
		 
		 BEGIN
		 FOR tmp IN tmp1_cur
		   LOOP
		 	   BEGIN
			 	  	--nsiSid:= Amd_Utils.GetNsiSid(pNsn => tmp.nsn);
					INSERT INTO TMP_AMD_REQS
					(
					 	  req_id,
						  part_no,
						  loc_sid,
						  quantity_due,
						  action_code,
						  last_update_dt
					)
					VALUES
					(
					 	  tmp.temp_out_id,
						  tmp.part_no,
						  tmp.loc_sid,
						  tmp.qty_due,
						  Amd_Defaults.INSERT_ACTION,
						  SYSDATE
					);
     			END;
			END LOOP;
			COMMIT;	  
	  END loadAmdReqs;
  END;
	
	
	
	FUNCTION getSiteLocation(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN
			 AMD_SPARE_NETWORKS.spo_location%TYPE IS
			 
			 site_location AMD_SPARE_NETWORKS.spo_location%TYPE ;
			 result NUMBER ;
	BEGIN
		SELECT spo_location INTO site_location 
		FROM AMD_SPARE_NETWORKS
		WHERE loc_sid = getSiteLocation.loc_sid ;
		
		RETURN site_location ;
	EXCEPTION WHEN OTHERS THEN
		result := ErrorMsg(pSqlFunction => 'select',
		pTableName => 'amd_reqs',
		pErrorLocation => 10 , 
		pReturn_code => FAILURE,
		pKey_1 => TO_CHAR(getSiteLocation.loc_sid)) ;
		RAISE ;
	END getSiteLocation ;
																		 	
	
	/* amd_reqs diff function */
	FUNCTION InsertRow(
			 		   req_id 				IN VARCHAR2,
					   part_no				IN VARCHAR2,
					   loc_sid				IN NUMBER,
					   quantity_due			IN NUMBER) RETURN NUMBER IS
					   
					   result  NUMBER ;
					   
	BEGIN
		 <<insertAmdReqs>>
		 DECLARE
		 		PROCEDURE doUpdate IS
				BEGIN
					 <<getActionCode>>
					 DECLARE
					 		action_code AMD_REQS.action_code%TYPE;
							badInsert EXCEPTION ;
				  	 BEGIN
					 	   SELECT action_code INTO action_code
						   FROM AMD_REQS
						   WHERE req_id = insertRow.req_id
						   AND part_no = InsertRow.part_no;
						   IF action_code != Amd_Defaults.DELETE_ACTION THEN
						   	  			  RAISE badInsert ;
						   END IF;
					EXCEPTION WHEN OTHERS THEN
							  	   		   result:= ErrorMsg(pSqlFunction=>'select',
										  								 	pTableName =>'amd_reqs',
																			pErrorLocation => 20,
																			pReturn_code => FAILURE,
																			pKey_1 => req_id,
																			pKey_2 => part_no,
																			pKey_3 => loc_sid,
																			pkey_4 => quantity_due);
					END getActionCode;
					
					UPDATE AMD_REQS
					SET loc_sid = InsertRow.loc_sid,
								quantity_due = InsertRow.quantity_due,
								action_code = Amd_Defaults.INSERT_ACTION,
								last_update_dt = SYSDATE
					WHERE req_id = InsertRow.req_id
						  		  AND part_no = InsertRow.part_no;
			END doUpdate;
																			
	BEGIN
		 <<insertAmdReqs>>
		 BEGIN
		    INSERT INTO AMD_REQS
			(
		  	  req_id,
			  part_no,
			  loc_sid,
			  quantity_due,
			  action_code,
			  last_update_dt
		 	)
		 	VALUES
		 	(
		  	  req_id,
			  part_no,
			  loc_sid,
			  quantity_due,
			  Amd_Defaults.INSERT_ACTION,
			  SYSDATE
			); 
			
			EXCEPTION
					WHEN standard.DUP_VAL_ON_INDEX THEN
						 doUpdate ;
		 		  WHEN OTHERS THEN
					  	 RETURN ErrorMsg(pSqlFunction => 'insert',
								  		 pTableName => 'amd_reqs1',
										 pErrorLocation => 30,
									     pReturn_code => FAILURE,
									     pKey_1 => req_id,
										 pKey_2 => part_no,
									     pKey_3 => loc_sid,
										 pKey_4 => quantity_due);							
      	  END  insertAmdReqs ;																							  										
			RETURN SUCCESS; 				
					
	END insertRow;
END;
								 
	FUNCTION UpdateRow(
			 		   	REQ_ID			IN VARCHAR2,
						PART_NO			IN VARCHAR2,
						LOC_SID			IN NUMBER,
						QUANTITY_DUE	IN NUMBER) RETURN NUMBER IS
	BEGIN
		 <<updateAmdReqs>>
		 BEGIN
		 	UPDATE AMD_REQS SET
					quantity_due = UpdateRow.quantity_due,
					action_code = Amd_Defaults.UPDATE_ACTION,
					last_update_dt = SYSDATE
			WHERE
					req_id = UpdateRow.req_id
					AND loc_sid = UpdateRow.loc_sid
					AND part_no = UpdateRow.part_no ;
			EXCEPTION 
				WHEN OTHERS THEN 
				   RETURN ErrorMsg(pSqlFunction => 'update',
								pTableName => 'amd_reqs',
								pErrorlocation => 40,
								pReturn_code => FAILURE,
								pKey_1 => req_id,
								pKey_2 => part_no,
								pKey_3 => loc_sid);
		END updateAmdReqs;	 
		 RETURN SUCCESS ;
		 
	END UpdateRow ;
	
	FUNCTION DeleteRow(
			 		   	REQ_ID	   			IN VARCHAR2,
						PART_NO				IN VARCHAR2,
						LOC_SID				IN NUMBER) RETURN NUMBER IS
	BEGIN
		 <<updateAmdReqs>>
		 BEGIN
		 	  	UPDATE AMD_REQS SET
	                req_id = DeleteRow.req_id,
					part_no =  DeleteRow.part_no,
					loc_sid = DeleteRow.loc_sid,
					action_code	= Amd_Defaults.DELETE_ACTION,
					last_update_dt  =  SYSDATE
				WHERE req_id = DeleteRow.req_id
				AND  part_no  = DeleteRow.part_no
				AND loc_sid = DeleteRow.loc_sid ;
							
		        EXCEPTION WHEN OTHERS THEN
				RETURN ErrorMsg(pSqlFunction => 'update',
							pTableName => 'amd_reqs',
							pErrorLocation => 50,
							pReturn_code => FAILURE,
							pKey_1 => req_id,
							pKey_2 => part_no,
							pKey_3 => loc_sid);
		END updateAmdReqs;
		RETURN SUCCESS ;
		
	END DeleteRow;
	/*
	procedure LoadTmpBackorderSum IS
	
	 begin
	 	  insert into amd_backorder_sum
		  (
		   part_no,
		   loc_sid,
		   qty,
		   action_code,
		   last_update_dt
		  )
		  select
		   part_no,
		   loc_sid,
		   sum(quantity_due),
		   action_code,
		   sysdate
		  from tmp_amd_reqs
		  group by part_no, loc_sid, action_code ;
		 commit;
	  end ; */
	  
	  /* amd_backorder_sum diff function */

	-- added this procedure DSE 12/02/05	  
	PROCEDURE doInsertTmpA2ABackOrderInfo (part_no IN VARCHAR2, loc_sid IN NUMBER, 
			  site_location IN TMP_A2A_BACKORDER_INFO.site_location%TYPE,
			  qty IN NUMBER,
			  action_code IN VARCHAR2) IS
			  
		  PROCEDURE doUpdateTmpA2ABackOrderInfo IS
		  BEGIN
		  	   UPDATE TMP_A2A_BACKORDER_INFO
			   SET qty = qty,
			   action_code = doInsertTmpA2ABackOrderInfo.action_code,
			   last_update_dt = SYSDATE
			   WHERE part_no = doInsertTmpA2ABackOrderInfo.part_no
			   AND site_location = doInsertTmpA2ABackOrderInfo.site_location
			   AND loc_sid = doInsertTmpA2ABackOrderInfo.loc_sid ;
		  EXCEPTION WHEN OTHERS THEN
		        ErrorMsg(pSqlfunction => 'update',
			     pTableName => 'tmnp_a2a_backorder_info', pError_location => 60,
			     pKey_1 => part_no, pKey_2 => TO_CHAR(doInsertTmpA2ABackOrderInfo.loc_sid), pKey_3 => doInsertTmpA2ABackOrderInfo.site_location,
				 pKey_4 => TO_CHAR(qty) ) ;
		  END doUpdateTmpA2ABackOrderInfo ;
		  
	BEGIN
		INSERT INTO TMP_A2A_BACKORDER_INFO
			(part_no, loc_sid, site_location,qty, action_code, last_update_dt)
			VALUES
			(part_no, loc_sid, site_location, qty, action_code, SYSDATE);
			
	EXCEPTION
	    WHEN standard.DUP_VAL_ON_INDEX THEN
			 doUpdateTmpA2ABackOrderInfo ; 
	    WHEN OTHERS THEN 
	        ErrorMsg(pSqlfunction => 'insert',
			     pTableName => 'tmnp_a2a_backorder_info', pError_location => 70,
			     pKey_1 => part_no, pKey_2 => TO_CHAR(doInsertTmpA2ABackOrderInfo.loc_sid), 
				 pKey_3 => doInsertTmpA2ABackOrderInfo.site_location,
				 pKey_4 => TO_CHAR(qty)) ;
			RAISE ;
				
	END doInsertTmpA2ABackOrderInfo ;
		
	  FUNCTION InsertRow(
	  		   			 part_no	IN VARCHAR2,
						 loc_sid	IN NUMBER,
						 qty		IN NUMBER) RETURN NUMBER IS
			
			result NUMBER ;
		FUNCTION doUpdate RETURN NUMBER IS
	  		   action_code AMD_BACKORDER_SUM.action_code%TYPE;
			   badInsert EXCEPTION;
		BEGIN
			
			UPDATE AMD_BACKORDER_SUM
			SET qty = InsertRow.qty,
			action_code = Amd_Defaults.INSERT_ACTION,
			last_update_dt = SYSDATE
			WHERE part_no = InsertRow.part_no AND loc_sid = InsertRow.loc_sid;
			
			RETURN SUCCESS ;
			
		EXCEPTION WHEN OTHERS THEN
			result := ErrorMsg(pSqlFunction => 'update',
				pTableName => 'amd_backorder_sum',
				pErrorLocation => 60 , 
				pReturn_code => FAILURE,
				pKey_1 => part_no,
				pKey_2 => TO_CHAR(loc_sid),
				pKey_3 => TO_CHAR(qty)) ;
			RAISE ;
		END doUpdate ;
			
		
	  BEGIN
	  	  
		<<validateData>>  
		DECLARE
		  			line_no NUMBER := 0 ;
					rec AMD_BACKORDER_SUM%ROWTYPE ;
		BEGIN
			line_no := line_no + 1; rec.part_no := part_no ;
			line_no := line_no + 1; rec.loc_sid := insertRow.loc_sid ;
			line_no := line_no + 1; rec.qty := qty ;
		EXCEPTION WHEN OTHERS THEN
		  
			result := ErrorMsg(pSqlFunction => 'insert',
				pTableName => 'amd_backorder_sum',
				pErrorLocation => 70 , 
				pReturn_code => FAILURE,
				pKey_1 => part_no,
				pKey_2 => TO_CHAR(loc_sid),
				pKey_3 => TO_CHAR(qty),
				pKey_4 => TO_CHAR(line_no)) ;
			RAISE ;
		END validateDate ;
		
		IF (qty > 0) THEN  
			BEGIN			
				INSERT INTO AMD_BACKORDER_SUM
					(
					part_no,
					loc_sid,
					qty,
					action_code,
					last_update_dt
					)
					VALUES
					(
					part_no,
					InsertRow.loc_sid,
					qty,
					Amd_Defaults.INSERT_ACTION,
					SYSDATE
					);
			  
			EXCEPTION
				WHEN standard.DUP_VAL_ON_INDEX THEN
					 result := doUpdate ; 
				WHEN OTHERS THEN
			
				result := ErrorMsg(pSqlFunction => 'insert',
					pTableName => 'amd_backorder_sum',
					pErrorLocation => 80 , 
					pReturn_code => FAILURE,
					pKey_1 => part_no,
					pKey_2 => TO_CHAR(loc_sid),
					pKey_3 => TO_CHAR(qty) ) ;
				RAISE ;
			END insertAmdBackorderSum;
					  
			<<insertTmpA2ABackorderInfo>>
			DECLARE
				site_location TMP_A2A_BACKORDER_INFO.site_location%TYPE := Amd_Utils.GetSpoLocation(loc_sid);
			BEGIN
				 IF A2a_Pkg.isPartValid(part_no) 
				 AND A2a_Pkg.wasPartSent(partNo => part_no) 
				 AND site_location IS NOT NULL THEN
				 	 doInsertTmpA2ABackOrderInfo (part_no => part_no, loc_sid => loc_sid, site_location => site_location,
					 							 qty => qty, 
												 action_code => Amd_Defaults.INSERT_ACTION) ;
				 END IF ;
			END insertAmdBackorderSum;
			
		    RETURN SUCCESS ;
		END IF ;
	END InsertRow;
		
		
	FUNCTION  UpdateRow(
			  			part_no		  IN VARCHAR2,
						loc_sid		  IN NUMBER,
						qty			  IN NUMBER) RETURN NUMBER IS
			result NUMBER;
	BEGIN
	  <<updateAmdBackorderSum>>
	  BEGIN
	  	   UPDATE AMD_BACKORDER_SUM SET
		   	 qty = UpdateRow.qty,
			 action_code = Amd_Defaults.UPDATE_ACTION,
			 last_update_dt = SYSDATE
		   WHERE part_no = UpdateRow.part_no
		   AND loc_sid = UpdateRow.loc_sid;
	
	  
		  IF (qty > 0) THEN
		  
			  <<insertTmpA2ABackoderInfo>>
			  DECLARE
			     site_location TMP_A2A_BACKORDER_INFO.site_location%TYPE := Amd_Utils.GetSpoLocation(loc_sid);			 
			  BEGIN
			    IF site_location IS NOT NULL 
				AND A2a_Pkg.isPartValid(part_no)
				AND A2a_Pkg.wasPartSent(part_no) THEN
				 	 doInsertTmpA2ABackOrderInfo (part_no => part_no, loc_sid => loc_sid, site_location => site_location,
					 							 qty => qty,
												 action_code => Amd_Defaults.UPDATE_ACTION) ;
				END IF ;
			  END insertTmpA2ABackorderInfo;
			  
		   END IF ;
	   END updateAmdBackorderSum;
	   
	   RETURN SUCCESS;
	   
	END UpdateRow;
	
	 
	 FUNCTION DeleteRow(
	 		  			part_no			 IN VARCHAR2,
						loc_sid			 IN NUMBER) RETURN NUMBER IS
	
	 BEGIN
	 	<<updateAmdBackorderSum>>
		BEGIN
		
		  UPDATE AMD_BACKORDER_SUM SET
		    action_code = Amd_Defaults.DELETE_ACTION,
			last_update_dt = SYSDATE
		  WHERE part_no = DeleteRow.part_no
		  AND loc_sid = DeleteRow.loc_sid ;
	
		
		<<insertTmpA2aBackorderInfo>>
		DECLARE
			   site_location TMP_A2A_BACKORDER_INFO.site_location%TYPE := Amd_Utils.GetSpoLocation(loc_sid);
		BEGIN
			 IF A2a_Pkg.isPartValid(part_no) 
			 AND A2a_Pkg.wasPartSent(part_no) 
			 AND site_location IS NOT NULL THEN
			 	 doInsertTmpA2ABackOrderInfo (part_no => part_no, loc_sid => loc_sid, site_location => site_location,
				 							 qty => 0,
											 action_code => Amd_Defaults.DELETE_ACTION) ;
			END IF;
			
		END insertTmpA2ABackorderInfo ;
		
		RETURN SUCCESS ;
		END updateAmdBackorderSum;
		
	END DeleteRow;
		 		    	
	FUNCTION InsertRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type,
						 qty		IN amd_backorder_spo_sum.QTY%type) RETURN NUMBER IS
			
			result NUMBER ;
			
			procedure doUpdate is
					  action_code amd_backorder_spo_sum.action_code%type ;
			begin
				 <<getActionCode>>
				 begin
				 	  select action_code into doUpdate.action_code
					  from amd_backorder_spo_sum
					  where spo_prime_part_no = InsertRowSpoSum.spo_prime_part_no
					  and action_code = amd_defaults.DELETE_ACTION ;
				 exception when standard.NO_DATA_FOUND then
				 	  RAISE_APPLICATION_ERROR(-20000, spo_prime_part_no || ' does not have a ' || amd_defaults.DELETE_ACTION || ' action_code.');
				 end getActionCode ;
				 
				update amd_backorder_spo_sum
				set qty = InsertRowSpoSum.qty,
				action_code = amd_defaults.INSERT_ACTION,
				last_update_dt = sysdate
				where spo_prime_part_no = InsertRowSpoSum.spo_prime_part_no ;
			end doUpdate ;
			
		
	BEGIN
	  	  
		<<validateData>>  
		DECLARE
		  			line_no NUMBER := 0 ;
					rec AMD_BACKORDER_spo_SUM%ROWTYPE ;
		BEGIN
			line_no := line_no + 1; rec.spo_prime_part_no := spo_prime_part_no ;
			line_no := line_no + 1; rec.qty := qty ;
		EXCEPTION WHEN OTHERS THEN
		  
			result := ErrorMsg(pSqlFunction => 'insert',
				pTableName => 'amd_backorder_spo_sum',
				pErrorLocation => 90 , 
				pReturn_code => FAILURE,
				pKey_1 => spo_prime_part_no,
				pKey_2 => TO_CHAR(qty),
				pKey_3 => TO_CHAR(line_no)) ;
			RAISE ;
		END validateDate ;
		
		IF (qty > 0) THEN  
		    <<insertAmdBackorderSpoSum>>
			BEGIN			
				INSERT INTO AMD_BACKORDER_SPO_SUM
					(
					spo_prime_part_no,
					qty,
					action_code,
					last_update_dt
					)
					VALUES
					(
					spo_prime_part_no,
					qty,
					Amd_Defaults.INSERT_ACTION,
					SYSDATE
					);
			  
			EXCEPTION
			    when standard.DUP_VAL_ON_INDEX then
					 doUpdate ;
				WHEN OTHERS THEN
			
				result := ErrorMsg(pSqlFunction => 'insert',
					pTableName => 'amd_backorder_spo_sum',
					pErrorLocation => 100 , 
					pReturn_code => FAILURE,
					pKey_1 => spo_prime_part_no,
					pKey_2 => TO_CHAR(qty) ) ;
				RAISE ;
			END insertAmdBackorderSpoSum;
					  
			
		    RETURN SUCCESS ;
		END IF ;
	END InsertRowSpoSum ;
	
	FUNCTION UpdateRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type,
						 qty		IN amd_backorder_spo_sum.QTY%type) RETURN NUMBER IS
			
			result NUMBER ;
			
		
	  BEGIN
	  	  
		<<validateData>>  
		DECLARE
		  			line_no NUMBER := 0 ;
					rec AMD_BACKORDER_spo_SUM%ROWTYPE ;
		BEGIN
			line_no := line_no + 1; rec.spo_prime_part_no := spo_prime_part_no ;
			line_no := line_no + 1; rec.qty := qty ;
		EXCEPTION WHEN OTHERS THEN
		  
			result := ErrorMsg(pSqlFunction => 'update',
				pTableName => 'amd_backorder_spo_sum',
				pErrorLocation => 110 , 
				pReturn_code => FAILURE,
				pKey_1 => spo_prime_part_no,
				pKey_2 => TO_CHAR(qty),
				pKey_3 => TO_CHAR(line_no)) ;
			RAISE ;
		END validateDate ;
		
		IF (qty > 0) THEN
		    <<updateAmdBackorderSpoSum>>  
			BEGIN			
				update AMD_BACKORDER_SPO_SUM
				set qty = UpdateRowSpoSum.qty,
				action_code = amd_defaults.UPDATE_ACTION,
				last_update_dt = sysdate
				where spo_prime_part_no = UpdateRowSpoSum.spo_prime_part_no ;
			EXCEPTION
				WHEN OTHERS THEN
			
				result := ErrorMsg(pSqlFunction => 'update',
					pTableName => 'amd_backorder_spo_sum',
					pErrorLocation => 120 , 
					pReturn_code => FAILURE,
					pKey_1 => spo_prime_part_no,
					pKey_2 => TO_CHAR(qty) ) ;
				RAISE ;
			END updateAmdBackorderSpoSum;
					  
			
		    RETURN SUCCESS ;
			
		END IF ;
	END UpdateRowSpoSum ;
	
	FUNCTION DeleteRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type) RETURN NUMBER IS
			
			result NUMBER ;
			
		
	  BEGIN
	  	  
		
			update AMD_BACKORDER_SPO_SUM
			set action_code = amd_defaults.DELETE_ACTION,
			last_update_dt = sysdate
			where spo_prime_part_no = DeleteRowSpoSum.spo_prime_part_no ;
			
		    RETURN SUCCESS ;

	 EXCEPTION
		WHEN OTHERS THEN
	
		result := ErrorMsg(pSqlFunction => 'update',
			pTableName => 'amd_backorder_spo_sum',
			pErrorLocation => 130 , 
			pReturn_code => FAILURE,
			pKey_1 => spo_prime_part_no) ;
		RAISE ;
			
	END DeleteRowSpoSum ;
	
	procedure version is
	begin
		 writeMsg(pTableName => 'amd_reqs_pkg', 
		 		pError_location => 110, pKey1 => 'amd_reqs_pkg', pKey2 => '$Revision:   1.13  $') ;
	end version ;
		  	
	 
END amd_reqs_pkg ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Demand AS
/*
      $Author:   zf297a  $
    $Revision:   1.20  $
        $Date:   Jun 09 2006 12:51:26  $
    $Workfile:   amd_demand.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_demand.pkb-arc  $
   
      Rev 1.20   Jun 09 2006 12:51:26   zf297a
   implemented version
   
      Rev 1.19   Mar 07 2006 13:17:32   c402417
   Changed field Site to get spo_location from amd_spare_networks instead of loc_id.
   
      Rev 1.18   Dec 07 2005 13:12:20   zf297a
   When joining with amd_sent_to_a2a, make sure the part was not deleted from the SPO - i.e. action_code != 'D'.
   
   Check that the super prime part no is actually vaild and that it has been sent to the SPO.
   
      Rev 1.17   Dec 05 2005 16:43:30   c402417
   Added version 1.10.1.2 to the current version.
   
      Rev 1.14   Dec 01 2005 09:30:38   zf297a
   added pvcs keywords
*/

	FUNCTION CalcQuantity(
							pDocNo VARCHAR2,
							pDic VARCHAR2) RETURN NUMBER;
	FUNCTION CalcBadQuantity(
							pDocNo VARCHAR2,
							pDic VARCHAR2) RETURN NUMBER;
	PROCEDURE InsertTmpLcf1;
	PROCEDURE InsertTmpLcfIcp;
	PROCEDURE InsertL67TmpLcfIcp;


	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_demand',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	FUNCTION CalcQuantity(
							pDocNo VARCHAR2,
							pDic VARCHAR2) RETURN NUMBER IS
		qty     NUMBER := 0;
		qtyd1   NUMBER := 0;
		qtyd2	  NUMBER := 0;
	BEGIN

		IF pDic = 'TIN' THEN
			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qty
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'TIN'
					AND ttpc = '1B'
					AND reason IN ('B','C','J','V','X','A','D','F','G','K','L','Z',
						'1','2','3','4','5','6','7','8','9');
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					qty := 0;
			END;
		ELSIF pDic = 'TRN' THEN
			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qty
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'TRN'
					AND ttpc = '4S'
					AND dmd_cd IN ('A','F','G','K','L','Z');
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					qty := 0;
			END;
		ELSIF pDic = 'ISU' THEN
			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qty
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'ISU'
					AND ttpc IN ('1A','3P','3Q');
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					qty := 0;
			END;
		ELSIF pDic = 'MSI' THEN
			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qty
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'MSI'
					AND ttpc IN ('1C','1G','1O','1Q','2I','2K','3P');
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					qty := 0;
			END;
		ELSIF pDic = 'DUO' THEN
			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qty
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'DUO'
					AND ttpc IN ('2D','4W');
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					qty := 0;
			END;
		ELSIF pDic = 'DOC' THEN
			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qtyd1
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'DOC'
					AND ttpc IN ('2A','2C')
					AND reason IN ('B','C','J','V','X');
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					qtyd1 := 0;
			END;

			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qtyd2
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'DOC'
					AND ttpc NOT IN ('2A','2C')
					AND reason IN ('A','F','G','K','L','Z');
				EXCEPTION
			WHEN NO_DATA_FOUND THEN
				qtyd2 := 0;
			END;

			qty := qtyd1 + qtyd2;
		END IF;

		RETURN(qty);

	END CalcQuantity;


	FUNCTION CalcBadQuantity(
							pDocNo VARCHAR2,
							pDic VARCHAR2) RETURN NUMBER IS
		qty      NUMBER := 0;
	BEGIN

		IF pDic = 'TIN' THEN
			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qty
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'TIN'
					AND ttpc = '1B'
					AND reason NOT IN ('B','C','J','V','X','A','D','F','G','K',
										'L','Z','1','2','3','4','5','6','7','8','9');
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					qty := 0;
			END;
		ELSIF pDic = 'TRN' THEN
			BEGIN
				SELECT
					NVL(SUM(action_qty),0)
				INTO qty
				FROM TMP_LCF_ICP
				WHERE doc_no = pDocNo
					AND dic = 'TRN'
					AND ttpc = '4S'
					AND dmd_cd NOT IN ('A','F','G','K','L','Z');
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					qty := 0;
			END;
		END IF;

		RETURN(qty);

	END CalcBadQuantity;


	PROCEDURE InsertTmpLcf1 IS
	BEGIN

		INSERT INTO TMP_LCF_1
		(
			stock_no,
			erc,
			dic,
			ttpc,
			dmd_cd,
			reason,
			doc_no,
			trans_date,
			trans_ser,
			action_qty,
			sran,
			nomenclature,
			marked_for,
			date_of_last_demand,
			unit_of_issue,
			supplemental_address
		)
		SELECT
			stock_no,
			erc,
			dic,
			ttpc,
			dmd_cd,
			reason,
			doc_no,
			TO_DATE(trans_date,'yyyyddd'),
			trans_ser,
			action_qty,
			sran,
			nomenclature,
			marked_for,
			TO_DATE(date_of_last_demand,'yyyyddd'),
			unit_of_issue,
			supplemental_address
		FROM TMP_LCF_RAW
		WHERE SUBSTR(doc_no,1,1) IN ('X','J','R','B','S')
		GROUP BY
			stock_no,
			erc,
			dic,
			ttpc,
			dmd_cd,
			reason,
			doc_no,
			TO_DATE(trans_date,'yyyyddd'),
			trans_ser,
			action_qty,
			sran,
			nomenclature,
			marked_for,
			TO_DATE(date_of_last_demand,'yyyyddd'),
			unit_of_issue,
			supplemental_address;

		COMMIT;

		UPDATE TMP_LCF_1 SET
			nsn = SUBSTR(stock_no,1,13),
			mmc = SUBSTR(stock_no,14,2),
			sran = 'FB'||sran;

		COMMIT;

	END InsertTmpLcf1;


	PROCEDURE InsertTmpLcfIcp IS
	BEGIN

		INSERT INTO TMP_LCF_ICP
		(
			nsn,
			mmc,
			stock_no,
			erc,
			dic,
			ttpc,
			dmd_cd,
			reason,
			doc_no,
			trans_date,
			trans_ser,
			action_qty,
			sran,
			nomenclature,
			marked_for,
			date_of_last_demand,
			supplemental_address
		)
		SELECT
			nsn,
			mmc,
			stock_no,
			erc,
			dic,
			ttpc,
			dmd_cd,
			reason,
			doc_no,
			trans_date,
			trans_ser,
			action_qty,
			DECODE(asn.loc_type,'TMP',asn.mob,sran) sran,
			nomenclature,
			marked_for,
			date_of_last_demand,
			supplemental_address
		FROM
			TMP_LCF_1 tl1,
			AMD_SPARE_NETWORKS asn
		WHERE
			tl1.sran = asn.loc_id;

		COMMIT;

	END InsertTmpLcfIcp;



	PROCEDURE InsertL67TmpLcfIcp IS
		CURSOR l67Cur IS
			SELECT DISTINCT
				nsn,
				mmc,
				erc,
				tric,
				ttpc,
				dmd_cd,
				reason,
				doc_no,
				trans_date,
				trans_ser,
				action_qty,
				DECODE(asn.loc_type,'TMP',asn.mob,sran) sran,
				nomenclature,
				marked_for,
				dold,
				supp_address
			FROM
				AMD_L67_SOURCE als,
				AMD_SPARE_NETWORKS asn
			WHERE
				SUBSTR(als.doc_no,1,1) IN ('X','J','R','B','S')
				AND als.sran = asn.loc_id;

		nsn         VARCHAR2(20);
		mmacCode    NUMBER;
	BEGIN

		FOR rec IN l67Cur LOOP
			BEGIN
				mmacCode := rec.mmc;
				nsn      := rec.nsn||rec.mmc;
			EXCEPTION
				WHEN OTHERS THEN
					nsn := rec.nsn;
			END;

			INSERT INTO TMP_LCF_ICP
			(
				nsn,
				mmc,
				stock_no,
				erc,
				dic,
				ttpc,
				dmd_cd,
				reason,
				doc_no,
				trans_date,
				trans_ser,
				action_qty,
				sran,
				nomenclature,
				marked_for,
				date_of_last_demand,
				supplemental_address
			)
			VALUES
			(
				nsn,
				rec.mmc,
				nsn,
				rec.erc,
				rec.tric,
				rec.ttpc,
				rec.dmd_cd,
				rec.reason,
				rec.doc_no,
				rec.trans_date,
				rec.trans_ser,
				rec.action_qty,
				rec.sran,
				rec.nomenclature,
				rec.marked_for,
				rec.dold,
				rec.supp_address
			);

		END LOOP;

		COMMIT;

	END;



	--
	-- LoadAmdDemands -
	--
	-- procedure to load amd_af_reqs from lcf data.
	--
	-- currently, we manually load lcf data into tmp_lcf_raw, tmp_lcf_1,
	-- tmp_lcf_icp tables manually.  we do not know at this time how we would
	-- receive the lcf data in the future.
	--
	-- assume we have data loaded into tmp_lcf_icp, the follows are processes
	-- to be perform to load data into amd_af_reqs table.
	--
	-- 1) loop for each doc_no.
	-- 2) for each doc_no:
	-- 	2.1) select sum of qualified tin into goodtin
	-- 	2.2) select sum of non-qualified tin into badtin
	-- 	2.3) select sum of qualified trn into goodtrn
	-- 	2.4) select sum of non-qualified trn into badtrn
	-- 	2.5) calculate tin quantity:
	-- 						tinqty = goodtin + goodtrn
	-- 	2.6) calculate badtin quantity:
	-- 			badtinqty = badtin + badtrn
	-- 2.7) select sum of qualified isu
	-- 2.8) select sum of qualified msi
	-- 2.9) select sum of qualified duo
	-- 2.10)select sum of qualified doc
	-- 2.11)calculate duo quantity:
	-- 			duoqty = duo - doc.
	-- 		  note: if duoqty is negative, set duoqty = 0.
	-- 2.12)calculate non tin quantity:
	-- 			ntinqty = isu + msi + duoqty - badtinqty
	-- 	2.13)calculate other quantity:
	-- 			otherqty = ntinqty - tinqty
	-- 2.14)calculate requisition quantity:
	-- 				if otherqty > 0 then
	-- 							qty		= tinqty + otherqty
	--					else
	--                      qty		= tinqty
	--					end if
	--	2.15) if the qty = 0, do not insert the requisition.
	--
	-- 3) select nsn of the doc_no and select prime part from amd_spare_parts
	-- 4) use trans_date as requistion_date
	-- 5) insert into amd_demands table.
	--
	PROCEDURE LoadAmdDemands IS
		vNsn         VARCHAR2(20);
		tinqty       NUMBER := 0;
		ntinqty      NUMBER := 0;
		otherqty     NUMBER := 0;
		qty	       NUMBER := 0;
		goodtin      NUMBER := 0;
		badtin       NUMBER := 0;
		goodtrn      NUMBER := 0;
		badtrn       NUMBER := 0;
		badtinqty    NUMBER := 0;
		isu          NUMBER := 0;
		msi          NUMBER := 0;
		duo          NUMBER := 0;
		doc          NUMBER := 0;
		duoqty       NUMBER := 0;
		reqDate      DATE;
		lcf1cnt      NUMBER;
		nsiSid       NUMBER;
		loadNo       NUMBER;

		CURSOR docCur IS
			SELECT
				tli.doc_no,
				asn.loc_sid,
				MIN(tli.trans_date) trans_date
			FROM
				TMP_LCF_ICP tli,
				AMD_SPARE_NETWORKS asn
			WHERE
				tli.sran = asn.loc_id
			GROUP BY
				tli.doc_no,
				asn.loc_sid;


	BEGIN
		loadNo := Amd_Utils.GetLoadNo('AMD_DEMAND','AMD_DEMANDS');

		--
		-- if there are no records in tmp_lcf_1 then
		-- insert them from tmp_lcf_raw
		--
		SELECT COUNT(*)
		INTO lcf1cnt
		FROM TMP_LCF_1;

		IF (lcf1cnt = 0) THEN
			InsertTmpLcf1;
		END IF;

		InsertTmpLcfIcp;                         --* limits locations to the ones specified in amd_spare_networks
		InsertL67TmpLcfIcp;

		FOR rec IN docCur LOOP

			goodtin   := CalcQuantity(rec.doc_no, 'TIN');
			badtin    := CalcBadQuantity(rec.doc_no, 'TIN');
			goodtrn   := CalcQuantity(rec.doc_no, 'TRN');
			badtrn    := CalcBadQuantity(rec.doc_no, 'TRN');
			tinqty    := goodtin + goodtrn;
			badtinqty := badtin  + badtrn;

			isu       := CalcQuantity(rec.doc_no, 'ISU');
			msi       := CalcQuantity(rec.doc_no, 'MSI');
			duo       := CalcQuantity(rec.doc_no, 'DUO');
			doc       := CalcQuantity(rec.doc_no, 'DOC');

			duoqty    := duo - doc;

			IF duoqty < 0 THEN
				duoqty := 0;
			END IF;

			ntinqty   := isu + msi + duoqty - badtinqty;
			otherqty  := ntinqty - tinqty;

			IF otherqty > 0 THEN
				qty    := tinqty + otherqty;
			ELSE
				qty    := tinqty;
			END IF;

			IF qty != 0 THEN

				--
				--  Get the NSN to use for BSSM
				--
				IF tinqty > 0 THEN
					SELECT MAX(nsn)
					INTO vNsn
					FROM TMP_LCF_ICP
					WHERE doc_no = rec.doc_no
						AND dic IN ('TIN', 'TRN');
				ELSE
					SELECT MAX(nsn)
					INTO vNsn
					FROM TMP_LCF_ICP
					WHERE doc_no = rec.doc_no
						AND dic NOT IN ('TIN', 'TRN');
				END IF;

				IF (vNsn IS NOT NULL) THEN
					reqDate := rec.trans_date;

					--
					-- send data to bssm table for extract to bssm
					--
					INSERT INTO AMD_BSSM_SOURCE
					(
						requisition_no,
						requisition_date,
						quantity,
						loc_sid,
						nsn
					)
					VALUES
					(
						rec.doc_no,
						reqDate,
						qty,
						rec.loc_sid,
						vNsn
					);

					BEGIN
						nsiSid := Amd_Utils.GetNsiSid(pNsn=>vNsn);

						INSERT INTO TMP_AMD_DEMANDS
						(
							doc_no,
							doc_date,
							nsi_sid,
							loc_sid,
							quantity,
							action_code,
							last_update_dt
						)
						VALUES
						(
							rec.doc_no,
							reqDate,
							nsiSid,
							rec.loc_sid,
							qty,
							Amd_Defaults.INSERT_ACTION,
							SYSDATE
						);

					EXCEPTION
						WHEN NO_DATA_FOUND THEN
							NULL;      -- nsiSid not found generates this, just ignore
--						when others then
--							amd_utils.InsertErrorMsg(loadNo,'AMD_DEMAND.LoadAmdDemands',
--									'Exception: OTHERS','insert into tmp_amd_demands',null,sysdate,
--									pMsg=>substr(sqlerrm,1,2000));
					END;

				END IF;

			END IF;

		END LOOP;

	END LoadAmdDemands;



	PROCEDURE LoadBascUkDemands IS
		CURSOR demandCur IS
			SELECT
				RTRIM(c.nsn) nsn,
				RTRIM(r.request_id) request_id,
				r.created_datetime,
				(NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) quantity,
				asn.loc_sid,
				RTRIM(r.prime) prime
			FROM
				REQ1 r,
				CAT1 c,
				(SELECT
					DECODE(asn1.loc_type,'TMP',asn2.loc_sid,asn1.loc_sid) loc_sid,
					DECODE(asn1.loc_type,'TMP',asn2.loc_id ,asn1.loc_id ) loc_id
				FROM
					AMD_SPARE_NETWORKS asn1,
					AMD_SPARE_NETWORKS asn2
				WHERE
					asn1.mob = asn2.loc_id(+)) asn
			WHERE
				r.prime = c.part
				AND r.nsn IS NOT NULL
				AND r.request_id LIKE 'EY1746%'
				AND r.select_from_sc LIKE 'C17%'
				AND (NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) != 0
				AND SUBSTR(request_id,11,1) != 'S'
				AND r.status != 'X'
				AND SUBSTR(r.request_id,1,6) = asn.loc_id
			UNION
			SELECT
				RTRIM(c.nsn) nsn,
				RTRIM(r.request_id) request_id,
				r.created_datetime,
				(NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) quantity,
				asn.loc_sid,
				RTRIM(r.prime) prime
			FROM
				REQ1 r,
				CAT1 c,
				(SELECT
					DECODE(asn1.loc_type,'TMP',asn2.loc_sid,asn1.loc_sid) loc_sid,
					DECODE(asn1.loc_type,'TMP',asn2.loc_id,asn1.loc_id ) loc_id
				FROM
					AMD_SPARE_NETWORKS asn1,
					AMD_SPARE_NETWORKS asn2
				WHERE
					asn1.mob = asn2.loc_id(+)) asn
			WHERE
				r.prime = c.part
				AND r.nsn IS NOT NULL
				AND r.select_from_sc LIKE 'C17%'
				AND r.request_id LIKE 'EY1213%'
				AND asn.loc_id = 'EY1746'
				AND (NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) != 0
				AND SUBSTR(request_id,11,1) != 'S'
				AND r.status != 'X'
				UNION
			SELECT
				RTRIM(c.nsn) nsn,
				RTRIM(r.request_id) request_id,
				r.created_datetime,
				(NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) quantity,
				asn.loc_sid,
				RTRIM(r.prime) prime
			FROM
				REQ1 r,
				CAT1 c,
				(SELECT
					DECODE(asn1.loc_type,'TMP',asn2.loc_sid,asn1.loc_sid) loc_sid,
					DECODE(asn1.loc_type,'TMP',asn2.loc_id,asn1.loc_id ) loc_id
				FROM
					AMD_SPARE_NETWORKS asn1,
					AMD_SPARE_NETWORKS asn2
				WHERE
					asn1.mob = asn2.loc_id(+)) asn
			WHERE
				r.prime = c.part
				AND r.nsn IS NOT NULL
				AND r.select_from_sc LIKE 'C17%'
				AND r.request_id LIKE 'FB2065%'
				AND asn.loc_id = 'EY1746'
				AND (NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) != 0
				AND SUBSTR(request_id,11,1) != 'S'
				AND r.status != 'X'
				UNION
			 SELECT
				RTRIM(c.nsn) nsn,
				RTRIM(r.request_id) request_id,
				r.created_datetime,
				(NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) quantity,
				asn.loc_sid,
				RTRIM(r.prime) prime
			FROM
				REQ1 r,
				CAT1 c,
				(SELECT
					DECODE(asn1.loc_type,'TMP',asn2.loc_sid,asn1.loc_sid) loc_sid,
					DECODE(asn1.loc_type,'TMP',asn2.loc_id,asn1.loc_id ) loc_id
				FROM
					AMD_SPARE_NETWORKS asn1,
					AMD_SPARE_NETWORKS asn2
				WHERE
					asn1.mob = asn2.loc_id(+)) asn
			WHERE
				r.prime = c.part
				AND r.nsn IS NOT NULL
				AND r.select_from_sc LIKE 'C17%'
				AND r.request_id LIKE 'FB2029%'
				AND asn.loc_id = 'EY1746'
				AND (NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) != 0
				AND SUBSTR(request_id,11,1) != 'S'
				AND r.status != 'X'
				UNION
			SELECT
				RTRIM(c.nsn) nsn,
				RTRIM(r.request_id) request_id,
				r.created_datetime,
				(NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) quantity,
				asn.loc_sid,
				RTRIM(r.prime) prime
			FROM
				REQ1 r,
				CAT1 c,
				(SELECT
					DECODE(asn1.loc_type,'TMP',asn2.loc_sid,asn1.loc_sid) loc_sid,
					DECODE(asn1.loc_type,'TMP',asn2.loc_id,asn1.loc_id ) loc_id
				FROM
					AMD_SPARE_NETWORKS asn1,
					AMD_SPARE_NETWORKS asn2
				WHERE
					asn1.mob = asn2.loc_id(+)) asn
			WHERE
				r.prime = c.part
				AND r.nsn IS NOT NULL
				AND r.select_from_sc LIKE 'C17%'
				AND r.request_id LIKE 'FB2039%'
				AND asn.loc_id = 'EY1746'
				AND (NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) != 0
				AND SUBSTR(request_id,11,1) != 'S'
				AND r.status != 'X'
			UNION
			SELECT
				RTRIM(c.nsn) nsn,
				RTRIM(r.request_id) request_id,
				r.created_datetime,
				(NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) quantity,
				asn.loc_sid,
				RTRIM(r.prime) prime
			FROM
				REQ1 r,
				CAT1 c,
				(SELECT
					DECODE(asn1.loc_type,'TMP',asn2.loc_sid,asn1.loc_sid) loc_sid,
					DECODE(asn1.loc_type,'TMP',asn2.loc_id ,asn1.loc_id ) loc_id
				FROM
					AMD_SPARE_NETWORKS asn1,
					AMD_SPARE_NETWORKS asn2
				WHERE
					asn1.mob = asn2.loc_id(+)) asn
			WHERE
				r.prime = c.part
				AND r.nsn IS NOT NULL
				AND r.select_from_sc LIKE 'C17%'
				AND r.request_id LIKE 'EY8780%'
				AND r.status != 'X'
				AND (NVL(r.qty_issued ,0)+ NVL(r.qty_due,0) + NVL(r.qty_reserved,0)) != 0
				AND SUBSTR(r.request_id,1,6) = asn.loc_id
			ORDER BY
				1;
				
	 CURSOR demandSACur IS
		   SELECT
				 RTRIM(o.order_no) order_no,
				 o.created_datetime,
				 (NVL(o.qty_due,0) + NVL(o.qty_completed,0)) quantity,
				 asn.loc_sid,
				 RTRIM(o.part) part_no
		  FROM
				 ORD1 o,
				 CAT1 c,
				 (SELECT
					DECODE(asn1.loc_type,'TMP',asn2.loc_sid,asn1.loc_sid) loc_sid,
					DECODE(asn1.loc_type,'TMP',asn2.loc_id ,asn1.loc_id ) loc_id
				 FROM
					AMD_SPARE_NETWORKS asn1,
					AMD_SPARE_NETWORKS asn2
				 WHERE
					asn1.mob = asn2.loc_id(+)) asn
          WHERE
				 RTRIM(o.part) = RTRIM(c.part)
				 AND o.sc LIKE 'C17%'
				 AND o.order_no LIKE 'SA%'
				 AND SUBSTR(o.sc ,8,6) != 'MODKLY'
				 AND asn.loc_id LIKE 'EY1746%'
				 AND o.order_type  = 'C'
				 AND o.status != 'C'
				 AND (NVL(o.qty_due,0) + NVL(o.qty_completed,0)) != 0
				 AND TO_CHAR(o.created_docdate,'mm/dd/yyyy') < '04/01/2005';

		loadNo    NUMBER;
		nsiSid    NUMBER;
		nsnAmd    VARCHAR2(20);
	BEGIN
		loadNo := Amd_Utils.GetLoadNo('REQ1','AMD_DEMANDS');

		FOR rec IN demandCur LOOP

			nsnAmd := Amd_Utils.FormatNsn(rec.nsn,'AMD');

			INSERT INTO AMD_BSSM_SOURCE
			(
				requisition_no,
				requisition_date,
				quantity,
				loc_sid,
				nsn
			)
			VALUES
			(
				rec.request_id,
				rec.created_datetime,
				rec.quantity,
				rec.loc_sid,
				nsnAmd
			);

			BEGIN
				nsiSid := Amd_Utils.GetNsiSid(pPart_no=>rec.prime);

				INSERT INTO TMP_AMD_DEMANDS
				(
					doc_no,
					doc_date,
					nsi_sid,
					loc_sid,
					quantity,
					action_code,
					last_update_dt
				)
				VALUES
				(
					rec.request_id,
					rec.created_datetime,
					nsiSid,
					rec.loc_sid,
					rec.quantity,
					Amd_Defaults.INSERT_ACTION,
					SYSDATE
				);

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					NULL;      -- nsiSid not found generates this, just ignore
--				when others then
--					amd_utils.InsertErrorMsg(loadNo,'AMD_DEMAND.LoadBascUkDemands',
--							'Exceptions: OTHERS','insert into tmp_amd_demands',null,sysdate,
--							pMsg=>substr(sqlerrm,1,2000));
			END;
		END LOOP;
      
      FOR rec IN demandSaCur LOOP
		   BEGIN
			 	nsiSid := Amd_Utils.GetNsiSid(pPart_no=>rec.part_no);
				 
				INSERT INTO TMP_AMD_DEMANDS
				 (
				  		doc_no,
						doc_date,
						nsi_sid,
						loc_sid,
						quantity,
						action_code,
						last_update_dt
				 )
            VALUES
				 (
				  	   rec.order_no,
					   rec.created_datetime,
					   nsiSid,
					   rec.loc_sid,
					   rec.quantity,
					   Amd_Defaults.INSERT_ACTION,
					   SYSDATE
				 );
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
				  NULL;
		   END;
		END LOOP;

	END;

	PROCEDURE amd_demand_a2a IS

	   CURSOR get_new_demands_cur IS
	   SELECT doc_no, doc_date, doc_date_defaulted, nsi_sid, loc_sid,
	          quantity, action_code, last_update_dt
	     FROM TMP_AMD_DEMANDS a
	    WHERE NOT EXISTS (SELECT 'x'
	                        FROM AMD_DEMANDS b
			       WHERE a.doc_no = b.doc_no
				 AND a.loc_sid = b.loc_sid);

	   lv_amd_send_a2a_chk			NUMBER;
	   lv_part_no						AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE;
	   lv_loc_id						AMD_SPARE_NETWORKS.loc_id%TYPE;

	BEGIN
	   FOR get_new_demands_rec IN get_new_demands_cur LOOP
	   
   -- insert into amd_demands just the additions from tmp_amd_demands
	     INSERT INTO AMD_DEMANDS VALUES
		    (get_new_demands_rec.doc_no,
		     get_new_demands_rec.doc_date,
		     get_new_demands_rec.doc_date_defaulted,
		     get_new_demands_rec.nsi_sid,
		     get_new_demands_rec.loc_sid,
		     get_new_demands_rec.quantity,
		     get_new_demands_rec.action_code,
		     get_new_demands_rec.last_update_dt
	       );

	-- checks to see if all the part info is complete before sending over to A2A
	     SELECT COUNT(*)
	       INTO lv_amd_send_a2a_chk
	       FROM AMD_NATIONAL_STOCK_ITEMS a, AMD_SENT_TO_A2A b
	      WHERE a.nsi_sid = get_new_demands_rec.nsi_sid
	        AND a.prime_part_no = b.part_no
			AND b.action_code != 'D'; -- 12/07/2005 DSE if the action code is a D, then it no longer exists in the Spo system

	     IF lv_amd_send_a2a_chk != 0 THEN
	-- gets the master prime part no more than one demand can relate to a single prime part

	       lv_part_no := Amd_Partprime_Pkg.getSuperPrimePartByNsiSid(get_new_demands_rec.nsi_sid);

	       IF lv_part_no IS NULL THEN -- Can't find the Prime Part for whatever reason
	         NULL;                    -- bypass but leave on tmp_amd_demands
	       ELSE
	         SELECT spo_location     -- changed from loc_id to spo_location . Thuy 2/16/06
			     INTO lv_loc_id
			     FROM AMD_SPARE_NETWORKS
	          WHERE loc_sid = get_new_demands_rec.loc_sid;
			  
			 IF A2a_Pkg.isPartValid(lv_part_no) AND A2a_Pkg.wasPartSent(lv_part_no) THEN -- 12/07/2005 DSE make sure the part meets all the criteria to be sent to the Spo  
	            INSERT INTO TMP_A2A_DEMANDS
	              (part_no,
	               site,
	               docno,
	               demand_date,
	               qty,
	               demand_level,
	               action_code,
	               last_update_dt)
	            VALUES
		           (lv_part_no,
		            lv_loc_id,
		            get_new_demands_rec.doc_no,
		            get_new_demands_rec.doc_date,
		            get_new_demands_rec.quantity,
		            NULL,
		            'A',
		            SYSDATE
		           );
				END IF ;

	       END IF;

	     END IF;

	   END LOOP;

	EXCEPTION
	   WHEN NO_DATA_FOUND THEN
	      RAISE_APPLICATION_ERROR (-20001,'no data found amd_demand_a2a proc for loc_id, amd_spare_networks');
	   WHEN OTHERS THEN
	      RAISE_APPLICATION_ERROR (-20001,'OTHERS: amd_demand_a2a proc SQLERRM '||SQLERRM||' SQLCODE '||SQLCODE);
  END amd_demand_a2a;

  PROCEDURE prime_part_change (old_part_no AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE,
                               new_part_no AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE) AS

     CURSOR get_nsi_sid_cur (cv_prime_part_no	AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE)IS
     SELECT nsi_sid
       FROM AMD_NATIONAL_STOCK_ITEMS
      WHERE prime_part_no = cv_prime_part_no;

     CURSOR get_demands_cur (cv_nsi_sid   AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE) IS
     SELECT a.doc_no, a.doc_date, a.doc_date_defaulted, a.nsi_sid, b.spo_location,  -- changed loc_id to spo_location . Thuy 2/16/06
	         a.quantity, a.action_code, a.last_update_dt
	    FROM AMD_DEMANDS a, AMD_SPARE_NETWORKS b
	   WHERE a.nsi_sid = cv_nsi_sid
	     AND a.loc_sid = b.loc_sid;

  BEGIN
--  This iteration is for all the 'D' using the old_part_no being passed
--  Then read them with the new_part_no being passed

  	  FOR get_nsi_sid_rec IN get_nsi_sid_cur (old_part_no) LOOP
  	    FOR get_demands_rec IN get_demands_cur (get_nsi_sid_rec.nsi_sid) LOOP

         IF A2a_Pkg.isPartValid(old_part_no) AND A2a_Pkg.wasPartSent(old_part_no) THEN
           INSERT INTO TMP_A2A_DEMANDS
             (part_no,
              site,
              docno,
              demand_date,
              qty,
              demand_level,
              action_code,
              last_update_dt)
           VALUES
             (old_part_no,
              get_demands_rec.spo_location,
              get_demands_rec.doc_no,
			 	  get_demands_rec.doc_date,
			 	  get_demands_rec.quantity,
			 	  NULL,
			 	  'D',
			 	  SYSDATE);
         END IF;
         
         IF A2a_Pkg.isPartValid(new_part_no) AND A2a_Pkg.wasPartSent(new_part_no) THEN
           INSERT INTO TMP_A2A_DEMANDS
             (part_no,
              site,
              docno,
              demand_date,
              qty,
              demand_level,
              action_code,
              last_update_dt)
           VALUES
             (new_part_no,
              get_demands_rec.spo_location,
              get_demands_rec.doc_no,
			 	  get_demands_rec.doc_date,
			 	  get_demands_rec.quantity,
			 	  NULL,
			 	  'A',
			 	  SYSDATE);
         END IF;
		 END LOOP;
	  END LOOP;
  END;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_demand', 
		 		pError_location => 10, pKey1 => 'amd_demand', pKey2 => '$Revision:   1.20  $') ;
	end version ;
	
END Amd_Demand;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_defaults as

	/*

     $Author:   zf297a  $
   $Revision:   1.27  $
       $Date:   Jun 09 2006 12:55:38  $
   $Workfile:   amd_defaults.pkb  $
       $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_defaults.pkb-arc  $
   
      Rev 1.27   Jun 09 2006 12:55:38   zf297a
   implemented version
   
      Rev 1.26   Jan 05 2006 12:23:28   zf297a
   Fixed getNslLogonId - was using the NSN_PLANNER_CODE instead of the NSL_PLANNER_CODE
   
      Rev 1.25   Dec 02 2005 10:18:10   zf297a
   Fixed getNsnPlannerCode, getNslPlannerCode, getNsnLogonId, and getNslLogonId so that they always return a default value. NOTE: if the literal is returned, it may not be a valid planner_code or logon_id.  In that case the data may no go to the SPO correctly unless RJBplanner.xml and RichellBodine.xml is sent manully to the SPO!
   
      Rev 1.24   Nov 30 2005 10:57:38   zf297a
   added getBom, getBomQuantity, and used these new functions to get data from the amd_param_changes table, if there is not data found bom defaults to 'C17' and bom_quantity defaults to 1.
   
      Rev 1.23   Nov 01 2005 12:32:52   zf297a
   Added some more "getter" functions for other constants.
   
      Rev 1.22   Nov 01 2005 12:21:34   zf297a
   Simplified the name of the "getter's" to getCONSTANT where CONSTANT is the identifier for the associated constant.
   
      Rev 1.21   Nov 01 2005 11:50:32   zf297a
   Added "getter 's" (get functions) for some of the constant's so they can be used in ordinary SQL instead of only in PL/SQL code.
   
      Rev 1.20   Sep 13 2005 11:04:22   zf297a
   Implemented interfaces for isParamKey and addParamKey.
   
      Rev 1.19   Aug 15 2005 11:43:36   zf297a
   Removed all debugMsg's since they were causing more trouble than they were worth.
   
      Rev 1.18   Aug 09 2005 11:50:20   zf297a
   Removed debugMsg that reports a missing logon_id / planner_code in amd_planner_logons since this caused an error with DataStage's query since it was inserting data into amd_load_details, which is not allowed for only a DataStage query.
   
      Rev 1.17   Aug 05 2005 11:27:02   zf297a
   Removed raise_application errors and made them into debugMsg's.  This is better than having a hard error here, since  execution should continue and the reported condition can be corrected at another time.
   
      Rev 1.16   Jul 27 2005 10:24:38   zf297a
   Streamlined code for default planner_codes and logon_id's
   
      Rev 1.15   Jul 26 2005 15:10:28   zf297a
   added additional edits for the default logon_id's
   
      Rev 1.14   Jul 08 2005 09:36:32   zf297a
   Added PVCS keyword $Log$ and copied the PVCS history log into the header comments. 

		Rev 1.13
		Locked by:      zf297a
		Checked in:     Jul 08 2005 09:08:36
		Last modified:  Jul 08 2005 09:08:36
		Author id: zf297a     lines deleted/added/moved: 2/11/0
		added the public function getLogonId
		-----------------------------------
		Rev 1.12
		Checked in:     Jul 08 2005 08:58:34
		Last modified:  Jul 08 2005 08:58:34
		Author id: zf297a     lines deleted/added/moved: 6/11/0
		Added the public function getPlannerCode
		-----------------------------------
		Rev 1.11
		Checked in:     Jul 05 2005 13:54:12
		Last modified:  Jul 05 2005 13:54:12
		Author id: zf297a     lines deleted/added/moved: 2/6/0
		added $Log$ PVCS keyword
		-----------------------------------
		Rev 1.10
		Checked in:     Jul 05 2005 13:50:52
		Last modified:  Jul 05 2005 13:50:52
		Author id: zf297a     lines deleted/added/moved: 3/56/0
		Added NSN_PLANNER_CODE and NSL_PLANNER_CODE and their corresponding logon_id's: NSN_LOGON_ID and NSL_LOGON_ID.
		-----------------------------------
		Rev 1.9
		Checked in:     Mar 27 2002 12:22:38
		Last modified:  Mar 27 2002 12:22:38
		Author id: c970183     lines deleted/added/moved: 0/6/0
		Added PVCS keywords
		-----------------------------------
		Rev 1.8
		Checked in:     Nov 30 2001 06:28:40
		Last modified:  Nov 02 2001 10:22:08
		Author id: c372701     lines deleted/added/moved: 26/130/0
		gw - 11/29/01 - Updates due to system problems on the Version Manager NT Server. - Done to reflect latest changes - per Doug Elder
		-----------------------------------
		Rev 1.7
		Checked in:     Oct 28 2001 15:08:28
		Last modified:  Oct 28 2001 12:40:22
		Author id: c378632     lines deleted/added/moved: 0/12/0
		unit_cost_factor_offbase
		time_to_repair_offbase
		-----------------------------------
		Rev 1.6
		Checked in:     Oct 28 2001 11:31:26
		Last modified:  Oct 28 2001 11:21:32
		Author id: c378632     lines deleted/added/moved: 0/12/0
		time_to_repair_onbase,
		cost_to_repair_onbase
		-----------------------------------
		Rev 1.5
		Checked in:     Oct 25 2001 09:57:38
		Last modified:  Oct 25 2001 09:57:04
		Author id: c970183     lines deleted/added/moved: 48/178/0
		Made action codes, consumable, and repairable constants.
		-----------------------------------
		Rev 1.4
		Checked in:     Oct 25 2001 09:48:00
		Last modified:  Oct 25 2001 09:48:00
		Author id: c970183     lines deleted/added/moved: 196/48/0
		Added constants repairable and consumable.
		-----------------------------------
		Rev 1.3
		Checked in:     Oct 25 2001 07:14:08
		Last modified:  Oct 25 2001 07:13:40
		Author id: c970183     lines deleted/added/moved: 2/20/0
		Added routines to initialize the Action Codes from the amd_param_changes table
		-----------------------------------
		Rev 1.2
		Checked in:     Oct 23 2001 14:33:58
		Last modified:  Oct 23 2001 14:28:42
		Author id: c970183     lines deleted/added/moved: 45/175/0
		Made implementation updates
		-----------------------------------
		Rev 1.1
		Checked in:     Oct 18 2001 07:00:10
		Last modified:  Oct 18 2001 06:59:22
		Author id: c970183     lines deleted/added/moved: 172/51/0
		Changed to use new amd_param_changes table
		-----------------------------------
		Rev 1.0
		Checked in:     Oct 11 2001 08:19:52
		Last modified:  Oct 11 2001 07:33:40
		Author id: c372701     lines deleted
		
	  The order_lead_time_........ variables will be initialized by the
	  package body's 'begin' block.  This will happen the first time
	  the package is referenced.
	  */
	order_lead_time_consumable 			amd_spare_parts.order_lead_time_defaulted%type := null ;
	order_lead_time_repairable 			amd_spare_parts.order_lead_time_defaulted%type := null ;
	engine_part_reduction_factor 		number := null ;
	non_engine_part_reductn_factor		number := null ;
	consumable_reduction_factor			number := null ;

	
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_defaults',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	procedure debugMsg(
					sqlFunction IN VARCHAR2,
					tableName IN VARCHAR2,
					rptLocation IN NUMBER,
					key1 IN VARCHAR2 := '',
			 		key2 IN VARCHAR2 := '',
					key3 IN VARCHAR2 := '',
					key4 IN VARCHAR2 := '',
					key5 in varchar2 := '',					
					keywordValuePairs IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => sqlFunction,
						pTableName  => tableName),
				pData_line_no => rptLocation,
				pData_line    => 'amd_defaults',
				pKey_1 => key1,
				pKey_2 => key2,
				pKey_3 => key3,
				pKey_4 => key4,
				pKey_5 => key5 || ' ' || to_char(SYSDATE,'MM/DD/YY HH:MM:SS') ||
						   ' ' || keywordValuePairs,
				pComments => 'sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')');
		COMMIT;
		RETURN ;
	END debugMsg;

	-- put a wrapper around debugMsg so it will only write one message to amd_load_details
	procedure displayOnce(
					sqlFunction IN VARCHAR2,
					tableName IN VARCHAR2,
					rptLocation IN NUMBER,
					key1 IN VARCHAR2 := '',
			 		key2 IN VARCHAR2 := '',
					key3 IN VARCHAR2 := '',
					key4 IN VARCHAR2 := '',
					key5 in varchar2 := '',					
					keywordValuePairs IN VARCHAR2 := '')  IS
					
		-- rptLocation must be unique for a given package for this to work
		cursor loadDetails is
			 select load_no
			 from amd_load_details
			 where amd_load_details.DATA_LINE = 'amd_defaults'
			 and amd_load_details.DATA_LINE_NO = rptLocation ;
			 
		recExists boolean := false ;
		
	begin
		 for rec in loadDetails loop
		 	 recExists := true ;
		 	 exit ;
		 end loop ;
		 
		 if not recExists then
			 debugMsg(sqlFunction => sqlFunction,
						tableName => tableName,
						rptLocation => rptLocation,
						key1 => key1,
				 		key2 => key2,
						key3 => key3,
						key4 => key4,
						key5 => key5,					
						keywordValuePairs => keywordValuePairs) ;
		end if ;
		
	end displayOnce ;
	function isParamKey(key in varchar2) return boolean is
			 theKey amd_params.PARAM_KEY%type ;
	begin
		 select param_key into theKey from amd_params where param_key = key ;
		 return true ;
	exception when standard.no_data_found then
		 return false ;
	end isParamKey ;
	
	procedure addParamKey(key in varchar2, description in varchar2) is
	begin
		 insert into amd_params
		 	   (param_key, param_description)
		 values(key, description) ;
	end addParamKey ; 

	procedure setParamValue(key in varchar2, value in varchar2) is
	begin
		 insert into amd_param_changes
		 (param_key, param_value, effective_date, user_id)
		 values (key, value, sysdate, user) ;
	end setParamValue ;
	
	function GetParamValue(key in varchar2) return amd_param_changes.param_value%type is
		value amd_param_changes.param_value%type := null ;
	begin
		select  param_value into value
		from amd_param_changes
		where param_key = key
		and effective_date = (
					select max(effective_date)
					from amd_param_changes
					where param_key = key) ;
		return value ;
	exception when NO_DATA_FOUND then
		return null ;
	end GetParamValue ;

	function GetOrderLeadTime(pItem_type in amd_national_stock_items.item_type%type) return  amd_spare_parts.order_lead_time_defaulted%type is

		function IsConsumable return boolean is
		begin
			return (upper(pItem_type) =  amd_defaults.CONSUMABLE) ;
		end IsConsumable ;

		function IsRepairable return boolean is
		begin
			return (upper(pItem_type) = amd_defaults.REPAIRABLE) ;
		end IsRepairable ;


	begin
			if IsConsumable then
				return order_lead_time_consumable ;
			elsif IsRepairable then
				return order_lead_time_repairable ;
			else
				return null ;
			end if;
	end GetOrderLeadTime ;

	function GetSmrCode(pNsn in varchar2,
		pPart_no in varchar2,
		pMfgr in varchar2,
		pPlanner_code in varchar2) return	varchar2 is
	begin
		return null ; /* todo The field in the
						amd_national_stock_items may not be used
						so this function can be left as is until
						further notice.
						*/
	end GetSmrCode ;

	function GetUnitCost(
		pNsn in amd_spare_parts.nsn%type,
		pPart_no in amd_spare_parts.part_no%type,
		pMfgr in amd_spare_parts.mfgr%type,
		pSmr_code in amd_national_stock_items.smr_code%type,
		pPlanner_code in amd_national_stock_items.planner_code%type) return amd_spare_parts.unit_cost_defaulted%type is

		gfp_price fedc.gfp_price%type := null ;
		unit_cost_defaulted amd_spare_parts.unit_cost_defaulted%type := null ;

		function GetGfpPriceFromFedc(pPart_number in fedc.part_number%type, pVendor_code in fedc.vendor_code%type) return fedc.gfp_price%type is
			min_gfp_price fedc.gfp_price%type := null ;
			max_gfp_price fedc.gfp_price%type := null ;
		begin
			begin
				select min(gfp_price), max(gfp_price)
				into min_gfp_price, max_gfp_price
				from fedc
				where part_number = pPart_number
				and vendor_code = pVendor_code ;
			exception when NO_DATA_FOUND then
				null ;
			end GetViaPartNumberVendorCode ;
			/*
			  If it didn't match on part_number/cage try part_number/nsn
			*/
			if min_gfp_price is null and max_gfp_price is null then
				begin
					select min(gfp_price), max(gfp_price)
					into min_gfp_price, max_gfp_price
					from fedc
					where
						part_number = pPart_number
						and nsn     = amd_utils.FormatNSN(pNsn,'Dash') ;
				exception when NO_DATA_FOUND then
					return null ;
				end GetViaPartNumberNsn ;
			end if ;
			if min_gfp_price != max_gfp_price then
				return null ;
			else
				return min_gfp_price ;
			end if ;
		end GetGfpPriceFromFedc ;

		function IsEnginePart(pPlanner_code in amd_national_stock_items.planner_code%type) return boolean is
		begin
			return (pPlanner_code = 'PSA' or pPlanner_code = 'PSB') ;
		end IsEnginePart ;

		/*
			A quasi-repairable item would be like a frayed rope,
			it can be fixed temporarily but the rope is eventually
			consumed - so in this context the item more closely
			resembles a consumable item.
		*/
		function IsQuasiRepariable(pSmr_code in amd_national_stock_items.smr_code%type) return boolean is
		begin
			if length(pSmr_code) >= 6 then
				return upper(substr(pSmr_code,6,1)) = 'P' ;
			else
				return false ;
			end if ;
		end  IsQuasiRepariable ;

		function IsConsumable(pSmr_code in amd_national_stock_items.smr_code%type) return boolean is
		begin
			if length(pSmr_code) >= 6 then
				return upper(substr(pSmr_code,6,1)) = 'N' ;
			else
				return false ;
			end if ;
		end IsConsumable ;

	begin -- GetUnitCost
		gfp_price := GetGfpPriceFromFedc(pPart_number => pPart_no, pVendor_code => pMfgr) ;

		if gfp_price is not null then
			if IsQuasiRepariable(pSmr_code) or IsConsumable(pSmr_code) then
				unit_cost_defaulted := gfp_price * consumable_reduction_factor ;
			else
				if IsEnginePart(pPlanner_code) then
					unit_cost_defaulted := gfp_price * engine_part_reduction_factor ;
				else
					unit_cost_defaulted := gfp_price * non_engine_part_reductn_factor ;
				end if ;
			end if ;
		end if ;
		return unit_cost_defaulted ; /* defaults to null if there
										isn't a fedc gfp_price.
										*/
	end GetUnitCost ;

	function GetOffBaseRepairCost(
		pUnitCost in number) return number is
	begin
		-- todo
		-- off base repair cost is currently 10% of unit cost.  put the .10 in params table
		return null;
	end GetOffBaseRepairCost;
	
	function getPlannerCode(nsn in varchar2) return varchar2 is
	begin
		 if upper(substr(nsn,1,3)) = 'NSL' then
		 	return nsl_planner_code ;
		 else
		 	return nsn_planner_code ;
		 end if ;
	end getPlannerCode ;
	
	function getLogonId(nsn in varchar2) return varchar2 is
	begin
		 if upper(substr(nsn,1,3)) = 'NSL' then
		 	return nsl_logon_id ;
		 else
		 	return nsn_logon_id ;
		 end if ;
	end getLogonId ;
	
	-- define getter routines for constants so they can be used outside of pl/sql in ordinary sql
	-- dse 11/01/05 
	function getDELETE_ACTION return varchar2 is
	begin
		 return DELETE_ACTION ;
	end getDELETE_ACTION ;
	
	function getINSERT_ACTION return varchar2 is
	begin
		 return INSERT_ACTION ;
	end getINSERT_ACTION ;
	
	function getUPDATE_ACTION return varchar2 is
	begin
		 return UPDATE_ACTION ;
	end getUPDATE_ACTION ;
	
	function getCONSUMABLE return varchar2 is
	begin
		 return CONSUMABLE ;
	end getCONSUMABLE ;
	
	function getREPAIRABLE return varchar2 is
	begin
		 return REPAIRABLE ;
	end getREPAIRABLE ;

	function getAMD_WAREHOUSE_LOCID return varchar2 is
	begin
		 return AMD_WAREHOUSE_LOCID ;
	end getAMD_WAREHOUSE_LOCID ;
	
	function getBSSM_WAREHOUSE_SRAN return varchar2 is
	begin
		 return BSSM_WAREHOUSE_SRAN ;
	end getBSSM_WAREHOUSE_SRAN ;	
	
	function getAMD_UK_LOC_ID return varchar2 is
	begin
		 return AMD_UK_LOC_ID ;
	end getAMD_UK_LOC_ID ;
	
	function getAMD_BASC_LOC_ID return varchar2 is
	begin
		 return AMD_BASC_LOC_ID ;
	end getAMD_BASC_LOC_ID ;
	
	function getAMD_VUB_LOC_ID return varchar2 is
	begin
		 return AMD_VUB_LOC_ID ;
	end getAMD_VUB_LOC_ID ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_defaults', 
		 		pError_location => 10, pKey1 => 'amd_defaults', pKey2 => '$Revision:   1.27  $') ;
	end version ;
	
/*
 The following begin block is executed the first time this package is
 referenced.  It initialializes all the default variables from a table.
 The package will stay in memory until the application using it is finished.
 */
begin
	declare
		function GetCondemnAvg return amd_national_stock_items.condemn_avg%type is
		begin
			return to_number(GetParamValue('condemn_avg')) ;
		end GetCondemnAvg ;

		function GetConsumableReductionFactor return consumable_reduction_factor%type is
		begin
			return to_number(GetParamValue('consumable_reduction_factor')) ;
		end GetConsumableReductionFactor ;

		function GetDisposalCost return amd_spare_parts.disposal_cost%type is
		begin
			return to_number(GetParamValue('disposal_cost')) ;
		end GetDisposalCost ;

		function GetDistribUom return amd_national_stock_items.distrib_uom%type is
		begin
			return GetParamValue('distrib_uom') ;
		end GetDistribUom ;

		function GetEnginePartReductionFactor return engine_part_reduction_factor%type is
		begin
			return to_number(GetParamValue('engine_part_reduction_factor')) ;
		end GetEnginePartReductionFactor ;

		function GetNonEnginePartReductnFactor return engine_part_reduction_factor%type is
		begin
			return to_number(GetParamValue('non_engine_part_reductn_factor')) ;
		end GetNonEnginePartReductnFactor ;

		function GetNrtsAvg return amd_national_stock_items.nrts_avg%type is
		begin
			return GetParamValue('nrts_avg') ;
		end GetNrtsAvg ;

		function GetOffBaseTurnAround return amd_part_locs.time_to_repair%type is
		begin
			return GetParamValue('off_base_turn_around') ;
		end GetOffBaseTurnAround ;

		function GetOrderLeadTimeConsumable return amd_spare_parts.order_lead_time_defaulted%type is
		begin
			return to_number(GetParamValue('order_lead_time_consumable')) ;
		end GetOrderLeadTimeConsumable ;

		function GetOrderLeadTimeRepairable return amd_spare_parts.order_lead_time_defaulted%type is
		begin
			return to_number(GetParamValue('order_lead_time_repairable')) ;
		end GetOrderLeadTimeRepairable ;

		function GetOrderQuantity return amd_national_stock_items.order_quantity%type is
		begin
			return to_number(GetParamValue('order_quantity')) ;
		end GetOrderQuantity;

		function GetOrderUom return amd_spare_parts.order_uom%type is
		begin
			return GetParamValue('order_uom') ;
		end GetOrderUom ;

		function GetQpeiWeighted return amd_national_stock_items.qpei_weighted%type is
		begin
			return to_number(GetParamValue('qpei_weighted')) ;
		end GetQpeiWeighted ;

		function GetRtsAvg return amd_national_stock_items.rts_avg%type is
		begin
			return to_number(GetParamValue('rts_avg')) ;
		end GetRtsAvg ;

		function GetScrapValue return amd_spare_parts.scrap_value%type is
		begin
			return to_number(GetParamValue('scrap_value')) ;
		end GetScrapValue ;

		function GetShelfLife return  amd_spare_parts.shelf_life%type is
		begin
			return to_number(GetParamValue('shelf_life')) ;
		end GetShelfLife ;

		function GetTimeToRepairOnBaseAvg return amd_national_stock_items.time_to_repair_on_base_avg_df%type is
		begin
			return to_number(GetParamValue('time_to_repair_on_base_avg')) ;
		end GetTimeToRepairOnBaseAvg ;

		function GetUnitVolume return	amd_spare_parts.unit_volume%type is
		begin
			return to_number(GetParamValue('unit_volume')) ;
		end GetUnitVolume ;

		function GetUseBssmToGetNsls return varchar2 is
		begin
			return GetParamValue('use_bssm_to_get_nsls') ;
		end GetUseBssmToGetNsls ;

		function GetCostToRepairOnbase return varchar2 is
		begin
			 return GetParamValue('cost_to_repair_onbase');
		end GetCostToRepairOnbase;

		function GetTimeToRepairOnbase return varchar2 is
		begin
			 return GetParamValue('time_to_repair_onbase');
		end GetTimeToRepairOnbase;

		function GetUnitCostFactorOffbase return varchar2 is
		begin
			 return GetParamValue('unit_cost_factor_offbase');
		end GetUnitCostFactorOffbase;

		function GetTimeToRepairOffbase return varchar2 is
		begin
			 return GetParamValue('time_to_repair_offbase');
		end GetTimeToRepairOffbase;
		
		function getNsnPlannerCode return amd_planners.PLANNER_CODE%type is
				 wk_planner_code amd_planners.planner_code%type := null ;
				 planner_code amd_planners.planner_code%type := null ;
		begin
			 wk_planner_code := trim(GetParamValue('nsn_planner_code')) ;
			 
			 if wk_planner_code is null then
			 	return 'RJB' ; -- this may not be in amd_planners, but this is the current default
			 end if ;
			 
		     <<validatePlannerCode>>
		     begin
				 select planner_code into getNsnPlannerCode.planner_code
				 from amd_planners
				 where planner_code =  wk_planner_code ;
			 exception when standard.no_data_found then
	  		 	 dbms_output.put_line('amd_defaults 10: Default NSN Planner_code ' || wk_planner_code || ' is not in amd_planners.') ;
			 end validatePlannerCode ;
			 
			 return wk_planner_code ;
			 
		end getNsnPlannerCode ;
		
		function getNslPlannerCode return amd_planners.PLANNER_CODE%type is
				 wk_planner_code amd_planners.PLANNER_CODE%type := null ;
				 planner_code amd_planners.PLANNER_CODE%type := null ;
	    begin
			 wk_planner_code := trim(GetParamValue('nsl_planner_code')) ;
			 if wk_planner_code is null then
			 	wk_planner_code := 'NSD' ;
			 end if ;
			 <<validatePlannerCode>>
			 begin
				 select planner_code into getNslPlannerCode.planner_code
				 from amd_planners
				 where planner_code =  wk_planner_code ;
			 exception when no_data_found then
		  	   dbms_output.put_line('amd_defaults 20: Default NSL Planner_code ' || wk_planner_code || ' is not in amd_planners.') ;
			 end validatePlannerCode ;
			 
			 return wk_planner_code ;
			 
		end getNslPlannerCode ;

		function getNsnLogonId return amd_planner_logons.LOGON_ID%type is
				 logon_id amd_planner_logons.logon_id%type ;
				 wk_logon_id amd_planner_logons.logon_id%type ;
		begin
			 wk_logon_id := trim(GetParamValue('nsn_logon_id')) ;
			 
			 if wk_logon_id is null then
			 	wk_logon_id := '0334080' ; -- this user may not exist in amd_users, but this is the current default 
			 end if ;
			 
		    <<validateLogonId>>
		 	begin
				select logon_id into getNsnLogonId.logon_id
				from amd_planner_logons
				where logon_id = wk_logon_id
				and planner_code = NSN_PLANNER_CODE ;
			exception when standard.NO_DATA_FOUND then
				dbms_output.put_line('amd_defaults 30: Default NSN Logon_id, ' || wk_logon_id || ' does not exist in amd_planner_logons for planner ' || NSN_PLANNER_CODE) ;
			end validateLogonId ;
			 
			 return wk_logon_id ;
			 
		end getNsnLogonId ;

		function getNslLogonId return amd_planner_logons.LOGON_ID%type is
				 logon_id amd_planner_logons.logon_id%type ;
				 wk_logon_id amd_planner_logons.logon_id%type ;
		begin
			 wk_logon_id := trim(GetParamValue('nsl_logon_id')) ;
			 if wk_logon_id is null then
			 	wk_logon_id := '0235143' ;
			 end if ;
			 
		    <<validateLogonId>>
		 	begin
				 select logon_id into getNslLogonId.logon_id
				 from amd_planner_logons
				 where logon_id = wk_logon_id
				 and planner_code = NSL_PLANNER_CODE ;
			exception when standard.NO_DATA_FOUND then
	  		  dbms_output.put_line('amd_defaults 40: Default NSL Logon_id,' || wk_logon_id || ' does not exist in amd_planner_logons for planner ' || NSL_PLANNER_CODE) ;
			end validateLogonId ;
			
			return wk_logon_id ;
			
		end getNslLogonId ;
		
		function getBom return tmp_a2a_bom_detail.bom%type is
				 bom tmp_a2a_bom_detail.bom%type ;
		begin
			 bom := trim(getParamValue('bom')) ;
			 if bom is null then
			 	return 'C17' ;
			 else
			 	return bom ;
			 end if ;
		end getBom ;
		
		function getBomQuantity return tmp_a2a_bom_detail.quantity%type is
				 quantity tmp_a2a_bom_detail.quantity%type ;
		begin
			 quantity := trim(GetParamValue('bom_quantity'));
			 if quantity is null then
			 	return 1 ;
			 else
			 	 return quantity ;
			 end if ;
		end getBomQuantity ;

	begin
		amd_defaults.CONDEMN_AVG := GetCondemnAvg() ;
		amd_defaults.consumable_reduction_factor := GetConsumableReductionFactor() ;
		amd_defaults.DISPOSAL_COST := GetDisposalCost() ;
		amd_defaults.DISTRIB_UOM := GetDistribUom() ;
		amd_defaults.engine_part_reduction_factor := GetEnginePartReductionFactor() ;
		amd_defaults.non_engine_part_reductn_factor := GetNonEnginePartReductnFactor() ;
		amd_defaults.NRTS_AVG := GetNrtsAvg() ;
		amd_defaults.OFF_BASE_TURN_AROUND := GetOffBaseTurnAround() ;
		amd_defaults.ORDER_QUANTITY := GetOrderQuantity() ;
		amd_defaults.ORDER_UOM := GetOrderUom() ;
		amd_defaults.QPEI_WEIGHTED :=	GetQpeiWeighted() ;
		amd_defaults.RTS_AVG := GetRtsAvg() ;
		amd_defaults.SCRAP_VALUE := GetScrapValue() ;
		amd_defaults.SHELF_LIFE := GetShelfLife() ;
		amd_defaults.order_lead_time_consumable := GetOrderLeadTimeConsumable() ;
		amd_defaults.order_lead_time_repairable := GetOrderLeadTimeRepairable() ;
		amd_defaults.TIME_TO_REPAIR_ON_BASE_AVG := GetTimeToRepairOnBaseAvg() ;
		amd_defaults.UNIT_VOLUME := GetUnitVolume() ;
		amd_defaults.USE_BSSM_TO_GET_NSLs := GetUseBssmToGetNsls() ;
		amd_defaults.TIME_TO_REPAIR_ONBASE := GetTimeToRepairOnbase();
		amd_defaults.TIME_TO_REPAIR_OFFBASE := GetTimeToRepairOffbase();
		amd_defaults.COST_TO_REPAIR_ONBASE := GetCostToRepairOnbase();
		amd_defaults.UNIT_COST_FACTOR_OFFBASE := GetUnitCostFactorOffbase();
		amd_defaults.NSL_PLANNER_CODE := getNslPlannerCode() ;
		amd_defaults.NSN_PLANNER_CODE := getNsnPlannerCode() ;
		amd_defaults.NSN_LOGON_ID := getNsnLogonId() ; -- assumes NSN_PLANNER_CODe has a valid value
		amd_defaults.NSL_LOGON_ID := getNslLogonId() ; -- assumes NSL_PLANNER_CODE has a valid value
		amd_defaults.BOM := getBom() ;
		amd_defaults.BOM_QUANTITY := getBomQuantity() ; 
	end ;
end amd_defaults ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_clean_data as
    /*   				
	    PVCS Keywords
		
       $Author:   zf297a  $
     $Revision:   1.6  $
         $Date:   Jun 09 2006 12:42:54  $
     $Workfile:   amd_clean_data.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_clean_data.pkb-arc  $
   
      Rev 1.6   Jun 09 2006 12:42:54   zf297a
   implemented version
   
      Rev 1.6   Aug 23 2005 12:22:38   zf297a
   Implemented interfaces using the nsn and part_no  that is retrieving cleaned data via the amd_load / diff process.  This will allow the routine to attempt to retrieve the cleaned_data via the part_no if it is not found via the nsn.
   
      Rev 1.5   Aug 03 2005 10:33:58   zf297a
   Fixed CheckCache - checked if nsn is NULL
   
      Rev 1.4   May 06 2005 08:15:38   c970183
   changed dla_warehouse_stock and dla_warehouse_stock_cleaned to current_backorder and current_backorder_cleaned.  added pvcs keywords
   	  */	  

/*
 	These routines will make it easy to retrieve cleaned data from BSSM
 	Douglas S. Elder and Chung D. Lu  	10/03/01	Initial implementation

	Douglas S. Elder					11/6/01		The cache will work best
		when the data is sorted by nsn asc, prime_ind desc
 */

 	cleanRec		amd_cleaned_from_bssm_pkg.partFields := null ;
	
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_clean_data',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	procedure CheckCache(pNsn in varchar2) is
	begin
		if cleanRec.nsn != pNsn or cleanRec.nsn is null then
			cleanRec := amd_cleaned_from_bssm_pkg.GetValues(pNsn) ;
		end if ;
	exception when NO_DATA_FOUND then
		cleanRec := null ;
	end CheckCache ;
	
	procedure checkCache(pNsn in varchar2, pPartNo in varchar2) is
	begin
		if (cleanRec.nsn != pNsn and cleanRec.part_no != pPartNo)  or cleanRec.nsn is null then
			cleanRec := amd_cleaned_from_bssm_pkg.GetValuesX(pNsn, pPartNo) ;
		end if ;
	exception when NO_DATA_FOUND then
		cleanRec := null ;
	end CheckCache ;

   	-- ks - base specific clean fields, not in pkg body yet
	function RemovalInd(pNsn in varchar2, pLocSid in number ) return varchar2 is
	begin
		return null ; -- todo
	end ;

	function RepairLevelCode(pNsn in varchar2, pLocSid in number) return varchar2 is
	begin
		return null ; -- todo
	end ;
	--

	function GetAddIncrement(pNsn in varchar2) return amd_national_stock_items.add_increment_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.add_increment ;
	end ;
	function GetAmcBaseStock(pNsn in varchar2) return amd_national_stock_items.amc_base_stock_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.amc_base_stock ;
	end ;
	function GetAmcDaysExperience(pNsn in varchar2) return amd_national_stock_items.amc_days_experience_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.amc_days_experience ;
	end ;
	function GetAmcDemand(pNsn in varchar2) return amd_national_stock_items.amc_demand_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.amc_demand ;
	end ;
	function GetCapabilityRequirement(pNsn in varchar2) return amd_national_stock_items.capability_requirement_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.capability_requirement ;
	end ;
	function GetCondemnAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.condemn_avg_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.condemn_avg ;
	end ;
	function GetCostToRepairOffBase(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.cost_to_repair_off_base_cleand%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.cost_to_repair_off_base ;
	end ;
	function GetCriticality(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.criticality_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.criticality ;
	end ;
	function GetDlaDemand(pNsn in varchar2) return amd_national_stock_items.dla_demand_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.dla_demand ;
	end ;
	function GetCurrentBackorder(pNsn in varchar2) return amd_national_stock_items.current_backorder_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.current_backorder ;
	end ;
	function GetFedcCost(pNsn in varchar2) return amd_national_stock_items.fedc_cost_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.fedc_cost ;
	end ;
	function GetItemType(pNsn in varchar2) return amd_national_stock_items.item_type_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return cleanRec.item_type ;
	end ;
	function GetMicCodeLowest(pNsn in varchar2) return amd_national_stock_items.mic_code_lowest_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.mic_code_lowest ;
	end ;
	function GetMtbdr(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.mtbdr_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.mtbdr ;
	end ;
	function GetNomenclature(pNsn in varchar2) return amd_national_stock_items.nomenclature_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.nomenclature ;
	end ;
	function GetNrtsAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.nrts_avg_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.nrts_avg ;
	end ;
	function GetOrderLeadTime(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.order_lead_time_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.order_lead_time ;
	end ;
	function GetOrderUom(pNsn in varchar2) return amd_national_stock_items.order_uom_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.order_uom ;
	end ;

	function GetPlannerCode(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.planner_code_cleaned%type is
	begin
		--return	amd_cleaned_from_bssm_pkg.GetValues(pNsn => pNsn, pFieldName => amd_cleaned_from_bssm_pkg.PLANNER_CODE) ;
		CheckCache(pNsn, pPartNo) ;		
		return cleanRec.planner_code ; -- todo
	end ;
	function GetPrimeInd(pNsn in varchar2, pPart_no in varchar2, pMfgr in varchar2) return amd_nsi_parts.prime_ind_cleaned%type is
	begin
		-- return	amd_cleaned_from_bssm_pkg.GetValues(pNsn => pNsn, pFieldName => amd_cleaned_from_bssm_pkg.PRIME_IND) ;
		return null ; -- todo
	end ;
	function GetRuInd(pNsn in varchar2) return amd_national_stock_items.ru_ind_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.ru_ind ;
	end ;
	function GetRtsAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.rts_avg_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.rts_avg ;
	end ;
	function GetSmrCode(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.smr_code_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.smr_code ;
	end ;
	function GetTimeToRepairOffBase(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.time_to_repair_off_base_cleand%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.time_to_repair_off_base ;
	end ;
	function GetTimeToRepairOnBaseAvg(pNsn in varchar2) return amd_national_stock_items.time_to_repair_on_base_avg_cl%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.time_to_repair_on_base_avg ;
	end ;
	function GetUnitCost(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.unit_cost_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.unit_cost ;
	end ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_clean_data', 
		 		pError_location => 10, pKey1 => 'amd_clean_data', pKey2 => '$Revision:   1.6  $') ;
	end version ;
	
end amd_clean_data ;
/

show errors

CREATE OR REPLACE PACKAGE BODY AMD_CLEANED_FROM_BSSM_PKG 
is
    /*   				
	    PVCS Keywords
		
       $Author:   zf297a  $
     $Revision:   1.14  $
         $Date:   Jul 11 2006 11:30:04  $
     $Workfile:   amd_cleaned_from_bssm_pkg.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_cleaned_from_bssm_pkg.pkb-arc  $
   
      Rev 1.14   Jul 11 2006 11:30:04   zf297a
   Removed quotes from package name.
   
      Rev 1.13   Jun 09 2006 12:47:26   zf297a
   implemented version
   
      Rev 1.12   Dec 06 2005 09:35:34   zf297a
   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
   
      Rev 1.11   Oct 06 2005 10:09:10   zf297a
   added code to return planner_code
   
      Rev 1.10   Aug 04 2005 14:23:52   zf297a
   Made sure all queries using lock_sid compare against a character string versus a number so that the index is used.
   
      Rev 1.9   Jun 21 2005 07:58:32   c970183
   Added more excepton handlers.  Terminated the routine for all critical exceptions that should not occur.
   
      Rev 1.8   May 17 2005 11:05:56   c970183
   added new cleaned fields.  added fields that are not part of amd, but could provide an easy way to get field from bssm
   
      Rev 1.7   May 17 2005 10:26:46   c970183
   Changed dla_wareshouse_stock to current_backorder
   
      Rev 1.6   May 06 2005 07:45:26   c970183
   Changed dla_warehouse_stock to current_backorder.  added pvcs keywords.
   	  */	  
  	ERRSOURCE constant varchar2(20) := 'amdCleanedFromBssm';
  	type tab_modflag is table of varchar2(50) index by binary_integer;
	gModflag1Map tab_modflag;
	gModflag2Map tab_modflag;
	gSetflagBaseMap tab_modflag;

	procedure CheckPartModFlag(pModflagMap tab_modflag, pModflagValue bssm_parts.modflag1%type, pBssmParts bssm_parts%rowtype, pOutCleanable IN OUT partFields);
	function GetBaseCleanable(pLockSidTwo bssm_base_parts%rowtype) return partBaseFields;
	function GetCleanable(pLockSidTwo bssm_parts%rowtype) return partFields;
  	-- function GetCleanable(pLockSidZero bssm_parts%rowtype, pLockSidTwo bssm_parts%rowtype) return partFields;
	function GetCurrentAmdNsn(pNsiSid amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.nsn%type;
  	function NotEqual(pField1 varchar2, pField2 varchar2) return boolean;
	procedure UpdateAmdPartCleaned(pNsn amd_national_stock_items.nsn%type, pCleanable partFields);
	procedure UpdateAmdBaseCleaned(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type, pCleanable partBaseFields);


	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_cleaned_from_bssm_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	procedure errorMsg(
					sqlFunction in varchar2,
					tableName in varchar2,
					errorLocation in number,
					key1 in varchar2 := '',
			 		key2 in varchar2 := '',
					key3 in varchar2 := '',
					key4 in varchar2 := '',
					key5 in varchar2 := '',					
					keywordvaluepairs in varchar2 := '') is
	begin
		rollback;
		amd_utils.inserterrormsg (
				pload_no => amd_utils.getloadno(
						psourcename => sqlfunction,
						ptablename  => tablename),
				pdata_line_no => errorlocation,
				pdata_line    => 'amd_cleaned_from_bssm_pkg',
				pkey_1 => key1,
				pkey_2 => key2,
				pkey_3 => key3,
				pkey_4 => key4,
				pkey_5 => key5 || ' ' || to_char(sysdate,'MM/DD/YYYY HH:MI:SS') ||
						   ' ' || keywordvaluepairs,
				pcomments => sqlfunction || '/' || tablename || ' sqlcode('||sqlcode||') sqlerrm('||sqlerrm||')');
		commit;
		return ;
	end errorMsg;

	procedure CheckPartModFlag(pModflagMap tab_modflag, pModflagValue bssm_parts.modflag1%type, pBssmParts bssm_parts%rowtype, pOutCleanable IN OUT partFields) is
		bitNumber binary_integer;
	begin
		bitNumber := pModflagMap.FIRST;
		while (bitNumber is not null)
		loop
			if (BITAND(pModflagValue, bitNumber) > 0) then
  				if (pModflagMap(bitNumber) = ACQUISITION_ADVICE_CODE) then
					pOutCleanable.acquisition_advice_code := pBssmParts.acquisition_advice_code ;
  				elsif (pModflagMap(bitNumber) = ADD_INCREMENT) then
					pOutCleanable.add_increment := pBssmParts.add_increment;
				elsif (pModflagMap(bitNumber) = AMC_BASE_STOCK) then
					pOutCleanable.amc_base_stock := pBssmParts.amc_base_stock;
				elsif (pModflagMap(bitNumber) = AMC_DAYS_EXPERIENCE) then
					pOutCleanable.amc_days_experience := pBssmParts.amc_days_experience;
				elsif (pModflagMap(bitNumber) = AMC_DEMAND) then
					pOutCleanable.amc_demand := pBssmParts.amc_demand;
				elsif (pModflagMap(bitNumber) = CAPABILITY_REQUIREMENT) then
					pOutCleanable.capability_requirement := pBssmParts.capability_requirement;
				elsif (pModflagMap(bitNumber) = CONDEMN_AVG) then
					pOutCleanable.condemn_avg := pBssmParts.condemn;
				elsif (pModflagMap(bitNumber) = CRITICALITY) then
					pOutCleanable.criticality := pBssmParts.criticality ;
				elsif (pModflagMap(bitNumber) = DLA_DEMAND) then
					pOutCleanable.dla_demand := pBssmParts.dla_demand;
				elsif (pModflagMap(bitNumber) = CURRENT_BACKORDER) then
					pOutCleanable.current_backorder := pBssmParts.CURRENT_BACKORDER;
				elsif (pModflagMap(bitNumber) = FEDC_COST) then
					pOutCleanable.fedc_cost := pBssmParts.fedc_cost;
				elsif (pModflagMap(bitNumber) = GOLD_MFGR_CAGE) then
					pOutCleanable.gold_mfgr_cage := pBssmParts.gold_mfgr_cage;
				elsif (pModflagMap(bitNumber) = ITEM_TYPE) then
					pOutCleanable.item_type := amd_from_bssm_pkg.ConvertItemType(pBssmParts.item_type);
				elsif (pModflagMap(bitNumber) = MFGR) then
					pOutCleanable.mfgr := pBssmParts.mfgr;
				elsif (pModflagMap(bitNumber) = MIC_CODE_LOWEST) then
					pOutCleanable.mic_code_lowest := pBssmParts.mic_code;
				elsif (pModflagMap(bitNumber) = MTBDR) then
					pOutCleanable.mtbdr := pBssmParts.mtbdr;
				elsif (pModflagMap(bitNumber) = MIN_PURCHASE_QUANTITY) then
					pOutCleanable.min_purchase_quantity := pBssmParts.min_purchase_quantity;
				elsif (pModflagMap(bitNumber) = NOMENCLATURE) then
					pOutCleanable.nomenclature := pBssmParts.nomenclature;
				elsif (pModflagMap(bitNumber) = NRTS_AVG) then
					pOutCleanable.nrts_avg := pBssmParts.nrts;
				elsif (pModflagMap(bitNumber) = COST_TO_REPAIR_OFF_BASE) then
					pOutCleanable.cost_to_repair_off_base := pBssmParts.off_base_repair_cost;
				elsif (pModflagMap(bitNumber) = TIME_TO_REPAIR_OFF_BASE) then
					pOutCleanable.time_to_repair_off_base := pBssmParts.off_base_turnaround;
				elsif (pModflagMap(bitNumber) = TIME_TO_REPAIR_ON_BASE_AVG) then
					pOutCleanable.time_to_repair_on_base_avg := pBssmParts.on_base_turnaround;
				elsif (pModflagMap(bitNumber) = ORDER_LEAD_TIME) then
					pOutCleanable.order_lead_time := pBssmParts.order_lead_time;
				elsif (pModflagMap(bitNumber) = ORDER_UOM) then
					pOutCleanable.order_uom := pBssmParts.order_uom;
				elsif (pModflagMap(bitNumber) = PLANNER_CODE) then
					pOutCleanable.planner_code := pBssmParts.planner_code;
				elsif (pModflagMap(bitNumber) = RTS_AVG) then
					pOutCleanable.rts_avg := pBssmParts.rts;
				elsif (pModflagMap(bitNumber) = RU_IND) then
					pOutCleanable.ru_ind := pBssmParts.ru_ind;
				elsif (pModflagMap(bitNumber) = SMR_CODE) then
					pOutCleanable.smr_code := pBssmParts.smr_code;
				elsif (pModflagMap(bitNumber) = UNIT_COST) then
					pOutCleanable.unit_cost := pBssmParts.unit_cost;
				end if;
			end if;
			bitNumber := pModflagMap.NEXT(bitNumber);
		end loop;
	end CheckPartModflag;

	function GetCleanable(pLockSidTwo bssm_parts%rowtype) return partFields is
		cleanable partFields := null;
	begin
		CheckPartModFlag(gModflag1Map, pLockSidTwo.modflag1, pLockSidTwo, cleanable);
		CheckPartModFlag(gModflag2Map, pLockSidTwo.modflag2, pLockSidTwo, cleanable);
		return cleanable;
	end GetCleanable;

	/*
	-- not used currently, switched back to other methodology of using bit comparisons
	-- order important when passing to this function, lockSidTwo must be second
  	function GetCleanable(pLockSidZero bssm_parts%rowtype, pLockSidTwo bssm_parts%rowtype) return partFields is
		recPart partFields := null;
	begin
		if (NotEqual(pLockSidTwo.add_increment, pLockSidZero.add_increment)) then
			recPart.add_increment := pLockSidTwo.add_increment;
		end if;
		if (NotEqual(pLockSidTwo.amc_base_stock,pLockSidZero.amc_base_stock)) then
			recPart.amc_base_stock := pLockSidTwo.amc_base_stock;
		end if;
		if (NotEqual(pLockSidTwo.amc_days_experience, pLockSidZero.amc_days_experience)) then
			recPart.amc_days_experience := pLockSidTwo.amc_days_experience;
		end if;
		if (NotEqual(pLockSidTwo.amc_demand, pLockSidZero.amc_demand)) then
			recPart.amc_demand := pLockSidTwo.amc_demand;
		end if;
		if (NotEqual(pLockSidTwo.capability_requirement,pLockSidZero.capability_requirement)) then
			recPart.capability_requirement := pLockSidTwo.capability_requirement;
		end if;
		if (NotEqual(pLockSidTwo.condemn, pLockSidZero.condemn)) then
			recPart.condemn_avg := pLockSidTwo.condemn;
		end if;
		if (NotEqual(pLockSidTwo.criticality,pLockSidZero.criticality)) then
			recPart.criticality := amd_from_bssm_pkg.ConvertCriticality(pLockSidTwo.criticality);
		end if;
		if (NotEqual(pLockSidTwo.dla_demand,pLockSidZero.dla_demand)) then
			recPart.dla_demand := pLockSidTwo.dla_demand;
		end if;
		if (NotEqual(pLockSidTwo.dla_warehouse_stock, pLockSidZero.dla_warehouse_stock)) then
			recPart.dla_warehouse_stock := pLockSidTwo.dla_warehouse_stock;
		end if;
		if (NotEqual(pLockSidTwo.fedc_cost,pLockSidZero.fedc_cost)) then
			recPart.fedc_cost := pLockSidTwo.fedc_cost;
		end if;
		if (NotEqual(pLockSidTwo.item_type,pLockSidZero.item_type)) then
			recPart.item_type := amd_from_bssm_pkg.ConvertItemType(pLockSidTwo.item_type);
		end if;
		if (NotEqual(pLockSidTwo.mic_code, pLockSidZero.mic_code)) then
			recPart.mic_code_lowest := pLockSidTwo.mic_code;
		end if;
		if (NotEqual(pLockSidTwo.mtbdr,pLockSidZero.mtbdr)) then
			recPart.mtbdr := pLockSidTwo.mtbdr;
		end if;
		if (NotEqual(pLockSidTwo.nomenclature, pLockSidZero.nomenclature)) then
			recPart.nomenclature := pLockSidTwo.nomenclature;
		end if;
		if (NotEqual(pLockSidTwo.nrts, pLockSidZero.nrts)) then
			recPart.nrts_avg := pLockSidTwo.nrts;
		end if;
		if (NotEqual(pLockSidTwo.off_base_repair_cost, pLockSidZero.off_base_repair_cost)) then
			recPart.cost_to_repair_off_base := pLockSidTwo.off_base_repair_cost;
		end if;
		if (NotEqual(pLockSidTwo.off_base_turnaround, pLockSidZero.off_base_turnaround)) then
			recPart.time_to_repair_off_base := pLockSidTwo.off_base_turnaround;
		end if;
		if (NotEqual(pLockSidTwo.on_base_turnaround, pLockSidZero.on_base_turnaround)) then
			recPart.time_to_repair_on_base_avg := pLockSidTwo.on_base_turnaround;
		end if;
		if (NotEqual(pLockSidTwo.order_lead_time, pLockSidZero.order_lead_time)) then
			recPart.order_lead_time := pLockSidTwo.order_lead_time;
		end if;
		if (NotEqual(pLockSidTwo.order_uom, pLockSidZero.order_uom)) then
			recPart.order_uom := pLockSidTwo.order_uom;
		end if;
		if (NotEqual(pLockSidTwo.planner_code, pLockSidZero.planner_code)) then
			recPart.planner_code := pLockSidTwo.planner_code;
		end if;
		if (NotEqual(pLockSidTwo.rts, pLockSidZero.rts)) then
			recPart.rts_avg := pLockSidTwo.rts;
		end if;
		if (NotEqual(pLockSidTwo.ru_ind, pLockSidZero.ru_ind)) then
			recPart.ru_ind := pLockSidTwo.ru_ind;
		end if;
		if (NotEqual(pLockSidTwo.smr_code, pLockSidZero.smr_code)) then
			recPart.smr_code := pLockSidTwo.smr_code;
		end if;
		if (NotEqual(pLockSidTwo.unit_cost, pLockSidZero.unit_cost)) then
			recPart.unit_cost := pLockSidTwo.unit_cost;
   		end if;
		return recPart;
	end GetCleanable;
	*/

	function GetBaseCleanable(pLockSidTwo bssm_base_parts%rowtype) return partBaseFields is
	  -- prior to today 11/12/01, bob said even for bssm_base_parts table, cannot
	  -- have lock_sid 2 w/o lock_sid 0.  however test with today demonstrated a lock_sid 2
	  -- was created w/o lock_sid 0. may have to abort comparison of lock_sid 2 to lock_sid 0.
	  -- all base specific fields are in gSetflagBaseMap
	  	 cleanable partBaseFields := null;
		 bitNumber binary_integer;
	begin
		bitNumber := gSetflagBaseMap.FIRST;
		while (bitNumber is not null)
		loop
			if (BITAND(pLockSidTwo.setflag, bitNumber) > 0) then
			   	if (gSetflagBaseMap(bitNumber) = REPAIR_LEVEL_CODE) then
					cleanable.repair_level_code := pLockSidTwo.repair_indicator;
				elsif (gSetflagBaseMap(bitNumber) = REMOVAL_IND) then
					cleanable.removal_ind := pLockSidTwo.replacement_indicator;
				end if;
			end if;
			bitNumber := gSetflagBaseMap.NEXT(bitNumber);
		end loop;
		return cleanable;
	end GetBaseCleanable;


	function GetBaseValues(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type) return partBaseFields is
		 -- lockSidZero bssm_base_parts%rowtype := null;
		 lockSidTwo bssm_base_parts%rowtype := null;
		 recBase partBaseFields := null;
		 currentBssmNsn bssm_parts.nsn%type;
	begin
		 -- will throw exception if not found, important when nsn coming from amd
		currentBssmNsn := amd_from_bssm_pkg.GetCurrentBssmNsn(pNsn);
		select bbp.*
		 		into lockSidTwo
				from bssm_base_parts bbp
				where
		 	   		  lock_sid = '2'   	 	and
		 	   		  sran = pSran 	 	 	and
			   		  bbp.nsn = currentBssmNsn;
		recBase := GetBaseCleanable(lockSidTwo);
		/*
		 select bbp.*
		 		into lockSidZero
				from bssm_base_parts bbp
				where
		 	   		  lock_sid = 0   	 	and
		 	   		  sran = pSran 	 	 	and
					  bbp.nsn = currentBssmNsn;
		 if (NotEqual(lockSidTwo.replacement_indicator,lockSidZero.replacement_indicator)) then
			recBase.removal_ind := lockSidTwo.replacement_indicator;
		 end if;
		 if (NotEqual(lockSidTwo.repair_indicator, lockSidZero.repair_indicator)) then
			recBase.repair_level_code := lockSidTwo.repair_indicator;
		 end if;
		 */
		 return recBase;
	exception
		 when no_data_found then
		 	  return recBase;
	end GetBaseValues;

				-- below not really used, just for convenience if want to query by field name
	function GetBaseValues(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type, pFieldName varchar2) return varchar2 is
		recBase partBaseFields := null;
	begin
		recBase := GetBaseValues(pNsn, pSran);
		if (pFieldName = REMOVAL_IND) then
		 	return recBase.removal_ind;
		elsif (pFieldName = REPAIR_LEVEL_CODE) then
			return recBase.repair_level_code;
		end if;
	end GetBaseValues;

  	function GetCurrentAmdNsn(pNsiSid amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.nsn%type is
		currentNsn amd_national_stock_items.nsn%type;
	begin
		 select nsn
		 into currentNsn
		 from amd_national_stock_items
		 where nsi_sid = pNsiSid;
		 return currentNsn;
		 -- let it throw exception if not found
	end GetCurrentAmdNsn;
	
	function GetValuesX(pNsn bssm_parts.nsn%type, pPartNo bssm_parts.part_no%type) return partFields is
		recPart partFields := null;
		-- lockSidZero bssm_parts%rowtype := null;
		lockSidTwo bssm_parts%rowtype := null;
		currentBssmNsn bssm_parts.nsn%type;
	begin
			   -- pNsn comes from amd or bssm,amd may be ahead of nsn in bssm_parts => get current bssm nsn
			   -- will throw exception if not available
		currentBssmNsn := amd_from_bssm_pkg.GetCurrentBssmNsn(pNsn);
		select bp.*
			   into lockSidTwo
			   from bssm_parts bp
			   where
			   		 bp.nsn = currentBssmNsn and
			   		 lock_sid = '2';
		recPart := GetCleanable(lockSidTwo);
		/*
		select bp.*
			   into lockSidZero
			   from bssm_parts bp
			   where
			   		 bp.nsn = currentBssmNsn and
			   		 lock_sid = 0;

		recPart := GetCleanable(lockSidZero, lockSidTwo);
		*/
		recPart.part_no := pPartNo ;
		return recPart;
	exception
			 -- will occur if cannot current bssm nsn or no lock_sid 2 entry
		when no_data_found then
			 recPart := null ;
			 <<getViaPart>>
			 declare
			 		nsn bssm_parts.nsn%type := null ;
			 begin
			 	  select nsn into getViaPart.nsn from bssm_parts where part_no = pPartNo and lock_sid = '0' ;
				  
				  select bp.* into lockSidTwo
				  from bssm_parts bp
				  where bp.nsn = getViaPart.nsn  and lock_sid = '2';
				  
				  recPart := GetCleanable(lockSidTwo);
				  
				  recPart.nsn := pNsn ;
				  recPart.part_no := pPartNo ;
				  
			 	  return recPart;
			 exception 
			 		   when standard.no_data_found then
					   		return recPart ;
			 end getViaPart ;
	end GetValuesX ;

    	-- if field not cleaned, GetBssmPartsRec return value will be null for that particular field.
	function GetValues(pNsn bssm_parts.nsn%type) return partFields is
		recPart partFields := null;
		-- lockSidZero bssm_parts%rowtype := null;
		lockSidTwo bssm_parts%rowtype := null;
		currentBssmNsn bssm_parts.nsn%type;
	begin
			   -- pNsn comes from amd or bssm,amd may be ahead of nsn in bssm_parts => get current bssm nsn
			   -- will throw exception if not available
		currentBssmNsn := amd_from_bssm_pkg.GetCurrentBssmNsn(pNsn);
		select bp.*
			   into lockSidTwo
			   from bssm_parts bp
			   where
			   		 bp.nsn = currentBssmNsn and
			   		 lock_sid = '2';
		recPart := GetCleanable(lockSidTwo);
		/*
		select bp.*
			   into lockSidZero
			   from bssm_parts bp
			   where
			   		 bp.nsn = currentBssmNsn and
			   		 lock_sid = 0;

		recPart := GetCleanable(lockSidZero, lockSidTwo);
		*/
		return recPart;
	exception
			 -- will occur if cannot current bssm nsn or no lock_sid 2 entry
		when no_data_found then
		 	 	-- return null record
			 return recPart;
	end GetValues;

		-- not really used anymore, here for convenience
	function GetValues(pNsn bssm_parts.nsn%type, pFieldName varchar2) return varchar2 is
		recPart partFields := null;
	begin
		 -- implicit conversion of numbers, dates to return type of varchar2.
		 -- gets all cleaned values as a group, will be null if not cleaned
		recPart := GetValues(pNsn);
		if (pFieldName = ADD_INCREMENT) then
		 	return recPart.add_increment;
		elsif (pFieldName = AMC_BASE_STOCK) then
			return recPart.amc_base_stock;
		elsif (pFieldName = AMC_DAYS_EXPERIENCE) then
			return recPart.amc_days_experience;
		elsif (pFieldName = AMC_DEMAND) then
			return recPart.amc_demand;
		elsif (pFieldName = CAPABILITY_REQUIREMENT) then
			return recPart.capability_requirement;
		elsif (pFieldName = CONDEMN_AVG) then
			return recPart.condemn_avg;
		elsif (pFieldName = CRITICALITY) then
			return recPart.criticality;
		elsif (pFieldName = DLA_DEMAND) then
			return recPart.dla_demand;
		elsif (pFieldName = CURRENT_BACKORDER) then
			return recPart.current_backorder;
		elsif (pFieldName = FEDC_COST) then
			return recPart.fedc_cost;
		elsif (pFieldName = ITEM_TYPE) then
			return recPart.item_type;
		elsif (pFieldName = MIC_CODE_LOWEST) then
			return recPart.mic_code_lowest;
		elsif (pFieldName = MTBDR) then
			return recPart.mtbdr;
		elsif (pFieldName = MIN_PURCHASE_QUANTITY) then
			return recPart.min_purchase_quantity ;
		elsif (pFieldName = NOMENCLATURE) then
			return recPart.nomenclature;
		elsif (pFieldName = NRTS_AVG) then
			return recPart.nrts_avg;
		elsif (pFieldName = COST_TO_REPAIR_OFF_BASE) then
			return recPart.cost_to_repair_off_base;
		elsif (pFieldName = TIME_TO_REPAIR_OFF_BASE) then
			return recPart.time_to_repair_off_base;
		elsif (pFieldName = TIME_TO_REPAIR_ON_BASE_AVG) then
			return recPart.time_to_repair_on_base_avg;
		elsif (pFieldName = ORDER_LEAD_TIME) then
			return recPart.order_lead_time;
		elsif (pFieldName = ACQUISITION_ADVICE_CODE) then
			return recPart.acquisition_advice_code ;
		elsif (pFieldName = ORDER_UOM) then
			return recPart.order_uom;
		elsif (pFieldName = PLANNER_CODE) then
			return recPart.planner_code;
		elsif (pFieldName = RTS_AVG) then
			return recPart.rts_avg;
		elsif (pFieldName = RU_IND) then
			return recPart.ru_ind;
		elsif (pFieldName = SMR_CODE) then
			return recPart.smr_code;
		elsif (pFieldName = UNIT_COST) then
			return recPart.unit_cost;
		else
			-- asking for field that is not cleanable
			return null;
		end if;
	end GetValues;



	function NotEqual(pField1 varchar2, pField2 varchar2) return boolean is
	begin
		 if ((pField1 is null) and (pField2 is null)) then
		 	return FALSE;
		 elsif ( pField1 = pField2) then
		 	return FALSE;
		 else
		 	return  TRUE;
		 end if;
	end NotEqual;


		-- thought below approach would be faster than cursor and reusing above procedures
	procedure NullAmdAllCleanedFields is
	begin
	     <<updateAmdNationalStockItems>>
	     begin
			 update amd_national_stock_items
			 set
				add_increment_cleaned = null,
				amc_base_stock_cleaned = null,
				amc_days_experience_cleaned = null,
				amc_demand_cleaned = null,
				capability_requirement_cleaned = null,
				condemn_avg_cleaned = null,
				criticality_cleaned = null,
				dla_demand_cleaned = null,
				current_backorder_cleaned = null,
				fedc_cost_cleaned = null,
				item_type_cleaned = null,
				mic_code_lowest_cleaned = null,
				mtbdr_cleaned = null,
				nomenclature_cleaned = null,
				nrts_avg_cleaned = null,
				order_lead_time_cleaned = null,
		 		order_uom_cleaned = null,
				cost_to_repair_off_base_cleand = null,
				time_to_repair_off_base_cleand = null,
				time_to_repair_on_base_avg_cl = null,
				planner_code_cleaned = null,
				rts_avg_cleaned = null,
				ru_ind_cleaned = null,
				smr_code_cleaned = null,
				unit_cost_cleaned = null,
				last_update_dt = SYSDATE;
		exception when others then
			errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items',
			  errorLocation => 10) ;
			raise ;
		end updateAmdNationalStockItems ;

		begin
		update amd_part_locs
		set
			removal_ind_cleaned = null,
			repair_level_code = null,
			last_update_dt = SYSDATE;
	    exception when others then
			errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items',
			  errorLocation => 20) ;
			raise ;
	    end updatePartLocs ;
		
	exception
		when others then
			errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items/amd_part_locs',
			  errorLocation => 30) ;
			raise ;
	end NullAmdAllCleanedFields;

	procedure NullAmdBaseCleanedFields(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type) is
		cleanableNull partBaseFields := null;
	begin
		UpdateAmdBaseCleaned(pNsn, pSran, cleanableNull);
	exception
		when others then
			errorMsg(sqlFunction => 'update', tableName => 'amd_part_locs',
			  errorLocation => 40, key1 => pNsn, key2 => pSran) ;
			raise ;
	end NullAmdBaseCleanedFields;

	procedure NullAmdPartCleanedFields(pNsn bssm_parts.nsn%type) is
		cleanableNull partFields := null;
	begin
		UpdateAmdPartCleaned(pNsn, cleanableNull);
	exception
		when others then
			errorMsg(sqlFunction => 'update', tableName => 'amd_national_stock_items',
			  errorLocation => 50, key1 => pNsn) ;
			raise ;
	end NullAmdPartCleanedFields;

	procedure UpdateAmdAllBaseCleaned is
	    -- appears lots of lock_sid 2 recs created with no change of info.
		-- to speed up, only list those that have a change for our
		-- fields of concern (testing went from 4500 records to 88).
		cursor nsnSranListFromBssm_cur is
			select nsn, sran, repair_indicator, replacement_indicator
			from bssm_base_parts where lock_sid = '2'
				 minus
			select nsn, sran, repair_indicator, replacement_indicator
			from bssm_base_parts where lock_sid = '0';
		cleanableBase partBaseFields := null;
	begin
		for nsnSranBssm in nsnSranListFromBssm_cur
		loop
			begin
		 	   cleanableBase := GetBaseValues(nsnSranBssm.nsn, nsnSranBssm.sran);
			   UpdateAmdBaseCleaned(nsnSranBssm.nsn, nsnSranBssm.sran, cleanableBase);
			exception
		       when others then
					errorMsg(sqlFunction => 'update', tablename => 'amd_part_locs',
					  errorLocation => 60) ;
					raise ;
			end;
		end loop;
		commit;
	end UpdateAmdAllBaseCleaned;

	procedure UpdateAmdBaseCleaned(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type, pCleanable partBaseFields) is
		nsiSid amd_national_stock_items.nsi_sid%type;
		locSid amd_spare_networks.loc_sid%type;
	begin
			-- removal indicator be cleaned.  amd_part_locs is determined by this and therefore current
			-- (i.e. no action_code delete).  since dropped and reloaded, reloading will take into
			-- account when cleaned.  choose not to delete record on fly when cleaned - affects
			-- quite a few children.
			-- i.e. wait till next load
		nsiSid := amd_utils.GetNsiSid(pNsn => pNsn);
			-- associate warehouse to 'W' in GetLocSid
		locSid := amd_from_bssm_pkg.GetLocSid(pSran);
		if (nsiSid is not null and locSid is not null) then
			update amd_part_locs
				set repair_level_code_cleaned = pCleanable.repair_level_code,
					removal_ind_cleaned = pCleanable.removal_ind,
					last_update_dt = SYSDATE
				where
					nsi_sid = nsiSid and
					loc_sid = locSid;
		end if;
	exception
		when no_data_found then
			 null;
		when others then
			errorMsg(sqlFunction => 'update', tablename => 'amd_part_locs',
			  errorLocation => 70) ;
			raise ;
	end UpdateAmdBaseCleaned;

	procedure UpdateAmdAllPartCleaned is
		cursor listFromBssm_cur is
			select *
			from bssm_parts
			where lock_sid = '2';
		cleanablePart partFields := null;
		-- lockSidZero bssm_parts%rowtype;
	begin
			-- do those from bssm_parts.
			-- kind of slow so not using GetValues

		for lockSidTwo in listFromBssm_cur
		loop
			begin
				cleanablePart := GetCleanable(lockSidTwo);
				UpdateAmdPartCleaned(lockSidTwo.nsn, cleanablePart);
			/*
				begin
					select *
					   into lockSidZero
					   from bssm_parts
					   where nsn = lockSidTwo.nsn
					   and lock_sid = 0;
					   -- order important for GetCleanable parameters
					cleanablePart := GetCleanable(lockSidZero, lockSidTwo);
					UpdateAmdPartCleaned(lockSidTwo.nsn, cleanablePart);
				exception
						 -- possibilities occur where lock_sid 2 record and no lock_sid 0 record.
					when no_data_found then
						 null;
				end;
			*/
			exception
		       when others then
					errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items',
					  errorLocation => 80, key1 => lockSidTwo.nsn) ;
					raise ;
			end;
		end loop;
		commit;
	end UpdateAmdAllPartCleaned;

	procedure UpdateAmdPartCleaned(pNsn amd_national_stock_items.nsn%type, pCleanable partFields) is
		nsiSid amd_national_stock_items.nsi_sid%type;
		currentNsn amd_national_stock_items.nsn%type;
	begin
		nsiSid := amd_utils.GetNsiSid(pNsn => pNsn);
				-- some or most maybe null
		update amd_national_stock_items
		set
			add_increment_cleaned = pCleanable.add_increment,
			amc_base_stock_cleaned = pCleanable.amc_base_stock,
			amc_days_experience_cleaned = pCleanable.amc_days_experience,
			amc_demand_cleaned = pCleanable.amc_demand,
			capability_requirement_cleaned = pCleanable.capability_requirement,
			condemn_avg_cleaned = pCleanable.condemn_avg,
			criticality_cleaned = pCleanable.criticality,
			dla_demand_cleaned = pCleanable.dla_demand,
			current_backorder = pCleanable.current_backorder,
			fedc_cost_cleaned = pCleanable.fedc_cost,
			item_type_cleaned = pCleanable.item_type,
			mic_code_lowest_cleaned = pCleanable.mic_code_lowest,
			mtbdr_cleaned = pCleanable.mtbdr,
			nomenclature_cleaned = pCleanable.nomenclature,
			nrts_avg_cleaned = pCleanable.nrts_avg,
			order_lead_time_cleaned = pCleanable.order_lead_time,
	 		order_uom_cleaned = pCleanable.order_uom,
			cost_to_repair_off_base_cleand = pCleanable.cost_to_repair_off_base,
			time_to_repair_off_base_cleand = pCleanable.time_to_repair_off_base,
			time_to_repair_on_base_avg_cl = pCleanable.time_to_repair_on_base_avg,
			planner_code_cleaned = pCleanable.planner_code,
			rts_avg_cleaned = pCleanable.rts_avg,
			ru_ind_cleaned = pCleanable.ru_ind,
			smr_code_cleaned = pCleanable.smr_code,
			unit_cost_cleaned = pCleanable.unit_cost,
			last_update_dt = SYSDATE
		where nsi_sid = nsiSid;

	exception
		when no_data_found then
			 -- this would occur when cannot find nsi_sid or current nsn
			 null;
		when others then
			 errorMsg(sqlFunction => 'update', tableName => 'amd_national_stock_items',
			   errorLocation => 70, key1 => pNsn, key2 => to_char(nsiSid)) ;
			 raise ;
	end UpdateAmdPartCleaned;

		------- trigger oriented procedures ---------
	procedure UpdateAmdPartByTrigger(pLockSidTwo bssm_parts%rowtype) is
		cleanablePart partFields := null;
	begin
		cleanablePart := GetCleanable(pLockSidTwo);
		UpdateAmdPartCleaned(pLockSidTwo.nsn, cleanablePart);
	exception
			  -- part of trigger, don't want to fail
		when others then
			errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items',
			  errorLocation => 80, key1 => pLockSidTwo.nsn) ;
			raise ; 
	end UpdateAmdPartByTrigger;


	procedure UpdateAmdBaseByTrigger(pLockSidTwo bssm_base_parts%rowtype) is
		cleanable partBaseFields := null;
	begin
		cleanable := GetBaseCleanable(pLockSidTwo);
		UpdateAmdBaseCleaned(pLockSidTwo.nsn, pLockSidTwo.sran, cleanable);
	exception
			  -- part of trigger, don't want to fail
		when others then
			 errorMsg(sqlFunction => 'update', tableName => 'amd_part_locs',
			   errorLocation => 90, key1 => pLockSidTwo.nsn, key2 => pLockSidTwo.sran) ;
			 raise ;
	end UpdateAmdBaseByTrigger;


	procedure OnPartResetByTrigger(pLockSidTwo bssm_parts%rowtype) is
		-- bob's code on reset deletes lock_sid 2 then updates lock_sid 0
		 bssmPartRec bssm_parts%rowtype;
	begin
		 -- on reset, values are not considered "cleaned" anymore, source systems caught up.
		 NullAmdPartCleanedFields(pLockSidTwo.nsn);
		 -- since amd should catch up at the same time of it's load,
		 -- grab only those that currently bssm is the only source for (may be off by 10%).
		 -- if want to be safer run amd_from_bssm_pkg.loadamdfrombssmraw to alleviate
		 -- possible off by 10%.
		  amd_from_bssm_pkg.UpdateAmdNsi(pLockSidTwo);
	exception
		when no_data_found then
			 errorMsg(sqlFunction => 'update', tableName => 'amd_national_stock_items',
			   errorLocation => 100, key1 => pLockSidTwo.nsn) ;
			 raise ;
		when others then
			 errorMsg(sqlFunction => 'update', tableName => 'amd_national_stock_items',
			   errorLocation => 110, key1 => pLockSidTwo.nsn) ;
			 raise ;
	end OnPartResetByTrigger;

	procedure OnBaseResetByTrigger(pLockSidTwo bssm_base_parts%rowtype) is
		-- bob's code on reset deletes lock_sid 2 then updates lock_sid 0
		 bssmBaseRec bssm_base_parts%rowtype;
	begin
		 -- on reset, values are not considered "cleaned" anymore, source systems caught up.
		 NullAmdBaseCleanedFields(pLockSidTwo.nsn, pLockSidTwo.sran);
		 -- since amd should catch up at the same time of it's load,
		 -- grab only those that currently bssm is the only source for (may be off by 10%).
		 -- if want to be safer run amd_from_bssm_pkg.loadamdfrombssmraw to alleviate
		 -- possible off by 10%.
		 amd_from_bssm_pkg.UpdateAmdPartLocs(pLockSidTwo);
	exception
		when no_data_found then
			 errorMsg(sqlFunction => 'update', tableName => 'amd_part_locs',
			   errorLocation => 120, key1 => pLockSidTwo.nsn) ;
			 raise ;
		when others then
			 errorMsg(sqlFunction => 'update', tableName => 'amd_part_locs',
			   errorLocation => 130, key1 => pLockSidTwo.nsn) ;
			 raise ;
	end OnBaseResetByTrigger;
	
	procedure version is
	begin
		 writeMsg(pTableName => 'amd_cleaned_from_bssm_pkg', 
		 		pError_location => 140, pKey1 => 'amd_cleaned_from_bssm_pkg', pKey2 => '$Revision:   1.14  $') ;
	end version ;

begin
	 /*  this is an alternative method than comparing lock_sid 2 with lock_sid 0
  to determine cleaned data.  marginally more difficult to maintain as not as intuitive
  as comparing lock_sids - best spares uses this approach of reading modflag1 and modflag2
  to determine if something has been cleaned.  this is here because a trigger, for
  example on bssm_parts, cannot requery the table to get the lock_sid 0 value
  used for comparison - get mutating error.  this and associated functions
  can go away if triggers not used for update of cleaned data - or everything can be updated
  to use this and skip the lock_sid 2 vs lock_sid 0 comparison.

       2 fields, modflag1 and modflag2 contain the bits of those fields that
  have been cleaned. Created 2 pl/sql arrays to relate this.
  Using characteristic of sparseness in pl/sql array to hold
  "power" values to their associated field names (probably could've used
  constants instead).
  This means the indexvalue of pl/sql array is also the bit value
  related to the field as defined in best spares application. Little
  easier to cycle thru list this way.
  When bitAnd'ed with corresponding modflag1 or modflag2, will note
  cleaned field. the definitions of the modflag1 and modflag2 come from
  the SparesCommon.h file.
  Changed SparesCommon.h definition names to match database field names.
  Easier to read/maintain than hardcode calculated values by
  using power function - will match up well with SparesCommon.h if needed
  updated or added.
  eg. mtbdr    from sparesCommon.h
  	  		   		#define MOD1_MTBRD (1 << 28)
			   below
			   		gModflag1Map(POWER(2,28)) := MTBDR

*/
  		  -- modflag1
 	gModflag1Map(POWER(2,9))  := GOLD_MFGR_CAGE;   		 -- no cleaned spot in amd, but still get it
 	gModflag1Map(POWER(2,10)) := MFGR; 					 -- no cleaned spot in amd, but still get it
	gModflag1Map(POWER(2,11)) := ADD_INCREMENT;
	gModflag1Map(POWER(2,12)) := COST_TO_REPAIR_OFF_BASE; -- OFF_BASE_REPAIR_COST
	gModflag1Map(POWER(2,13)) := ORDER_UOM; /* UNITS */
    gModflag1Map(POWER(2,14)) := PLANNER_CODE; 		   	 
	gModflag1Map(POWER(2,15)) := MIC_CODE_LOWEST;
	gModflag1Map(POWER(2,16)) := SMR_CODE;
	gModflag1Map(POWER(2,19)) := MONTHLY_DEMAND_RATE ; -- not an amd field
	gModflag1Map(POWER(2,21)) := NOMENCLATURE;
	gModflag1Map(POWER(2,22)) := WUC;  		 			 -- no cleaned spot in amd, but get it
	gModflag1Map(POWER(2,23)) := CURRENT_BACKORDER ;
	gModflag1Map(POWER(2,24)) := DLA_DEMAND;
	gModflag1Map(POWER(2,25)) := AMC_DEMAND;
	gModflag1Map(POWER(2,26)) := AMC_DAYS_EXPERIENCE;
	gModflag1Map(POWER(2,27)) := AMC_BASE_STOCK;
	gModflag1Map(POWER(2,28)) := MTBDR;
	gModflag1Map(POWER(2,29)) := MIN_PURCHASE_QUANTITY ;


	 	-- modflag2
	gModflag2Map(POWER(2,10)) := UNIT_COST;
	gModflag2Map(POWER(2,11)) := FEDC_COST;
	gModflag2Map(POWER(2,12)) := RU_IND;
	gModflag2Map(POWER(2,13)) := ITEM_TYPE;
	gModflag2Map(POWER(2,14)) := CAPABILITY_REQUIREMENT; 	  -- CATEGORY
	gModflag2Map(POWER(2,15)) := CRITICALITY;
	gModflag2Map(POWER(2,16)) := RTS_AVG;	 			  	  -- RTS
	gModflag2Map(POWER(2,17)) := NRTS_AVG;				  	  -- NRTS
	gModflag2Map(POWER(2,18)) := CONDEMN_AVG;			  	  -- CONDEMN
	gModflag2Map(POWER(2,19)) := TIME_TO_REPAIR_ON_BASE_AVG;  -- ON_BASE_TURNAROUND, TBASE
	gModflag2Map(POWER(2,20)) := TIME_TO_REPAIR_OFF_BASE;  	  -- OFF_BASE_TURNAROUND,TDEPOT
	gModflag2Map(POWER(2,21)) := ORDER_LEAD_TIME;     	  	  -- TCONDEMN
	gModflag2Map(POWER(2,26)) := ACQUISITION_ADVICE_CODE;     
	

		-- decide to separate base specific into their own array,
		-- but still matches bob's "power".
	gSetflagBaseMap(POWER(2,0)) := REPAIR_LEVEL_CODE;
	gSetflagBaseMap(POWER(2,1)) := REMOVAL_IND;
	-- following not passed on to amd at this time, i.e. no cleaned hole in amd
	/*
		gSetflagBaseMap(POWER(2,2)) := MAXIMUM_STOCK;
		gSetflagBaseMap(POWER(2,3)) := MINIMUM_STOCK;
		gSetflagBaseMap(POWER(2,8)) := RSP_ON_HAND;
		gSetflagBaseMap(POWER(2,9)) := RSP_OBJECTIVE;

		gSetflagBaseMap(POWER(2,22) := HOLDING_COST;
		gSetflagBaseMap(POWER(2,23) := BACKORDER_FIXED_COST;
		gSetflagBaseMap(POWER(2,24) := BACKORDER_VARIABLE_COST;
		gSetflagBaseMap(POWER(2,25) := ORDER_COST;
	*/
end AMD_CLEANED_FROM_BSSM_PKG;
/

show errors

CREATE OR REPLACE PACKAGE BODY amd_spare_parts_pkg as
	--
	-- SCCSID:   %M%   %I%   Modified: %G%  %U%
	--
	/*
       $Author:   zf297a  $
     $Revision:   1.78  $
         $Date:   Sep 14 2006 00:42:34  $
     $Workfile:   AMD_SPARE_PARTS_PKG.pkb  $
	     $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_spare_parts_pkg.pkb-arc  $	
   
      Rev 1.78   Sep 14 2006 00:42:34   zf297a
   Added procedure deleteAnyRblPairs which is used when the nsn gets updated in amd_national_stock_items - this will delete any dependent child from amd_rbl_pairs if necessary.
   
      Rev 1.77   Jun 21 2006 11:36:44   zf297a
   Fixed loadCurrentBackOrder - needed to trim the part_no in the where clause of the update statements, otherwise the update did not find any matches per the criteria and it does not generate an exception.
   
      Rev 1.76   Jun 09 2006 12:29:48   zf297a
   implemented version
   
      Rev 1.75   Mar 23 2006 14:15:38   zf297a
   Changed code to use amd_defaults.nsn_planner_code or nsl_planner_code where either the cleaned planner code or the original planner_code do not exist in amd_planners.
   
      Rev 1.74   Mar 08 2006 09:25:46   zf297a
   Added mtbdr_computed
   
      Rev 1.73   Oct 10 2005 09:36:26   zf297a
   added price to insertPartInfo and updatePartInfo parameter list
   
      Rev 1.72   Sep 27 2005 08:53:46   zf297a
   Fixed updatePartLeadtime and updatePartPricing by adding a parts.part_no to both where clauses.  Aslo, added comprehensive checks of the data changing from null to not null or not null to null.
   
      Rev 1.72   Aug 19 2005 12:48:26   zf297a
   Since the amd_load package is converting ime_to_repair_off_base_cleand and order_lead_time_cleaned from months to calendar days and Converting order_lead_time from business days to calendar days remove all conversions from this package.
   
      Rev 1.71   Aug 17 2005 15:01:24   zf297a
   Enhanced loadCurrentBackOrder with periodic commits and display of update counters.
   
      Rev 1.70   Aug 16 2005 12:51:22   zf297a
   made same change as made to version 1.39.1.7
   
      Rev 1.69   Aug 10 2005 10:02:06   zf297a
   converted cleaned order_lead_time and order_lead_time to calandar days for a2a transactions.
   
      Rev 1.68   Aug 09 2005 07:23:32   zf297a
   Applied the same update for getQtyDue and cursor curDue - same patch will be applied to current prod (1.7.1)
   
      Rev 1.67   Jul 29 2005 14:59:40   zf297a
   Allow Nsn to change on the Prime or the Equivalent part.
   
      Rev 1.66   Jul 28 2005 10:36:20   zf297a
   Make sure that when a prime_part_no becomes unassigned that its associated national_stock_item gets logically deleted (set the last_update_dt too).  Whenever a new prime_part_no gets assigned to an exisiting national_stock_item update the action_code (U) and the last_update_dt.
   
      Rev 1.65   Jun 27 2005 13:55:24   c970183
   Moved a2a code for part_lead_time and part_pricing to be after partInfo
   
      Rev 1.64   Jun 27 2005 11:37:26   c970183
   Added the display of pPart_no and pNsn for the errorMsg when doing updatePartLeadTime
   
      Rev 1.63   Jun 17 2005 09:03:08   c970183
   Removed exception handler for insertLoadDetail, added raise_application for dup keys, and updated deleteRow's exception handler.
   
      Rev 1.62   Jun 16 2005 15:53:14   c970183
   Changed errorMsg to be the same as the errorMsg in the a2a_pkg: this uses a unique pError_location number to pinpoint the block of code that has the exception.  Also, added some user defined exception instead of return codes.
   
      Rev 1.61   Jun 03 2005 12:50:08   c970183
   Added the procedure loadCurrentBackOrder for amd_national_stock_items.current_backorder
   
      Rev 1.60   May 18 2005 08:59:04   c970183
   Started using a2a_pkg.getIndenture.
   
      Rev 1.59   May 18 2005 07:29:44   c970183
   Modified how mArgs is used.  Added function name for args list and prefixed package name.
   
      Rev 1.58   May 16 2005 11:59:50   c970183
   Moved time_to_repair_off_base and cost_to_repair_off_base from amd_part_locs to amd_national_stock_items.  Created "changed indicators" for both of these fields.
   
      Rev 1.57   May 13 2005 14:44:06   c970183
   Started using a2a_pkg.THIRD_PARTY_FLAG and a2a_pkg.INDENTURE constants
   
      Rev 1.56   May 06 2005 08:23:46   c970183
   changed dla_warehouse_stock, dla_warehouse_stock_cleaned, and getDlaWarehouseStock to current_backorder, current_backorder_cleaned, and getCurrentBackorder.
   
      Rev 1.55   May 02 2005 12:54:42   c970183
   Added some error handling for deleteRow.
   
      Rev 1.53   Apr 26 2005 14:04:02   c970183
   Fixed return value of getCriticalityChangedInd, getNrtsAvgChangedInd, getRtsAvgChangedInd, and getCondemiAvgChanged.
   
      Rev 1.52   Apr 26 2005 11:36:48   c970183
   Added criticality_changed, nrts_avg_changed, rts_avg_changed, and condemn_avg_changed indicators to amd_national_stock_items.
   
      Rev 1.51   Apr 25 2005 12:46:34   c970183
   Fixed the update of amd_spare_parts by adding in mfgr.  Enhanced debugging by adding a global mArgs string that contains all the data that was used to invoke insertRow, updateRow, or deleteRow.
   
      Rev 1.50   Apr 22 2005 08:33:34   c970183
   Fixed InsertRow so that it only invokes a2a_pkg.insertPartInfo when it does a physical insert to amd_national_stock_items, otherwise it will do an update function.
   
      Rev 1.49   Apr 22 2005 08:08:46   c970183
   added additional debug code
   
      Rev 1.48   Apr 18 2005 10:54:42   c970183
   Added new parameters to insertRow and updateRow.  Leveraged the old routines by just defining the new parameters as global member variables and invoking the old insertRow and updateRow methods.   Change the insert and update of amd_national_stock_items to use the new global member variables.
   
      Rev 1.47   Mar 24 2005 14:37:06   c970183
   added ver 1.40 - 1.45 changes.  Plus fixed a2a trans
   
      Rev 1.46  Mar 24 2005 09:36:22   c970183
   Added qpei_weighted, order_lead_time_cleaned, unit_cost_cleaned, planner_code_cleaned, smr_code_cleaned, cost_to_repair_off_base_cleand to InsertRow and UpdateRow

      Rev 1.39.1.0   06 Jan 2005 10:26:24   c970183
   Added mmac and unit_of_issue
   
   Copied the following changes from the SCCS version:
         Rev 1.6   13 Jun 2003 09:52:24   c970408
      Modified updateAmdSparePartRow() to use it's own nsn and removed call to updateNsnFromPrimeRec(). Modifed nsnChanged() to look at an.nsn instead of asp.nsn. Added call to makeNsnSameForAllParts() to checkNsnAndPrimeInd().
   
         Rev 1.5   18 Mar 2003 11:07:44   c970408
      Modified the code to correctly move a part from one nsn to another if both nsns exist concurrently in CAT1.
   
         Rev 1.4   05 Mar 2003 13:23:42   c970408
      fixed the movement of temp nsns to cat1 and the unassociation that results.
   
         Rev 1.3   26 Nov 2002 17:04:22   c970408
      Added getFedcCost().
   
         Rev 1.2   04 Nov 2002 16:20:06   c970408
      Mod'ed updating of the ansi.action_code = 'D' query in UpdateRow method to be more efficient.
   
         Rev 1.1   14 Oct 2002 16:03:44   c970408
      Added query at end of UpdateRow to update ansi.action_code = 'D' if no active amd_nsi_parts recs are linked to and ansi.nsi_sid.
   
         Rev 1.0   07 Oct 2002 06:26:18   c372701
      Initial revision.
   
   

      Rev 1.39   02 Oct 2002 12:30:06   c970408
   Added updateNsnFromPrimeRec() to resolve issue with amd_spare_parts.nsn not updating correctly on non-primes. Removed the nsi_sid qualification in UnassignPrimePart() to resolve issue when a part moves from one nsi_sid to another AND changes from a prime to a non-prime.

      Rev 1.38   30 Aug 2002 11:46:26   c970183
   Fixed updating of the prime_part_no.   When a prime_part_no and its equivalent parts got deleted and reinserted,  the logic caused the amd_national_stock_items.prime_part_no column to get set to a null value.  To accomodate this condition code has been added to the equivalent part section that checks for an existing amd_nsi_parts.part_no with its prime_ind set to 'Y'.  If found it makes sure that the same part_no appears in amd_national_stock_items.prime_part_no.

      Rev 1.37   28 Aug 2002 09:56:04   c970183
   Added the latest_config column for amd_national_stock_items with a value of 'Y'

      Rev 1.35   23 Aug 2002 12:10:54   c970183
   Stripped out ErrorMsg as a nested procedure and made it global to eliminate some redundant code.  Stripped out the updating of amd_national_stock_items to eliminate some redundant code.  Stripped out the routine for making all the equivalent parts have the same nsn as the prime part to eliminate some redundant code.
   Added the invocation of the routine to make nsn's same for equivalent parts for a part that was equivalent, but is now prime.

      Rev 1.34   08 Aug 2002 13:58:58   c970183
   Fixed InsertNewNsn's no_data_found exception: made sure it returned a value.

      Rev 1.33   08 Aug 2002 13:49:14   c970183
   Made the InsertNatStkItem function global to the package.  Wrap all the code needed to create the amd_national_stock_items and amd_nsns rows in a global procedure called CreateNationalStockItem.
   Changed the UpdateRow.InsertNewNsn to accomodate not finding a nsi_sid via the part_no (after having attempted to get it by the Nsn) to create a new Amd_National_Stock_Item/Amd_Nsns pair.

      Rev 1.32   07 Aug 2002 08:58:22   c970183
   Set unassignment_date to sysdate for deleted parts.

				 29 July 2002 fixed code so that a part that will be used a prime
				  	is unassigned no matter what nsn it is currently assigned and
					regardless of its current prime_ind


      	 		 22 July 2002 fixed code so that only one current 'C', nsn_type will
				 exist in amd_nsns for a given nsi_sid

      Rev 1.30   22 May 2002 06:41:16   c970183
   Added routines to create an NsiGroup for new Nsn's and to create NsiEffects for new Nsn's using the amd_default_effectivity_pkg

      Rev 1.29   16 May 2002 09:59:28   c970183
   Qualifed two updates of amd_nsns with the nsn so that only one will be CURRENT.

      Rev 1.28   11 Apr 2002 10:02:08   c970183
   Added 2nd SUCCESS return code for the exception handler of insertNsiPart when it recovers without a problem.

      Rev 1.27   11 Apr 2002 09:51:08   c970183
   Added SUCCESS return code to insertNsiParts

      Rev 1.26   11 Apr 2002 08:32:22   c970183
   Added ONE routine that inserts the amd_nsi_parts row and handles the dup key problem by sleeping one second and then doing the insert again.

      Rev 1.25   11 Apr 2002 08:09:20   c970183
   Added $Log$ keyword

      10/02/01 Douglas Elder   Initial implementation
	  03/28/02 Douglas Elder   Made application sleep when a duplicate insert
	  		   		   		   occurs and then retry the insert.
	  04/04/02 Douglas Elder	Added Mic Code to insert and update
	  04/05/02 Douglas Elder	Added code to update the nsn_type for
	  		   		   			a given nsi_sid to
	  		   		   			the amd_spare_parts_pkg.TEMPORARY_NSN
								whenever the nsn_type is
								amd_spare_parts_pkg.CURRENT_NSN
	   04/11/02 Douglas Elder   Added ONE routine that inserts the
	   							amd_nsi_parts row and handles the dup key
								problem by sleeping one second and then doing
								the insert again.
	   04/11/12 Douglas Elder   Added SUCCESS return code to insertNsiParts
     */


	UNIT_COST_CLEANED_VIA_NSN   exception;
	CANNOT_FIND_PART            exception;
	
	-- package member variables
	mRc		   		  		   	  number := FAILURE ;
	mArgs	   		  		      varchar2(2000) ;
	mMtbdr	   		              amd_national_stock_items.mtbdr%type ;
	mMtbdr_computed				  amd_national_stock_items.mtbdr_computed%type ;
	mQpeiWeighted	  			  amd_national_stock_items.qpei_weighted%type ;
	mCondemnAvgCleaned			  amd_national_stock_items.condemn_avg_cleaned%type ;
  	mCriticalityCleaned			  amd_national_stock_items.criticality%type ;
    mMtbdrCleaned       		  amd_national_stock_items.mtbdr_cleaned%type ;
  	mNrtsAvgCleaned     		  amd_national_stock_items.nrts_avg_cleaned%type ;
  	mCostToRepairOffBaseCleand    amd_national_stock_items.cost_to_repair_off_base_cleand%type ;
  	mTimeToRepairOffBaseCleand    amd_national_stock_items.time_to_repair_off_base_cleand%type ;
  	mOrderLeadTimeCleaned         amd_national_stock_items.order_lead_time_cleaned%type ;
  	mPlannerCodeCleaned           amd_national_stock_items.planner_code_cleaned%type ;
  	mRtsAvgCleaned                amd_national_stock_items.rts_avg_cleaned%type ;
  	mSmrCodeCleaned               amd_national_stock_items.smr_code_cleaned%type ;
  	mUnitCostCleaned              amd_national_stock_items.unit_cost_cleaned%type ;
  	mCondemnAvg                   amd_national_stock_items.condemn_avg%type ;
  	mCriticality                  amd_national_stock_items.criticality%type ;
  	mNrtsAvg                      amd_national_stock_items.nrts_avg%type ;
  	mRtsAvg                       amd_national_stock_items.rts_avg%type ;
	mCostToRepairOffBase		  amd_national_stock_items.cost_to_repair_off_base%type ;
	mTimeToRepairOffBase		  amd_national_stock_items.time_to_repair_off_base%type ;
	

	---------------------------------------------------------------
	-- Private declarations
	--

	function  getFedcCost(
							pPartNo varchar2) return number;
	function hasPartMoved(
							pPartNo varchar2,
							pNsn varchar2) return boolean;
	procedure unassignPart(
							pPartNo varchar2);

	function ErrorMsg(
							pSourceName in amd_load_status.SOURCE%type,
							pTableName in amd_load_status.TABLE_NAME%type,
							pError_location in amd_load_details.DATA_LINE_NO%type,
							pReturn_code in number,
							pPart_no in varchar2 := '',
							pNsi_sid in varchar2 := '',
							pKeywordValuePairs in varchar2 := '',
							pComments in varchar2 := '') return number ;
	--
	-- End Private declarations
	---------------------------------------------------------------

	debugThreshold number := 1000 ;
	debugCnt	   number := 0 ;
	
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_spare_parts_pkg',	
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;
	
	function ErrorMsg(
				pSqlfunction in amd_load_status.SOURCE%type,
				pTableName in amd_load_status.TABLE_NAME%type,
				pError_location amd_load_details.DATA_LINE_NO%type,
				pReturn_code in number,
				pKey_1 in amd_load_details.KEY_1%type,
		 		pKey_2 in amd_load_details.KEY_2%type := '',
				pKey_3 in amd_load_details.KEY_3%type := '',
				pKey_4 in amd_load_details.KEY_4%type := '',					
				pKeywordValuePairs in varchar2 := '') return number is
	key5 amd_load_details.KEY_5%type := pKeywordValuePairs ;
	begin
		rollback;
		if key5 = '' then
		   key5 := pSqlFunction || '/' || pTableName ;
		else
			key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
		end if ;
		-- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
		-- do not exceed the length of the column's that the data gets inserted into
		-- This is for debugging and logging, so efforts to make it not be the source of more
		-- errors is VERY important
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => substr(pSqlfunction,1,20),
						pTableName  => substr(pTableName,1,20)),
				pData_line_no => pError_location,
				pData_line    => 'amd_spare_parts_pkg.' || mArgs,
				pKey_1 => substr(pKey_1,1,50),
				pKey_2 => substr(pKey_2,1,50),
				pKey_3 => substr(pKey_3,1,50),
				pKey_4 => substr(pKey_4,1,50),
				pKey_5 => substr('rc=' || to_char(pReturn_code) ||
					       ' ' || to_char(sysdate,'MM/DD/YYYY HH:MM:SS') ||
						   ' ' || key5,1,50),
				pComments => substr('sqlcode('||sqlcode||') sqlerrm('||sqlerrm||')',1,2000));
		commit;
		return pReturn_code;
	exception when others then
			  commit ;
	end ErrorMsg;

	procedure ErrorMsg(
					pSqlfunction in amd_load_status.SOURCE%type,
					pTableName in amd_load_status.TABLE_NAME%type := '',
					pError_location amd_load_details.DATA_LINE_NO%type,
					pKey_1 in amd_load_details.KEY_1%type := '',
			 		pKey_2 in amd_load_details.KEY_2%type := '',
					pKey_3 in amd_load_details.KEY_3%type := '',
					pKey_4 in amd_load_details.KEY_4%type := '',					
					pKeywordValuePairs in varchar2 := '') is
		result number ;
	begin
		 result := ErrorMsg(pSqlfunction => pSqlfunction,
							pTableName => pTableName,
							pError_location => pError_location,
							pReturn_code => a2a_pkg.FAILURE,
						    pKey_1 => pKey_1,
							pKey_2 => pKey_2,
							pKey_3 => pKey_3,
							pKey_4 => pKey_4,
							pKeywordValuePairs => pKeywordValuePairs) ;
							
	exception when others then
			  commit ;
	end ErrorMsg;

	-- add wrapper for amd_utils.debugMsg
	procedure debugMsg(pMsg in varchar2,pLineNo in number) is
		result number ;
	begin
		-- is debugging turned on for this package?
		if mDebug then
		   amd_utils.debugMsg(pMsg => pMsg,pPackage => 'amd_spare_parts', pLocation => pLineNo) ;
		   commit ; -- make sure the trace is kept
		end if ;
	end;

	function getCriticalityChangedInd(nsi_sid in amd_national_stock_items.nsi_sid%type) 
			 return amd_national_stock_items.criticality_changed%type  is
			 oldCriticality amd_national_stock_items.CRITICALITY%type ;
			 oldCriticalityCleaned amd_national_stock_items.CRITICALITY_CLEANED%type ;
	begin
		 <<getOldValues>>
		 begin
			 select criticality, criticality_cleaned into oldCriticality, oldCriticalityCleaned
			 from amd_national_stock_items
			 where nsi_sid = getCriticalityChangedInd.nsi_sid ;
		 exception
		 		  when standard.NO_DATA_FOUND then
				  	   oldCriticality := null ;
					   oldCriticalityCleaned := null ;
				  when others then
				  	   ErrorMsg(pSqlfunction => 'select',
							pTableName => 'amd_national_stock_items',
							pError_location => 10, 
							pKey_1 => to_char(getCriticalityChangedInd.nsi_sid)) ;
				  		raise ;
		 end getOldValues ;
		 if amd_preferred_pkg.GetPreferredValue(mCriticalityCleaned, mCriticality) !=
		 	amd_preferred_pkg.GetPreferredValue(oldCriticalityCleaned, oldCriticality) then
			return 'Y' ;
		 else
		 	 return 'N' ;
		 end if ;
	end getCriticalityChangedInd ; 

	function getNrtsAvgChangedInd(nsi_sid in amd_national_stock_items.nsi_sid%type) return 
			 							  amd_national_stock_items.nrts_avg_changed%type is
			 oldNrtsAvg amd_national_stock_items.Nrts_Avg%type ;
			 oldNrtsAvgCleaned amd_national_stock_items.Nrts_Avg_CLEANED%type ;
	begin
		 <<getOldValues>>
		 begin
			 select Nrts_Avg, Nrts_Avg_cleaned into oldNrtsAvg, oldNrtsAvgCleaned
			 from amd_national_stock_items
			 where nsi_sid = getNrtsAvgChangedInd.nsi_sid ;
		 exception
		 		  when standard.NO_DATA_FOUND then
				  	   oldNrtsAvg := null ;
					   oldNrtsAvgCleaned := null ;
				  when others then
				  	   ErrorMsg(pSqlfunction => 'select',
							pTableName => 'amd_national_stock_items',
							pError_location => 20, 
							pKey_1 => to_char(getNrtsAvgChangedInd.nsi_sid)) ;
				  		raise ;
		 end getOldValues ;
		 if amd_preferred_pkg.GetPreferredValue(mNrtsAvgCleaned, mNrtsAvg) !=
		 	amd_preferred_pkg.GetPreferredValue(oldNrtsAvgCleaned, oldNrtsAvg) then
			return 'Y' ;
		 else
		 	 return 'N' ;
		 end if ;
	end getNrtsAvgChangedInd ; 

	function getRtsAvgChangedInd(nsi_sid in amd_national_stock_items.nsi_sid%type) return 
			  amd_national_stock_items.rts_avg_changed%type  is
			 oldRtsAvg amd_national_stock_items.Rts_Avg%type ;
			 oldRtsAvgCleaned amd_national_stock_items.Rts_Avg_CLEANED%type ;
	begin
		 <<getOldValues>>
		 begin
			 select Rts_Avg, Rts_Avg_cleaned into oldRtsAvg, oldRtsAvgCleaned
			 from amd_national_stock_items
			 where nsi_sid = getRtsAvgChangedInd.nsi_sid ;
		 exception
		 		  when standard.NO_DATA_FOUND then
				  	   oldRtsAvg := null ;
					   oldRtsAvgCleaned := null ;
				  when others then
				  	   ErrorMsg(pSqlfunction => 'select',
							pTableName => 'amd_national_stock_items',
							pError_location => 30, 
							pKey_1 => to_char(getRtsAvgChangedInd.nsi_sid)) ;
				  		raise ;
		 end getOldValues ;
		 if amd_preferred_pkg.GetPreferredValue(mRtsAvgCleaned, mRtsAvg) !=
		 	amd_preferred_pkg.GetPreferredValue(oldRtsAvgCleaned, oldRtsAvg) then
			return 'Y' ;
		 else
		 	 return 'N' ;
		 end if ;
	end getRtsAvgChangedInd ; 

	function getCondemnAvgChangedInd(nsi_sid in amd_national_stock_items.nsi_sid%type) return 
			 	amd_national_stock_items.condemn_avg_changed%type is
			 oldCondemnAvg amd_national_stock_items.Condemn_Avg%type ;
			 oldCondemnAvgCleaned amd_national_stock_items.Condemn_Avg_CLEANED%type ;
	begin
		 <<getOldValues>>
		 begin
			 select Condemn_Avg, Condemn_Avg_cleaned into oldCondemnAvg, oldCondemnAvgCleaned
			 from amd_national_stock_items
			 where nsi_sid = getCondemnAvgChangedInd.nsi_sid ;
		 exception
		 		  when standard.NO_DATA_FOUND then
				  	   oldCondemnAvg := null ;
					   oldCondemnAvgCleaned := null ;
				  when others then
				  	   ErrorMsg(pSqlfunction => 'select',
							pTableName => 'amd_national_stock_items',
							pError_location => 40, 
							pKey_1 => to_char(getCondemnAvgChangedInd.nsi_sid)) ;
				  		raise ;
		 end getOldValues ;
		 if amd_preferred_pkg.GetPreferredValue(mCondemnAvgCleaned, mCondemnAvg) !=
		 	amd_preferred_pkg.GetPreferredValue(oldCondemnAvgCleaned, oldCondemnAvg) then
			return 'Y' ;
		 else
		 	 return 'N' ;
		 end if ;
	end getCondemnAvgChangedInd ; 

	function getCostToRepairOffBaseChgedInd(nsi_sid in amd_national_stock_items.nsi_sid%type) return 
			 	amd_national_stock_items.cost_to_repair_off_base_chged%type is
			 oldCostToRepairOffBase amd_national_stock_items.cost_to_repair_off_base%type ;
			 oldCostToRepairOffBaseCleand amd_national_stock_items.cost_to_repair_off_base_cleand%type ;
	begin
		 <<getOldValues>>
		 begin
			 select cost_to_repair_off_base, cost_to_repair_off_base_cleand into oldCostToRepairOffBase, oldCostToRepairOffBaseCleand
			 from amd_national_stock_items
			 where nsi_sid = getCostToRepairOffBaseChgedInd.nsi_sid ;
		 exception
		 		  when standard.NO_DATA_FOUND then
				  	   oldCostToRepairOffBase := null ;
					   oldCostToRepairOffBaseCleand := null ;
				  when others then
				  	   ErrorMsg(pSqlfunction => 'select',
							pTableName => 'amd_national_stock_items',
							pError_location => 50, 
							pKey_1 => to_char(getCostToRepairOffBaseChgedInd.nsi_sid)) ;
				  		raise ;
		 end getOldValues ;
		 if amd_preferred_pkg.GetPreferredValue(mCostToRepairOffBaseCleand, mCostToRepairOffBase) !=
		 	amd_preferred_pkg.GetPreferredValue(oldCostToRepairOffBaseCleand, oldCostToRepairOffBase) then
			return 'Y' ;
		 else
		 	 return 'N' ;
		 end if ;
	end getCostToRepairOffBaseChgedInd ; 

	function getTimeToRepairOffBaseChgedInd(nsi_sid in amd_national_stock_items.nsi_sid%type) return 
			 	amd_national_stock_items.time_to_repair_off_base_chged%type is
			 oldTimeToRepairOffBase amd_national_stock_items.time_to_repair_off_base%type ;
			 oldTimeToRepairOffBaseCleand amd_national_stock_items.time_to_repair_off_base_cleand%type ;
	begin
		 <<getOldValues>>
		 begin
			 select time_to_repair_off_base, time_to_repair_off_base_cleand into oldTimeToRepairOffBase, oldTimeToRepairOffBaseCleand
			 from amd_national_stock_items
			 where nsi_sid = getTimeToRepairOffBaseChgedInd.nsi_sid ;
		 exception
		 		  when standard.NO_DATA_FOUND then
				  	   oldTimeToRepairOffBase := null ;
					   oldTimeToRepairOffBaseCleand := null ;
				  when others then
				  	   ErrorMsg(pSqlfunction => 'select',
							pTableName => 'amd_national_stock_items',
							pError_location => 60, 
							pKey_1 => to_char(getTimeToRepairOffBaseChgedInd.nsi_sid)) ;
				  		raise ;
		 end getOldValues ;
		 if amd_preferred_pkg.GetPreferredValue(mTimeToRepairOffBaseCleand, mTimeToRepairOffBase) !=
		 	amd_preferred_pkg.GetPreferredValue(oldTimeToRepairOffBaseCleand, oldTimeToRepairOffBase) then
			return 'Y' ;
		 else
		 	 return 'N' ;
		 end if ;
	end getTimeToRepairOffBaseChgedInd ; 

	procedure insertLoadDetail(
							pPartNo varchar2,
							pNsn varchar2,
							pPrimeInd varchar2,
							pAction varchar2) is
		aspNsn     amd_spare_parts.nsn%type;
		aspAction  amd_spare_parts.action_code%type;
		anpNsiSid  amd_nsi_parts.nsi_sid%type;
		anNsiSid   amd_nsns.nsi_sid%type;
		anNsn      amd_nsns.nsn%type;
		anNsn2     amd_nsns.nsn%type;
		anNsnType  amd_nsns.nsn_type%type;
		anNsnType2 amd_nsns.nsn_type%type;
		anpPrime   amd_nsi_parts.prime_ind%type;
	begin
		begin
			select anp.prime_ind,an.nsn,an.nsn_type,anp.nsi_sid,
				asp.action_code,asp.nsn
			into anpPrime,anNsn,anNsnType,anpNsiSid,aspAction,aspNsn
			from amd_spare_parts asp,
				amd_nsi_parts anp,
				amd_nsns an
			where asp.part_no = pPartNo
				and asp.part_no = anp.part_no
				and anp.nsi_sid = an.nsi_sid
				and anp.unassignment_date is null
				and an.nsn_type = 'C';
		exception when others then 
				  NULL; 
		end;

		begin
			select nsi_sid,nsn,nsn_type
			into anNsiSid,anNsn2,anNsnType2
			from amd_nsns
			where nsn = pNsn;
		exception when others then
				  null ; 
		end;

		amd_utils.InsertErrorMsg (
				pLoad_no => amd_utils.GetLoadNo(
					pSourceName => 'amd_spare_parts_pkg',
					pTableName  => 'amd_spare_parts'),
				pData_line_no => 1,
				pData_line    => substr('D: '||pAction||'- Curr View - pPartNo('||pPartNo||') pNsn('||pNsn||') pPrimeInd('||pPrimeInd||') - anNsn('||anNsn||') anNsnType('||anNsnType||') aspAction('||aspAction||') anpPrime('||anpPrime||') anpNsiSid('||anpNsiSid||')',1,2000),
				pKey_1 => 'anNsn2('||anNsiSid||')',
				pKey_2 => 'anNsnType2('||anNsnType2||')',
				pKey_3 => 'aspNsn('||aspNsn||')',
				pKey_4 => 'anNsiSid('||anNsiSid||')',
				pKey_5 => '',
				pComments => to_char(sysdate,'yyyymmdd hh:mi:ss am'));

		commit;
	end insertLoadDetail ;


	procedure unassociateTmpNsn(
							pNsn varchar2) is
	begin
		debugMsg('unassociateTmpNsn('||pNsn||')', pLineNo => 10);
		-- We do this when a temp nsn now appears in CAT1. This will remove
		-- the association to the current nsn and will set up the process
		-- to create a new nsi_sid for this formerly temp nsn.
		--
		delete from amd_nsns
		where nsn = pNsn
			and nsn_type = 'T';
	end;


	function hasPartMoved(
							pPartNo varchar2,
							pNsn varchar2) return boolean is
		nsn    amd_nsns.nsn%type;
	begin
		debugMsg('hasPartMoved('||pPartNo||')', pLineNo => 20);

		-- A part has moved from one nsn to another if the new and old nsns
		-- appear in tmp_amd_spare_parts at the same time.
		--
		select distinct 'Part has moved.'
		into nsn
		from tmp_amd_spare_parts
		where
			nsn =
				(select an.nsn
				from
					amd_nsi_parts anp,
					amd_nsns an
				where anp.part_no = pPartNo
					and anp.nsi_sid = an.nsi_sid
					and anp.unassignment_date is null
					and an.nsn_type = 'C'
					and an.nsn != pNsn)
		union
		select 'Part has moved.'
		from amd_nsns an,
			amd_nsi_parts anp
		where anp.part_no = pPartNo
			and an.nsi_sid != anp.nsi_sid
			and anp.unassignment_date is null
			and an.nsn_type = 'C'
			and an.nsn = pNsn;

		return TRUE;
	exception
		when NO_DATA_FOUND then
			return FALSE;
	end;


	function  getFedcCost(
							pPartNo varchar2) return number is
		cursor costCur is
			select gfp_price
			from prc1
			where
				part = pPartNo
				and gfp_price is not null
			order by sc desc;

		fedcCost    number;
	begin
		debugMsg('getFedcCost(' || pPartNo || ')', pLineNo => 30) ;
		for rec in costCur loop
			fedcCost := rec.gfp_price;
			exit;
		end loop;

		return fedcCost;
	exception when others then
  	   ErrorMsg(pSqlfunction => 'select',
			pTableName => 'prcl',
			pError_location => 80, 
			pKey_1 => pPartNo) ;
  		raise ;
	end getFedcCost ;



	procedure unassignPart(
							pPartNo varchar2) is
	begin
		debugMsg('unassignPart('||pPartNo||')', pLineNo => 40);
		update amd_nsi_parts set
			unassignment_date = sysdate
		where
			part_no = pPartNo
			and unassignment_date is null;
	end unassignPart ;


	function IsPrimePart(
						pPrime_ind in amd_nsi_parts.prime_ind%type) return boolean is
	begin
		debugMsg('isPrimePart(' || pPrime_ind || ')', pLineNo => 50);
		return (Upper(pPrime_ind) = amd_defaults.PRIME_PART);
	exception when others then
  	   ErrorMsg(pSqlfunction => 'isPrimeInd',
			pTableName => '',
			pError_location => 90, 
			pKey_1 => pPrime_ind) ;
  		raise ;
	end IsPrimePart;


	procedure sleep(
							secs in number) is
		ss varchar2(2);
	begin
		ss := to_char(sysdate,'ss');
		while to_number(ss) + secs > to_number(to_char(sysdate,'ss'))
		loop
			null;
		end loop;
	end;


	/* 8/23/02 DSE added ErrorMsg to eliminate some redundant code
	 * and to give the error messages a std structure.
	 */
	 -- 9/3/04 DSE add stronger typing for Source and Table_name + add substr's to make
	 -- certain that the key_1 to key_5 never exceed 50 characters
	function ErrorMsg(
							pSourceName in amd_load_status.SOURCE%type,
							pTableName in amd_load_status.TABLE_NAME%type,
							pError_location in amd_load_details.DATA_LINE_NO%type,
							pReturn_code in number,
							pPart_no in varchar2 := '',
							pNsi_sid in varchar2 := '',
							pKeywordValuePairs in varchar2 := '',
							pComments in varchar2 := '') return number is
	begin
		rollback; -- rollback may not be complete if running with mDebug set to true
		amd_utils.InsertErrorMsg (
				pLoad_no => amd_utils.GetLoadNo(
						pSourceName => pSourceName,
						pTableName  => pTableName),
				pData_line_no => pError_location,
				pData_line    => 'amd_spare_parts_pkg.' || mArgs,
				pKey_1 => substr(pPart_no,1,50),
				pKey_2 => substr(pNsi_sid,1,50),
				pKey_3 => pKeywordValuePairs,
				pKey_4 => to_char(pReturn_code),
				pKey_5 => sysdate,
				pComments => 'sqlcode('||sqlcode||') sqlerrm('||sqlerrm||') ' || pComments);

		commit;
		return pReturn_code;
	end;


	function insertNsiParts(
							pNsi_sid in amd_nsi_parts.nsi_sid%type,
							pPart_no in amd_nsi_parts.part_no%type,
							pPrime_ind in amd_nsi_parts.prime_ind%type,
							pPrime_ind_cleaned in amd_nsi_parts.prime_ind_cleaned%type,
							pBadRc in number) return number is
		currDate   date:=sysdate;
	begin
		debugMsg('insertNsiParts('||pNsi_sid||','||pPart_no||','||pPrime_ind||','||pPrime_ind_cleaned||','||pBadRc||')', pLineNo => 60);

		insert into amd_nsi_parts
		(
			nsi_sid,
			assignment_date,
			part_no,
			prime_ind
		)
		values
		(
			pNsi_sid,
			currDate,
			pPart_no,
			pPrime_ind
		);

		-- This is a safeguard to ensure all other records are unassigned
		update amd_nsi_parts set
			unassignment_date = sysdate
		where
			part_no = pPart_no
			and unassignment_date is null
			and assignment_date < currDate;

		return SUCCESS;
	exception
		when dup_val_on_index then
		    <<InsertAgainAfterOneSecond>>
			begin
				sleep(1);
				insert into amd_nsi_parts
				(
					nsi_sid,
					assignment_date,
					part_no,
					prime_ind
				)
				values
				(
					pNsi_sid,
					sysdate,
					pPart_no,
					pPrime_ind
				);
				return SUCCESS;
			exception
				when others then
				   mRc := amd_spare_parts_pkg.INSERTAGAIN_ERR + pBadRC ;
			  	   ErrorMsg(pSqlfunction => 'insert',
						pTableName => 'amd_nsi_parts',
						pError_location => 100, 
						pKey_1 => pPart_no,
						pKey_2 => to_char(pNsi_sid),
						pKey_3 => 'prime_ind=' || pPrime_ind) ;
			  		raise ;
			end InsertAgainAfterOneSecond;
		when others then
			   mRC := pBadRc ;
		  	   ErrorMsg(pSqlfunction => 'update',
					pTableName => 'amd_nsi_parts',
					pError_location => 110, 
					pKey_1 => pPart_no) ;
		  		raise ;
	end insertNsiParts;


	/* 8/22/02 DSE added MakeNsnSameForAllParts to eliminate some
	 * redundant code.\
	 */
	function MakeNsnSameForAllParts(
							pNsi_sid in amd_nsi_parts.nsi_sid%type,
							pNsn in amd_national_stock_items.nsn%type) return number is
		cursor partList is
			select
				part_no
			from amd_nsi_parts
			where nsi_sid = pNsi_sid
			and unassignment_date is null;
	begin
		for partList_rec in partList loop
			update amd_spare_parts parts set
				nsn = pNsn
			where part_no = partList_rec.part_no;
		end loop;
		return SUCCESS;
	exception
		when others then
		   mRC := amd_spare_parts_pkg.UPD_NSN_SPARE_PARTS_ERR ;
	  	   ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_nsi_parts',
				pError_location => 120, 
				pKey_1 => to_char(pNsi_sid)) ;
	  		raise ;
	end MakeNsnSameForAllParts;


	/*
		For a given nsn if all related parts are marked
		as deleted, then its associated nsn in the
		amd_national_stock_items should be marked as DELETED.
		For a given nsn if any related part is not marked
		DELETED and its associated nsn is marked DELETED,
		then mark the nsn as either INSERTED or UPDATED depending
		on the current action
	  */
	function UpdateNatStkItem(
							pNsn in amd_spare_parts.nsn%type,
							pAction in varchar2,
							pPartNo varchar2 default null) return number is

		nsi_sid     amd_nsi_parts.nsi_sid%type := null;

		function NumberOfActiveParts return number is
			cnt number := 0;
			result number := SUCCESS;
		begin

			select count(*)
			into cnt
			from  amd_nsi_parts nsi, amd_spare_parts parts
			where nsi.nsi_sid = UpdateNatStkItem.nsi_sid
			and nsi.part_no = parts.part_no
			and nsi.unassignment_date is null
			and parts.action_code != amd_defaults.DELETE_ACTION;

			return cnt;
		exception
			when NO_DATA_FOUND then
				return 0;
			when others then
		  	   ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_nsi_parts',
					pError_location => 130, 
					pKey_1 => to_char(UpdateNatStkItem.nsi_sid)) ;
		  		raise ;
		end NumberOfActiveParts;


		function IsNsnMarkedDeleted return boolean is
			action_code amd_national_stock_items.action_code%type := null;
			result number;
		begin
			select action_code
			into action_code
			from amd_national_stock_items items
			where items.nsi_sid = UpdateNatStkItem.nsi_sid;
			return (action_code = amd_defaults.DELETE_ACTION);
		exception
			when others then
		  	   ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_national_stock_items',
					pError_location => 140, 
					pKey_1 => to_char(UpdateNatStkItem.nsi_sid)) ;
		  		raise ;
		end IsNsnMarkedDeleted;

	begin -- UpdateNatStkItem
	    debugMsg('UpdateNatStkItem(' || pNsn || ', ' || pAction || ', ' || pPartNo || ')', pLineNo => 70) ;
		
		<<GetNsiSid>>
		begin
			/*
				use the nsi_sid to get a row from the
				amd_national_stock_items since it is always
				better than the Nsn - even though this Nsn
				should be the current Nsn for the prime part
				and its equivalent parts.
			*/
			nsi_sid := amd_utils.GetNsiSid(pNsn => pNsn);
		exception
			when NO_DATA_FOUND then
				return amd_spare_parts_pkg.UNABLE_TO_GET_NSI_SID;
		end GetNsiSid;

		if pAction = amd_defaults.DELETE_ACTION then
		
		    <<numberOfActivePartsGt0>>
			begin
				if NumberOfActiveParts() = 0 then
						update amd_national_stock_items set
							action_code    = amd_defaults.DELETE_ACTION,
							last_update_dt = sysdate
						where nsi_sid = UpdateNatStkItem.nsi_sid;
				end if;
			exception
				when others then
					return amd_spare_parts_pkg.UNABLE_TO_GET_NUM_ACTIVE_PARTS;
			end numberOfActivePartsGt0;
			
		else
			/* must be an INSERT_ACTION or an UPDATE_ACTION */
			<<processInsertOrDelete>>
			begin
				if (NumberOfActiveParts() > 0 and IsNsnMarkedDeleted() ) then
					update amd_national_stock_items set
						action_code    = pAction,
						last_update_dt = sysdate
					where nsi_sid = UpdateNatStkItem.nsi_sid;
				end if;
			exception
				when others then
					return amd_spare_parts_pkg.UNABLE_TO_PROC_INS_OR_DLET;
			end processInsertOrDelete;
		end if;

		return SUCCESS;
	exception
		when others then
			mRC := amd_spare_parts_pkg.UPDT_NATSTKITEM_ERR ;
			ErrorMsg(pSqlfunction => 'updateNatStkItem',
				pTableName => 'amd_national_stock_items',
				pError_location => 150) ;
			raise ;
	end UpdateNatStkItem;


	/* 8/22/02 DSE added UpdtNsiPrimePartData to eliminate some
	 * redundant code.
	 */
	function UpdtNsiPrimePartData(
							pPrime_ind in amd_nsi_parts.prime_ind%type,
							pNsi_sid in amd_national_stock_items.nsi_sid%type,
							pPartNo in amd_national_stock_items.prime_part_no%type,
							pNsn in amd_national_stock_items.nsn%type,
							pItem_type in amd_national_stock_items.item_type%type,
							pOrder_quantity in amd_national_stock_items.order_quantity%type,
							pPlannerCode in amd_national_stock_items.planner_code%type,
							pSmr_code in amd_national_stock_items.smr_code%type,
							pMic_code_lowest in amd_national_stock_items.mic_code_lowest%type,
							pAction_code in amd_national_stock_items.action_code%type,
							pReturn_code in number,
							pMmac in amd_national_stock_items.mmac%type) RETURN NUMBER is
		fedcCost   number;
		procedure verifyData is
				  rec amd_national_stock_items%rowtype ;
				  x number := 0 ;
		begin
		    debugMsg('verifyData', pLineNo => 80) ;
		 	x:=x+1;rec.prime_part_no := pPartNo ;
		 	x:=x+1;rec.fedc_cost := fedcCost ;
		 	x:=x+1;rec.nsn := pNsn ;
		 	x:=x+1;rec.item_type := pItem_type ;
		 	x:=x+1;rec.order_quantity := pOrder_quantity ;
		 	x:=x+1;rec.planner_code := pPlannerCode ;
		 	x:=x+1;rec.smr_code := pSmr_Code ;
		 	x:=x+1;rec.mic_code_lowest := pMic_code_lowest ;
			x:=x+1;rec.last_update_dt := sysdate ;
		 	x:=x+1;rec.mmac := pMmac ;
		 	x:=x+1;rec.mtbdr := mMtbdr ;
			x:=x+1;rec.mtbdr_computed := mMtbdr_computed ;
		 	x:=x+1;rec.qpei_weighted := mQpeiWeighted ;
			 
			x:=x+1;rec.condemn_avg_cleaned 		 := mCondemnAvgCleaned ;
			x:=x+1;rec.criticality_cleaned   		   := mCriticalityCleaned ;
			x:=x+1;rec.mtbdr_cleaned 		  		   := mMtbdrCleaned ;
			x:=x+1;rec.nrts_avg_cleaned 	  		   := mNrtsAvgCleaned ;
			x:=x+1;rec.cost_to_repair_off_base_cleand := mCostToRepairOffBaseCleand ;
			x:=x+1;rec.time_to_repair_off_base_cleand := mTimeToRepairOffBaseCleand ;
			x:=x+1;rec.order_lead_time_cleaned 	   := mOrderLeadTimeCleaned ;
			x:=x+1;rec.planner_code_cleaned 		   := mPlannerCodeCleaned ;
			x:=x+1;rec.rts_avg_cleaned 			   := mRtsAvgCleaned ;
			x:=x+1;rec.smr_code_cleaned 			   := mSmrCodeCleaned ;
			x:=x+1;rec.unit_cost_cleaned 			   := mUnitCostCleaned ;
			x:=x+1;rec.condemn_avg 				   := mCondemnAvg ;
			x:=x+1;rec.criticality 				   := mCriticality ;
			x:=x+1;rec.nrts_avg 					   := mNrtsAvg ;
			x:=x+1;rec.rts_avg 					   := mRtsAvg ;
			x:=x+1;rec.cost_to_repair_off_base	   := mCostToRepairOffBase ;
			x:=x+1;rec.time_to_repair_off_base	   := mTimeToRepairOffBase ;
			x:=x+1;rec.action_code := pAction_code ;
		exception when others then
			ErrorMsg(pSqlfunction => 'verifyData',
				pTableName => 'amd_national_stock_items',
				pError_location => 160) ;
			raise ;
		end verifyData ;
		
		procedure doUpdate(planner_code_cleaned in varchar2, planner_code in varchar2) is
				  criticality_changed amd_national_stock_items.CRITICALITY_CHANGED%type 
				   :=  getCriticalityChangedInd(pNsi_sid) ;
				  nrts_avg_changed amd_national_stock_items.NRTS_AVG_CHANGED%type 
				    := getNrtsAvgChangedInd(pNsi_sid) ;
				  rts_avg_changed amd_national_stock_items.RTS_AVG_CHANGED%type 
				    := getRtsAvgChangedInd(pNsi_sid) ;
				  condemn_avg_changed amd_national_stock_items.CONDEMN_AVG_CHANGED%type
				    := getCondemnAvgChangedInd(pNsi_sid) ;
				  cost_to_repair_off_base_chged amd_national_stock_items.COST_TO_REPAIR_OFF_BASE_CHGED%type 
				    := getCostToRepairOffBaseChgedInd(pNsi_sid) ;
				  time_to_repair_off_base_chged amd_national_stock_items.time_to_repair_off_base_chged%type
				    := getTimeToRepairOffBaseChgedInd(PNsi_sid) ;
					
				procedure deleteAnyRblPairs is
				begin
					 
					 delete from amd_rbl_pairs where 
					 		(old_nsn in (select nsn from amd_national_stock_items where nsi_sid = pNsi_sid)
							 and old_nsn <> pNsn)
					 or (new_nsn in (select nsn from amd_national_stock_items where nsi_sid = pNsi_sid) 
					 	 and new_nsn <> pNsn) ;
					 
				end deleteAnyRblPairs ;
				
				   	    
		begin
			debugMsg('doUpdate', pLineNo => 90) ;
			
			deleteAnyRblPairs ;
			
			update amd_national_stock_items set
			    criticality_changed = doUpdate.criticality_changed,
				nrts_avg_changed = doUpdate.nrts_avg_changed,
				rts_avg_changed = doUpdate.rts_avg_changed,
				condemn_avg_changed = doUpdate.condemn_avg_changed,
				cost_to_repair_off_base_chged = doUpdate.cost_to_repair_off_base_chged,
				time_to_repair_off_base_chged = doUpdate.time_to_repair_off_base_chged,
				prime_part_no   = pPartNo,
				fedc_cost       = fedcCost,
				nsn             = pNsn,
				item_type       = pItem_type,
				order_quantity  = pOrder_quantity,
				planner_code    = doUpdate.planner_code,
				smr_code        = pSmr_code,
				mic_code_lowest = pMic_code_lowest,
				last_update_dt  = sysdate,
				mmac			= pMmac,
				mtbdr			= mMtbdr,
				mtbdr_computed  = mMtbdr_computed,
				qpei_weighted	= mQpeiWeighted,
				condemn_avg_cleaned 		   = mCondemnAvgCleaned,
				criticality_cleaned   		   = mCriticalityCleaned,
				mtbdr_cleaned 		  		   = mMtbdrCleaned,
				nrts_avg_cleaned 	  		   = mNrtsAvgCleaned,
				cost_to_repair_off_base_cleand = mCostToRepairOffBaseCleand,
				time_to_repair_off_base_cleand = mTimeToRepairOffBaseCleand,
				order_lead_time_cleaned 	   = mOrderLeadTimeCleaned,
				planner_code_cleaned 		   = doUpdate.planner_code_cleaned,
				rts_avg_cleaned 			   = mRtsAvgCleaned,
				smr_code_cleaned 			   = mSmrCodeCleaned,
				unit_cost_cleaned 			   = mUnitCostCleaned,
				condemn_avg 				   = mCondemnAvg,
				criticality 				   = mCriticality,
				nrts_avg 					   = mNrtsAvg,
				rts_avg 					   = mRtsAvg,
				cost_to_repair_off_base		   = mCostToRepairOffBase,
				time_to_repair_off_base		   = mTimeToRepairOffBase,
				action_code     			   = pAction_code
			where nsi_sid = pNsi_sid;
		end doUpdate ;
		
	begin
		debugMsg('UpdtNsiPrimePartData',pLineNo => 100) ;
		if (IsPrimePart(pPrime_ind)) then
			fedcCost := getFedcCost(pPartNo);
			
			verifyData ;
			

			begin
				 doUpdate (planner_code_cleaned => mPlannerCodeCleaned, planner_code => pPlannerCode);
			exception when others then
				if sqlcode = -2291 then
				   <<constraintError>>
				   declare
				   		  msg varchar2(50) ;
						  planner_code amd_planners.planner_code%type ;
				   begin
				       -- figurr out which foreign key does not have a parent
					   if instr(sqlerrm,'FK04') > 0  then
						  if substr(pNsn,1,3) = 'NSL' then
						  	 mPlannerCodeCleaned := amd_defaults.NSL_PLANNER_CODE ;
						  else
						     mPlannerCodeCleaned := amd_defaults.NSN_PLANNER_CODE ;
						  end if ;
						  doUpdate (planner_code_cleaned => mPlannerCodeCleaned, planner_code => pPlannerCode) ;
						  return SUCCESS ;
					   elsif instr(sqlerrm,'FK03') > 0 then
						  if substr(pNsn,1,3) = 'NSL' then
						  	 planner_code := amd_defaults.NSL_PLANNER_CODE ;
						  else
						     planner_code := amd_defaults.NSN_PLANNER_CODE ;
						  end if ;
						  doUpdate(planner_code_cleaned => mPlannerCodeCleaned, planner_code => planner_code) ;
					   	  return SUCCESS ;
					   elsif instr(sqlerrm,'FK02') > 0 then
					   	  msg := 'no parent for partNo=' || pPartNo ;
					   elsif instr(sqlerrm,'FK01') > 0 then
					   	  msg := 'no parent for nsn=' || pNsn ;
					   else
					   	   msg := 'Unknown' ;
					   end if ;
					   mRC := pReturn_code ;
					   ErrorMsg(pSqlfunction => 'UpdtNsiPrimePartData',
							pTableName => 'amd_national_stock_items',
							pError_location => 170,
							pKey_1 => pPartNo,
							pKey_2 => to_char(pNsi_sid),
							pKey_3 => msg) ;
						raise ;
					end constraintError ;
				else
				   mRC := pReturn_code ;
				   ErrorMsg(pSqlfunction => 'UpdtNsiPrimePartData',
						pTableName => 'amd_national_stock_items',
						pError_location => 180,
						pKey_1 => pPartNo,
						pKey_2 => to_char(pNsi_sid),
						pKey_3 => 'plannerCodeCleaned=' || mPlannerCodeCleaned) ;
					raise ;
				end if ;
			end ;
		end if;

		return SUCCESS;

	exception
		when others then
		   mRC := pReturn_code ;
		   ErrorMsg(pSqlfunction => 'UpdtNsiPrimePartData',
				pTableName => 'amd_national_stock_items',
				pError_location => 190,
				pKey_1 => pPartNo,
				pKey_2 => to_char(pNsi_sid),
				pKey_3 => 'nsn=' || pNsn) ;
			raise ;
	end UpdtNsiPrimePartData;


	function InsertNatStkItem(
							pNsi_sid out amd_national_stock_items.nsi_sid%type,
							pNsn in amd_spare_parts.nsn%type,
							pItem_type in amd_national_stock_items.item_type%type,
							pOrder_quantity in amd_national_stock_items.order_quantity%type,
							pPlanner_code in amd_national_stock_items.planner_code%type,
							pSmr_code in amd_national_stock_items.smr_code%type,
							pTactical in amd_national_stock_items.tactical%type,
							pMic_code_lowest in amd_national_stock_items.mic_code_lowest%type,
							pMmac in amd_national_stock_items.mmac%type) RETURN NUMBER is

		result number := SUCCESS;
		nsiGroupSid number;

		function GetNsiSid return amd_national_stock_items.nsi_sid%type is
			nsi_sid amd_national_stock_items.nsi_sid%type := null;
		begin
			select amd_nsi_sid_seq.CURRVAL
			into nsi_sid
			from dual;
			return nsi_sid;
		end GetNsiSid;

	begin -- InsertNatStkItem
	    debugMsg('InsertNatStkItem', pLineNo => 110) ;
		nsiGroupSid := amd_default_effectivity_pkg.NewGroup;

		begin
			INSERT INTO AMD_NATIONAL_STOCK_ITEMS
			(
				nsn,
				add_increment_cleaned,
				amc_base_stock_cleaned,
				amc_days_experience_cleaned,
				amc_demand_cleaned,
				capability_requirement_cleaned,
				criticality_cleaned,
				distrib_uom_defaulted,
				dla_demand_cleaned,
				current_backorder_cleaned,
				fedc_cost_cleaned,
				item_type,
				item_type_cleaned,
				mic_code_lowest_cleaned,
				mtbdr_cleaned,
				nomenclature_cleaned,
				order_lead_time_cleaned,
				order_quantity,
				order_quantity_defaulted,
				order_uom_cleaned,
				planner_code,
				planner_code_cleaned,
				prime_part_no,
				qpei_weighted_defaulted,
				ru_ind_cleaned,
				smr_code,
				smr_code_cleaned,
				unit_cost_cleaned,
				condemn_avg_defaulted,
				condemn_avg_cleaned,
				nrts_avg_defaulted,
				nrts_avg_cleaned,
				rts_avg_defaulted,
				rts_avg_cleaned,
				cost_to_repair_off_base_cleand,
				time_to_repair_off_base_cleand,
				time_to_repair_on_base_avg_df,
				time_to_repair_on_base_avg_cl,
				tactical,
				action_code,
				last_update_dt,
				mic_code_lowest,
				nsi_group_sid,
				latest_config,
				effect_by,
				mmac,
				mtbdr,
				mtbdr_computed,
				qpei_weighted,
				criticality,
				nrts_avg,
				rts_avg,
				cost_to_repair_off_base,
				time_to_repair_off_base
			)
			VALUES
			(
				NULL, -- nsn
				Amd_Clean_Data.GetAddIncrement(pNsn),
				Amd_Clean_Data.GetAmcBaseStock(pNsn),
				Amd_Clean_Data.GetAmcDaysExperience(pNsn),
				Amd_Clean_Data.GetAmcDemand(pNsn),
				Amd_Clean_Data.GetCapabilityRequirement(pNsn),
				mCriticalityCleaned,
				Amd_Defaults.DISTRIB_UOM,
				Amd_Clean_Data.GetDlaDemand(pNsn),
				Amd_Clean_Data.GetCurrentBackorder(pNsn),
				Amd_Clean_Data.GetFedcCost(pNsn),
				pItem_type,
				Amd_Clean_Data.GetItemType(pNsn),
				Amd_Clean_Data.GetMicCodeLowest(pNsn),
				mMtbdrCleaned,
				Amd_Clean_Data.GetNomenclature(pNsn),
				mOrderLeadTimeCleaned,
				pOrder_Quantity,
				Amd_Defaults.ORDER_QUANTITY,
				Amd_Clean_Data.GetOrderUom(pNsn),
				pPlanner_code,
				mPlannerCodeCleaned,
				NULL, -- prime_part_no
				Amd_Defaults.QPEI_WEIGHTED,
				Amd_Clean_Data.GetRuInd(pNsn),
				pSmr_code,
				mSmrCodeCleaned,
				mUnitCostCleaned,
				mCondemnAvg,
				mCondemnAvgCleaned,
				Amd_Defaults.NRTS_AVG,
				mNrtsAvgCleaned,
				Amd_Defaults.RTS_AVG,
				mRtsAvgCleaned,
				mCostToRepairOffBaseCleand,
				mTimeToRepairOffBaseCleand,
				Amd_Defaults.TIME_TO_REPAIR_ONBASE,
				Amd_Clean_Data.GetTimeToRepairOnBaseAvg(pNsn),
				pTactical,
				Amd_Defaults.INSERT_ACTION,
				SYSDATE,
				pMic_code_lowest,
				nsiGroupSid,
				'Y',
				'S',
				pMmac,
				mMtbdr,
				mMtbdr_computed,
				mQpeiWeighted,
				mCriticality,
				mNrtsAvg,
				mRtsAvg,
				mCostToRepairOffBase,
				mTimeToRepairOffBase
			);
		exception
			when others then
			   mRC := amd_spare_parts_pkg.CREATE_NATSTKITEM_ERR ;
			   ErrorMsg(pSqlfunction => 'insert',
					pTableName => 'amd_national_stock_items',
					pError_location => 200) ;
			   raise ;
		end InsertNsi;

		pNsi_sid := GetNsiSid();

		return SUCCESS;
	end InsertNatStkItem;


	function ChgCurNsn2TempNsn(
							pNsiSid in amd_nsns.nsi_sid%type) return number is
	begin
	    debugMsg('ChgCurNsn2TempNsn(' || pNsiSid || ')', pLineNo => 120) ;
		update amd_nsns set
			nsn_type = amd_spare_parts_pkg.TEMPORARY_NSN
		where nsi_sid = pNsiSid and nsn_type = amd_spare_parts_pkg.CURRENT_NSN;
		return SUCCESS;
	exception
		when others then
		   mRC := amd_spare_parts_pkg.UNABLE_TO_CHG_NSN_TYPE ;
		   ErrorMsg(pSqlfunction => 'update',
				pTableName => 'amd_nsns',
				pError_location => 210,
				pKey_1 => to_char(pNsiSid)) ;
		   raise ;
	end ChgCurNsn2TempNsn;


	function InsertAmdNsn(
							pNsi_sid in amd_nsns.nsi_sid%type,
							pNsn in amd_nsns.nsn%type,
							pNsn_type in amd_nsns.nsn_type%type ) return number is

		result number ;

	begin
	    debugMsg('InsertAmdNsn(' || pNsi_sid || ', ' || pNsn || ', ' || pNsn_type, pLineNo => 130) ;
	    if pNsn_type = amd_spare_parts_pkg.CURRENT_NSN then
		   result:= ChgCurNsn2TempNsn(pNsiSid => pNsi_sid);
		end if;
		if result = SUCCESS then
			insert into amd_nsns
			(
				nsn,
				nsn_type,
				nsi_sid,
				creation_date
			)
			values
			(
				pNsn,
				pNsn_type,
				pNsi_sid,
				sysdate
			);
			return SUCCESS;
		end if;
		return result;
	exception
		when others then
		   mRC := amd_spare_parts_pkg.UNABLE_TO_INSERT_AMD_NSNS ;
		   ErrorMsg(pSqlfunction => 'insert',
				pTableName => 'amd_nsns',
				pError_location => 220,
				pKey_1 => to_char(pNsi_Sid),
				pKey_2 => pNsn,
				pKey_3 => pNsn_type) ;
		   raise ;
	end InsertAmdNsn;


	function UpdateAmdNsn(
							pNsi_sid in amd_nsns.nsi_sid%type,
							pNsn in amd_nsns.nsn%type,
							pNsn_type in amd_nsns.nsn_type%type ) return number is
		result number;
	begin
		debugMsg('UpdateAmdNsn(' || pNsi_sid || ', ' || pNsn || ', ' || pNsn_type || ')', pLineNo => 140) ;
		if pNsn_type = amd_spare_parts_pkg.CURRENT_NSN then
		   result:= ChgCurNsn2TempNsn(pNsiSid => pNsi_sid);
		end if ;
		if result = SUCCESS then
			update amd_nsns set
				nsn_type = pNsn_type
			where nsi_sid = pNsi_sid and nsn = pNsn;
			return SUCCESS;
		end if;
		return result;

	exception
		when others then
		   mRC := amd_spare_parts_pkg.UNABLE_TO_INSERT_AMD_NSNS ;
		   ErrorMsg(pSqlfunction => 'update',
				pTableName => 'amd_nsns',
				pError_location => 230,
				pKey_1 => to_char(pNsi_Sid),
				pKey_2 => pNsn) ;
		   raise ;
	end UpdateAmdNsn;


	function CreateNationalStockItem(
							pNsi_sid out amd_national_stock_items.nsi_sid%type,
							pNsn in amd_spare_parts.nsn%type,
							pItem_type in amd_national_stock_items.item_type%type,
							pOrder_quantity in amd_national_stock_items.order_quantity%type,
							pPlanner_code in amd_national_stock_items.planner_code%type,
							pSmr_code in amd_national_stock_items.smr_code%type,
							pTactical in amd_national_stock_items.tactical%type,
							pMic_code_lowest in amd_national_stock_items.mic_code_lowest%type,
							pNsn_type in amd_nsns.nsn_type%type,
							pMmac in amd_national_stock_items.mmac%type) RETURN NUMBER is
		result number := SUCCESS;

	begin
		result := InsertNatStkItem(pNsi_sid => pNsi_sid,
					 pNsn => pNsn,
					 pItem_type => pItem_type,
					 pOrder_quantity => pOrder_quantity,
					 pPlanner_code => pPlanner_code,
					 pSmr_code => pSmr_code,
					 pTactical => pTactical,
					 pMic_code_lowest => pMic_code_lowest,
					 pMmac => pMmac) ;					 

		if result = SUCCESS then
		   amd_default_effectivity_pkg.SetNsiEffects(pNsi_sid);
		   if pNsn_type = amd_spare_parts_pkg.CURRENT_NSN then
		   	  result := amd_spare_parts_pkg.ChgCurNsn2TempNsn(
							pNsiSid => pNsi_sid);
		   end if;
		   if result = SUCCESS then
		   	  result := InsertAmdNsn(pNsi_sid => pNsi_sid, pNsn => pNsn, pNsn_type => pNsn_type);
		   end if;
		end if;

		return result;

	end CreateNationalStockItem;

	-- forward declare the old insertRow method, which is now private, so it can be used in
	-- the new public insertRow method
	FUNCTION InsertRow
                (pPart_no IN VARCHAR2,
                pMfgr IN VARCHAR2,
                pDate_icp IN DATE,
                pDisposal_cost IN NUMBER,
                pErc IN VARCHAR2,
                pIcp_ind IN VARCHAR2,
                pNomenclature IN VARCHAR2,
                pOrder_lead_time IN NUMBER,
				pOrder_quantity IN NUMBER,
                pOrder_uom IN VARCHAR2,
				pPrime_ind IN VARCHAR2,
                pScrap_value IN NUMBER,
                pSerial_flag IN VARCHAR2,
                pShelf_life IN NUMBER,
                pUnit_cost IN NUMBER,
                pUnit_volume IN NUMBER,
                pNsn IN VARCHAR2,
				pNsn_type IN VARCHAR2,
                pItem_type IN VARCHAR2,
                pSmr_code IN VARCHAR2,
                pPlanner_code IN VARCHAR2,
				pMic_code_lowest IN VARCHAR2,
				pAcquisition_advice_code IN VARCHAR2,
				pMmac IN VARCHAR2,
				pUnitOfIssue IN VARCHAR2) return number ;
				
	FUNCTION InsertRow
                (pPart_no IN VARCHAR2,
                pMfgr IN VARCHAR2,
                pDate_icp IN DATE,
                pDisposal_cost IN NUMBER,
                pErc IN VARCHAR2,
                pIcp_ind IN VARCHAR2,
                pNomenclature IN VARCHAR2,
                pOrder_lead_time IN NUMBER,
				pOrder_quantity IN NUMBER,
                pOrder_uom IN VARCHAR2,
				pPrime_ind IN VARCHAR2,
                pScrap_value IN NUMBER,
                pSerial_flag IN VARCHAR2,
                pShelf_life IN NUMBER,
                pUnit_cost IN NUMBER,
                pUnit_volume IN NUMBER,
                pNsn IN VARCHAR2,
				pNsn_type IN VARCHAR2,
                pItem_type IN VARCHAR2,
                pSmr_code IN VARCHAR2,
                pPlanner_code IN VARCHAR2,
				pMic_code_lowest IN VARCHAR2,
				pAcquisition_advice_code IN VARCHAR2,
				pMmac IN VARCHAR2,
				pUnitOfIssue IN VARCHAR2,
				pMtbdr in number,
				pMtbdr_computed in number,
  				pQpeiWeighted in number,
  				pCondemnAvgCleaned in number,
  				pCriticalityCleaned in number,
  				pMtbdrCleaned in number,
  				pNrtsAvgCleaned in number,
  				pCosToRepairOffBaseCleand in number,
  				pTimeToRepairOffBaseCleand in  number,
  				pOrderLeadTimeCleaned in number,
  				pPlannerCodeCleaned in amd_national_stock_items.planner_code_cleaned%type,
  				pRtsAvgCleaned in number,
  				pSmrCodeCleaned in amd_national_stock_items.smr_code_cleaned%type,
  				pUnitCostCleaned in number,
  				pCondemnAvg in number,
  				pCriticality in number,
  				pNrtsAvg in number,
  				pRtsAvg in number,
				pCostToRepairOffBase in number,
				pTimeToRepairOffBase in number) return number is
	begin
		 -- By overriding the insertRow and updateRow routines all that needs to be done
		 -- is to set the member variables to the values passed in and then invoke
		 -- the old insertRow method, which is now private, That way I don't have to pass parameters just get the data
		 -- from these global member variables.
		 mArgs := 'insertRow(' || pPart_no || ', ' ||
                pMfgr || ', ' ||
                pDate_icp || ', ' ||
                pDisposal_cost || ', ' ||
                pErc || ', ' ||
                pIcp_ind || ', ' ||
                pNomenclature || ', ' ||
                pOrder_lead_time || ', ' ||
				pOrder_quantity || ', ' ||
                pOrder_uom || ', ' ||
				pPrime_ind || ', ' ||
                pScrap_value || ', ' ||
                pSerial_flag || ', ' ||
                pShelf_life || ', ' ||
                pUnit_cost || ', ' ||
                pUnit_volume || ', ' ||
                pNsn || ', ' ||
				pNsn_type || ', ' ||
                pItem_type || ', ' ||
                pSmr_code || ', ' ||
                pPlanner_code || ', ' ||
				pMic_code_lowest || ', ' ||
				pAcquisition_advice_code || ', ' ||
				pMmac || ', ' ||
				pUnitOfIssue || ', ' ||
				pMtbdr || ', ' ||
				pMtbdr_computed || ', ' ||
  				pQpeiWeighted || ', ' ||
  				pCondemnAvgCleaned || ', ' ||
  				pCriticalityCleaned || ', ' ||
  				pMtbdrCleaned || ', ' ||
  				pNrtsAvgCleaned || ', ' ||
  				pCosToRepairOffBaseCleand || ', ' ||
  				pTimeToRepairOffBaseCleand || ', ' ||
  				pOrderLeadTimeCleaned || ', ' ||
  				pPlannerCodeCleaned || ', ' ||
  				pRtsAvgCleaned || ', ' ||
  				pSmrCodeCleaned || ', ' ||
  				pUnitCostCleaned || ', ' ||
  				pCondemnAvg || ', ' ||
  				pCriticality || ', ' ||
  				pNrtsAvg || ', ' ||
  				pRtsAvg || ')' ;
		 mMtbdr 		   		   	:= pMtbdr ;
		 mMtbdr_computed			:= pMtbdr_computed ;
  		 mQpeiWeighted 	   		   	:= pQpeiWeighted ;
  		 mCondemnAvgCleaned 		:= pCondemnAvgCleaned ;
  		 mCriticalityCleaned   		:= pCriticalityCleaned ;
  		 mMtbdrCleaned 		 		:= pMtbdrCleaned ;
		 mNrtsAvgCleaned  			:= pNrtsAvgCleaned ;
		 mCostToRepairOffBaseCleand := pCosToRepairOffBaseCleand ;
  		 mTimeToRepairOffBaseCleand := pTimeToRepairOffBaseCleand ;
  		 mOrderLeadTimeCleaned 		:= pOrderLeadTimeCleaned ;
  		 mPlannerCodeCleaned   		:= pPlannerCodeCleaned ;
		 mRtsAvgCleaned 	 		:= pRtsAvgCleaned ;
  		 mSmrCodeCleaned 			:= pSmrCodeCleaned ;
  		 mUnitCostCleaned			:= pUnitCostCleaned ;
  		 mCondemnAvg				:= pCondemnAvg ;
  		 mCriticality				:= pCriticality ;
  		 mNrtsAvg					:= pNrtsAvg ;
  		 mRtsAvg					:= pRtsAvg ;
		 mCostToRepairOffBase		:= pCostToRepairOffBase ;
		 mTimeToRepairOffBase		:= pTimeToRepairOffBase ;
		 
		 return InsertRow
                (pPart_no,
                pMfgr,
                pDate_icp,
                pDisposal_cost,
                pErc,
                pIcp_ind,
                pNomenclature,
                pOrder_lead_time,
				pOrder_quantity,
                pOrder_uom,
				pPrime_ind,
                pScrap_value,
                pSerial_flag,
                pShelf_life,
                pUnit_cost,
                pUnit_volume,
                pNsn,
				pNsn_type,
                pItem_type,
                pSmr_code,
                pPlanner_code,
				pMic_code_lowest,
				pAcquisition_advice_code,
				pMmac,
				pUnitOfIssue) ;
				
	end InsertRow ;

	-- forward declare the old updateRow method, which is now private, so it can be used in
	-- the new public updateRow method
	FUNCTION UpdateRow
                (pPart_no IN VARCHAR2,
                pMfgr IN VARCHAR2,
                pDate_icp IN DATE,
                pDisposal_cost in number,
                pErc IN VARCHAR2,
                pIcp_ind IN VARCHAR2,
                pNomenclature IN VARCHAR2,
                pOrder_lead_time IN NUMBER,
				pOrder_quantity IN NUMBER,
                pOrder_uom IN VARCHAR2,
				pPrime_ind IN VARCHAR2,
                pScrap_value IN NUMBER,
                pSerial_flag IN VARCHAR2,
                pShelf_life IN NUMBER,
                pUnit_cost IN NUMBER,
                pUnit_volume IN NUMBER,
                pNsn IN VARCHAR2,
				pNsn_type IN VARCHAR2,
                pItem_type IN VARCHAR2,
                pSmr_code IN VARCHAR2,
                pPlanner_code IN VARCHAR2,
				pMic_code_lowest IN VARCHAR2,
				pAcquisition_advice_code IN VARCHAR2,
				pMmac IN VARCHAR2,
				pUnitOfIssue IN VARCHAR2) return number ;

	FUNCTION UpdateRow
                (pPart_no IN VARCHAR2,
                pMfgr IN VARCHAR2,
                pDate_icp IN DATE,
                pDisposal_cost IN NUMBER,
                pErc IN VARCHAR2,
                pIcp_ind IN VARCHAR2,
                pNomenclature IN VARCHAR2,
                pOrder_lead_time IN NUMBER,
				pOrder_quantity IN NUMBER,
                pOrder_uom IN VARCHAR2,
				pPrime_ind IN VARCHAR2,
                pScrap_value IN NUMBER,
                pSerial_flag IN VARCHAR2,
                pShelf_life IN NUMBER,
                pUnit_cost IN NUMBER,
                pUnit_volume IN NUMBER,
                pNsn IN VARCHAR2,
				pNsn_type IN VARCHAR2,
                pItem_type IN VARCHAR2,
                pSmr_code IN VARCHAR2,
                pPlanner_code IN VARCHAR2,
				pMic_code_lowest IN VARCHAR2,
				pAcquisition_advice_code IN VARCHAR2,
				pMmac IN VARCHAR2,
				pUnitOfIssue IN VARCHAR2,
				pMtbdr in number,
				pMtbdr_computed in number,
  				pQpeiWeighted in number,
  				pCondemnAvgCleaned in number,
  				pCriticalityCleaned in number,
  				pMtbdrCleaned in number,
  				pNrtsAvgCleaned in number,
  				pCosToRepairOffBaseCleand in number,
  				pTimeToRepairOffBaseCleand in  number,
  				pOrderLeadTimeCleaned in number,
  				pPlannerCodeCleaned in amd_national_stock_items.planner_code_cleaned%type,
  				pRtsAvgCleaned in number,
  				pSmrCodeCleaned in amd_national_stock_items.smr_code_cleaned%type,
  				pUnitCostCleaned in number,
  				pCondemnAvg in number,
  				pCriticality in number,
  				pNrtsAvg in number,
  				pRtsAvg in number,
				pCostToRepairOffBase in number,
				pTimeToRepairOffBase in number) return number is
				
				lineNo number := 0 ;
				result number ;
	begin
		 -- By overriding the updateRow andinsertRow routines all that needs to be done
		 -- is to set the member variables to the values passed in and then invoke
		 -- the old updateRow method, which is now private, That way I don't have to pass parameters just get the data
		 -- from these global member variables.
		 mArgs := 'UpdateRow(' || pPart_no || ', ' ||
                pMfgr || ', ' ||
                pDate_icp || ', ' ||
                pDisposal_cost || ', ' ||
                pErc || ', ' ||
                pIcp_ind || ', ' ||
                pNomenclature || ', ' ||
                pOrder_lead_time || ', ' ||
				pOrder_quantity || ', ' ||
                pOrder_uom || ', ' ||
				pPrime_ind || ', ' ||
                pScrap_value || ', ' ||
                pSerial_flag || ', ' ||
                pShelf_life || ', ' ||
                pUnit_cost || ', ' ||
                pUnit_volume || ', ' ||
                pNsn || ', ' ||
				pNsn_type || ', ' ||
                pItem_type || ', ' ||
                pSmr_code || ', ' ||
                pPlanner_code || ', ' ||
				pMic_code_lowest || ', ' ||
				pAcquisition_advice_code || ', ' ||
				pMmac || ', ' ||
				pUnitOfIssue || ', ' ||
				pMtbdr || ', ' ||
				pMtbdr_computed || ', ' ||
  				pQpeiWeighted || ', ' ||
  				pCondemnAvgCleaned || ', ' ||
  				pCriticalityCleaned || ', ' ||
  				pMtbdrCleaned || ', ' ||
  				pNrtsAvgCleaned || ', ' ||
  				pCosToRepairOffBaseCleand || ', ' ||
  				pTimeToRepairOffBaseCleand || ', ' ||
  				pOrderLeadTimeCleaned || ', ' ||
  				pPlannerCodeCleaned || ', ' ||
  				pRtsAvgCleaned || ', ' ||
  				pSmrCodeCleaned || ', ' ||
  				pUnitCostCleaned || ', ' ||
  				pCondemnAvg || ', ' ||
  				pCriticality || ', ' ||
  				pNrtsAvg || ', ' ||
  				pRtsAvg || ', ' ||
				pCostToRepairOffBase || ', ' ||
				pTimeToRepairOffBase || ')' ;
		 lineNo := lineNo + 1 ;mMtbdr 		   		   	:= pMtbdr ;
		 lineNo := lineNo + 1 ;mMtbdr_computed			:= pMtbdr_computed ;
  		 lineNo := lineNo + 1 ;mQpeiWeighted 	   		   	:= pQpeiWeighted ;
  		 lineNo := lineNo + 1 ;mCondemnAvgCleaned 		:= pCondemnAvgCleaned ;
  		 lineNo := lineNo + 1 ;mCriticalityCleaned   		:= pCriticalityCleaned ;
  		 lineNo := lineNo + 1 ;mMtbdrCleaned 		 		:= pMtbdrCleaned ;
		 lineNo := lineNo + 1 ;mNrtsAvgCleaned  			:= pNrtsAvgCleaned ;
		 lineNo := lineNo + 1 ;mCostToRepairOffBaseCleand := pCosToRepairOffBaseCleand ;
  		 lineNo := lineNo + 1 ;mTimeToRepairOffBaseCleand := pTimeToRepairOffBaseCleand ;
  		 lineNo := lineNo + 1 ;mOrderLeadTimeCleaned 		:= pOrderLeadTimeCleaned ;
  		 lineNo := lineNo + 1 ;mPlannerCodeCleaned   		:= pPlannerCodeCleaned ;
		 lineNo := lineNo + 1 ;mRtsAvgCleaned 	 		:= pRtsAvgCleaned ;
  		 lineNo := lineNo + 1 ;mSmrCodeCleaned 			:= pSmrCodeCleaned ;
  		 lineNo := lineNo + 1 ;mUnitCostCleaned			:= pUnitCostCleaned ;
  		 lineNo := lineNo + 1 ;mCondemnAvg				:= pCondemnAvg ;
  		 lineNo := lineNo + 1 ;mCriticality				:= pCriticality ;
  		 lineNo := lineNo + 1 ;mNrtsAvg					:= pNrtsAvg ;
  		 lineNo := lineNo + 1 ;mRtsAvg					:= pRtsAvg ;
		 lineNo := lineNo + 1 ;mCostToRepairOffBase		:= pCostToRepairOffBase ;
		 lineNo := lineNo + 1 ;mTimeToRepairOffBase		:= pTimeToRepairOffBase ;
		 
		 return UpdateRow
                (pPart_no,
                pMfgr,
                pDate_icp,
                pDisposal_cost,
                pErc,
                pIcp_ind,
                pNomenclature,
                pOrder_lead_time,
				pOrder_quantity,
                pOrder_uom,
				pPrime_ind,
                pScrap_value,
                pSerial_flag,
                pShelf_life,
                pUnit_cost,
                pUnit_volume,
                pNsn,
				pNsn_type,
                pItem_type,
                pSmr_code,
                pPlanner_code,
				pMic_code_lowest,
				pAcquisition_advice_code,
				pMmac,
				pUnitOfIssue) ;
	exception when others then
		   ErrorMsg(pSqlfunction => 'updateRow',
				pTableName => '',
				pError_location => 240) ;
		   return UPDT_ERRX ;
	end UpdateRow ;

	function InsertRow(
							pPart_no in varchar2,
							pMfgr in varchar2,
							pDate_icp in date,
							pDisposal_cost in number,
							pErc in varchar2,
							pIcp_ind in varchar2,
							pNomenclature in varchar2,
							pOrder_lead_time in number,
							pOrder_quantity in number,
							pOrder_uom in varchar2,
							pPrime_ind in varchar2,
							pScrap_value in number,
							pSerial_flag in varchar2,
							pShelf_life in number,
							pUnit_cost in number,
							pUnit_volume in number,
							pNsn in varchar2,
							pNsn_type in varchar2,
							pItem_type in varchar2,
							pSmr_code in varchar2,
							pPlanner_code in varchar2,
							pMic_code_lowest in varchar2,
							pAcquisition_advice_code in varchar2,
							pMmac in varchar2,
							pUnitOfIssue in varchar2) RETURN NUMBER is

		/* Although the following variables are local to the InsertRow
		  procedure, you will see them referenced as InsertRow.variable_name.
		  This was done to improve readability.  A similar approach is used
		  for package constants: package_name.constant_name.
		 */
		prime_ind_cleaned    amd_nsi_parts.prime_ind_cleaned%type := null;
		result               number := SUCCESS;
		tactical             amd_spare_parts.tactical%type := 'N';
		unit_cost_defaulted  amd_spare_parts.unit_cost_defaulted%type := null;


		/* Put a wrapper on the amd_utils.InsertErrorMsg procedure, so it is
			more specific to the InsertRow function.  Output gets stored
			into amd_load_details and amd_load_status.
		*/

		function InsertAmdNsiParts(
							pNsi_sid in amd_nsi_parts.nsi_sid%type) return number is

			result number := SUCCESS;
		begin
			return insertNsiParts(pNsi_sid => pNsi_sid,
				   	   pPart_no => pPart_no,
				   	   pPrime_ind => pPrime_ind,
					   pPrime_ind_cleaned => prime_ind_cleaned,
				   	   pBadRc => amd_spare_parts_pkg.UNABLE_TO_INSERT_AMD_NSI_PARTS);
		end InsertAmdNsiParts;


		function InsertEquivalentPartData(
							pNsi_sid in amd_nsi_parts.nsi_sid%type) return number is
		begin
			return InsertAmdNsiParts(pNsi_sid);
		end InsertEquivalentPartData;


		function DoPhysicalInsert return number is

			nsi_sid amd_national_stock_items.nsi_sid%type := null;

			function IsPrimeReplacingExistingOne(
							pNsi_sid in amd_nsi_parts.nsi_sid%type,
							pCurrent_prime_part_no out amd_nsi_parts.part_no%type) return boolean is

				prime_ind amd_nsi_parts.prime_ind%type := null;
			begin
				begin
					select
						part_no,
						prime_ind
					into pCurrent_prime_part_no, prime_ind
					from amd_nsi_parts
					where nsi_sid = pNsi_sid
					and prime_ind = amd_defaults.PRIME_PART
					and unassignment_date is null;
					return true;
				exception
					when no_data_found then
						return false;
				end;
			end IsPrimeReplacingExistingOne;


			function PrepareDataForInsert return number is
			begin

				-- todo prime_ind_cleaned will be set in a separate routine since it is
				-- so complicated
				-- InsertRow.prime_ind_cleaned := amd_clean_data.prime_ind(nsn);

				<<getTacticalInd>>
				begin
					InsertRow.tactical :=
							amd_validation_pkg.GetTacticalInd(
								amd_preferred_pkg.GetPreferredValue(mUnitCostCleaned,
										  pUnit_cost,
										  InsertRow.unit_cost_defaulted),
								amd_preferred_pkg.GetPreferredValue(mSmrCodeCleaned,
										 pSmr_code)
								 );
				exception
					when others then
					   ErrorMsg(pSqlfunction => 'getTacticalInd',
							pError_location => 270) ;
					   raise ;
				end getTacticalInd;

				if pPlanner_code is not null then
					if not amd_validation_pkg.IsValidPlannerCode(pPlanner_code) then
						if amd_validation_pkg.AddPlannerCode(pPlanner_code) != amd_validation_pkg.SUCCESS then
							return amd_spare_parts_pkg.ADD_PLANNER_CODE_ERR;
						end if;
					end if;
				end if;

				if pOrder_uom is not null then
					if not amd_validation_pkg.IsValidUomCode(pOrder_uom) then
						if amd_validation_pkg.AddUomCode(pOrder_uom) != amd_validation_pkg.SUCCESS then
							return amd_spare_parts_pkg.ADD_UOM_CODE_ERR;
						end if;
					end if;
				end if;
				return SUCCESS;
			exception
				when others then
				       mRC := amd_spare_parts_pkg.UNABLE_TO_PREP_DATA ;
					   ErrorMsg(pSqlfunction => 'prepareDataForInsert',
							pError_location => 280) ;
					   raise ;
			end prepareDataForInsert;


			function NatStkItemExists(
							pNsn in amd_spare_parts.nsn%type,
							pNsi_sid out amd_nsns.nsi_sid%type) return boolean is
			begin
				select nsi_sid
				into pNsi_sid
				from amd_nsns
				where nsn = pNsn
				and nsi_sid is not null;
				return true;
			exception
				when no_data_found then
					return false;
			end NatStkItemExists;


			function InsertSparePart return number is
			begin
				insert into amd_spare_parts
				(
					part_no,
					mfgr,
					date_icp,
					disposal_cost,
					disposal_cost_defaulted,
					erc,
					icp_ind,
					nomenclature ,
					order_lead_time,
					order_lead_time_defaulted,
					order_uom,
					order_uom_defaulted,
					scrap_value,
					scrap_value_defaulted,
					serial_flag,
					shelf_life,
					shelf_life_defaulted,
					unit_cost,
					unit_cost_defaulted,
					unit_volume,
					unit_volume_defaulted,
					nsn,
					tactical,
					action_code,
					last_update_dt,
					acquisition_advice_code,
					unit_of_issue
				)
				values
				(
					pPart_no,
					pMfgr,
					pDate_icp,
					pDisposal_cost,
					amd_defaults.DISPOSAL_COST,
					pErc,
					pIcp_ind,
					pNomenclature ,
					pOrder_lead_time,
					amd_defaults.GetOrderLeadTime(pItem_type),
					pOrder_uom,
					amd_defaults.ORDER_UOM,
					pScrap_value,
					amd_defaults.SCRAP_VALUE,
					pSerial_flag,
					pShelf_life,
					amd_defaults.SHELF_LIFE,
					pUnit_cost,
					InsertRow.unit_cost_defaulted,
					pUnit_volume,
					amd_defaults.UNIT_VOLUME,
					pNsn,
					InsertRow.tactical,
					amd_defaults.INSERT_ACTION,
					sysdate,
					pAcquisition_advice_code,
					pUnitOfIssue
				);
				return SUCCESS;
			exception
				when DUP_VAL_ON_INDEX then	   
					   ErrorMsg(pSqlfunction => 'insert',
							pTableName => 'amd_spare_parts',
							pError_location => 290,
							pKey_1 => pPart_no) ;
					   raise_application_error(-20101, 'Part ' || pPart_no || ' already exists.  Try rerunning the diff and the error should go away.') ;
				when others then
					   ErrorMsg(pSqlfunction => 'insert',
							pTableName => 'amd_spare_parts',
							pError_location => 300,
							pKey_1 => pPart_no) ;
					   raise ;
			end InsertSparePart;


			function UpdatePrimePartData(
							pNsi_sid in amd_national_stock_items.nsi_sid%type) return number is

				result number := SUCCESS;


			begin -- UpdatePrimePartData
			    <<insertNsiParts>>
				begin
					result := InsertAmdNsiParts(pNsi_sid);
				exception
					when others then
					   mRC := INS_AMD_NSI_PARTS_ERR ;
					   ErrorMsg(pSqlfunction => 'insert',
							pTableName => 'amd_nsi_parts',
							pError_location => 310,
							pKey_1 => to_char(pNsi_sid)) ;
					   raise ;
				end insertNsiParts;
				
				if result = SUCCESS then
					result := UpdtNsiPrimePartData (pPrime_ind => pPrime_ind,
		 					  pNsi_sid => pNsi_sid,
		 					  pPartNo => pPart_no,
		 					  pNsn => pNsn,
							  pItem_type => pItem_type,
							  pOrder_quantity => pOrder_quantity,
							  pPlannerCode => pPlanner_code,
							  pSmr_code => pSmr_code,
							  pMic_code_lowest => pMic_code_lowest,
							  pAction_code => amd_defaults.INSERT_ACTION,
							  pReturn_code => amd_spare_parts_pkg.UNABLE_TO_PRIME_INFO,
							  pMmac => pMmac) ;					 
				end if;
				return result;
			exception
				when others then
					   mRC := INSERT_PRIMEPART_ERR ;
					   ErrorMsg(pSqlfunction => 'updatePrimePartData',
							pError_location => 320) ;
					   raise ;
			end UpdatePrimePartData;


			function UpdatePrimePartData(
							pNsn in amd_national_stock_items.nsn%type,
							pNsi_sid in amd_nsns.nsi_sid%type,
							pCurrent_prime_part_no in amd_nsi_parts.part_no%type) return number is

				result number := SUCCESS;

				function MakePrimeAnEquivalentPart return number is
						 curPrime amd_nsi_parts.PART_NO%type ;
						 
				begin
					-- first make sure the prime_part is flagged as logically deleted 
					update amd_national_stock_items
					set action_code = amd_defaults.DELETE_ACTION,
					last_update_dt = sysdate
					where nsi_sid = pNsi_sid
					and prime_part_no =
						  (select part_no from amd_nsi_parts
						   where nsi_sid = pNsi_sid
						   and (prime_ind = amd_defaults.PRIME_PART or prime_ind_cleaned = amd_defaults.PRIME_PART)
						   and unassignment_date is null ) ;
						  
						    
					update amd_nsi_parts set
						unassignment_date = sysdate
					where
						nsi_sid = pNsi_sid
						and (prime_ind             = amd_defaults.PRIME_PART
								or prime_ind_cleaned = amd_defaults.PRIME_PART)
						and unassignment_date is null;

					return insertNsiParts(pNsi_sid => pNsi_sid,
						    pPart_no => pCurrent_prime_part_no,
							pPrime_ind => amd_defaults.NOT_PRIME_PART,
							pPrime_ind_cleaned => null,
							pBadRc => amd_spare_parts_pkg.UNASSIGN_OLD_PRIME_PART_ERR);

				end MakePrimeAnEquivalentPart;


			begin -- UpdatePrimePartData
				result := UpdtNsiPrimePartData (pPrime_ind => pPrime_ind,
	 					  pNsi_sid => pNsi_sid,
	 					  pPartNo => pPart_no,
	 					  pNsn => pNsn,
						  pItem_type => pItem_type,
						  pOrder_quantity => pOrder_quantity,
						  pPlannerCode => pPlanner_code,
						  pSmr_code => pSmr_code,
						  pMic_code_lowest => pMic_code_lowest,
						  pAction_code => amd_defaults.UPDATE_ACTION,
						  pReturn_code => amd_spare_parts_pkg.CANNOT_UPADATE_NAT_STCK_ITEMS,
						  pMmac => pMmac) ;					 

				if result != SUCCESS then
				   return result;
				end if;

				if pNsn_type = amd_spare_parts_pkg.CURRENT_NSN then
					result := amd_spare_parts_pkg.ChgCurNsn2TempNsn(pNsiSid => pNsi_sid);
					if result != SUCCESS then
						return result;
					end if;
				end if;

				begin
					result := amd_spare_parts_pkg.UpdateAmdNsn(pNsn_Type => pNsn_Type,
													 pNsi_Sid => pNsi_sid,
													 pNsn => pNsn ) ;
				exception
					when others then
					   mRC := CANNOT_UPDATE_AMD_NSNS ;
					   ErrorMsg(pSqlfunction => 'updateAmdNsn',
							pError_location => 330,
							pKey_1 => pNsn_Type,
							pKey_2 => to_char(pNsi_sid),
							pKey_3 => pNsn) ;
					   raise ;
				end update_amd_nsns;

				result := MakePrimeAnEquivalentPart();
				if result = SUCCESS then
					result := insertNsiParts(pNsi_sid => pNsi_sid,
				   	  			pPart_no => pPart_no,
								pPrime_ind => pPrime_ind,
								pPrime_ind_cleaned => null,
								pBadRc => amd_spare_parts_pkg.MAKE_NEW_PRIME_PART_ERR);
				end if;
				if result = SUCCESS then
					result := MakeNsnSameForAllParts(pNsi_sid => pNsi_sid, pNsn => pNsn );
				end if;
				return result;
			end UpdatePrimePartData;

		begin -- DoPhysicalInsert
			debugMsg('DoPhysicalInsert', pLineNo => 150) ;
			result := PrepareDataForInsert;

			if result = SUCCESS then
				if NatStkItemExists(pNsn => pNsn, pNsi_sid => DoPhysicalInsert.nsi_sid) then
					null ; -- OK do nothing
				else -- create one
				    result := CreateNationalStockItem(pNsi_sid => DoPhysicalInsert.nsi_sid,
			 			   	  pNsn => pNsn,
			 				  pItem_type => pItem_type,
			 				  pOrder_quantity => pOrder_quantity,
			 				  pPlanner_code => pPlanner_code,
			 				  pSmr_code => pSmr_code,
			 				  pTactical => InsertRow.tactical,
			 				  pMic_code_lowest => InsertRow.pMic_code_lowest,
							  pNsn_type => pNsn_type,
							  pMmac => pMmac) ;					 
				end if;
			end if;

			if result = SUCCESS then
				result := InsertSparePart();
			end if;

			if result = SUCCESS then
				if IsPrimePart(pPrime_ind) then
					declare
						current_prime_part_no amd_nsi_parts.part_no%type := null;
					begin
						if IsPrimeReplacingExistingOne(pNsi_sid => DoPhysicalInsert.nsi_sid,
								pCurrent_prime_part_no 	=> current_prime_part_no) then
							begin
								result := UpdatePrimePartData(pNsn => pNsn,
											pNsi_sid => DoPhysicalInsert.nsi_sid,
											pCurrent_prime_part_no => current_prime_part_no);
							exception when others then
							   mRC := UPD_PRIME_PART_ERR ;
							   ErrorMsg(pSqlfunction => 'updatePrimePartData',
									pError_location => 340,
									pKey_1 => pNsn,
									pKey_2 => to_char(DoPhysicalInsert.nsi_sid),
									pKey_3 => current_prime_part_no) ;
							   raise ;
							end UpdatePrimePartData;
						else
							begin
								result := UpdatePrimePartData(pNsi_sid => DoPhysicalInsert.nsi_sid);
							exception when others then
							   ErrorMsg(pSqlfunction => 'updatePrimePartData',
									pError_location => 350,
									pKey_1 => to_char(DoPhysicalInsert.nsi_sid)) ;
							   raise ;
							end UpdatePrimePartData;
						end if;
					end CheckForExistingPrime;
				else
					begin
						result := InsertEquivalentPartData(pNsi_sid => DoPhysicalInsert.nsi_sid);
					exception when others then
					   mRC := UPD_PRIME_PART_ERR ;
					   ErrorMsg(pSqlfunction => 'insertEquiivalentPartData',
							pError_location => 360,
							pKey_1 => to_char(DoPhysicalInsert.nsi_sid)) ;
					   raise ;
					end;
				end if;
			end if ;
			if result = SUCCESS then
				if pNsn is not null then
					begin
						result := UpdateNatStkItem(pNsn, amd_defaults.INSERT_ACTION,pPart_no);
					exception when others then
					   mRC := UPDATE_NATSTK_ERR ;
					   ErrorMsg(pSqlfunction => 'updateNatStkItem',
							pError_location => 370,
							pKey_1 => pNsn,
							pKey_2 => pPart_no) ;
					   raise ;
					end;
				end if;
			end if;

			return result;
		end DoPhysicalInsert;


		function DoLogicalInsert return number is
		begin

			result := UpdateRow
						(pPart_no,
						pMfgr,
						pDate_icp,
						pDisposal_cost,
						pErc,
						pIcp_ind,
						pNomenclature,
						pOrder_lead_time,
						pOrder_quantity,
						pOrder_uom,
						pPrime_ind,
						pScrap_value,
						pSerial_flag,
						pShelf_life,
						pUnit_cost,
						pUnit_volume,
						pNsn,
						pNsn_type,
						pItem_type,
						pSmr_code,
						pPlanner_code,
						pMic_code_lowest,
						pAcquisition_advice_code,
						pMmac,
						pUnitOfIssue) ;
						
			if result = SUCCESS then
				begin
					-- Make it look like an insert was just
					-- done.
					update amd_spare_parts set
						action_code = amd_defaults.INSERT_ACTION
					where part_no = pPart_no;
				exception
					when others then
					   mRC := LOGICAL_INSERT_FAILED ;
					   ErrorMsg(pSqlfunction => 'update',
					   		pTablename => 'amd_spare_parts',
							pError_location => 380,
							pKey_1 => pPart_no) ;
					   raise ;
				end LogicalInsert;
			end if;
			return result;
		end DoLogicalInsert;


		function IsPartMarkedAsDeleted return boolean is

			function GetActionCode return varchar2 is
				action_code varchar2(1);
			begin
				select action_code
				into action_code
				from amd_spare_parts
				where		part_no = pPart_no;
				return action_code;
			exception
				when NO_DATA_FOUND then
					return null;
			end GetActionCode;

		begin
			return (GetActionCode() = amd_defaults.DELETE_ACTION);
		end IsPartMarkedAsDeleted;

    begin -- <<<---- InsertRow
		amd_spare_parts_pkg.mDebug := true ;
		amd_utils.mDebugThreshold := 100000 ;
		debugMsg(mArgs, pLineNo => 5) ;

--		insertLoadDetail(pPart_No,pNsn,pPrime_Ind,'Insert');

		if IsPartMarkedAsDeleted() then
			result := DoLogicalInsert();
		else
			unassociateTmpNsn(pNsn);

			result := DoPhysicalInsert();
		end if;
		if result = SUCCESS then
		   declare
		   		  rc number ;
				  smrCodePreferred amd_national_stock_items.SMR_CODE%type :=
				  		   amd_preferred_pkg.GetPreferredValue(mSmrCodeCleaned, pSmr_code) ;
				  mtbdrPreferred amd_national_stock_items.MTBDR%type := amd_preferred_pkg.GetPreferredValue(mMtbdrCleaned,mMtbdr_computed, mMtbdr) ;
				  plannerCodePreferred amd_national_stock_items.PLANNER_CODE%type := amd_preferred_pkg.GetPreferredValue(mPlannerCodeCleaned,pPlanner_code) ;
				  indenture tmp_a2a_part_info.indenture%type := a2a_pkg.getIndenture(smrCodePreferred) ;
				  
		   begin
		   		debugMsg('a2a.insertPartInfo(' || pMfgr || ', ' || pPart_no || ', ' ||  pUnitOfIssue || ', '
											   || pNomenclature || ', ' || smrCodePreferred || ', ' || pNsn || ', '
											   || plannerCodePreferred || ', ' || a2a_pkg.THIRD_PARTY_FLAG || ', ' || mtbdrPreferred
											   || ', ' || indenture || ')',555) ;
		   		rc := a2a_pkg.InsertPartInfo(mfgr => pMfgr, part_no => pPart_no, unit_issue => pUnitOfIssue, 
				   	  				nomenclature => PNomenclature, smr_code => smrCodePreferred, nsn => pNsn, 
									planner_code => plannerCodePreferred, third_party_flag => a2a_pkg.THIRD_PARTY_FLAG, 
									mtbdr => mtbdrPreferred, indenture => indenture,
									price => amd_preferred_pkg.GetPreferredValue(mUnitCostCleaned,pUnit_cost) ) ;
				if rc = SUCCESS then
					rc := a2a_pkg.InsertPartLeadTime(pPart_no,a2a_pkg.NEW_BUY,amd_preferred_pkg.GetPreferredValue( mOrderLeadTimeCleaned, pOrder_lead_time, amd_defaults.GetOrderLeadTime(pItem_type)) );
				end if ;
				if rc = SUCCESS then
				   result := a2a_pkg.InsertPartPricing(pPart_no,a2a_pkg.AN_ORDER,amd_preferred_pkg.GetPreferredValue(mUnitCostCleaned,pUnit_cost)) ; -- used for SCM 4.2
				end if ;
		   end ;
 	    end if ;

		mDebug := false ;
		return result;

	exception
		when others then
		   ErrorMsg(pSqlfunction => 'insertRow',
				pError_location => 390 ) ;
		   return mRC ;
	end InsertRow;


	function UpdateRow(
							pPart_no in varchar2,
							pMfgr in varchar2,
							pDate_icp in date,
							pDisposal_cost in number,
							pErc in varchar2,
							pIcp_ind in varchar2,
							pNomenclature in varchar2,
							pOrder_lead_time in number,
							pOrder_quantity in number,
							pOrder_uom in varchar2,
							pPrime_ind in varchar2,
							pScrap_value in number,
							pSerial_flag in varchar2,
							pShelf_life in number,
							pUnit_cost in number,
							pUnit_volume in number,
							pNsn in varchar2,
							pNsn_type in varchar2,
							pItem_type in varchar2,
							pSmr_code in varchar2,
							pPlanner_code in varchar2,
							pMic_code_lowest in varchar2,
							pAcquisition_advice_code in varchar2,
							pMmac in varchar2,
							pUnitOfIssue in varchar2) RETURN NUMBER is

		/* Although the following variables are local to the UpdateRow
		  procedure, you will see them referenced as UpdateRow.variable_name.
		  This was done to improve readability.  A similar approach is used
		  for package constants: package_name.constant_name.
		 */
		nsiSid      amd_national_stock_items.nsi_sid%type := null;
		result      number := SUCCESS;
		tactical    amd_spare_parts.tactical%type := 'N';


		/* Put a wrapper on the amd_utils.InsertErrorMsg procedure, so it is
			more specific to the UpdateRow function.  Output gets stored
			into amd_load_details and amd_load_status.
		*/


		function PrepareDataForUpdate return number is
			function GetSmrCode
				return amd_national_stock_items.smr_code%type is
				smr_code_cleaned	amd_national_stock_items.smr_code_cleaned%type;
			begin
				select smr_code_cleaned
				into smr_code_cleaned
				from amd_national_stock_items items
				where nsi_sid = nsiSid;
				return amd_preferred_pkg.GetPreferredValue(smr_code_cleaned,
					pSmr_code);
			exception
				when NO_DATA_FOUND then
					return null;
			end GetSmrCode;


			function GetUnitCost return amd_spare_parts.unit_cost%type is
				unit_cost_cleaned amd_national_stock_items.unit_cost_cleaned%type;
				unit_cost_defaulted amd_spare_parts.unit_cost_defaulted%type;
			begin
				begin
					select unit_cost_cleaned, unit_cost_defaulted
					into unit_cost_cleaned, unit_cost_defaulted
					from amd_national_stock_items
					where nsn = pNsn;
				exception
					when NO_DATA_FOUND then
						unit_cost_cleaned := null;
					when others then
						raise amd_spare_parts_pkg.UNIT_COST_CLEANED_VIA_NSN;
				end get_unit_cost_cleaned;
				return amd_preferred_pkg.GetPreferredValue(unit_cost_cleaned,
					pUnit_cost, unit_cost_defaulted);
			end GetUnitCost;

		begin -- PrepareDataForUpdate
			begin
				UpdateRow.tactical :=
					amd_validation_pkg.GetTacticalInd(GetUnitCost(),GetSmrCode() );
			exception
				when amd_spare_parts_pkg.UNIT_COST_CLEANED_VIA_NSN then
				   mRC := amd_spare_parts_pkg.CANNOT_GET_UNIT_COST_CLEANED ;
				   ErrorMsg(pSqlfunction => 'getTacticalInd',
						pError_location => 400 ) ;
				   raise ;
			end setTactical;

			if pPlanner_code is not null then
				if not amd_validation_pkg.IsValidPlannerCode(pPlanner_code) then
					if amd_validation_pkg.AddPlannerCode(pPlanner_code) != amd_validation_pkg.SUCCESS then
						return amd_spare_parts_pkg.ADD_PLANNER_CODE_ERR;
					end if;
				end if;
			end if;

			if pOrder_uom is not null then
				if not amd_validation_pkg.IsValidUomCode(pOrder_uom) then
					if amd_validation_pkg.AddUomCode(pOrder_uom) != amd_validation_pkg.SUCCESS then
						return amd_spare_parts_pkg.ADD_UOM_CODE_ERR;
					end if;
				end if;
			end if;

			return SUCCESS;
		exception when others then
		   mRC := amd_spare_parts_pkg.PREP_DATA_FOR_UPDT_ERR ;
		   ErrorMsg(pSqlfunction => 'prepareDataForUpdate',
				pError_location => 410 ) ;
		   raise ;
		end PrepareDataForUpdate;


		function UpdateAmdSparePartRow(
							pPartNo amd_spare_parts.part_no%type,
							pNsn amd_spare_parts.nsn%type) return number is
		begin
			debugMsg('updateAmdSparePartRow('||pPartNo||','||pNsn||')', pLineNo => 160);
			update amd_spare_parts set
				mfgr            = pMfgr,
				date_icp        = pDate_icp,
				disposal_cost   = pDisposal_cost,
           	erc             = pErc,
           	icp_ind         = pIcp_ind,
           	nomenclature    = pNomenclature ,
           	order_lead_time = pOrder_lead_time,
           	order_uom       = pOrder_uom,
           	scrap_value     = pScrap_value,
           	serial_flag     = pSerial_flag,
           	shelf_life      = pShelf_life,
           	unit_cost       = pUnit_cost,
           	unit_volume     = pUnit_volume,
				tactical        = UpdateRow.tactical,
				action_code     = amd_defaults.UPDATE_ACTION,
				last_update_dt  = sysdate,
				nsn             = pNsn,
				acquisition_advice_code = pAcquisition_advice_code,
				unit_of_issue = pUnitOfIssue
			where part_no = pPartNo;

			return SUCCESS;
		exception when others then
		   mRC := amd_spare_parts_pkg.UPDT_SPAREPART_ERR ;
		   ErrorMsg(pSqlfunction => 'updateAmdSparePartRow',
				pError_location => 420 ) ;
		   raise ;
		end UpdateAmdSparePartRow;


		function UpdatePrimePartData return number is
		begin
		
			<<update_amd_nsns>>
			begin
				result := amd_spare_parts_pkg.UpdateAmdNsn(
					   pNsn_type => pNsn_type,
					   pNsi_sid => nsiSid,
					   pNsn => pNsn);
			exception when others then
			   mRC := amd_spare_parts_pkg.CANNOT_UPDATE_AMD_NSNS ;
			   ErrorMsg(pSqlfunction => 'updateAmdNsn',
					pError_location => 430 ) ;
		   	   raise ;
			end update_amd_nsns;

			return SUCCESS;
		exception when others then
		   mRC := amd_spare_parts_pkg.UPDT_PRIMEPART_ERR ;
		   ErrorMsg(pSqlfunction => 'updatePrimePartData',
				pError_location => 440 ) ;
	   	   raise ;
		end UpdatePrimePartData;


		function NsnChanged(
							pPartNo varchar2,
							pNsn varchar2) return boolean is
			nsn amd_nsns.nsn%type;
		begin
			debugMsg('nsnChanged('||pPartNo||','||pNsn||')', pLineNo => 170);
			select an.nsn
			into nsn
			from
				amd_nsi_parts anp,
				amd_nsns an
			where
				anp.nsi_sid = an.nsi_sid
				and anp.part_no = pPartNo
				and anp.unassignment_date is null
				and an.nsn_type = 'C';

			if nsn != pNsn then
				return true;
			else
				return false;
			end if;

		exception
			when NO_DATA_FOUND then
				return TRUE;
		end NsnChanged;


		function PrimeIndChanged return boolean is
			prime_ind amd_nsi_parts.prime_ind%type := null;
		begin
			debugMsg('primeIndChanged(' || prime_ind || ')', pLineNo => 180);

			select prime_ind
			into prime_ind
			from amd_nsi_parts
			where nsi_sid = nsiSid
			and part_no = pPart_no
			and unassignment_date is null;

			return (prime_ind != pPrime_ind);
		exception
			when no_data_found then
				return true;
		end;


		function UpdateNsnForPrimePart return number is
		/*
		IMPORTANT:  The prime part controls the value of
		the nsn column in amd_spare_parts. Whenever the value
		of the amd_spare_parts nsn column changes for a prime part, the
		following will happen:
				1.	Update the nsn column of amd_national_stock_items.
				2.	Using the amd_nsi_parts linked via nsi_sid update the
					nsn column of amd_spare_parts with the new value -
					i.e. update the prime part and its equivalent parts.
		*/
			result number := SUCCESS;

			function UpdtNsnOfNationalStockItems(
							pNsiSid number) return number is
			begin
				debugMsg('updtNsnOfNationalStockItems('||pNsn||','||pNsiSid||')', pLineNo => 190);
				update amd_national_stock_items set
					nsn = pNsn
				where nsi_sid = pNsiSid;
				return SUCCESS;
			exception when others then
			   mRC := amd_spare_parts_pkg.CANNOT_UPDT_NSN_NAT_STCK_ITEMS ;
			   ErrorMsg(pSqlfunction => 'update', pTableName => 'amd_national_stock_items',
					pError_location => 450 ) ;
		   	   raise ;
			end UpdtNsnOfNationalStockItems;

		begin -- UpdateNsnForPrimePart

			if result = SUCCESS then
				result := UpdtNsnOfNationalStockItems(nsiSid);
			end if;

			if result = SUCCESS then
				result := MakeNsnSameForAllParts(pNsi_sid => nsiSid,
					   	  						   pNsn => pNsn);
			end if;
			return result;
		exception when others then
		   mRC := amd_spare_parts_pkg.UPDT_NSN_PRIME_ERR ;
		   ErrorMsg(pSqlfunction => 'updateNsnForPrimePart',
				pError_location => 460 ) ;
	   	   raise ;
		end UpdateNsnForPrimePart;


		function UpdatePrimeInd return number is
			result number := SUCCESS;

			function UnassignPrimePart(
							pPart_no in amd_nsi_parts.part_no%type) return number is
			begin
				debugMsg('unassignPrimePart(' || pPart_no || ')', pLineNo => 200);

				update amd_nsi_parts set
					unassignment_date = sysdate
				where
					part_no = pPart_no
					and (prime_ind             = amd_defaults.PRIME_PART
							or prime_ind_cleaned = amd_defaults.PRIME_PART)
					and unassignment_date is null;
					
				-- Since this prime_part is unassigned logically delete the 
				-- national_stock_item
				update amd_national_stock_items
				set action_code = amd_defaults.DELETE_ACTION,
				last_update_dt = sysdate				
				where prime_part_no = pPart_no ;

				return SUCCESS;
			end UnassignPrimePart;

			function MakeCurrentPrimeIntoEquiv return number is
				result   number := SUCCESS;
				part_no  amd_nsi_parts.part_no%type := null;
			begin
				begin
					-- get the current Prime Part
					select part_no
					into part_no
					from amd_nsi_parts
					where nsi_sid = nsiSid
					and (prime_ind = amd_defaults.PRIME_PART
						or prime_ind_cleaned = amd_defaults.PRIME_PART)
					and unassignment_date is null;
				exception
					when no_data_found then
						/* This can occur when a prime has alreay become an
							equivalent part, before the NEW prime is processed.
							*/
						return SUCCESS;
					when others then
					   mRC := amd_spare_parts_pkg.UNABLE_TO_GET_PRIME_PART ;
					   ErrorMsg(pSqlfunction => 'select', pTableName => 'amd_nsi_parts',
							pError_location => 470,
							pKey_1 => to_char(nsiSid)) ;
		   	   		   raise ;
				end GetCurrentPrimePart;

				result := UnassignPrimePart(pPart_no => part_no);

				if result = SUCCESS then
					 result := insertNsiParts(pNsi_sid => nsiSid,
								pPart_no => part_no,
							   pPrime_ind => amd_defaults.NOT_PRIME_PART,
							   pPrime_ind_cleaned => null,
							   pBadRc =>amd_spare_parts_pkg.ASSIGN_PRIME_TO_EQUIV_ERR);
				end if;

				return result;

			end MakeCurrentPrimeIntoEquiv;


			function UpdatePrimePartNo return number is
				temp_prime_part_no amd_national_stock_items.prime_part_no%type := null;
			begin
				<<getPrimePart>>
				begin
				    -- check if the prime part has been set yet
					select part_no
					into temp_prime_part_no
					from amd_nsi_parts
					where nsi_sid = nsiSid
					and unassignment_date is null
					and (prime_ind = amd_defaults.PRIME_PART or prime_ind_cleaned = amd_defaults.PRIME_PART);
				exception
					when no_data_found then
				  	   null ; -- OK the prime_part_no has not been set yet
					when others then
					   mRC := amd_spare_parts_pkg.UNABLE_TO_GET_PRIME_PART ;
					   ErrorMsg(pSqlfunction => 'select', pTableName => 'amd_nsi_parts',
							pError_location => 480,
							pKey_1 => to_char(nsiSid)) ;
		   	   		   raise ;
				end getPrimePart ;
				
				if temp_prime_part_no != null then
				   begin
					   select prime_part_no
						into temp_prime_part_no
					   from amd_national_stock_items
					   where nsi_sid = nsiSid
					   and prime_part_no = temp_prime_part_no;
				   exception
					   when no_data_found then
							begin
							    /* This should not happen, but just in
								 * case this will gaurantee that the
								 * prime_part_no = part_no in
								 * amd_nsi_parts with prime_ind = 'Y'
								 */
								update amd_national_stock_items set
									prime_part_no  = temp_prime_part_no,
									last_update_dt = sysdate,
									action_code    = amd_defaults.UPDATE_ACTION
								where nsi_sid = nsiSid;
							exception when others then
							   mRC := amd_spare_parts_pkg.UPDT_NULL_PRIME_COLS_ERR ;
							   ErrorMsg(pSqlfunction => 'update', 
							   		pTableName => 'amd_national_stock_items',
									pError_location => 490,
									pKey_1 => to_char(nsiSid)) ;
				   	   		   raise ;
							end UpdateNationalStockItems;
					   when others then
						   mRC := amd_spare_parts_pkg.UNABLE_TO_GET_PRIME_PART ;
						   ErrorMsg(pSqlfunction => 'updatePrimePartNo', 
								pError_location => 500)  ;
			   	   		   raise ;
				   end;
				else
					-- the prime part is null, but it should get
					-- set with subsequent data
					begin
						update amd_national_stock_items set
							prime_part_no  = temp_prime_part_no,
							last_update_dt = sysdate,
							action_code    = amd_defaults.UPDATE_ACTION
						where nsi_sid = nsiSid;
					exception when others then
					   mRC := amd_spare_parts_pkg.UPDT_NULL_PRIME_COLS_ERR2 ;
					   ErrorMsg(pSqlfunction => 'update',
					   		pTableName => 'amd_national_stock_items', 
							pError_location => 510,
							pKey_1 => to_char(nsiSid))  ;
		   	   		   raise ;
					end UpdateNationalStockItems;
				end if ;
				return SUCCESS;
			end UpdatePrimePartNo;

		begin --  UpdatePrimeInd
			debugMsg('updatePrimeInd()', pLineNo => 210);
			if IsPrimePart(pPrime_ind) then
				result := MakeCurrentPrimeIntoEquiv();
				if result = SUCCESS then

					unassignPart(pPart_no);

					begin
						result := insertNsiParts(pNsi_sid => nsiSid,
							   	      pPart_no => pPart_no,
									  pPrime_ind => pPrime_ind,
									  pPrime_ind_cleaned => null,
									  pBadRc => amd_spare_parts_pkg.ASSIGN_NEW_PRIME_PART_ERR);
					end AssignNewPrimePart;

					begin
					    -- make sure action_code and last_update_dt get set too
						update amd_national_stock_items set
							prime_part_no = pPart_no,
							nsn           = pNsn,
							last_update_dt = sysdate,
							action_code = amd_defaults.UPDATE_ACTION
						where nsi_sid = nsiSid;
					exception when others then
					   mRC := amd_spare_parts_pkg.UPDT_ERR_NATIONAL_STK_ITEMS ;
					   ErrorMsg(pSqlfunction => 'update',
					   		pTableName => 'amd_national_stock_items', 
							pError_location => 520,
							pKey_1 => to_char(nsiSid))  ;
		   	   		   raise ;
					end UpdateNationalStockItems;

					if result = SUCCESS then
					    /* added invocation of MakeNsnSameForAllParts to
						 * to fix bug where equiv parts did not have the same
						 * nsn as the prime part.
						 */
						result := MakeNsnSameForAllParts(pNsi_sid => nsiSid,
							   	  									pNsn => pNsn);
					end if;

				end if;

			else
				result := UnassignPrimePart(pPart_no => pPart_no);
				if result = SUCCESS then
					begin
					   result := insertNsiParts(pNsi_sid => nsiSid,
					   		  	    pPart_no => pPart_no,
									pPrime_ind => pPrime_ind,
									pPrime_ind_cleaned => null,
									pBadRc => amd_spare_parts_pkg.ASSIGN_NEW_EQUIV_PART_ERR);
					end AssignNewEquivPart;

					result := UpdatePrimePartNo;

				end if;
			end if;

		return result;

		exception when others then
		   mRC := amd_spare_parts_pkg.UPD_NSI_PARTS_ERR ;
		   ErrorMsg(pSqlfunction => 'updatePrimeInd',
				pError_location => 530) ;
  	   	   raise ;
		end UpdatePrimeInd;


		function InsertNewNsn(
							pNsi_sid out amd_nsns.nsi_sid%type) return number is
			result number := SUCCESS;

			/* Get the nsi_sid using the part_no */
			function GetNsiSid return number is
			begin
				pNsi_sid := amd_utils.GetNsiSid(pPart_no => pPart_no);
				return SUCCESS;
			exception
				when no_data_found then
					 raise;
			    when others then
				   pNsi_sid := null;
				   mRC := amd_spare_parts_pkg.GET_NSISID_BY_PART_ERR ;
				   ErrorMsg(pSqlfunction => 'getNsiSid',
						pError_location => 540) ;
		  	   	   raise ;
			end GetNsiSid;

		begin -- InsertNewNsn
			result := GetNsiSid();

			if result = SUCCESS then
				result := InsertAmdNsn(pNsi_sid => pNsi_sid,
					   pNsn => pNsn,
					   pNsn_type => pNsn_type);
			end if;
			return result;
		exception
		    when no_data_found then
			    return CreateNationalStockItem(pNsi_sid => pNsi_sid,
	 			   	  pNsn => pNsn,
		 				  pItem_type => pItem_type,
		 				  pOrder_quantity => pOrder_quantity,
		 				  pPlanner_code => pPlanner_code,
		 				  pSmr_code => pSmr_code,
		 				  pTactical => UpdateRow.tactical,
		 				  pMic_code_lowest => pMic_code_lowest,
						  pNsn_type => pNsn_type,
						  pMmac => pMmac) ;					 

		    when others then
			   pNsi_sid := null;
			   mRC := amd_spare_parts_pkg.NEW_NSN_ERROR ;
			   ErrorMsg(pSqlfunction => 'insertNewNsn',
					pError_location => 550) ;
	  	   	   raise ;
		end InsertNewNsn;


		function GetNsiSid(
							pNsi_sid out amd_nsns.nsi_sid%type) return number is

		begin
			debugMsg('getNsiSid()', pLineNo => 220);
			pNsi_sid := amd_utils.GetNsiSid(pNsn => pNsn);
			debugMsg('pNsi_sid=' || pNsi_sid, pLineNo => 230) ;
			return SUCCESS;
		exception
			when no_data_found then
				raise ; -- must be a new nsn

			when others then
			   pNsi_sid := null;
			   ErrorMsg(pSqlfunction => 'getNsiSid',
					pError_location => 560) ;
	  	   	   raise ;
		end GetNsiSid;


		function CheckNsnAndPrimeInd return number is
			result number := SUCCESS;
		begin
			debugMsg('checkNsnAndPrimeInd()',pLineNo => 240);

			if NsnChanged(pPart_no,pNsn) then
			   if IsPrimePart(pPrime_ind) then
					if PrimeIndChanged() then
						result := UpdatePrimeInd();
						if result = SUCCESS then
							result := UpdateNsnForPrimePart();
						end if;
					else
						result := UpdateNsnForPrimePart();
					end if;
	
					result := MakeNsnSameForAllParts(nsiSid,pNsn);
				else
					unassignPart(pPart_no);
					
					result := insertNsiParts(pNsi_sid => nsiSid,
						   	      pPart_no => pPart_no,
								  pPrime_ind => pPrime_ind,
								  pPrime_ind_cleaned => null,
								  pBadRc => amd_spare_parts_pkg.ASSIGN_NEW_PRIME_PART_ERR);
				
					if PrimeIndChanged() then
						result := UpdatePrimeInd();
					end if;
				end if ;
			else
				if PrimeIndChanged() then
					result := UpdatePrimeInd();
				end if;
			end if;
			return result;
		exception
			when amd_spare_parts_pkg.CANNOT_FIND_PART then
			   ErrorMsg(pSqlfunction => 'CheckNsnAndPrimeInd',
					pError_location => 570) ;
	  	   	   raise ;
			when others then
			   mRC := amd_spare_parts_pkg.CHK_NSN_AND_PRIME_ERR2 ;
			   ErrorMsg(pSqlfunction => 'CheckNsnAndPrimeInd',
					pError_location => 580) ;
	  	   	   raise ;
		end CheckNsnAndPrimeInd;

		function updatePartLeadTime return number is
				 result number := SUCCESS ;
				 order_lead_time amd_spare_parts.order_lead_time%type ;
				 order_lead_time_cleaned amd_national_stock_items.order_lead_time_cleaned%type ;
		begin
			 select parts.order_lead_time, items.order_lead_time_cleaned 
			 into order_lead_time, order_lead_time_cleaned
			 from amd_spare_parts parts, amd_national_stock_items items
			 where parts.part_no = pPart_no
			 and parts.nsn = items.nsn ;
			 
			 if order_lead_time != pOrder_lead_time
			 or (order_lead_time is null and pOrder_lead_time is not null)
			 or (order_lead_time is not null and pOrder_lead_time is null) 
			 or order_lead_time_cleaned != mOrderLeadTimeCleaned
			 or (order_lead_time_cleaned is null and mOrderLeadTimeCleaned is not null)
			 or (order_lead_time_cleaned is not null and mOrderLeadTimeCleaned is null) 
			 then
			 	result := a2a_pkg.UpdatePartLeadTime(pPart_no,a2a_pkg.NEW_BUY,amd_preferred_pkg.GetPreferredValue(mOrderLeadTimeCleaned, pOrder_lead_time, amd_defaults.GetOrderLeadTime(pItem_type))) ;
			 end if ;
			 
			 return result ;
		exception
			when standard.NO_DATA_FOUND then
				 return result ;
			when others then
			   ErrorMsg(pSqlfunction => 'updatePartLeadTime',
					pError_location => 590,
					pKey_1 => pPart_no,
					pKey_2 => pNsn) ;
				raise ;
		end updatePartLeadTime ;
		
		function updatePartPricing return number is
				 unit_cost amd_spare_parts.unit_cost%type ;
				 unit_cost_cleaned amd_national_stock_items.unit_cost_cleaned%type ;
		begin
			 select unit_cost, unit_cost_cleaned into unit_cost, unit_cost_cleaned
			 from amd_spare_parts parts, amd_national_stock_items items
			 where parts.part_no = pPart_no
			 and parts.nsn = items.nsn ;
			 
			 if unit_cost != pUnit_Cost
			 or (unit_cost is null and pUnit_cost is not null)
			 or (unit_cost is not null and pUnit_cost is null)			   
			 or unit_cost_cleaned != mUnitCostCleaned
			 or (unit_cost_cleaned is null and mUnitCostCleaned is not null)
			 or (unit_cost_cleaned is not null and mUnitCostCleaned is null) then
			 	result := a2a_pkg.UpdatePartPricing(pPart_no,a2a_pkg.AN_ORDER,amd_preferred_pkg.GetPreferredValue(mUnitCostCleaned, pUnit_Cost)) ;
			 end if ;
			 return result ;
		exception
			when standard.no_data_found then
				 return result ; 
			when others then
			   mRC := amd_spare_parts_pkg.CANNOT_UPDATE_PART_PRICING ; 
			   ErrorMsg(pSqlfunction => 'updatePartPricing',
					pError_location => 600) ;
			   raise ;
		end updatePartPricing ;
		
		procedure validateInput is
	                part_no amd_spare_parts.part_no%type ;
                mfgr amd_spare_parts.mfgr%type ;
                date_icp  amd_spare_parts.DATE_ICP%type ;
                disposal_cost amd_spare_parts.DISPOSAL_COST%type ;
                erc amd_spare_parts.ERC%type ; 
                icp_ind amd_spare_parts.ICP_IND%type ; 
                nomenclature amd_spare_parts.NOMENCLATURE%type ;
                order_lead_time amd_spare_parts.ORDER_LEAD_TIME%type ;
				order_quantity amd_national_stock_items.ORDER_QUANTITY%type ;
                order_uom amd_spare_parts.ORDER_UOM%type ;
				prime_ind amd_nsi_parts.PRIME_IND%type ;
                scrap_value amd_spare_parts.SCRAP_VALUE%type ;
                serial_flag amd_spare_parts.SERIAL_FLAG%type ;
                shelf_life amd_spare_parts.SHELF_LIFE%type ;
                unit_cost amd_spare_parts.UNIT_COST%type ;
                unit_volume amd_spare_parts.UNIT_VOLUME%type ;
                nsn amd_spare_parts.NSN%type ;
				nsn_type amd_nsns.NSN_TYPE%type ;
                item_type amd_national_stock_items.ITEM_TYPE%type ;
                smr_code amd_national_stock_items.SMR_CODE%type ;
                planner_code amd_national_stock_items.PLANNER_CODE%type ;
				mic_code_lowest amd_national_stock_items.MIC_CODE_LOWEST%type ;
				acquisition_advice_code amd_spare_parts.ACQUISITION_ADVICE_CODE%type ;
				mmac amd_national_stock_items.MMAC%type ;
				unit_Of_Issue amd_spare_parts.UNIT_OF_ISSUE%type ;
				mtbdr amd_national_stock_items.MTBDR%type ;
				mtbdr_computed amd_national_stock_items.mtbdr_computed%type ;
  				qpei_weighted amd_national_stock_items.QPEI_WEIGHTED%type ;
  				condemn_avg_cleaned amd_national_stock_items.CONDEMN_AVG_CLEANED%type ;
  				criticality_cleaned amd_national_stock_items.CRITICALITY_CLEANED%type ;
  				mtbdr_cleaned amd_national_stock_items.MTBDR_CLEANED%type ;
  				nrts_avg_cleaned amd_national_stock_items.NRTS_AVG_CLEANED%type ;
  				cost_to_repair_off_base_cleand amd_national_stock_items.COST_TO_REPAIR_OFF_BASE_CLEAND%type ;
  				time_to_repair_off_base_cleand amd_national_stock_items.TIME_TO_REPAIR_OFF_BASE_CLEAND%type ;
  				order_Lead_Time_cleaned amd_national_stock_items.ORDER_LEAD_TIME_CLEANED%type ;
  				planner_code_cleaned amd_national_stock_items.planner_code_cleaned%type ;
  				rts_avg_cleaned amd_national_stock_items.RTS_AVG_CLEANED%type ;
  				smr_code_cleaned amd_national_stock_items.smr_code_cleaned%type ;
  				unit_cost_cleaned amd_national_stock_items.UNIT_COST_CLEANED%type ;
  				condemn_avg amd_national_stock_items.CONDEMN_AVG%type ;
  				criticality amd_national_stock_items.CRITICALITY%type ;
  				nrts_avg amd_national_stock_items.NRTS_AVG%type ;
  				rts_avg amd_national_stock_items.RTS_AVG%type ;
				lineNo number := 0 ;
				result number ;
		begin
			lineNo := lineNo + 1;part_no := pPart_no ;
			lineNo := lineNo + 1;mfgr :=   pMfgr ;
			lineNo := lineNo + 1;date_icp := pDate_icp ;
			lineNo := lineNo + 1;disposal_cost := pDisposal_cost ;
			lineNo := lineNo + 1;erc := pErc ;
			lineNo := lineNo + 1;icp_ind :=  pIcp_ind ;
			lineNo := lineNo + 1;nomenclature :=  pNomenclature ;
			lineNo := lineNo + 1;order_lead_time := pOrder_lead_time ;
			lineNo := lineNo + 1;order_quantity :=	pOrder_quantity ;
            lineNo := lineNo + 1;order_uom :=    pOrder_uom ;
			lineNo := lineNo + 1;prime_ind :=	pPrime_ind ;
            lineNo := lineNo + 1;scrap_value :=    pScrap_value ;
            lineNo := lineNo + 1;serial_flag :=    pSerial_flag ;
            lineNo := lineNo + 1;shelf_life := pShelf_life ;
            lineNo := lineNo + 1;unit_cost :=    pUnit_cost ;
            lineNo := lineNo + 1;unit_volume :=    pUnit_volume ;
            lineNo := lineNo + 1;nsn :=    pNsn ;
			lineNo := lineNo + 1;nsn_type :=	pNsn_type ;
            lineNo := lineNo + 1;item_type :=    pItem_type ;
            lineNo := lineNo + 1;smr_code :=    pSmr_code ;
            lineNo := lineNo + 1;planner_code :=    pPlanner_code ;
			lineNo := lineNo + 1;mic_code_lowest :=	pMic_code_lowest ;
			lineNo := lineNo + 1;acquisition_advice_code :=	pAcquisition_advice_code ;
			lineNo := lineNo + 1;mmac :=	pMmac ;
			lineNo := lineNo + 1;unit_of_issue :=	pUnitOfIssue ;
			/*
			lineNo := lineNo + 1;mtbdr := pMtbdr ;
  			lineNo := lineNo + 1;qpei_weighted := pQpeiWeighted ;
  			lineNo := lineNo + 1;condemn_avg_cleaned := pCondemnAvgCleaned ;
  			lineNo := lineNo + 1;criticality_cleaned := pCriticalityCleaned ;
  			lineNo := lineNo + 1;mtbdr_cleaned := pMtbdrCleaned ;
  			lineNo := lineNo + 1;nrts_avg_cleaned := pNrtsAvgCleaned ;
  			lineNo := lineNo + 1;cost_to_repair_off_base_cleand := pCostOfRepairOffBaseCleand ;
  			lineNo := lineNo + 1;time_to_repair_off_base_cleand := pTimeToRepairOffBaseCleand ;
  			lineNo := lineNo + 1;order_Lead_Time_cleaned := pOrderLeadTimeCleaned ;
  			lineNo := lineNo + 1;planner_code_cleaned := pPlannerCodeCleaned ;
  			lineNo := lineNo + 1;rts_avg_cleaned := pRtsAvgCleaned ;
  			lineNo := lineNo + 1;smr_code_cleaned := pSmrCodeCleaned ;
  			lineNo := lineNo + 1;unit_cost_cleaned := pUnitCostCleaned ;
  			lineNo := lineNo + 1;condemn_avg := pCondemnAvg ;
  			lineNo := lineNo + 1;criticality := pCriticality ;
  			lineNo := lineNo + 1;nrts_avg := pNrtsAvg ;
  			lineNo := lineNo + 1;rts_avg := pRtsAvg ;
			*/
		exception when others then
		   ErrorMsg(pSqlfunction => 'validateInput',
				pError_location => 610) ;
		   raise ;
		end validateInput ;
		
	begin -- <<<---- UpdateRow
		validateInput ;
		debugMsg(mArgs  || ')',pLineNo => 250);
--		insertLoadDetail(pPart_No,pNsn,pPrime_Ind,'Update');

		-- if part has moved to a different nsn then unassign existing part to
		-- break it's relation to old nsn so it can get associated with a
		-- different sid(new nsn). Also break any current/temp nsn relation of
		-- old nsn(current) with incoming(new) nsn(temp).
		--
		-- "moved" means old nsn and new nsn appear in CAT1 at the same time or
		-- both nsns are already in AMD on different sids,
		-- therefore, they are no longer related regardless of what amd_nsns says.
		-- that's why the part needs to be unassigned from the old nsn.
		--
		if (hasPartMoved(pPart_no,pNsn)) then
			unassociateTmpNsn(pNsn);
			unassignPart(pPart_no);
		end if;

		-- retrieve the nsi_sid right away, since it will be make
		-- retrieving data from the amd_national_stock_items,
		-- amd_nsns, and amd_nsi_parts easier
		begin
			result := GetNsiSid(pNsi_sid => nsiSid);
			if result != SUCCESS then
				return result;
			end if;
		exception
			when no_data_found then
				/* This must be a new nsn - add it to amd_nsns
					using part_no to get the current nsi_sid
				*/
				result := InsertNewNsn(pNsi_sid => nsiSid);
				if result != SUCCESS then
					return result;
				end if;
		end;

		/* The nsi_sid should not be null, but just leave this code in
			as a backup parachute!
			*/
		if nsiSid is null then
		   ErrorMsg(pSqlfunction => 'getNsiSid',
				pError_location => 620) ;
		   raise cannotGetNsiSid ;
		end if;

		if result = SUCCESS then
			result := CheckNsnAndPrimeInd();
		end if;

		if result = SUCCESS then
			result := PrepareDataForUpdate();
		end if;

		if result = SUCCESS then
			result := UpdateAmdSparePartRow(pPart_no,pNsn);
		end if;

		if result = SUCCESS then
			result := UpdtNsiPrimePartData (pPrime_ind => pPrime_ind,
 					  pNsi_sid => nsiSid,
 					  pPartNo => pPart_no,
 					  pNsn => pNsn,
					  pItem_type => pItem_type,
					  pOrder_quantity => pOrder_quantity,
					  pPlannerCode => pPlanner_code,
					  pSmr_code => pSmr_code,
					  pMic_code_lowest => pMic_code_lowest,
					  pAction_code => amd_defaults.UPDATE_ACTION,
					  pReturn_code => amd_spare_parts_pkg.UPDATE_NATSTK_ERR,
					  pMmac => pMmac) ;					 
		end if ;
		if result = SUCCESS then
			result := amd_spare_parts_pkg.UpdateAmdNsn(
				   pNsn_type => pNsn_type,
				   pNsi_sid => nsiSid,
				   pNsn => pNsn);
		end if;

		if result = SUCCESS then
			if pNsn is not null then
				result:= UpdateNatStkItem(pNsn,amd_defaults.UPDATE_ACTION,pPart_no);
			end if;
		end if;

		-- Update amd_national_stock_items.action_code = 'D' for any other
		-- nsi_sid this part came off of that has no parts assigned to it.
		-- An nsi_sid w/o assigned parts is a "deleted" nsi_sid.
		--
		debugMsg('updating action code to D',pLineNo => 260) ;
		update amd_national_stock_items set
			action_code    = 'D',
			last_update_dt = sysdate
		where
			action_code != 'D'
			and nsi_sid in
				(select nsi_sid
				from amd_nsi_parts
				where part_no = pPart_no
					and nsi_sid != nsiSid
				minus
				select nsi_sid
				from amd_nsi_parts
				where
					nsi_sid in
						(select nsi_sid from amd_nsi_parts
						where part_no = pPart_no)
					and unassignment_date is null);

		if result = SUCCESS then
		   declare
		   		  rc number ;
				  smrCodePreferred amd_national_stock_items.SMR_CODE%type := amd_preferred_pkg.GetPreferredValue(mSmrCodeCleaned,pSmr_code) ;
				  plannerCodePreferred amd_national_stock_items.PLANNER_CODE%type := amd_preferred_pkg.GetPreferredValue(mPlannerCodeCleaned,pPlanner_code) ;
				  mtbdrPreferred amd_national_stock_items.MTBDR%type := amd_preferred_pkg.GetPreferredValue(mMtbdrCleaned,mMtbdr_computed,mMtbdr) ;
				  indenture tmp_a2a_part_info.indenture%type := a2a_pkg.getIndenture(smrCodePreferred) ;
		   begin
		   	   a2a_pkg.mDebug := mDebug ; -- turn on debugging for a2a
			   rc := a2a_pkg.UpdatePartInfo(mfgr => pMfgr, part_no => pPart_no, 
							unit_issue => pUnitOfIssue, nomenclature => pNomenclature, 
							smr_code => smrCodePreferred, nsn => pNsn, planner_code => plannerCodePreferred, 
							third_party_flag => a2a_pkg.THIRD_PARTY_FLAG, mtbdr => mtbdrPreferred, indenture => indenture,
							price => amd_preferred_pkg.GetPreferredValue(mUnitCostCleaned, pUnit_Cost)) ;
			   if rc = SUCCESS then	
			      commit ;
			   	  rc := updatePartLeadTime ;
			   end if ;
			   if rc = SUCCESS then
				   result:= updatePartPricing ; -- used for SCM 4.2
			   end if ;
		   end ;
		
		end if ;
		return result;
	exception
		when others then
		   ErrorMsg(pSqlfunction => 'updateRow',
				pError_location => 630) ;
			return mRC ;
	end UpdateRow;


	function DeleteRow(
							pPart_no in varchar2,
							pNomenclature in varchar2,
							pMfgr in varchar2 ) return number is

		result number := SUCCESS ;
		nsn amd_spare_parts.nsn%type := null;

		/* Put a wrapper on the amd_utils.InsertErrorMsg procedure, so it is
			more specific to the DeleteRow function.  Output gets stored
			into amd_load_details and amd_load_status.
		*/

		function GetNsn return amd_spare_parts.nsn%type is
			nsn amd_spare_parts.nsn%type := null;
		begin
			select nsn
			into nsn
			from amd_spare_parts
			where part_no = pPart_no;
			return nsn;
		end GetNsn;

	begin
		mArgs := 'DeleteRow(' || pPart_no || ', ' || pMfgr || ', ' || pNomenclature || ')' ;
		result := a2a_pkg.DeletePartLeadTime(pPart_no) ;
		if result = SUCCESS then
		   result := a2a_pkg.DeletePartPricing(pPart_no) ; -- used for SCM 4.2
		end if ;
		insertLoadDetail(pPart_No,'nsn','pPrimeInd','Delete');
		nsn := GetNsn();

		-- nsn is NULLed to facilitate temp nsns turning into current nsns. When a
		-- temp nsn becomes current the nsn/nsi_sid association needs to be broken
		-- and this helps facilitate that when it may happen at a later time.
		--
		<<updateAmdSpareParts>>
		begin
			update amd_spare_parts set
				action_code    = amd_defaults.DELETE_ACTION,
				nsn            = NULL,
				last_update_dt = sysdate
			where part_no = pPart_no;
		exception when others then
		   ErrorMsg(pSqlfunction => 'update', pTableName => 'amd_spare_parts',
				pError_location => 640, pKey_1 => pPart_no) ;
		   raise ;
		end updateAmdSpareParts ;

		unassignPart(pPart_no);

		if nsn is not null then
		   result := UpdateNatStkItem(nsn, amd_defaults.DELETE_ACTION);
		else
			result := SUCCESS;
		end if;
		if result = SUCCESS then
		   declare
		   		  rc number ;
		   begin
		   		rc := a2a_pkg.DeletePartInfo(pPart_no, pNomenclature) ;
		   end ;
		end if ;
		return result ;
	exception when others then
		   ErrorMsg(pSqlfunction => 'deleteRow',
				pError_location => 650) ;
			return mRC ;
	end DeleteRow ;

	procedure loadCurrentBackOrder(debug in boolean := False) is
			  TB constant varchar2(1) := chr(9);   -- tab character
			  
			COMMIT_THRESHOLD constant number := 250 ;
			curDueCnt number := 0 ;
			curTmpCnt number := 0 ;
			
			  cursor curDue is
			  select cat1.prime primePartNo, 
				sum(nvl(req1.qty_due,0) + nvl(req1.qty_reserved,0)) DUE 
				from req1, cat1 
				where
				req1.select_from_part = cat1.part and 
				req1.request_id not like 'KIT%' and 
				req1.mils_source_dic is not null and 
				req1.select_from_sc like 'C17%' and 
				req1.status in ('U','H','O','R') and 
				req1.request_priority <= 5 and
				upper(substr(req1.select_from_sc,8,6)) not in ('CODLGB','ROTLGB') and
				upper(substr(req1.select_from_sc,8,3)) not in ('MRC','SUP','TST') and
				cat1.SOURCE_CODE = 'F77'
				group by cat1.prime ;

			  cursor curTmp1QtyDue is
				select qty_due qtyDue, prime_part_no primePartNo  from 
				(
				select sum(qty_due) qty_due, prime prime_part_no 
				from tmp1, cat1, amd_national_stock_items, amd_spare_parts
				where from_part = cat1.PART
				and returned_voucher is null
				and status = 'O' 
				and tcn = 'LBR'
			    and upper(substr(to_sc,1,3)) = 'C17'
				and upper(substr(to_sc,8,3)) not in ('MRC','SUP','TST') 
				and upper(substr(to_sc,8,6)) not in ('CODLGB','ROTLGB') 
				and trim(from_part) = trim(amd_spare_parts.part_no) 
				and amd_spare_parts.action_code in ('A','C') 
				and amd_spare_parts.nsn = amd_national_stock_items.nsn
				group by prime)
				where prime_part_no not in ( 
				  select distinct cat1.prime primePartNo 
					from req1, cat1 
					where
					req1.select_from_part = cat1.part and 
					req1.request_id not like 'KIT%' and 
					req1.mils_source_dic is not null and 
					req1.select_from_sc like 'C17%' and 
					req1.status in ('U','H','O','R') and 
					req1.request_priority <= 5 and
					cat1.SOURCE_CODE = 'F77') ;

		function getQtyDue(primePartNo in varchar2) return number is
				 qtyDue number ;
		begin
			select qty_due into qtyDue from 
			(
			select sum(qty_due) qty_due, prime
			from tmp1, cat1, amd_national_stock_items, amd_spare_parts
			where 
			returned_voucher is null
			and status = 'O' 
			and tcn = 'LBR'
			and upper(substr(to_sc,1,3)) = 'C17'
			and upper(substr(to_sc,8,3)) not in ('MRC','SUP','TST') 
			and upper(substr(to_sc,8,6)) not in ('CODLGB','ROTLGB') 
			and trim(from_part) = trim(amd_spare_parts.part_no) 
			and amd_spare_parts.action_code in ('A','C') 
			and amd_spare_parts.nsn = amd_national_stock_items.nsn
			group by prime)
			where trim(prime) = trim(primePartNo) ; 
			
			return qtyDue ;
		exception
			when standard.NO_DATA_FOUND then
				 return 0 ;
		end getQtyDue ;
		
			  
	begin
		writeMsg(pTableName => 'amd_spare_parts', pError_location => 660,
				pKey1 => 'loadCurrentBackorder',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
	    update amd_national_stock_items
	    set current_backorder = null ;
	    commit ;
		
		writeMsg(pTableName => 'amd_spare_parts', pError_location => 670,
			pKey1 => 'curDue',
			pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		FOR rec IN curDue  LOOP
			if debug then
			   exit when curDueCnt = 10 ;
			end  if ;
			<<updateItems>>
			declare
				   qtyDue number := getQtyDue(trim(rec.primePartNo)) ;
			begin
			    if debug then
					writeMsg(pTableName => 'amd_spare_parts', pError_location => 680,
						pKey1 => 'primePartNo=' || trim(rec.primePartNo),
						pKey2 => 'current_backorder='  || to_char(rec.due + qtyDue)) ;
				end if ;
				update amd_national_stock_items
				set current_backorder =	rec.due + qtyDue
				where prime_part_no = trim(rec.primePartNo) ;
				curDueCnt := curDueCnt + 1 ;
				if mod(curDueCnt,COMMIT_THRESHOLD) = 0 then
				   commit ;
				end if ;
			exception
					 when standard.NO_DATA_FOUND then
					 	  null ;
					 when others then
					 	  raise ; 
			end updateItems ;
		END LOOP;
		writeMsg(pTableName => 'amd_spare_parts', pError_location => 690,
			pKey1 => 'curDue',
			pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		
		writeMsg(pTableName => 'amd_spare_parts', pError_location => 700,
			pKey1 => 'curTmp1QtyDue',
			pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
		for rec in curTmp1QtyDue loop
		    if debug then
			   exit when curTmpCnt = 10 ;
			end if ;
			<<updateItems2>>
			begin
				if debug then
					writeMsg(pTableName => 'amd_spare_parts', pError_location => 710,
						pKey1 => 'primePartNo=' || trim(rec.primePartNo),
						pKey2 => 'current_backorder='  || to_char(rec.qtyDue) ) ;
				end if ;
				update amd_national_stock_items
				set current_backorder =	rec.qtyDue
				where prime_part_no = trim(rec.primePartNo) ;
				curTmpCnt := curTmpCnt + 1 ;
				if mod(curDueCnt + curTmpCnt, COMMIT_THRESHOLD) = 0 then
				   commit ;
				end if ;
			exception
					 when standard.NO_DATA_FOUND then
					 	  null ;
					 when others then
					 	  raise ; 
			end updateItems2 ;
		end loop ;
		writeMsg(pTableName => 'amd_spare_parts', pError_location => 720,
			pKey1 => 'curTmp1QtyDue',
			pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
			
		writeMsg(pTableName => 'amd_spare_parts', pError_location => 730,
				pKey1 => 'loadCurrentBackorder',
				pKey2 => 'curDueCnt=' || to_char(curDueCnt),
				pKey3 => 'curTmpCnt=' || to_char(curTmpCnt),
				pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
				
		commit ;
	end loadCurrentBackOrder ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_spare_parts_pkg', 
		 		pError_location => 740, pKey1 => 'amd_spare_parts_pkg', pKey2 => '$Revision:   1.78  $') ;
	end version ;

begin
	 <<getDebug>>
	 declare
	 		param amd_param_changes.PARAM_VALUE%type ;
	 begin
	 		select param_value into param from amd_param_changes where param_key = 'debugSpareParts' ;
			mDebug := (param = '1') ;  
	 exception when others then
	 		   mDebug := false ;
	 end getDebug ;
	 
end amd_spare_parts_pkg;
/

show errors

CREATE OR REPLACE PACKAGE BODY Amd_Utils AS
/*
       $Author:   zf297a  $
     $Revision:   1.37  $
         $Date:   Sep 25 2006 15:16:30  $
     $Workfile:   amd_utils.pkb  $
	 $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_utils.pkb-arc  $
   
      Rev 1.37   Sep 25 2006 15:16:30   zf297a
   implemented interface isDiff with date parameters
   
      Rev 1.36   Sep 18 2006 13:14:40   zf297a
   implemented overloaded boolean functions isDiff
   
      Rev 1.35   Sep 12 2006 10:57:00   zf297a
   implemented interface isNumber and isNumberYorN
   
      Rev 1.34   Sep 05 2006 10:32:58   zf297a
   Added dbms_output to version
   
      Rev 1.33   Aug 29 2006 08:43:30   zf297a
   For boolean function isPartRepairable, relaxed the select criteria so that it determines if the part is repairable even if it is deleted.  Also, added an exception handler for the NO_DATA_FOUND exception and had it return false: i.e. the function was not able to clearly determine if the part was repairable based on the smr_code alone.
   
      Rev 1.32   Aug 23 2006 09:45:12   zf297a
   implemented interface isPartRepairable and isPartRepairYorN
   
      Rev 1.31   Jul 13 2006 12:13:08   zf297a
   added implementation for  getSpoPrimePartNo.

      Rev 1.30   Jun 09 2006 11:27:40   zf297a
   implemented version

      Rev 1.29   Jun 01 2006 10:55:56   zf297a
   Added writeMsg

      Rev 1.28   Mar 05 2006 19:14:12   zf297a
   Fixed debugMsg bug: substr's were wrong for pMsg3, and pMsg4

      Rev 1.26   Dec 06 2005 09:21:56   zf297a
   Fixed date so it display MM/DD/YYYY HH:MM:SS for the debugMsg

      Rev 1.24   Nov 09 2005 11:26:02   zf297a
   Implemented interface for isPrimePartYorN.

      Rev 1.23   Oct 21 2005 10:54:26   zf297a
   Removed dbms_output.put_line from debugMsg because it was filling up the output buffer.

      Rev 1.22   Sep 09 2005 14:04:22   zf297a
   Make sure there are words to join for the joinString function

      Rev 1.21   Sep 09 2005 00:20:38   zf297a
   Changed splitString and joinString to use a single character delimiter.

      Rev 1.20   Sep 07 2005 10:13:52   zf297a
   Implemented interfaces splitString and joinString (lesson learned - varray type variables must always be initialized and extended before adding an element using the extend method)

      Rev 1.19   Sep 02 2005 15:06:28   zf297a
   Missing versions after 1.18 because of PVCS server change. Implemented interfaces for getLocType,  isPrimePart, getPrimePart, getEquivalentParts, equivalentParts

      Rev 1.20   Aug 19 2005 12:41:06   zf297a
   Added functions bizDays2CalendarDays, months2CalendarDays, and getSiteLocation.

      Rev 1.19   Aug 19 2005 11:35:16   c378632
   add GetNsiSidFromPartNo

      Rev 1.18   07 Jun 2005 22:13:02   c378632
   add GetLocationInfo, GetSpoLocation, GetPartNo

      Rev 1.17   May 17 2005 10:03:56   c970183
   Removed redundant version of InsertErrorMessage

      Rev 1.16   May 13 2005 14:18:58   c970183
   For the insertErrorMsg procedure all parameters are now optional.  The load_no will still get set, the key5 variable will get set if it is null to the sysdate, and the comments column will get set to sqlcode and sqlerrm.

      Rev 1.15   May 02 2005 13:40:22   c970183
   Removed global debugging.  Used exact types related to amd_load_details for paramater args to debugMsg

      Rev 1.14   Apr 21 2005 08:17:06   c970183
   Created debugMsg which can be controlled via mDebug and mDebugThreshold.  Both params can be controlled by the package user or the amd_param_changes table.  The data from amd_param_changes is loaded at package initialization, therefore the settings given by the package user have a higher priority since they can be overriden at any time during the session.

      Rev 1.13   03 Dec 2004 07:29:14   c970183
   Made sure sourceName and tableName do not exceed the column size for the getLoadNo function

      Rev 1.12   02 Dec 2004 14:32:44   c970183
   Made sure the error logging routines never try to insert a column that is longer than the maximum field.

      Rev 1.10   05 Sep 2002 10:16:34   c970183
   Added $Log$ keyword and changed variable name from sendorAddress to senderAddress
	-- 09/05/02 dse		added sendMail procedure

	--06/07/05 KS		added GetSpoLocation, GetLocationInfo, GetPartNo
*/

	debugCnt NUMBER := 0 ;


    -- use this function  to make sure a field never exceeds its max length
	FUNCTION trimToMax(str IN VARCHAR2, maxLen IN NUMBER) RETURN VARCHAR2 IS
	BEGIN
		 IF LENGTH(str) >maxLen THEN
		 	RETURN SUBSTR(str,1,maxLen) ;
		 ELSE
		 	 RETURN str ;
		 END IF ;
	END trimToMax ;

	FUNCTION GetLoadNo(
							pSourceName AMD_LOAD_STATUS.SOURCE%TYPE,
							pTableName AMD_LOAD_STATUS.TABLE_NAME%TYPE) RETURN NUMBER IS
		loadNo   NUMBER;
		sourceName AMD_LOAD_STATUS.SOURCE%TYPE := trimToMax(pSourceName,20) ;
		tableName AMD_LOAD_STATUS.TABLE_NAME%TYPE := trimToMax(pTableName,30) ;
	BEGIN
		SELECT
			amd_load_status_seq.NEXTVAL
		INTO loadNo
		FROM dual;
		INSERT INTO AMD_LOAD_STATUS
		(
			load_no,
			source,
			load_date,
			table_name
		)
		VALUES
		(
			loadNo,
			sourceName,
			SYSDATE,
			tableName
		);
		RETURN loadNo;
	END GetLoadNo;
	FUNCTION FormatNsn(
							pNsn VARCHAR2,
							pType VARCHAR2 DEFAULT 'AMD') RETURN VARCHAR2 IS
		RetVal	VARCHAR2(50);
	BEGIN
		--
		-- AMD uses NSN w/o dashes. GOLD uses NSN w/dashes.
		--
		IF (pType = 'AMD') THEN
			RetVal := REPLACE(pNsn,'-');
		ELSE
			RetVal := SUBSTR(pNsn,1,4)||'-'||SUBSTR(pNsn,5,2)||'-'||
							SUBSTR(pNsn,7,3)||'-'||SUBSTR(pNsn,10,4);
		END IF;
		RETURN RetVal;
	END;


	PROCEDURE InsertErrorMsg (
							pLoad_no IN AMD_LOAD_DETAILS.load_no%TYPE := NULL,
							pData_line_no IN AMD_LOAD_DETAILS.data_line_no%TYPE := NULL,
							pData_line IN AMD_LOAD_DETAILS.data_line%TYPE := NULL,
							pKey_1 IN AMD_LOAD_DETAILS.key_1%TYPE := NULL,
							pKey_2 IN AMD_LOAD_DETAILS.key_2%TYPE := NULL,
							pKey_3 IN AMD_LOAD_DETAILS.key_3%TYPE := NULL,
							pKey_4 IN AMD_LOAD_DETAILS.key_4%TYPE := NULL,
							pKey_5 IN AMD_LOAD_DETAILS.key_5%TYPE := NULL,
							pComments IN AMD_LOAD_DETAILS.comments%TYPE := NULL ) IS

		loadNo NUMBER := pLoad_no ;
		dataLine AMD_LOAD_DETAILS.data_line%TYPE := trimToMax(pData_line,2000) ;
		k1 AMD_LOAD_DETAILS.KEY_1%TYPE := trimToMax(pKey_1,50) ;
		k2 AMD_LOAD_DETAILS.KEY_2%TYPE := trimToMax(pKey_2, 50) ;
		k3 AMD_LOAD_DETAILS.KEY_3%TYPE := trimToMax(pKey_3, 50) ;
		k4 AMD_LOAD_DETAILS.KEY_4%TYPE := trimToMax(pKey_4, 40) ;
		k5 AMD_LOAD_DETAILS.KEY_5%TYPE := trimToMax(pKey_5, 50) ;
		msg AMD_LOAD_DETAILS.COMMENTS%TYPE := trimToMax(pComments, 2000) ;

	BEGIN
		 IF loadNo IS NULL THEN
		 	loadNo := getLoadNo('amd_utils','amd_load_details') ;
		 END IF ;
		 IF k5 IS NULL THEN
		 	k5 := TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ;
		 END IF ;
		 IF msg IS NULL THEN
		 	msg := SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000) ;
		 END IF ;
		INSERT INTO AMD_LOAD_DETAILS
		(
			load_no,
			data_line_no,
			data_line,
			key_1,
			key_2,
			key_3,
			key_4,
			key_5,
			comments
		)
		VALUES
		(
			pLoad_no,
			pData_line_no,
			dataLine,
			k1,
			k2,
			k3,
			k4,
			k5,
			msg
		);
	exception when others then
		  dbms_output.enable(100000) ;
		  if not isNumber(to_char(pLoad_no)) then
		  	 dbms_output.put_line('pLoad_no is not a number') ;
		  end if ;
		  if not isNumber(to_char(dataLine)) then
		  	 dbms_output.put_line('dataLine is not a number') ;
		  end if ;
		  dbms_output.put_line('k1=' || k1) ;			  
		  dbms_output.put_line('k2=' || k2) ;
		  dbms_output.put_line('k3=' || k3) ;
		  dbms_output.put_line('k4=' || k4) ;
		  dbms_output.put_line('k5=' || k5) ;
		  dbms_output.put_line('msg=' || msg) ;
		  raise ;
	END InsertErrorMsg;

	FUNCTION GetNsiSid(pNsn IN AMD_NSNS.nsn%TYPE) RETURN AMD_NSNS.nsi_sid%TYPE IS
		nsi_sid AMD_NSNS.nsi_sid%TYPE := NULL ;
	BEGIN
		SELECT nsi_sid INTO nsi_sid
		FROM AMD_NSNS
		WHERE nsn = pNsn ;
		RETURN nsi_sid ;
	END GetNsiSid ;

	FUNCTION GetNsiSid(pPart_no IN AMD_NSI_PARTS.part_no%TYPE) RETURN AMD_NSI_PARTS.nsi_sid%TYPE IS
		nsi_sid AMD_NSI_PARTS.nsi_sid%TYPE := NULL ;
	BEGIN
		SELECT nsi_sid INTO nsi_sid
		FROM AMD_NSI_PARTS
		WHERE part_no = pPart_no
		AND unassignment_date IS NULL ;
		RETURN nsi_sid ;
	END GetNsiSid ;

	FUNCTION GetLocSid(pLocId AMD_SPARE_NETWORKS.loc_id%TYPE) RETURN AMD_SPARE_NETWORKS.loc_sid%TYPE IS
		locSid AMD_SPARE_NETWORKS.loc_sid%TYPE := NULL;
		-- locId amd_spare_networks.loc_id%type := null;
	BEGIN
		 /* may not always be applicable, moved to amd_from_bssm_pkg
		 if (pLocId = amd_from_bssm_pkg.BSSM_WAREHOUSE_SRAN) then
	    	   locId := amd_from_bssm_pkg.AMD_WAREHOUSE_LOCID;
		 else
		 	   locId := pLocId;
		 end if;
		 */
		 SELECT loc_sid
		 INTO locSid
		 FROM AMD_SPARE_NETWORKS
		 WHERE loc_id = pLocId;
		 RETURN locSid;
	EXCEPTION
		 WHEN NO_DATA_FOUND THEN
		 	  RETURN NULL;
	END GetLocSid;

	FUNCTION GetLocType(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_type%TYPE IS
		locType AMD_SPARE_NETWORKS.loc_type%TYPE := NULL;
	BEGIN
		 SELECT loc_type
		 INTO locType
		 FROM AMD_SPARE_NETWORKS
		 WHERE loc_sid = pLocSid;
		 RETURN locType;
	EXCEPTION
		 WHEN NO_DATA_FOUND THEN
		 	  RETURN NULL;
	END GetLocType;

	FUNCTION GetLocId(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_id%TYPE IS
		locId AMD_SPARE_NETWORKS.loc_id%TYPE := NULL;
	BEGIN
		 SELECT loc_id
		 INTO locId
		 FROM AMD_SPARE_NETWORKS
		 WHERE loc_sid = pLocSid;
		 RETURN locid;
	EXCEPTION
		 WHEN NO_DATA_FOUND THEN
		 	  RETURN NULL;
	END GetLocId;

	procedure writeMsg(
			pSourceName in varchar2,
			pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
			pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
			pKey1 IN VARCHAR2 := '',
			pKey2 IN VARCHAR2 := '',
			pKey3 IN VARCHAR2 := '',
			pKey4 in varchar2 := '',
			pData IN VARCHAR2 := '',
			pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(pSourceName => pSourceName,	pTableName  => pTableName),
				pData_line_no => pError_location,
				pData_line    => pData,
				pKey_1 => SUBSTR(pKey1,1,50),
				pKey_2 => SUBSTR(pKey2,1,50),
				pKey_3 => substr(pKey3,1,50),
				pKey_4 => substr(pKey4,1,50),
				pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS'),
				pComments => 'sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||') ' || pComments);
	end writeMsg ;


	-- NOTE: this routine does not do any commit's that is left up to the user of the routine
	PROCEDURE debugMsg(pMsg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE,
			  pPackage IN AMD_LOAD_DETAILS.KEY_1%TYPE := 'amd_utils',
			  pLocation IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE := 999,
			  pMsg2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
			  pMsg3 IN AMD_LOAD_DETAILS.key_3%TYPE := '',
			  pMsg4 IN AMD_LOAD_DETAILS.key_4%TYPE := '') IS
	BEGIN
		IF debugCnt  <= mDebugThreshold THEN

		   -- dbms_output.put_line(pMsg);

		   InsertErrorMsg (
					pLoad_no => Amd_Utils.GetLoadNo(
							pSourceName => 'debugMsg',
							pTableName  => 'amd_load_details'),
					pData_line_no => pLocation,
					pData_line    => SUBSTR(pMsg,1,2000),
					pKey_1 => SUBSTR(pPackage,1,50),
					pKey_2 => SUBSTR(pMsg2,1,50),
					pKey_3 =>  SUBSTR(pMsg3,1,50),
					pKey_4 => SUBSTR(pMsg4,1,50),
					pKey_5 => SUBSTR(to_char(SYSDATE,'MM/DD/YYYY HH:MM:SS') || ' debugThreshold=' || TO_CHAR(mDebugThreshold),1,50),
					pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||') ' || SUBSTR(pMsg,201),1,2000));

		   debugCnt := debugCnt + 1 ;
		END IF ;
	EXCEPTION WHEN OTHERS THEN
			  dbms_output.put_line('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||') ') ;
	END;

	PROCEDURE sendMail(senderAddress   VARCHAR2, receiverAddress VARCHAR2, subject VARCHAR2, mesg VARCHAR2) IS
		 EmailServer     VARCHAR2(30) := 'mail.boeing.com';
		 Port NUMBER  := 25;
		 conn UTL_SMTP.CONNECTION;
		 mesg_body VARCHAR2(32767) ;
		 crlf VARCHAR2( 2 ):= CHR( 13 ) || CHR( 10 );
	BEGIN
		conn:= utl_smtp.open_connection( EmailServer, Port );
		utl_smtp.helo( conn, EmailServer );
		utl_smtp.mail( conn, senderAddress);
		utl_smtp.rcpt( conn, receiverAddress );
		mesg_body := 'Date: ' || TO_CHAR( SYSDATE, 'dd Mon yy hh24:mi:ss' )|| crlf ||
		       'From:'  || senderAddress || crlf ||
			   'Subject: ' || subject  || crlf ||
			   'To: '|| receiverAddress || crlf ||
			   '' || crlf || mesg ;

		utl_smtp.data( conn, mesg_body );
		utl_smtp.quit( conn );

	END sendMail ;

	 --- ks added 06/07/05 --

	FUNCTION GetSpoLocation(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE)
		RETURN AMD_SPARE_NETWORKS.spo_location%TYPE IS
		retLocation AMD_SPARE_NETWORKS.spo_location%TYPE := NULL ;
	BEGIN
		 SELECT spo_location INTO retLocation
	   	 	FROM AMD_SPARE_NETWORKS
	   		WHERE loc_sid = pLocSid ;
			RETURN retLocation ;
	EXCEPTION WHEN OTHERS THEN
		 RETURN NULL ;
	END GetSpoLocation ;

	FUNCTION GetPartNo(pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE)
		RETURN AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE IS
		retPart AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE := NULL ;
	BEGIN
		 SELECT prime_part_no INTO retPart
	   	 	FROM AMD_NATIONAL_STOCK_ITEMS
	   		WHERE nsi_sid = pNsiSid AND action_code != 'D';
		 RETURN retPart ;
	EXCEPTION WHEN OTHERS THEN
		RETURN NULL ;
	END GetPartNo ;

	FUNCTION GetLocationInfo(pLocSid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN
		AMD_SPARE_NETWORKS%ROWTYPE IS
		retRow AMD_SPARE_NETWORKS%ROWTYPE := NULL ;
	BEGIN
		SELECT * INTO retRow
			FROM AMD_SPARE_NETWORKS
			WHERE loc_sid = pLocSid ;
		RETURN retRow ;
	EXCEPTION WHEN OTHERS THEN
		RETURN retRow ;
	END GetLocationInfo ;

	-- ks added 06/09/05 ---
	FUNCTION GetNsiSidFromPartNo(pPart AMD_NSI_PARTS.part_no%TYPE)
		 RETURN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE IS
		 retNsiSid AMD_NSI_PARTS.nsi_sid%TYPE  ;
	BEGIN
		SELECT nsi_sid INTO retNsiSid
			FROM AMD_NSI_PARTS
			WHERE part_no = pPart
			AND unassignment_date IS NULL ;
		RETURN retNsiSid ;
	EXCEPTION WHEN NO_DATA_FOUND THEN
		RETURN NULL ;
	END GetNsiSidFromPartNo ;

	 --  added 08/19/05
	 FUNCTION bizDays2CalendarDays(bizDays IN INTEGER) RETURN INTEGER IS
	 BEGIN
	 	  RETURN ROUND((bizDays / 5) * 7) ;
	 END bizDays2CalendarDays ;


	 --  added 08/19/05
	 FUNCTION months2CalendarDays(months IN DECIMAL) RETURN NUMBER IS
	 BEGIN
	 	  RETURN ROUND((ROUND(months * 22) / 5) * 7) ;
	 END months2CalendarDays ;

	 --  added 08/19/05
	 FUNCTION getSiteLocation(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN
	    AMD_SPARE_NETWORKS.loc_id%TYPE IS

	    loc_id AMD_SPARE_NETWORKS.loc_id%TYPE ;
	 BEGIN
	  SELECT loc_id INTO loc_id
	  FROM AMD_SPARE_NETWORKS
	  WHERE loc_sid = getsitelocation.loc_sid ;

	  RETURN loc_id ;
	 END getSiteLocation ;

	 FUNCTION getLocType(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_type%TYPE IS
	 		  loc_type AMD_SPARE_NETWORKS.loc_type%TYPE ;
	 BEGIN
	 	  SELECT loc_type INTO loc_type FROM AMD_SPARE_NETWORKS WHERE loc_sid = getLocType.loc_sid ;
		  RETURN loc_type ;

	 EXCEPTION
	 	  WHEN standard.NO_DATA_FOUND THEN
		  	   RETURN NULL ;
	 END getLocType ;

	 FUNCTION isPrimePart(part_no IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN IS
	 		  prime_part_no AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE ;
	 BEGIN
	 	  SELECT sp.part_no INTO prime_part_no
		  FROM AMD_SPARE_PARTS sp,
		  AMD_NSI_PARTS np
		  WHERE action_code != 'D'
		  AND sp.part_no = isPrimePart.part_no
		  AND sp.part_no = np.part_no
		  AND np.UNASSIGNMENT_DATE IS NOT NULL
		  AND np.PRIME_IND = 'Y' ;
		  RETURN TRUE ;
	 EXCEPTION
	 	WHEN standard.NO_DATA_FOUND THEN
			 RETURN FALSE ;
	 END isPrimePart ;

	 FUNCTION isPrimePartYorN(part_no AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 IS
	 BEGIN
	 	  IF isPrimePart(part_no) THEN
		  	 RETURN 'Y' ;
		  ELSE
		     RETURN 'N' ;
		  END IF ;
	 END isPrimePartYorN ;

	 FUNCTION getPrimePart(part_no AMD_NSI_PARTS.part_no%TYPE) RETURN AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE IS
	 		  prime_part_no AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE ;
	 BEGIN
	 	  SELECT items.prime_part_no INTO prime_part_no
		  FROM AMD_NATIONAL_STOCK_ITEMS items,
		  AMD_NSI_PARTS parts
		  WHERE items.nsi_sid = (SELECT nsi_sid FROM AMD_NSI_PARTS parts WHERE getPrimePart.part_no = parts.part_no AND parts.unassignment_date IS NULL)
		  AND items.action_code != 'D'
		  AND items.nsi_sid = parts.nsi_sid
		  AND parts.prime_ind = 'Y'
		  AND parts.UNASSIGNMENT_DATE IS NULL ;

		  RETURN prime_part_no ;

	 EXCEPTION
	 	  WHEN standard.NO_DATA_FOUND THEN
		  	   RETURN NULL ;
	 END getPrimePart ;

	FUNCTION getEquivalentParts(part_no AMD_SPARE_PARTS.part_no%TYPE) RETURN equivalent_parts IS
			 equivParts equivalent_parts ;
			 rec AMD_SPARE_PARTS%ROWTYPE ;
	 BEGIN
	 	  OPEN equivParts FOR
		  SELECT * FROM AMD_SPARE_PARTS parts
		  WHERE parts.part_no IN
		    (SELECT part_no FROM AMD_NSI_PARTS nsi
			 WHERE nsi.nsi_sid = (
			 	   			   SELECT nsi_sid
							   FROM AMD_NATIONAL_STOCK_ITEMS
							   WHERE prime_part_no = Amd_Utils.getPrimePart(getEquivalentParts.part_no)
							   AND action_code != 'D'
							    )
			AND nsi.unassignment_date IS NULL
			AND nsi.prime_ind != 'Y' );

	 	  RETURN equivParts ;

	 END getEquivalentParts ;

	FUNCTION equivalentParts(part_no AMD_SPARE_PARTS.part_no%TYPE) RETURN parts PIPELINED IS
			 equivParts equivalent_parts ;
			 rec AMD_SPARE_PARTS%ROWTYPE ;
	 BEGIN
	 	  OPEN equivParts FOR
		  SELECT * FROM AMD_SPARE_PARTS parts
		  WHERE parts.part_no IN
		    (SELECT part_no FROM AMD_NSI_PARTS nsi
			 WHERE nsi.nsi_sid = (
			 	   			   SELECT nsi_sid
							   FROM AMD_NATIONAL_STOCK_ITEMS
							   WHERE prime_part_no = Amd_Utils.getPrimePart(equivalentParts.part_no)
							   AND action_code != 'D'
							    )
			AND nsi.unassignment_date IS NULL
			AND nsi.prime_ind != 'Y' );
		  LOOP
		  	  FETCH equivParts INTO rec ;
			  EXIT WHEN equivParts%NOTFOUND ;
	 	  	  pipe ROW(rec) ;
		  END LOOP ;
		  RETURN ;
	 END equivalentParts ;

	-- added 9/7/2005 dse
	FUNCTION splitString(text IN VARCHAR2, delim IN VARCHAR2 := ',') RETURN arrayOfWords IS
			 word VARCHAR2(512) ;
			 words arrayOfWords := arrayOfWords() ;
			 x NUMBER := 0 ;


			 PROCEDURE addWord IS
			 BEGIN
			 	 x := x + 1 ;
				 words.extend ;
				 words(x) := word ;
				 word := NULL ;
			 END addWord ;


	BEGIN
		 IF LENGTH(text) > 0 THEN
			 FOR i IN 1..LENGTH(text) LOOP
			 	 IF SUBSTR(text,i,1) != delim THEN
				 	word := word || SUBSTR(text,i,1) ;
				 ELSE
				 	 addWord ;
				 END IF ;
				 IF LENGTH(text) > 0 AND i = LENGTH(text) THEN
				 	addWord ;
				 END IF ;
			 END LOOP ;
		 END IF ;
		 RETURN words ;
	END splitString ;

	FUNCTION joinString(words IN arrayOfWords, delim IN VARCHAR2 := ',') RETURN VARCHAR2 IS
			 buf VARCHAR2(512) := '' ;
	BEGIN

		 IF words.COUNT() > 0 THEN
			 FOR i IN words.first..words.last LOOP
			 	 IF i != words.last THEN
					buf := buf || words(i) || delim ;
				 ELSE
				 	buf := buf || words(i) ;
				 END IF ;
			 END LOOP ;
		 END IF ;
		 RETURN buf ;
	END joinString ;

	FUNCTION getCageCode(part_no IN VARCHAR2) RETURN VARCHAR2 IS
			  cageCode AMD_SPARE_PARTS.mfgr%TYPE ;
	BEGIN
		  SELECT mfgr INTO cageCode FROM AMD_SPARE_PARTS WHERE part_no = getCageCode.part_no ;
	  RETURN cageCode ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		  RETURN NULL ;
	END getCageCode ;

	FUNCTION getUnitCostDefaulted(part_no IN VARCHAR2) RETURN AMD_SPARE_PARTS.unit_cost_defaulted%TYPE IS
			 nsn AMD_SPARE_PARTS.nsn%TYPE ;
			 mfgr AMD_SPARE_PARTS.mfgr%TYPE ;
			 smr_code AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE ;
			 planner_code AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE ;
	BEGIN
		 SELECT nsn, mfgr INTO nsn, mfgr
		 FROM AMD_SPARE_PARTS
		 WHERE part_no = getUnitCostDefaulted.part_no
		 AND action_code != Amd_Defaults.DELETE_ACTION ;

		 SELECT smr_code, planner_code INTO smr_code, planner_code
		 FROM AMD_NATIONAL_STOCK_ITEMS items,
		 AMD_SPARE_PARTS parts
		 WHERE parts.part_no = getUnitCostDefaulted.part_no
		 AND parts.nsn = items.nsn
		 AND items.action_code != Amd_Defaults.DELETE_ACTION ;
		 RETURN Amd_Defaults.GetUnitCost(pNsn => nsn, pPart_no => part_no,pMfgr => mfgr, pSmr_code => smr_code, pPlanner_code => planner_code)  ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
			  RETURN NULL ;
	END getUnitCostDefaulted ;

	function boolean2Varchar2(theValue in boolean, YorN in boolean := false) return varchar2 is
	begin
		 if theValue then
		 	if YorN then
			   return 'Y' ;
			else
		 		return 'true' ;
			end if ;
		 else
		    if YorN then
			   return 'N' ;
			else
		 		 return 'false' ;
			end if ;
		 end if ;
	end boolean2Varchar2 ;

	procedure version is
	begin
		 amd_utils.writeMsg(pSourceName => 'amd_utils', pTableName => 'amd_utils',
		 		pError_location => 999, pKey1 => 'amd_utils', pKey2 => '$Revision:   1.37  $') ;
		 dbms_output.put_line('a2a_utils: $Revision:   1.37  $') ;
	end version ;


   FUNCTION getSpoPrimePartNo(part_no AMD_SENT_TO_A2A.part_no%TYPE) RETURN AMD_SENT_TO_A2A.SPO_PRIME_PART_NO%TYPE IS
   			spo_prime_part_no AMD_SENT_TO_A2A.SPO_PRIME_PART_NO%TYPE ;
   BEGIN
   		SELECT DISTINCT spo_prime_part_no INTO spo_prime_part_no 
		FROM AMD_SENT_TO_A2A
		WHERE part_no = getSpoPrimePartNo.part_no ;
		RETURN spo_prime_part_no ;
   END getSpoPrimePartNo ;
   
   	function isPartRepairable(part_no amd_spare_parts.part_no%type) return boolean is
			 smr_code amd_national_stock_items.smr_code%type ;
			 result boolean := false ;
	begin
		 select smr_code into smr_code 
		 from amd_spare_parts parts, 
		 amd_national_stock_items items
		 where parts.part_no = isPartRepairable.part_no
		 and parts.nsn = items.nsn ;
		 if length(smr_code) >= 6 then
		 	result := upper(substr(smr_code,6,1)) = 'T' ;
		 end if ;
		 
		 return result ;
	exception when standard.no_data_found then
			  return false ;		 
	end isPartRepairable ;
	
	function isPartRepairableYorN(part_no amd_spare_parts.part_no%type) return varchar2 is
	begin
		 if isPartRepairable(part_no) then
		 	return 'Y' ;
		 else
		 	return 'N' ;
		 end if ;
	end isPartRepairableYorN ;

	function isNumber( p_string in varchar2 ) return boolean
	is
	   l_number number;
	begin
	   l_number := P_string;
	   return true;
	exception 
	   when others then return false;
	end;
	
	function isNumberYorN( p_string in varchar2 ) return varchar2 is
	begin
		 if isNumber(p_string) then
		 	return 'Y' ;
		else
			return 'N' ;
		end if ;
	end isNumberYorN ;
		   
	function isDiff(oldText in varchar2, newText in varchar2) return boolean is
	begin
		 return oldText <> newText 
		 		or (oldText is null and newText is not null) 
				or (oldText is not null and newText is null) ;
	end isDiff ;
	
	function isDiff(oldNum in number, newNum in number) return boolean is
	begin
		 return (oldNum <> newNum)
		 		or (oldNum is null and newNum is not null) 
				or (oldNum is not null and newNum is null) ;
	end isDiff ;

	function isDiff(oldDate in date, newDate in Date) return boolean is
	begin
		 return (oldDate <> newDate)
		 		or (oldDate is null and newDate is not null) 
				or (oldDate is not null and newDate is null) ;
	end isDiff ;	
	
BEGIN
	 <<getDebugThreshold>>
	 DECLARE
	 		param AMD_PARAM_CHANGES.PARAM_VALUE%TYPE ;
	 BEGIN
	 		SELECT param_value INTO param FROM AMD_PARAM_CHANGES WHERE param_key = 'debugUtilsThreshold' ;
			--mDebugThreshold := to_number(param) ;
	 EXCEPTION WHEN OTHERS THEN
	 		   mDebugThreshold := 1000 ;
	 END getDebugThreshold ;


END Amd_Utils;
/

show errors

CREATE OR REPLACE PROCEDURE AMD_OWNER.mta_truncate_table (
                            table_name   varchar2,
                            storage_type varchar2)
as
 /*
      $Author:   zf297a  $
	$Revision:   1.4  $
        $Date:   Jun 09 2006 09:18:32  $
    $Workfile:   MTA_TRUNCATE_TABLE.prc  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Procedures\MTA_TRUNCATE_TABLE.prc-arc  $
/*   
/*      Rev 1.4   Jun 09 2006 09:18:32   zf297a
/*   Added pData to set data_line in amd_load_details
/*   
/*      Rev 1.3   Jun 08 2006 13:00:16   zf297a
/*   Added mta_truncate_table to last "end" statement.
/*   
/*      Rev 1.2   Jun 08 2006 12:57:24   zf297a
/*   Made sure that the table_name appears in key2 of amd_load_details
/*   
/*      Rev 1.1   Jun 07 2006 19:20:54   zf297a
/*   Added writeMsg with $Revision:   1.4  $
*/
crsor integer;
rval  integer;
begin
 amd_utils.writeMsg(pSourceName => 'mta_truncate_table', 
   pTableName => table_name, pError_location => 1, pData => 'mta_truncate_table',
     pKey1 => storage_type, pKey2 => table_name, pKey3 => '$Revision:   1.4  $') ;
    dbms_output.put_line('Truncating Table : '|| table_name ||
                     ' Storage : '|| storage_type);
 crsor := dbms_sql.open_cursor;
 dbms_sql.parse(crsor, 'truncate table '|| table_name ||
                ' '|| storage_type ,dbms_sql.v7);
 rval := dbms_sql.execute(crsor);
 dbms_sql.close_cursor(crsor);
end mta_truncate_table;
/

show errors

CREATE OR REPLACE PROCEDURE AMD_OWNER.mta_enable_constraint (
                            table_name		varchar2,
                            constraint_name	varchar2)
as
 /*
      $Author:   zf297a  $
	$Revision:   1.1  $
        $Date:   Jun 09 2006 09:19:12  $
    $Workfile:   MTA_ENABLE_CONSTRAINT.prc  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Procedures\MTA_ENABLE_CONSTRAINT.prc-arc  $
/*   
/*      Rev 1.1   Jun 09 2006 09:19:12   zf297a
/*   Added PVCS keywords and writeMsg to log the event to amd_load_details
*/
crsor integer;
rval  integer;
begin
 amd_utils.writeMsg(pSourceName => 'mta_enable_constraint', 
   pTableName => table_name, pError_location => 1, pData => 'mta_enable_constraint',
     pKey1 => table_name, pKey2 => constraint_name, pKey3 => '$Revision:   1.1  $') ;
 dbms_output.put_line('Enabling Constraint: ' || constraint_name ||
	' Table: '|| table_name);
 crsor := dbms_sql.open_cursor;
 dbms_sql.parse(crsor, 'alter table '|| table_name ||
                ' enable constraint '|| constraint_name ,dbms_sql.v7);
 rval := dbms_sql.execute(crsor);
 dbms_sql.close_cursor(crsor);
end;
/

show errors

CREATE OR REPLACE PROCEDURE AMD_OWNER.mta_disable_constraint (
                            table_name		varchar2,
                            constraint_name	varchar2)
as
 /*
      $Author:   zf297a  $
	$Revision:   1.1  $
        $Date:   Jun 09 2006 09:19:12  $
    $Workfile:   MTA_DISABLE_CONSTRAINT.prc  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Procedures\MTA_DISABLE_CONSTRAINT.prc-arc  $
/*   
/*      Rev 1.1   Jun 09 2006 09:19:12   zf297a
/*   Added PVCS keywords and writeMsg to log the event to amd_load_details
*/
crsor integer;
rval  integer;
begin
 amd_utils.writeMsg(pSourceName => 'mta_disable_constraint', 
   pTableName => table_name, pError_location => 1, pData => 'mta_disable_constraint',
     pKey1 => table_name, pKey2 => constraint_name, pKey3 => '$Revision:   1.1  $') ;
 dbms_output.put_line('Disabling Constraint: ' || constraint_name ||
	' Table: '|| table_name);
 crsor := dbms_sql.open_cursor;
 dbms_sql.parse(crsor, 'alter table '|| table_name ||
                ' disable constraint '|| constraint_name ,dbms_sql.v7);
 rval := dbms_sql.execute(crsor);
 dbms_sql.close_cursor(crsor);
end;
/

show errors

CREATE OR REPLACE TRIGGER AMD_OWNER.tmp_loc_part_override_trg1
BEFORE INSERT OR UPDATE
ON AMD_OWNER.tmp_amd_location_part_override
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
DECLARE
/******************************************************************************
      $Author:   zf297a  $
    $Revision:   1.1  $
        $Date:   Sep 25 2006 08:30:22  $   Aug 23 2006 09:35:44  $
    $Workfile:   TMP_LOC_PART_OVERRIDE_TRG1.trg  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Triggers\TMP_LOC_PART_OVERRIDE_TRG1.trg.-arc  $
/*   
/*      Rev 1.1   Sep 25 2006 08:30:22   zf297a
/*   Make sure that the last_update_dt gets the updated
/*   
/*      Rev 1.0   Aug 24 2006 10:09:44   zf297a
/*   Initial revision.

******************************************************************************/
BEGIN
   if :new.loc_sid = Amd_Location_Part_Override_Pkg.THE_WAREHOUSE_LOC_SID
	and amd_utils.isPartRepairable(:new.part_no) then
	:new.tsl_override_qty := 0 ;
	:new.last_update_dt := sysdate ;
  end if ;
END tmp_loc_part_override_trg1 ;
/

show errors

CREATE OR REPLACE TRIGGER AMD_OWNER.amd_loc_part_override_trg1
BEFORE INSERT OR UPDATE
ON AMD_OWNER.amd_location_part_override
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
DECLARE
/******************************************************************************
      $Author:   zf297a  $
    $Revision:   1.0  $
        $Date:   Sep 25 2006 08:31:42  $
    $Workfile:   AMD_LOC_PART_OVERRIDE_TRG1.trg  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Triggers\AMD_LOC_PART_OVERRIDE_TRG1.trg.-arc  $
/*   
/*      Rev 1.0   Sep 25 2006 08:31:42   zf297a
/*   Initial revision.

******************************************************************************/
BEGIN
   if :new.loc_sid = Amd_Location_Part_Override_Pkg.THE_WAREHOUSE_LOC_SID
	and amd_utils.isPartRepairable(:new.part_no) then
	:new.tsl_override_qty := 0 ;
	:new.last_update_dt := sysdate ;
  end if ;
END amd_loc_part_override_trg1 ;
/

show errors

CREATE OR REPLACE TRIGGER AMD_OWNER.tmp_a2a_loc_part_override_trg1
BEFORE INSERT OR UPDATE
ON AMD_OWNER.tmp_a2a_loc_part_override
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
DECLARE
/******************************************************************************
      $Author:   zf297a  $
    $Revision:   1.0  $
        $Date:   Aug 23 2006 09:35:44  $
    $Workfile:   TMP_A2A_LOC_PART_OVERRIDE_TRG1.trg  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Triggers\TMP_A2A_LOC_PART_OVERRIDE_TRG1.trg.-arc  $
/*   
/*      Rev 1.0   Aug 23 2006 09:35:44   zf297a
/*   Initial revision.

******************************************************************************/
BEGIN
   if :new.site_location = Amd_Location_Part_Override_Pkg.THE_WAREHOUSE
	and amd_utils.isPartRepairable(:new.part_no) then
	:new.override_quantity := 0 ;
	:new.last_update_dt := sysdate ;
  end if ;
END tmp_a2a_loc_part_override_trg1 ;
/

show errors
CREATE OR REPLACE TRIGGER amd_spare_networks_bef_ins_upd
BEFORE INSERT OR UPDATE
ON AMD_OWNER.AMD_SPARE_NETWORKS
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
DECLARE
/******************************************************************************
      $Author:   zf297a  $
    $Revision:   1.3  $
	    $Date:   May 23 2006 10:10:26  $
    $Workfile:   AMD_SPARE_NETWORKS_BEF_INS_UPD.trg  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Triggers\AMD_SPARE_NETWORKS_BEF_INS_UPD.trg.-arc  $
/*   
/*      Rev 1.3   May 23 2006 10:10:26   zf297a
/*   Make sure last_update_dt gets filled in
/*   
/*      Rev 1.2   May 16 2006 09:49:16   zf297a
/*   Added trim for all varchar2 fields to prevent erroneous leading spaces and to remove unnecessary trailing spaces.
/*   
/*   
/*   
/*      Rev 1.1   Apr 10 2006 08:33:46   zf297a
/*   Trigger automatically removes blanks from all spo_location fields.  So, if the field contains one or more blanks, then the field gets a null value
/*   
/*      Rev 1.0   Apr 07 2006 12:42:22   zf297a
/*   Initial revision.
   PURPOSE: Make sure the spo_location is never a blank and gets rid of leading or trailing spaces   
   			      
******************************************************************************/
BEGIN
	 :new.location_name := trim(:new.location_name) ;
     :new.loc_id := trim(:new.loc_id) ;
  	 :new.loc_type := trim(:new.loc_type) ;
  	 :new.mob := trim(:new.mob) ;
  	 :new.repair_flag := trim(:new.repair_flag) ;
  	 :new.command := trim(:new.command) ;
  	 :new.sub_command := trim(:new.sub_command) ;
  	 :new.icao := trim(:new.icao) ;
  	 :new.calendar_name := trim(:new.calendar_name) ;
	 :new.spo_location := trim(:new.spo_location) ;
	 :new.last_update_dt := sysdate ;
END amd_spare_networks_bef_ins_upd;
/

show errors
CREATE OR REPLACE TRIGGER AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_TRG1
BEFORE INSERT OR UPDATE
ON AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS
REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
DECLARE
voucher varchar2(2) ;
/******************************************************************************
      $Author:   zf297a  $
    $Revision:   1.3  $
	    $Date:   Aug 24 2006 10:31:14  $
    $Workfile:   AMD_ON_ORDER_DATE_FILTERS_TRG1.trg  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Triggers\AMD_ON_ORDER_DATE_FILTERS_TRG1.trg.-arc  $
/*   
/*      Rev 1.3   Aug 24 2006 10:31:14   zf297a
/*   Do not allow create_order_date and the scheduled_receipt_date range to be entered at the same time.
/*   
/*      Rev 1.2   Aug 22 2006 09:44:00   zf297a
/*   Added check to make sure that any order_create_date is greater than the scheduled_receipt_date_to if it is entered.
/*   
/*      Rev 1.1   May 17 2006 14:51:36   zf297a
/*   removed start_date - column is not needed
/*   
/*      Rev 1.0   May 17 2006 12:00:34   zf297a
/*   Initial revision.

******************************************************************************/
BEGIN
   if inserting then
   	  begin
   	  	   select distinct substr(gold_order_number,1,2) into voucher from amd_on_order where substr(gold_order_number,1,2) = :new.voucher_prefix ;
	  exception when standard.no_data_found then
		   RAISE_APPLICATION_ERROR(-20000, 'The voucher prefix does not exist in amd_on_order.');
	  end ;	 
   else
   	   :new.last_update_dt := sysdate ;
	   :new.oracle_userid := user ; 
   end if ;
   if :new.calendar_days is not null then
   	  if :new.calendar_days < 0 then
	  	 RAISE_APPLICATION_ERROR(-20001, 'calendar_days must be positive.');
	  end if ;
   	  if :new.scheduled_receipt_date_from is not null then
	  	 RAISE_APPLICATION_ERROR(-20002, 'Cannot have scheduled_receipt_date_from with calendar_days.');
	  elsif :new.scheduled_receipt_date_to is not null then
	  	 RAISE_APPLICATION_ERROR(-20003, 'Cannot have scheduled_receipt_date_to with calendar_days.');
	  end if ;
   else
   	   if :new.scheduled_receipt_date_from is not null then
	   	  if :new.scheduled_receipt_date_to is null then
		  	 RAISE_APPLICATION_ERROR(-20004, 'You must enter scheduled_receipt_date_to.');
		  end if ;
	   else
	   	   if :new.scheduled_receipt_date_to is not null then
		  	 RAISE_APPLICATION_ERROR(-20005, 'You must enter scheduled_receipt_date_from.');
		   end if ;
	   end if ;
	   if :new.scheduled_receipt_date_from > :new.scheduled_receipt_date_to then
		  	 RAISE_APPLICATION_ERROR(-20006, 'scheduled_receipt_date_from must be <= scheduled_receipt_date_to.');
	   else
	   	   :new.calendar_days := null ; -- the calendar days are no longer needed
	   end if ;
   end if ;
   if :new.order_create_date is not null 
   and (:new.scheduled_receipt_date_from is not null or :new.scheduled_receipt_date_to is not null) then
	  	 RAISE_APPLICATION_ERROR(-20007, 'Cannot have both order_create_date and scheduled_receipt_date range.');
   end if ;
   EXCEPTION
     WHEN OTHERS THEN
       -- Consider logging the error and then re-raise
       RAISE;
END AMD_ON_ORDER_DATE_FILTERS_TRG1;
/

show errors

CREATE PUBLIC SYNONYM A2A_PKG FOR AMD_OWNER.A2A_PKG;


CREATE PUBLIC SYNONYM AMD_BATCH_PKG FOR AMD_OWNER.AMD_BATCH_PKG;


CREATE PUBLIC SYNONYM AMD_CLEANED_FROM_BSSM_PKG FOR AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG;


CREATE PUBLIC SYNONYM AMD_CLEAN_DATA FOR AMD_OWNER.AMD_CLEAN_DATA;


CREATE PUBLIC SYNONYM AMD_DEFAULTS FOR AMD_OWNER.AMD_DEFAULTS;


CREATE PUBLIC SYNONYM AMD_DEMAND FOR AMD_OWNER.AMD_DEMAND;


CREATE PUBLIC SYNONYM AMD_FROM_BSSM_PKG FOR AMD_OWNER.AMD_FROM_BSSM_PKG;


CREATE PUBLIC SYNONYM AMD_INVENTORY FOR AMD_OWNER.AMD_INVENTORY;


CREATE PUBLIC SYNONYM AMD_LOAD FOR AMD_OWNER.AMD_LOAD;


CREATE PUBLIC SYNONYM AMD_LOCATION_PART_LEADTIME_PKG FOR AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG;


CREATE PUBLIC SYNONYM AMD_LOCATION_PART_OVERRIDE_PKG FOR AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG;


CREATE PUBLIC SYNONYM AMD_ON_ORDER_DATE_FILTERS_PKG FOR AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG;


CREATE PUBLIC SYNONYM AMD_ORG_DEPLOYMENT_PKG FOR AMD_OWNER.AMD_ORG_DEPLOYMENT_PKG;


CREATE PUBLIC SYNONYM AMD_PARTPRIME_PKG FOR AMD_OWNER.AMD_PARTPRIME_PKG;


CREATE PUBLIC SYNONYM AMD_PART_FACTORS_PKG FOR AMD_OWNER.AMD_PART_FACTORS_PKG;


CREATE PUBLIC SYNONYM AMD_PART_LOCS_LOAD_PKG FOR AMD_OWNER.AMD_PART_LOCS_LOAD_PKG;


CREATE PUBLIC SYNONYM AMD_PART_LOC_FORECASTS_PKG FOR AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG;


CREATE PUBLIC SYNONYM AMD_REQS_PKG FOR AMD_OWNER.AMD_REQS_PKG;


GRANT EXECUTE ON  AMD_OWNER.AMD_BATCH_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.A2A_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_PART_LOCS_LOAD_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_PARTPRIME_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_ORG_DEPLOYMENT_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_LOAD TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_FROM_BSSM_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_DEMAND TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.MTA_DISABLE_CONSTRAINT TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.MTA_ENABLE_CONSTRAINT TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.MTA_TRUNCATE_TABLE TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_CLEAN_DATA TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_DEFAULTS TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_REQS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_INVENTORY TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_PART_FACTORS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_BATCH_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_ORG_DEPLOYMENT_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.MTA_DISABLE_CONSTRAINT TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.MTA_ENABLE_CONSTRAINT TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.MTA_TRUNCATE_TABLE TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_CLEAN_DATA TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_DEFAULTS TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_DEMAND TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_REQS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_FROM_BSSM_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_INVENTORY TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_LOAD TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_PARTPRIME_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_PART_FACTORS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_PART_LOCS_LOAD_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.A2A_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.A2A_PKG TO BSRM_LOADER;

GRANT EXECUTE ON  AMD_OWNER.MTA_DISABLE_CONSTRAINT TO BSRM_LOADER;

GRANT EXECUTE ON  AMD_OWNER.MTA_ENABLE_CONSTRAINT TO BSRM_LOADER;

GRANT EXECUTE ON  AMD_OWNER.AMD_ORG_DEPLOYMENT_PKG TO BSRM_LOADER;

GRANT EXECUTE ON  AMD_OWNER.AMD_INVENTORY TO BSRM_LOADER;

GRANT EXECUTE ON  AMD_OWNER.MTA_TRUNCATE_TABLE TO BSRM_LOADER;

GRANT EXECUTE ON  AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG TO BSSM_OWNER WITH GRANT OPTION;

CREATE PUBLIC SYNONYM AMD_UTILS FOR AMD_OWNER.AMD_UTILS;

GRANT EXECUTE ON  AMD_OWNER.AMD_UTILS TO AMD_READER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_UTILS TO AMD_WRITER_ROLE;

GRANT EXECUTE ON  AMD_OWNER.AMD_UTILS TO BSSM_OWNER WITH GRANT OPTION;

