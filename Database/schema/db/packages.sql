DROP PACKAGE AMD_OWNER.AMD_BASIC_DEFAULT_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_basic_default_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
     $Date:   Dec 01 2005 09:27:36  $
    $Workfile:   amd_basic_default_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_basic_default_pkg.pks-arc  $
/*
/*      Rev 1.1   Dec 01 2005 09:27:36   zf297a
/*   added pvcs keywords
*/

--
-- SCCSID: amd_basic_default_pkg.sql  1.2  Modified: 08/14/02 14:10:23
--
---------------------------------------------------------------
--  Date			By		History
--  ----                        --              ------
--  08/09/02			TP	Initial Implementation
--
--------------------------------------------------------------
	procedure setGroup(pNsiSid number);
	procedure setAllGroups ;

end amd_basic_default_pkg ;
 
/


DROP PACKAGE AMD_OWNER.AMD_BATCH_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_batch_pkg AS
	/*7
      $Author:   zf297a  $
    $Revision:   1.5  $
	    $Date:   Jun 09 2006 11:34:36  $
    $Workfile:   AMD_BATCH_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_BATCH_PKG.pks.-arc  $
/*
/*      Rev 1.5   Jun 09 2006 11:34:36   zf297a
/*   added interface version
/*
/*      Rev 1.4   Mar 23 2006 08:19:14   zf297a
/*   Added procedure truncateIfOld
/*
/*      Rev 1.3   Mar 19 2006 01:48:46   zf297a
/*   Added interface for isStepComplete function
/*
/*      Rev 1.2   Mar 16 2006 14:24:42   zf297a
/*   Added step procedures and functions
/*
/*      Rev 1.1   Mar 03 2006 12:32:56   zf297a
/*   Added three functions:
/*   getLastStartTime
/*   getLastEndTime
/*   isJobComplete.
/*
/*      Rev 1.0   Nov 22 2005 08:02:18   zf297a
/*   Initial revision.
*/
  	   ASSET_MANAGEMENT_DESKTOP constant varchar2(3) := 'AMD' ;

	   procedure start_job(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP, description in amd_batch_jobs.description%type := null) ;
	   procedure abort_job(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) ;
	   procedure end_job(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) ;
	   function getActiveJob(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_jobs.batch_job_number%type ;
  	   function isJobActive(batch_job_number in amd_batch_jobs.batch_job_number%type := null,
  		   system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean ;
	   function getLastCompleteJob(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_jobs.batch_job_number%type ;
	   function getLastStartTime(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP)
	   			return amd_batch_jobs.START_TIME%type ;

  	   function getLastEndTime(batch_job_number in amd_batch_jobs.batch_job_number%type := null,system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP)
	   			return amd_batch_jobs.END_TIME%type ;

  	   function isJobComplete(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type := null,
	   			system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean ;
  	   function isJob(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type,
	   			system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean ;

	   procedure start_step(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null,
	   			 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
				 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null,
				 description in amd_batch_job_steps.DESCRIPTION%type := null,
				 package_name in amd_batch_job_steps.PACKAGE_NAME%type := null,
				 procedure_name in amd_batch_job_steps.PROCEDURE_NAME%type := null,
				 function_name in amd_batch_job_steps.FUNCTION_NAME%type := null) ;

	   procedure abort_step(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			 system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
				 batch_step_number in amd_batch_job_steps.batch_step_number%type := null) ;


	   procedure end_step(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null,
				 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
	 			 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null) ;


	   function getActiveStep(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
	   function getLastCompleteStep(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.batch_step_number%type ;
	   function getLastStepStartTime(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.start_time%type ;
	   function getLastStepEndTime(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
	   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.start_time%type;
	   procedure deleteJob(batch_job_number in amd_batch_jobs.batch_job_number%type := null,
	   			 system_id in amd_batch_jobs.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP) ;
  	   function isStepComplete(batch_job_number in amd_batch_job_steps.batch_job_number%type,
  		   system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		   batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type) return boolean ;
       function isStepComplete(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
  		   system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		   description in amd_batch_job_steps.description%type) return boolean ;

  	   function didStepStart(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null,
  		 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
		 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null,
		 description in amd_batch_job_steps.DESCRIPTION%type := null,
		 package_name in amd_batch_job_steps.PACKAGE_NAME%type := null,
		 procedure_name in amd_batch_job_steps.PROCEDURE_NAME%type := null,
		 function_name in amd_batch_job_steps.FUNCTION_NAME%type := null) return boolean ;

  	  procedure truncateIfOld(tablename in varchar2, system_id in amd_batch_jobs.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP) ;

	  -- added 6/9/2006 by DSE
	  procedure version ;

END amd_batch_pkg;

 
/


DROP PACKAGE AMD_OWNER.AMD_BEST_SPARES_INPUT_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_best_spares_input_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
	    $Date:   Nov 30 2005 12:20:50  $
    $Workfile:   AMD_BEST_SPARES_INPUT_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_BEST_SPARES_INPUT_PKG.pks-arc  $
/*
/*      Rev 1.1   Nov 30 2005 12:20:50   zf297a
/*   added PVCS keywords
*/
	-- SCCSID: amd_best_spares_input_pkg.sql  1.1  Modified: 08/28/02 16:05:06
	--
	-- Date      By            History
	-- --------  ------------  -------------------------------------------
	-- 08/28/02  kcs		   Initial Implementation
	--
	--
	procedure getAsCapablePercent(pDate date DEFAULT sysdate);
	procedure getBliss;
	procedure getUpGradeable;
end amd_best_spares_input_pkg;
 
/


DROP PACKAGE AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG
IS
   /*
    PVCS Keywords

      $Author:   zf297a  $
    $Revision:   1.9  $
        $Date:   11 May 2007 12:09:38  $
    $Workfile:   AMD_CLEANED_FROM_BSSM_PKG.pks  $
      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_cleaned_from_bssm_pkg.pks-arc  $

     Rev 1.9   11 May 2007 12:09:38   zf297a
  Renamed gold_mfgr_cage to pbl_flag for BSSM V604

     Rev 1.8   Jun 09 2006 12:47:12   zf297a
  added interface version

     Rev 1.8   Aug 23 2005 12:27:14   zf297a
  Added funciont GetValuesX - it retireves bssm via the nsn or the part_no.  If the data is not found via the nsn, the routine attempts to find it via the part_no.

     Rev 1.7   May 17 2005 11:05:56   c970183
  added new cleaned fields.  added fields that are not part of amd, but could provide an easy way to get field from bssm

     Rev 1.6   May 17 2005 10:26:48   c970183
  Changed dla_wareshouse_stock to current_backorder

     Rev 1.5   May 06 2005 07:36:58   c970183
  changed dla_warehouse_stcok to current_backorder.  added pvcs keywords
   */



   -- constant name is amd field name, value is corresponding bssm field name.
   -- more of a visual reference.
   ACQUISITION_ADVICE_CODE      CONSTANT VARCHAR2 (30)
                                            := 'ACQUISITION_ADVICE_CODE' ;
   ADD_INCREMENT                CONSTANT VARCHAR2 (30) := 'ADD_INCREMENT';
   AMC_BASE_STOCK               CONSTANT VARCHAR2 (30) := 'AMC_BASE_STOCK';
   AMC_DAYS_EXPERIENCE          CONSTANT VARCHAR2 (30) := 'AMC_DAYS_EXPERIENCE';
   AMC_DEMAND                   CONSTANT VARCHAR2 (30) := 'AMC_DEMAND';
   CAPABILITY_REQUIREMENT       CONSTANT VARCHAR2 (30)
                                            := 'CAPABILITY_REQUIREMENT' ; -- CATEGORY
   CONDEMN_AVG                  CONSTANT VARCHAR2 (30) := 'CONDEMN';
   COST_TO_REPAIR_OFF_BASE      CONSTANT VARCHAR2 (30) := 'OFF_BASE_REPAIR_COST';
   CRITICALITY                  CONSTANT VARCHAR2 (30) := 'CRITICALITY';
   DLA_DEMAND                   CONSTANT VARCHAR2 (30) := 'DLA_DEMAND';
   CURRENT_BACKORDER            CONSTANT VARCHAR2 (30) := 'CURRENT_BACKORDER';
   FEDC_COST                    CONSTANT VARCHAR2 (30) := 'FEDC_COST';
   PBL_FLAG                     CONSTANT VARCHAR2 (30) := 'GOLD_MFGR_CAGE'; -- not an amd fiueld
   ITEM_TYPE                    CONSTANT VARCHAR2 (30) := 'ITEM_TYPE';
   MFGR                         CONSTANT VARCHAR2 (30) := 'MFGR'; -- not cleaned in amd
   MIC_CODE_LOWEST              CONSTANT VARCHAR2 (30) := 'MIC_CODE';
   MTBDR                        CONSTANT VARCHAR2 (30) := 'MTBDR';
   MIN_PURCHASE_QUANTITY        CONSTANT VARCHAR2 (30)
                                            := 'MIN_PURCHASE_QUANTITY' ;
   MONTHLY_DEMAND_RATE          CONSTANT VARCHAR2 (30) := 'MONTHLY_DEMAND_RATE';
   NOMENCLATURE                 CONSTANT VARCHAR2 (30) := 'NOMENCLATURE';
   NRTS_AVG                     CONSTANT VARCHAR2 (30) := 'NRTS';
   ORDER_LEAD_TIME              CONSTANT VARCHAR2 (30) := 'ORDER_LEAD_TIME'; -- TCONDEMN
   ORDER_UOM                    CONSTANT VARCHAR2 (30) := 'ORDER_UOM'; /* UNITS */
   PLANNER_CODE                 CONSTANT VARCHAR2 (30) := 'PLANNER_CODE';
   RTS_AVG                      CONSTANT VARCHAR2 (30) := 'RTS';
   RU_IND                       CONSTANT VARCHAR2 (30) := 'RU_IND';
   SMR_CODE                     CONSTANT VARCHAR2 (30) := 'SMR_CODE';
   TIME_TO_REPAIR_OFF_BASE      CONSTANT VARCHAR2 (30) := 'OFF_BASE_TURNAROUND'; -- TDEPOT
   TIME_TO_REPAIR_ON_BASE_AVG   CONSTANT VARCHAR2 (30)
                                            := 'ON_BASE_TURNAROUND' ; -- TBASE
   UNIT_COST                    CONSTANT VARCHAR2 (30) := 'UNIT_COST';
   WUC                          CONSTANT VARCHAR2 (30) := 'WUC'; -- not an amd field

   -- base specific cleanable fields
   REMOVAL_IND                  CONSTANT VARCHAR2 (30)
                                            := 'REPLACEMENT_INDICATOR' ;
   REPAIR_LEVEL_CODE            CONSTANT VARCHAR2 (30) := 'REPAIR_INDICATOR';

   -- if field needs to be converted, eg. item_type, criticality, from bssm to
   -- amd, any function in this package will return the converted value that
   -- amd needs.
   TYPE partFields IS RECORD
   (
      nsn                          amd_national_stock_items.nsn%TYPE,
      part_no                      amd_spare_parts.PART_NO%TYPE,
      add_increment                amd_national_stock_items.add_increment%TYPE,
      amc_base_stock               amd_national_stock_items.amc_base_stock%TYPE,
      amc_days_experience          amd_national_stock_items.amc_days_experience%TYPE,
      amc_demand                   amd_national_stock_items.amc_demand%TYPE,
      capability_requirement       amd_national_stock_items.capability_requirement%TYPE,
      condemn_avg                  amd_national_stock_items.condemn_avg%TYPE,
      cost_to_repair_off_base      amd_national_stock_items.cost_to_repair_off_base_cleand%TYPE,
      criticality                  amd_national_stock_items.criticality%TYPE,
      dla_demand                   amd_national_stock_items.dla_demand%TYPE,
      current_backorder            amd_national_stock_items.current_backorder%TYPE,
      fedc_cost                    amd_national_stock_items.fedc_cost%TYPE,
      item_type                    amd_national_stock_items.item_type%TYPE,
      mic_code_lowest              amd_national_stock_items.mic_code_lowest%TYPE,
      mtbdr                        amd_national_stock_items.mtbdr%TYPE,
      min_purchase_quantity        amd_national_stock_items.min_purchase_quantity%TYPE,
      nomenclature                 amd_national_stock_items.nomenclature_cleaned%TYPE,
      nrts_avg                     amd_national_stock_items.nrts_avg%TYPE,
      order_lead_time              amd_national_stock_items.order_lead_time_cleaned%TYPE,
      acquisition_advice_code      bssm_owner.bssm_parts.ACQUISITION_ADVICE_CODE%TYPE,
      order_uom                    amd_national_stock_items.order_uom_cleaned%TYPE,
      planner_code                 amd_national_stock_items.planner_code%TYPE,
      rts_avg                      amd_national_stock_items.rts_avg%TYPE,
      ru_ind                       amd_national_stock_items.ru_ind%TYPE,
      smr_code                     amd_national_stock_items.smr_code%TYPE,
      time_to_repair_off_base      amd_national_stock_items.time_to_repair_on_base_avg%TYPE,
      time_to_repair_on_base_avg   amd_national_stock_items.time_to_repair_on_base_avg%TYPE,
      unit_cost                    amd_national_stock_items.unit_cost_cleaned%TYPE,
      mfgr                         amd_spare_parts.MFGR%TYPE,
      pbl_flag                     bssm_owner.bssm_parts.PBL_FLAG%TYPE
   );

   TYPE partBaseFields IS RECORD
   (
      nsn                 amd_national_stock_items.nsn%TYPE,
      loc_id              amd_spare_networks.loc_id%TYPE,
      removal_ind         amd_part_locs.removal_ind%TYPE,
      repair_level_code   amd_part_locs.repair_level_code%TYPE
   );

   -- part specific

   FUNCTION GetValues (pNsn bssm_parts.nsn%TYPE)
      RETURN partFields;

   FUNCTION GetValuesX (pNsn       bssm_parts.nsn%TYPE,
                        pPartNo    bssm_parts.part_no%TYPE)
      RETURN partFields;

   FUNCTION GetValues (pNsn bssm_parts.nsn%TYPE, pFieldName VARCHAR2)
      RETURN VARCHAR2;

   -- base specific
   FUNCTION GetBaseValues (pNsn     bssm_base_parts.nsn%TYPE,
                           pSran    bssm_base_parts.sran%TYPE)
      RETURN partBaseFields;

   FUNCTION GetBaseValues (pNsn          bssm_base_parts.nsn%TYPE,
                           pSran         bssm_base_parts.sran%TYPE,
                           pFieldName    VARCHAR2)
      RETURN VARCHAR2;


   -- update all cleaned by listing all in bssm_parts for lock_sid 2
   PROCEDURE UpdateAmdAllPartCleaned;

   PROCEDURE UpdateAmdAllBaseCleaned;

   PROCEDURE NullAmdAllCleanedFields;

   -- update used by trigger
   PROCEDURE UpdateAmdPartByTrigger (pLockSidTwo bssm_parts%ROWTYPE);

   PROCEDURE UpdateAmdBaseByTrigger (pLockSidTwo bssm_base_parts%ROWTYPE);

   PROCEDURE OnPartResetByTrigger (pLockSidTwo bssm_parts%ROWTYPE);

   PROCEDURE OnBaseResetByTrigger (pLockSidTwo bssm_base_parts%ROWTYPE);

   -- added 6/9/2006 by dse
   PROCEDURE version;
END AMD_CLEANED_FROM_BSSM_PKG;
/


DROP PACKAGE AMD_OWNER.AMD_CLEAN_DATA;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_clean_data as
    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.5  $
         $Date:   Jun 09 2006 12:42:42  $
     $Workfile:   amd_clean_data.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_clean_data.pks-arc  $

      Rev 1.5   Jun 09 2006 12:42:42   zf297a
   added interface version

      Rev 1.5   Aug 23 2005 12:20:02   zf297a
   Added part_no to the interfaces of the cleaned data that is being retrived via the amd_load / diff process.  This will allow the routine to attempt to retrieve the cleaned_data via the part_no if it is not found via the nsn.

      Rev 1.4   May 06 2005 08:15:38   c970183
   changed dla_warehouse_stock and dla_warehouse_stock_cleaned to current_backorder and current_backorder_cleaned.  added pvcs keywords
   	  */

/*
 *	These routines will make it easy to retrieve cleaned data from BSSM
 *	Douglas S. Elder and Chung D. Lu  10/03/01  Initial implementation
 */
   	-- ks - base specific clean fields, not in pkg body yet
	function RemovalInd(pNsn in varchar2, pLocSid in number ) return varchar2;
	function RepairLevelCode(pNsn in varchar2, pLocSid in number) return varchar2;
	--
	function GetCondemnAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.condemn_avg_cleaned%type ;
	function GetNrtsAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.nrts_avg_cleaned%type ;
	function GetCriticality(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.criticality_cleaned%type ;
	function GetMtbdr(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.mtbdr_cleaned%type ;
	function GetRtsAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.rts_avg_cleaned%type ;
	function GetOrderLeadTime(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.order_lead_time_cleaned%type ;
	function GetPlannerCode(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.planner_code_cleaned%type ;
	function GetSmrCode(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.smr_code_cleaned%type ;
	function GetUnitCost(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.unit_cost_cleaned%type ;
	function GetCostToRepairOffBase(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.cost_to_repair_off_base_cleand%type ;
	function GetTimeToRepairOffBase(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.time_to_repair_off_base_cleand%type ;

	function GetAddIncrement(pNsn in varchar2) return amd_national_stock_items.add_increment_cleaned%type ;
	function GetAmcBaseStock(pNsn in varchar2) return amd_national_stock_items.amc_base_stock_cleaned%type ;
	function GetAmcDaysExperience(pNsn in varchar2) return amd_national_stock_items.amc_days_experience_cleaned%type ;
	function GetAmcDemand(pNsn in varchar2) return amd_national_stock_items.amc_demand_cleaned%type ;
	function GetCapabilityRequirement(pNsn in varchar2) return amd_national_stock_items.capability_requirement_cleaned%type ;
	function GetDlaDemand(pNsn in varchar2) return amd_national_stock_items.dla_demand_cleaned%type ;
	function GetCurrentBackorder(pNsn in varchar2) return amd_national_stock_items.current_backorder_cleaned%type ;
	function GetFedcCost(pNsn in varchar2) return amd_national_stock_items.fedc_cost_cleaned%type ;
	function GetItemType(pNsn in varchar2) return amd_national_stock_items.item_type_cleaned%type ;
	function GetMicCodeLowest(pNsn in varchar2) return amd_national_stock_items.mic_code_lowest_cleaned%type ;
	function GetNomenclature(pNsn in varchar2) return amd_national_stock_items.nomenclature_cleaned%type ;
	function GetOrderUom(pNsn in varchar2) return amd_national_stock_items.order_uom_cleaned%type ;
	function GetPrimeInd(pNsn in varchar2, pPart_no in varchar2, pMfgr in varchar2) return amd_nsi_parts.prime_ind_cleaned%type ;
	function GetRuInd(pNsn in varchar2) return amd_national_stock_items.ru_ind_cleaned%type ;
	function GetTimeToRepairOnBaseAvg(pNsn in varchar2) return amd_national_stock_items.time_to_repair_on_base_avg_cl%type ;

	-- added 6/9/2006 by dse
	procedure version ;

end amd_clean_data ;
 
/


DROP PACKAGE AMD_OWNER.AMD_DEFAULTS;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_defaults
AS
   /*

    $Author:   zf297a  $
  $Revision:   1.37 $
      $Date:   21 Sep 2015
  $Workfile:   amd_defaults.pks  $

     Rev 1.37 9/21/2015 added program_id

     Rev 1.36 2/23/2015 added start_loc_id

     Rev 1.35 2/5/2015 added non_stockage_list

     Rev 1.34 2/4/2015 added icp_ind.  source_of_supply new_nsn,, and source_code

     Rev 1.33 fixed bom & bom_quantity definitions since the tmp_a2a_bom_detail table was dropped

     Rev 1.32   09 Jul 2008 14:41:36   zf297a
  Added interfaces:
  function getCONSUMABLE_PLANNER_CODE return  amd_planners.PLANNER_CODE%type ;
  function getCONSUMABLE_LOGON_ID return
   amd_users.BEMS_ID%type ;
  function getREPAIRABLE_PLANNER_CODE return  amd_planners.PLANNER_CODE%type ;
  function getREPAIRABLE_LOGON_ID return  amd_users.BEMS_ID%type ;

     Rev 1.31   22 May 2008 16:47:58   zf297a
  Added interface for getVersion.

     Rev 1.30   22 May 2008 11:00:26   zf297a
  Changed AMD_AUS_SC, AMD_BASC_SC, AMD_CAN_SC, and AMD_UK_SC to variables that wiill either use their default literal or be initialized by data from the amd_param_changes table.  Define a varray to contain all the segment codes used to flag Foreign Military Sales.

     Rev 1.29   14 Nov 2007 12:08:04   zf297a
  Added interface for getTIME_TO_REPAIR_OFFBASE

     Rev 1.28   24 Oct 2007 17:36:16   zf297a
  Added ROP / ROQ default values and the functions to get them.

     Rev 1.27   12 Oct 2007 17:23:22   zf297a
  Added constants: AMD_BASC_LOC_ID, AMD_BASC_SC, AMD_UK_SC, AMD_CAN_LOC_ID, AMD_CAN_SC, AMD_AUS_LOC_ID, AMD_AUS_SC, AMD_WARNER_ROBINS_LOC_ID and related get functions.

     Rev 1.26   11 Oct 2007 23:33:36   zf297a
  Added TSL_CONSUMABL_CALENDAR_DAYS and function getTSL_CONSUMABL_CALENDAR_DAYS

     Rev 1.25   11 Oct 2007 12:42:40   zf297a
  Added Canada loc_id and added interface getAMD_CAN_LOC_ID

     Rev 1.24   28 Jun 2007 12:23:32   zf297a
  Added date_lvl_loaded_modifier and a get function for this number used by the load query for consumable gold.lvls.

     Rev 1.23   12 Apr 2007 09:31:16   zf297a
  defined interfaces for PSMS_COMMIT_TRESHOLD, GOLD_COMMIT_TRESHOLD, TEMP_NSNS_COMMIT_THRESHOLD, MAIN_COMMIT_THRESHOLD, and PARTSTUC_COMMIT_THRESHOLD.

     Rev 1.22   03 Apr 2007 14:32:38   zf297a
  Define interfaces:
  getNSN_LOGON_ID
  getNSL_LOGON_ID
  getNSN_PLANNER_CODE
  getNSL_PLANNER_CODE
  getCLEAN_DATA_DAY
  checkDefaultPlanners
  checkDefaultLogonIds

     Rev 1.21   22 Mar 2007 16:45:58   zf297a
  added constant AMD_AUS_LOC_ID and its get function interface

     Rev 1.20   Oct 26 2006 12:10:32   zf297a
  Added boolean flag STRICT.  This will be used to determine if an exception should be raised for certain errors that in most cases are not critical.

     Rev 1.19   Jun 09 2006 12:55:24   zf297a
  added interface version

     Rev 1.18   Nov 30 2005 10:56:18   zf297a
  added bom_quantity and bom

     Rev 1.17   Nov 01 2005 12:32:52   zf297a
  Added some more "getter" functions for other constants.

     Rev 1.16   Nov 01 2005 12:21:34   zf297a
  Simplified the name of the "getter's" to getCONSTANT where CONSTANT is the identifier for the associated constant.

     Rev 1.15   Nov 01 2005 11:50:32   zf297a
  Added "getter 's" (get functions) for some of the constant's so they can be used in ordinary SQL instead of only in PL/SQL code.

     Rev 1.14   Sep 13 2005 11:04:02   zf297a
  Added interfaces for isParamKey and addParamKey.

     Rev 1.13   Jul 08 2005 09:08:38   zf297a
  added the public function getLogonId

     Rev 1.12   Jul 08 2005 08:58:36   zf297a
  Added the public function getPlannerCode

     Rev 1.11   Jul 05 2005 13:54:12   zf297a
  added $Log$ PVCS keyword

     10/02/01 Douglas Elder Initial implementation
        Although variables that are CAPITALIZED
       are usually "constant's", these variables
       are quasi-constants, since they rarely change,
       but they are initialized from values stored
       in an Oracle table.  Some values are returned
       via functions, since they are dependent on
       the value of other variables.
 6/07/05  KS    Add more constants and defaults
    */



   TYPE fmsSegCodeTab IS VARRAY (4) OF whse.sc%TYPE; -- added 5/22/2008 by dse

   fmsSegCodes                         fmsSegCodeTab; -- added 5/22/2008 by dse

   STRICT                              BOOLEAN := FALSE; -- raise errors when true

   -- added 6/28/2007 by dse
   DATE_LVL_LOADED_MODIFIER            NUMBER := 210;

   FUNCTION getDATE_LVL_LOADED_MODIFIER
      RETURN NUMBER;

   -- added 4/12/2007 by dse
   PSMS_COMMIT_THRESHOLD               NUMBER := 1000;

   FUNCTION getPSMS_COMMIT_THRESHOLD
      RETURN NUMBER;

   -- added 4/12/2007 by dse
   MAIN_COMMIT_THRESHOLD               NUMBER := 1000;

   FUNCTION getMAIN_COMMIT_THRESHOLD
      RETURN NUMBER;

   -- added 4/12/2007 by dse
   TEMP_NSNS_COMMIT_THRESHOLD          NUMBER := 1000;

   FUNCTION getTEMP_NSNS_COMMIT_THRESHOLD
      RETURN NUMBER;

   -- added 4/12/2007 by dse
   GOLD_COMMIT_THRESHOLD               NUMBER := 1000;

   FUNCTION getGOLD_COMMIT_THRESHOLD
      RETURN NUMBER;

   -- added 4/12/2007 by dse
   PARTSTRUC_COMMIT_THRESHOLD          NUMBER := 1000;

   FUNCTION getPARTSTRUC_COMMIT_THRESHOLD
      RETURN NUMBER;

   CONDEMN_AVG                         amd_national_stock_items.condemn_avg%TYPE
                                          := NULL;
   CONSUMABLE                 CONSTANT amd_national_stock_items.item_type%TYPE
                                          := 'C' ;

   FUNCTION getCONSUMABLE
      RETURN VARCHAR2;

   DELETE_ACTION              CONSTANT amd_spare_parts.action_code%TYPE := 'D';

   FUNCTION getDELETE_ACTION
      RETURN VARCHAR2;

   DISPOSAL_COST                       amd_spare_parts.disposal_cost%TYPE := NULL;
   DISTRIB_UOM                         amd_national_stock_items.distrib_uom%TYPE
                                          := NULL;
   INSERT_ACTION              CONSTANT amd_spare_parts.action_code%TYPE := 'A';

   FUNCTION getINSERT_ACTION
      RETURN VARCHAR2;

   NOT_PRIME_PART             CONSTANT amd_nsi_parts.prime_ind%TYPE := 'N';
   NRTS_AVG                            amd_national_stock_items.nrts_avg%TYPE
                                          := NULL;

   OFF_BASE_TURN_AROUND                amd_part_locs.time_to_repair%TYPE := NULL;

   FUNCTION GetOrderLeadTime (
      pItem_type   IN amd_national_stock_items.item_type%TYPE)
      RETURN amd_spare_parts.order_lead_time_defaulted%TYPE;

   ORDER_QUANTITY                      amd_national_stock_items.order_quantity%TYPE
                                          := NULL;

   ORDER_UOM                           amd_spare_parts.order_uom%TYPE := NULL;
   PRIME_PART                 CONSTANT amd_nsi_parts.prime_ind%TYPE := 'Y';

   QPEI_WEIGHTED                       amd_national_stock_items.qpei_weighted%TYPE
                                          := NULL;
   REPAIRABLE                 CONSTANT amd_national_stock_items.item_type%TYPE
                                          := 'R' ;

   FUNCTION getREPAIRABLE
      RETURN VARCHAR2;

   RTS_AVG                             amd_national_stock_items.rts_avg%TYPE := NULL;
   SCRAP_VALUE                         amd_spare_parts.scrap_value%TYPE := NULL;
   SHELF_LIFE                          amd_spare_parts.shelf_life%TYPE := NULL;


   TIME_TO_REPAIR_ON_BASE_AVG          amd_national_stock_items.time_to_repair_on_base_avg_df%TYPE
      := NULL;

   BOM_QUANTITY                        NUMBER := 1;
   BOM                                 VARCHAR2 (8) := 'C17';

   FUNCTION GetUnitCost (
      pNsn            IN amd_spare_parts.nsn%TYPE,
      pPart_no        IN amd_spare_parts.part_no%TYPE,
      pMfgr           IN amd_spare_parts.mfgr%TYPE,
      pSmr_code       IN amd_national_stock_items.smr_code%TYPE,
      pPlanner_code   IN amd_national_stock_items.planner_code%TYPE)
      RETURN amd_spare_parts.unit_cost_defaulted%TYPE;

   FUNCTION getPlannerCode (nsn IN VARCHAR2)
      RETURN VARCHAR2;

   FUNCTION getLogonId (nsn IN VARCHAR2)
      RETURN VARCHAR2;

   UNIT_VOLUME                         amd_spare_parts.unit_volume%TYPE := NULL;
   UPDATE_ACTION              CONSTANT amd_spare_parts.action_code%TYPE := 'C';

   FUNCTION getUPDATE_ACTION
      RETURN VARCHAR2;

   USE_BSSM_TO_GET_NSLs                VARCHAR2 (1) := NULL;

   COST_TO_REPAIR_ONBASE               amd_part_locs.cost_to_repair%TYPE := NULL;
   TIME_TO_REPAIR_ONBASE               amd_part_locs.time_to_repair%TYPE := NULL;
   TIME_TO_REPAIR_OFFBASE              amd_part_locs.time_to_repair%TYPE := NULL;

   FUNCTION getTIME_TO_REPAIR_OFFBASE
      RETURN amd_part_locs.time_to_repair%TYPE;

   UNIT_COST_FACTOR_OFFBASE            NUMBER := 0;

   /* ks add 06/07/05
   -- expose GetParamValue
   -- constants
   */
   FUNCTION GetParamValue (key IN VARCHAR2)
      RETURN amd_param_changes.param_value%TYPE;

   -- added 9/3/2005 dse
   PROCEDURE setParamValue (key IN VARCHAR2, VALUE IN VARCHAR2);

   AMD_WAREHOUSE_LOCID        CONSTANT amd_spare_networks.loc_id%TYPE := 'CTLATL';

   FUNCTION getAMD_WAREHOUSE_LOCID
      RETURN VARCHAR2;

   BSSM_WAREHOUSE_SRAN        CONSTANT bssm_bases.sran%TYPE := 'W';

   FUNCTION getBSSM_WAREHOUSE_SRAN
      RETURN VARCHAR2;

   AMD_AUS_LOC_ID             CONSTANT amd_spare_networks.loc_id%TYPE := 'EY1258';

   FUNCTION getAMD_AUS_LOC_ID
      RETURN VARCHAR2;

   AMD_AUS_SC                          whse.sc%TYPE := 'C17%CODAUSG'; -- added 100/11/2007 by dse

   FUNCTION getAMD_AUS_SC
      RETURN VARCHAR2;                              -- added 10/11/2007 by dse

   AMD_CAN_LOC_ID             CONSTANT amd_spare_networks.loc_id%TYPE := 'EY1414'; -- added 10/11/2007 by dse

   FUNCTION getAMD_CAN_LOC_ID
      RETURN VARCHAR2;                              -- added 10/11/2007 by dse

   AMD_CAN_SC                          whse.sc%TYPE := 'C17%CODCANG'; -- added 10/11/2007 by dse

   FUNCTION getAMD_CAN_SC
      RETURN VARCHAR2;                              -- added 10/11/2007 by dse

   AMD_UK_LOC_ID              CONSTANT amd_spare_networks.loc_id%TYPE := 'EY8780';

   FUNCTION getAMD_UK_LOC_ID
      RETURN VARCHAR2;

   AMD_UK_SC                           whse.sc%TYPE := 'C17%CODUKBG'; -- added 10/11/2007 by dse

   FUNCTION getAMD_UK_SC
      RETURN VARCHAR2;                              -- added 10/11/2007 by dse

   AMD_BASC_LOC_ID            CONSTANT amd_spare_networks.loc_id%TYPE := 'EY1746';

   FUNCTION getAMD_BASC_LOC_ID
      RETURN VARCHAR2;

   AMD_BASC_SC                         whse.sc%TYPE := 'C17PCAG'; -- added 10/11/2007 by dse

   FUNCTION getAMD_BASC_SC
      RETURN VARCHAR2;                              -- added 10/11/2007 by dse

   AMD_VUB_LOC_ID             CONSTANT amd_spare_networks.loc_id%TYPE := 'FB4490';

   FUNCTION getAMD_VUB_LOC_ID
      RETURN VARCHAR2;

   AMD_WARNER_ROBINS_LOC_ID   CONSTANT amd_spare_networks.loc_id%TYPE
                                          := 'FB2065' ; -- added 10/11/2007 by dse

   FUNCTION getAMD_WARNER_ROBINS_LOC_ID
      RETURN VARCHAR2;                              -- added 10/11/2007 by dse

   --AMD_VCD_LOC_ID  CONSTANT amd_spare_networks.loc_id%TYPE := '?' ;

   NSN_PLANNER_CODE                    amd_planners.PLANNER_CODE%TYPE := NULL;

   FUNCTION getNSN_PLANNER_CODE
      RETURN amd_planners.PLANNER_CODE%TYPE;

   NSN_LOGON_ID                        amd_planner_logons.LOGON_ID%TYPE
                                          := NULL;

   FUNCTION getNSN_LOGON_ID
      RETURN amd_users.BEMS_ID%TYPE;

   NSL_PLANNER_CODE                    amd_planners.PLANNER_CODE%TYPE := NULL;

   FUNCTION getNSL_PLANNER_CODE
      RETURN amd_planners.PLANNER_CODE%TYPE;

   NSL_LOGON_ID                        amd_planner_logons.LOGON_ID%TYPE
                                          := NULL;

   FUNCTION getNSL_LOGON_ID
      RETURN amd_users.BEMS_ID%TYPE;

   CONSUMABLE_PLANNER_CODE             amd_planners.PLANNER_CODE%TYPE := NULL;

   FUNCTION getCONSUMABLE_PLANNER_CODE
      RETURN amd_planners.PLANNER_CODE%TYPE;

   CONSUMABLE_LOGON_ID                 amd_planner_logons.LOGON_ID%TYPE
                                          := NULL;

   FUNCTION getCONSUMABLE_LOGON_ID
      RETURN amd_users.BEMS_ID%TYPE;

   REPAIRABLE_PLANNER_CODE             amd_planners.PLANNER_CODE%TYPE := NULL;

   FUNCTION getREPAIRABLE_PLANNER_CODE
      RETURN amd_planners.PLANNER_CODE%TYPE;

   REPAIRABLE_LOGON_ID                 amd_planner_logons.LOGON_ID%TYPE
                                          := NULL;

   FUNCTION getREPAIRABLE_LOGON_ID
      RETURN amd_users.BEMS_ID%TYPE;


   CLEAN_DATA_DAY                      VARCHAR2 (10) := NULL;

   FUNCTION getCLEAN_DATA_DAY
      RETURN VARCHAR2;

   TSL_CONSUMABL_CALENDAR_DAYS         NUMBER := 210;

   FUNCTION getTSL_CONSUMABL_CALENDAR_DAYS
      RETURN NUMBER;

   FUNCTION isParamKey (key IN VARCHAR2)
      RETURN BOOLEAN;

   PROCEDURE addParamKey (key IN VARCHAR2, description IN VARCHAR2);

   -- added 6/09/2006 by dse
   PROCEDURE version;

   PROCEDURE checkDefaultPlanners;

   PROCEDURE checkDefaultLogonIds;

   ROP                                 NUMBER := -1; -- added 10/18/2007 by dse

   FUNCTION getROP
      RETURN NUMBER;

   ROQ                                 NUMBER := 1;        -- added 10/18/2007

   FUNCTION getROQ
      RETURN NUMBER;

   ICP_IND                             amd_spare_parts.icp_ind%TYPE := 'F77'; -- added 2/4/2005

   FUNCTION getIcpInd
      RETURN VARCHAR2;

   source_code                         CAT1.SOURCE_CODE%TYPE := 'F77'; -- added 2/4/2005

   FUNCTION getSourceCode
      RETURN VARCHAR2;


   source_of_supply                    VARCHAR2 (5) := 'F77'; -- added 2/4/2005

   FUNCTION getSourceOfSupply
      RETURN VARCHAR2;


   NON_STOCKAGE_LIST                   amd_spare_parts.nsn%TYPE := 'NSL'; -- added 2/5/2005

   FUNCTION getNonStockageList
      RETURN VARCHAR2;

   START_LOC_ID                        NUMBER := 8;

   FUNCTION getStartLocId
      RETURN NUMBER;

   PROGRAM_ID                          VARCHAR2 (30) := 'C17'; -- added 9/21/2015

   FUNCTION getProgramId
      RETURN VARCHAR2;

   LIKE_NEW_NSN                        VARCHAR2 (4) := 'NSL%'; -- added 5/19/2017

   FUNCTION getLikeNewNSN
      RETURN VARCHAR2;

   FUNCTION getVersion
      RETURN VARCHAR2;                               -- added 5/22/2008 by dse
END amd_defaults;
/


DROP PACKAGE AMD_OWNER.AMD_DEFAULT_EFFECTIVITY_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_default_effectivity_pkg as
    /*
       $Author:   c372701  $
     $Revision:   1.0  $
         $Date:   15 May 2002 08:18:28  $
     $Workfile:   amd_default_effectivity_pkg.pks  $
	      $Log:   \\www-amssc-01\pds\archives\SDS-AMD\Database\Packages\amd_default_effectivity_pkg.pks-arc  $
/*
/*      Rev 1.0   15 May 2002 08:18:28   c372701
/*   Initial revision.

	  SCCSID:	amd_default_effectivity_pkg.sql	1.2	Modified: 05/15/02  10:20:46
		  */
	function NewGroup return number ;
	procedure SetNsiEffects(pNsiSid number) ;

end amd_default_effectivity_pkg ;
 
/


DROP PACKAGE AMD_OWNER.AMD_DEMAND;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_demand as
/*
      $Author:   zf297a  $
    $Revision:   1.24
        $Date:   01 Feb 2018
    $Workfile:   amd_demand.sql  $
        Rev 1.24 DSE 2/1/2018 renamed LoadBascUkDemands() to loadDepotDemands - related to TFS 52919                             

       Rev 1.23 DSE 8/22/17 added loadWarnerRobinsDemands
       
       Rev 1.22 DSE 2/11/14 added get/set for doWarnings boolean flag

       Rev 1.21 DSE 2/11/14 Made CalcQuantity and CalcBadQuantity public for easy testing
       
      Rev 1.20  Renamed loadAmdDemands to loadAmdBssmSourceTmpAmdDemands

      Rev 1.19   Renamed amd_demand_a2a to load_amd_demands_table
   
      Rev 1.18   Added Procedure LoadFmsDemand per ClearQuest # LBPSS00002393 by Laurie Compton.
   
      Rev 1.17   11 Sep 2009 12:43:30   zf297a
     Added getVersion, setDebug, and getDebugYorN and added pragma for ErrorMsg 
   
      Rev 1.16   11 Sep 2009 12:39:48   zf297a
   Added interfaces getVersion, setDebug, and getDebugYorN
   
      Rev 1.15   24 Feb 2009 14:13:28   zf297a
   Removed a2a code
   
      Rev 1.14   03 Oct 2007 13:24:28   zf297a
   Changed interface getCurrentPeriod to getCalendarDate for a given period.
   Added interface getFiscalPeriod.
   
      Rev 1.13   20 Aug 2007 09:29:30   zf297a
   Merged branch 1.11.1.1 changes + added interface for procedure loadAllA2A
   
      Rev 1.11.1.1   01 Aug 2007 13:32:28   zf297a
   added duplicate to the doDmndFrcstConsumablesDiff.  Added interfaces for getCurrentPeriod and genDuplicateForConsumables.
   
      Rev 1.12   23 May 2007 00:11:54   zf297a
   Added interface for doDmndFrcstConsumablesDiff and added exception badActionCode.
   
      Rev 1.11   Jun 09 2006 12:51:12   zf297a
   added interface version

      Rev 1.10   Jul 27 2005 11:56:20   zf297a
   Modified by Dean Hoang for a2a transactions
*/

	--
	-- SCCSID: amd_demand.sql  1.9  Modified: 11/23/04 09:05:30
	--
	-- -------------------------------------------------------------------
	-- This program loads demand data into amd_af_reqs table.
	--
	-- Prior to execution of this procedure, we assume that the lcf data
	-- have been successfully loaded into tmp_lcf_raw table.
	--
	-- The temporary table amd_l67_tmp and tmp_lcf_icp should be truncated
	-- prior to the execution of the procedure.
	-- -------------------------------------------------------------------
	--
	-- Date     By     History
	-- 10/12/01 FF     Initial implementation
	-- 10/25/01 FF     Removed DedupL67() and moved into InsertL67TmpLcfIcp()
	-- 10/28/01 FF     Added LoadBascUkDemands().
	-- 11/21/01 FF     Removed use of mfgr, manuf_cage as part of key when
	--                 accessing data from amd_spare_parts
	-- 11/26/01 FF     Changed action_code to use defaults package.
	-- 12/13/01 FF     Added logic in Insertl67TmpLcfIcp() to handle 15-char
	--                 nsn's. MMC is added to NSN if numeric.
	-- 08/06/01 FF     Removed use of CalcReqDate(). Using trans_date instead.
	-- 10/23/02 FF     Added translation of loc_type='TMP' srans to its MOB val.
	-- 11/04/04 TP	   Added EY1213 to Request Id field.
	--

	badActionCode             EXCEPTION ;

	procedure loadAmdBssmSourceTmpAmdDemands;
    procedure LoadFmsDemands;
	procedure LoadDepotDemands;
    procedure loadSanAntonioDemands;    
    procedure loadWarnerRobinsDemands;
    procedure unloadWarnerRobinsDemands;

	procedure load_amd_demands_table;
	procedure prime_part_change (old_part_no amd_national_stock_items.prime_part_no%TYPE,
                                new_part_no amd_national_stock_items.prime_part_no%TYPE);

    -- added by dse 5/22/2007
	FUNCTION doDmndFrcstConsumablesDiff(
			 nsn	IN VARCHAR2,
			 sran       IN VARCHAR2,
			 period		     IN NUMBER,
			 demand_forecast IN NUMBER,
             duplicate in NUMBER,
			 action_code IN VARCHAR2) RETURN NUMBER ;
							
	-- added 6/9/2006 by dse
	procedure version ;
    -- added 7/31/2007 by dse
    
    procedure genDuplicateForConsumables ;
    function getCalendarDate(period in number) return date ;
    function getFiscalPeriod(aDate in date) return number ;

	function getVersion return varchar2 ;
    function getDebugYorN return varchar2 ;
	procedure setDebug(switch in varchar2) ;
    
    function getDoWarningsYorN return varchar2 ;
    procedure setDoWarnings(switch varchar2) ;


    FUNCTION CalcQuantity(
                            pDocNo VARCHAR2,
                            pNsn varchar2,
                            pDic VARCHAR2) RETURN NUMBER;
                            
    FUNCTION CalcBadQuantity(
                            pDocNo VARCHAR2,
                            pNsn varchar2,
                            pDic VARCHAR2) RETURN NUMBER;


end amd_demand;
/


DROP PACKAGE AMD_OWNER.AMD_EFFECTIVITY_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_effectivity_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
	    $Date:   Nov 30 2005 12:24:06  $
    $Workfile:   amd_effectivity_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_effectivity_pkg.pks-arc  $
/*
/*      Rev 1.1   Nov 30 2005 12:24:06   zf297a
/*   added PVCS keywords
*/
	--
	-- SCCSID: amd_effectivity_pkg.sql  1.15  Modified: 09/04/02 14:55:03
	--
	-- Date      By            History
	-- --------  ------------  -------------------------------------------
	-- 05/16/02  Fernando F.   Initial Implementation
	-- 06/18/02  Fernando F.   Added derived colunn to cur_loc_distribs.
	-- 06/20/02  Fernando F.   Fixed updating of by-fleet.
	-- 06/25/02  Fernando F.   Added generation of default cur_loc_dis recs.
	-- 07/01/02  Fernando F.   Fixed update so acld.user_defined isn't updated.
	-- 07/10/02  Fernando F.   Added updateAssetMgmtStatus().
	-- 07/25/02  Fernando F.   Added genDistribution() functions.
	-- 07/26/02  Fernando F.   Fixed rebuildChild() to qualify queries with
	--                         tail_no liked to a_l_f_s_m table.
	-- 08/01/02  Fernando F.   Fixed genFlyingByShip to qualify tails against
	--                         a_l_f_s_m.
	-- 08/05/02  Fernando F.   Moved genFlyingAltus() to the spec.
	-- 08/06/02  Fernando F.   Fixed genCapableByShip() to add as capable
	--                         correctly for 'limited' interchangeability.
	-- 08/06/02  Fernando F.   Added batchProcess() to run everything.
	-- 08/14/02  Fernando F.   Moved genFlyingAltus() to the body and
	--                         fixed genAsCapable().
	-- 08/15/02  Fernando F.   Fixed genAsCapable() to handle Altus differently.
	--                         Added update of fsl's asCapable.
	-- 08/19/02  Fernando F.   Fixed genAsCapable() by adding FOREVER constant
	--                         to the nvl statement.
	-- 08/29/02  Fernando F.   Fixed rebuildchild() to update ansi table
	--                         with effect_by='F' when updating for fleet.
	--                         Also to update effect_by of child.
	-- 09/04/02  Fernando F.   Fixed rebuildChild() to update effect_by_attrb
	--                         and added isOrphan() and updateOrphanStatus().
	-- 09/04/02  Fernando F.   Trim the userid to 8 characters.
	--

	procedure rebuildChild(
							pChildSid number,
							pType varchar2 default 'S');
	procedure rebuildChildren(
							pParentSid number);
	--
	-- pType is 'F'lying or 'C'apable or 'A'ltus AsFlying.
	--
	procedure genDistribution(
							pType varchar2);
	procedure genDistribution(
							pNsn varchar2,
							pType varchar2);
	procedure genDistribution(
							pNsiSid number,
							pType varchar2);
	procedure buildTimePeriods(
							pCount number);
	procedure updateAssetMgmtStatus(
							pGroupSid number);
	procedure batchProcess;
end;
 
/


DROP PACKAGE AMD_OWNER.AMD_EFFECTIVITY_TCTO_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_effectivity_tcto_pkg
as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
	    $Date:   Nov 30 2005 12:24:06  $
    $Workfile:   amd_effectivity_tcto_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_effectivity_tcto_pkg.pks-arc  $
/*
/*      Rev 1.1   Nov 30 2005 12:24:06   zf297a
/*   added PVCS keywords
*/
  --
	-- SCCSID: amd_effectivity_tcto_pkg.sql  1.3  Modified: 08/28/02 16:08:38
	--
	-- Date      By            History
	-- --------  ------------  -------------------------------------------
	-- 05/31/02  kcs		   Initial Implementation
    -- 08/19/02	 kcs		   move function getNsiLocDistribs here for performance

  TYPE ref_cursor IS REF CURSOR;
  procedure updateAnsiAudit(pNsiSid amd_national_stock_items.nsi_sid%type);
  procedure updateAsFlyAsCapable(pTcto amd_retrofit_schedules.tcto_number%type, pTailNo amd_retrofit_schedules.tail_no%type, pDate date);
  procedure updateAsFlyAsCapable(pFieldName varchar2, pFieldValue varchar2, pTailNo amd_aircrafts.tail_no%type, pDate date);
  function getAcAssignLocSid(pTailNo amd_ac_assigns.tail_no%type, pDate date) return amd_spare_networks.loc_sid%type;
  function getNsiLocDistribs(pNsiSid integer) return ref_cursor;
  pragma restrict_references(getAcAssignLocsid, WNDS);
end amd_effectivity_tcto_pkg;
 
/


DROP PACKAGE AMD_OWNER.AMD_FROM_BSSM_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_FROM_BSSM_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.7  $
	    $Date:   Jun 09 2006 10:46:00  $
    $Workfile:   amd_from_bssm_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_from_bssm_pkg.pks-arc  $

      Rev 1.7   Jun 09 2006 10:46:00   zf297a
   Added interface for version

      Rev 1.6   Nov 30 2005 12:26:02   zf297a
   added pvcs keywords
*/

   	   -------------------------------------------------------------------
	   --  Date	  		  By			History
	   --  ----			  --			-------
	   --  10/10/01		  ks			initial implementation
	   --  04/02/02		  ks			mic_code_lowest will not come from bssm anymore
	   -------------------------------------------------------------------


 	   	 -- those values where bssm is currently the only source
	   procedure LoadAmdPartFromBssmRaw;
	   procedure LoadAmdBaseFromBssmRaw;
	   procedure LoadAmdPartFromBssmRaw(pNsn bssm_parts.nsn%type);
   	   procedure LoadAmdBaseFromBssmRaw(pNsn bssm_base_parts.nsn%type,pSran bssm_base_parts.sran%type);
	   procedure LoadAmdPartLocTimePeriods;
	   procedure UpdateAmdNsi(pBssmPartsRec bssm_parts%rowtype);
	   procedure UpdateAmdPartLocs (pBssmBaseRec bssm_base_parts%rowtype);
	   function GetCurrentBssmNsn(pNsn bssm_parts.nsn%type) return bssm_parts.nsn%type;
       function ConvertCriticality(pCriticality bssm_parts.criticality%type) return varchar2;
	   function ConvertItemType(pItemType bssm_parts.item_type%type) return amd_national_stock_items.item_type%type;
	   function GetLocSid(pLocId amd_spare_networks.loc_id%type) return amd_spare_networks.loc_sid%type;
	   procedure version ;
	   AMD_WAREHOUSE_LOCID constant varchar2(30) := 'CTLATL';
	   BSSM_WAREHOUSE_SRAN constant varchar2(1) := 'W';
END AMD_FROM_BSSM_PKG;
 
/


DROP PACKAGE AMD_OWNER.AMD_INVENTORY;

CREATE OR REPLACE PACKAGE AMD_OWNER.Amd_Inventory AS
    --
    -- SCCSID: %M%  %I%  Modified: %G% %U%
    --
    -- Date     By     History
    -- -------- -----  ---------------------------------------------------
    -- 10/14/01 FF     Initial implementation
    -- 11/01/01 FF     Changed LoadGoldInventory() to accept parameter as
    --                 char to match item.prime char datatype.
    -- 11/07/01 FF     Implemented WWA mod. Removed GetLocSid().
    -- 11/21/01 FF     Removed references to gold_mfgr_cage.
    -- 11/26/01 FF     Changed action_code to use defaults package.
    -- 01/04/02 FF     Removed "tactical" check from select criteria.
    -- 01/23/02 FF     Added "distinct" keyword to partCur cursor.
    -- 02/20/02 FF     Modified load to be by part not roll up to prime.
    -- 03/05/02 FF     Fixed conditions for insert and rtrim()ed the join
    --                 to the ord1 table.
    -- 09/25/02 FF     Qualified all amd_spare_parts refereneces with
    --                 action_code != 'D'
    -- 10/23/02 FF     Added translation of loc_type='TMP' srans to its MOB val.
    -- 11/18/02 FF     Added exception handler to rampCur.
    -- 06/13/03 TP     Changed order_no prefixes from ord1 table.
    -- 04/05/04 TP       Removed 'TC' as a valid order prefix for including a
    --                 cap order in inventory.
    -- 05/13/04 TP       Changed LoadGoldInventory() in On Hand and in Repair .
    -- 06/16/04 TP       Added conditions in the OnHand and Repair types.
    --
    -- 07/26/04 TL    Added constant numbers for debugging purposes.
   --                Added implementations for insertRow, updateRow, and deleteRow on amd_on_order table
    /*
        PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.36  $
         $Date:   16 Feb 2009 17:39:14  $
     $Workfile:   amd_inventory.pks  $
          $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_inventory.pks-arc  $

      Rev 1.36   16 Feb 2009 17:39:14   zf297a
   Define function interface isInvalidDateYorN

      Rev 1.35   16 Jan 2009 22:52:36   zf297a
   Define interfaces for setDateThreshold and getDateThreshold.  dateThreshold will be used to validate dates going into amd_in_repair.  The default for dateThreshold is 1/1/1980l

      Rev 1.34   06 Feb 2008 21:24:46   zf297a
   Added interfaces for function getVersion and procedure setDebug.

      Rev 1.33   06 Feb 2008 20:27:32   zf297a
   Added loc_sid to getCurrentLine function since that is part of the primary key for amd_on_order

      Rev 1.32   29 Oct 2007 12:03:28   zf297a
   Fixed doRspSumDiff interface - moved override_type from the last argument to become the 3rd argument.

      Rev 1.31   19 Oct 2007 12:02:08   zf297a
   Added argument override_type to the function doRspSumDiff

      Rev 1.30   06 Apr 2007 20:47:52   zf297a
   Fixed getCurLine interface

      Rev 1.29   06 Apr 2007 09:11:52   zf297a
   Added interfaces getNextLIne and getCurrentLine.  These functions are for the unique index "line" for the amd_on_order table.

      Rev 1.28   Jun 09 2006 11:39:14   zf297a
   added interface version

      Rev 1.27   Apr 28 2006 12:37:32   c402417
   Added amd_rsp diff function.

      Rev 1.26   Dec 06 2005 12:28:20   zf297a
   Changed deleteRow interface for amd_on_order - passed in additional parameters: part_no, loc_sid, and order_date (gold_order_number was the only parameter previously).

      Rev 1.25   Nov 03 2005 09:35:54   c402417
   Have Procedure UpdateSpoTotalInventory execute after all the Procedure load amd tables .

      Rev 1.24   Oct 13 2005 11:04:52   c402417
   Added fucntion doRepairInvsSumDiff.

      Rev 1.23   Sep 13 2005 12:43:04   zf297a
   added interface for the isVoucher boolean function

      Rev 1.22   Sep 12 2005 11:36:18   zf297a
   added interfaces for one get and one set procedure for all the on order date parameters for a given voucher.

      Rev 1.21   Sep 09 2005 10:56:34   zf297a
   For amd_on_hand_inv_sums changed the site_location column to be the spo_location column.  The spo_location comes from amd_spare_networks.spo_location.

      Rev 1.20   Sep 07 2005 21:00:00   zf297a
   added sched_receipt_date_exception when the from date is 42; than the to date.

      Rev 1.19   Sep 02 2005 15:49:34   zf297a
   Added interfaces for getOrderCreateDate, setOrderCreateDate, getScdeduledReceiptDateFrom, getScdeduledReceiptDateTo, setScheduledReceiptDate, and setScheduledReceiptDateCalDays

      Rev 1.18   Aug 26 2005 12:15:38   zf297a
   Added interfaces for doOnHandInvsSumDiff, loadOnHandInvs, and loadInRepair.

      Rev 1.17   Aug 04 2005 08:04:46   zf297a
   Made insertRow and updateRow for amd_on_order unique for the jdbc interface.

      Rev 1.15   Jul 11 2005 09:30:34   zf297a
   made the loading of tmp_amd_in_transits a separate procedure

      Rev 1.14   Jul 11 2005 09:17:40   zf297a
   made the loading of tmp_amd_on_order a separate procedure

      Rev 1.13   Jul 06 2005 09:30:44   zf297a
   Changed deleteRow for in_repair to have a unique name.

      Rev 1.12   20 Sep 2004 10:17:40   c970183
   Fixed site_location for insertRow of in_transits - it must be varchar(20)

      Rev 1.11   06 Aug 2004 14:09:56   c970183
   removed repair_type

      Rev 1.8   Aug 02 2004 08:08:36   c970183
   Removed inv_date from insertRow, updateRow, and deleteRow for amd_on_hand_invs since diff is done on the summarized qty.  Also, changed parameter names so they would not conflict with the column names.

      Rev 1.7   Jul 30 2004 12:04:56   c970183
   added pvcs comments with keywords
     */

     -- added 9/7/2005
    sched_receipt_date_exception EXCEPTION ;

    SUCCESS                   CONSTANT NUMBER :=  0;
    FAILURE                   CONSTANT NUMBER :=  4;
    badActionCode             EXCEPTION ;


    PROCEDURE LoadGoldInventory;

    PROCEDURE loadOnOrder ;

    PROCEDURE loadInTransits ;

    PROCEDURE loadRsp ;


    /* amd_on_order diff functions */
    FUNCTION InsertOnOrderRow(
                            PART_NO             IN VARCHAR2,
                              LOC_SID             IN NUMBER,
                              --LINE                IN NUMBER,
                            ORDER_DATE            IN DATE,
                              ORDER_QTY           IN NUMBER,
                              GOLD_ORDER_NUMBER   IN VARCHAR2,
                            SCHED_RECEIPT_DATE IN  DATE) RETURN NUMBER ;

    FUNCTION UpdateOnOrderRow(
                            PART_NO             IN VARCHAR2,
                              LOC_SID             IN NUMBER,
                              --LINE                IN NUMBER,
                            ORDER_DATE          IN DATE,
                              ORDER_QTY           IN NUMBER,
                              GOLD_ORDER_NUMBER   IN VARCHAR2,
                            SCHED_RECEIPT_DATE IN  DATE) RETURN NUMBER ;

    FUNCTION deleterow(part_no IN VARCHAR2,
             loc_sid IN NUMBER,
             --line in number,
             gold_order_number IN VARCHAR2,
             order_date IN DATE) RETURN NUMBER ;

    /* amd_on_hand_invs diff functions */
    FUNCTION doOnHandInvsSumDiff(
             part_no IN VARCHAR2,
             spo_location VARCHAR2,
             qty_on_hand IN NUMBER,
             action_code IN VARCHAR2) RETURN NUMBER ;

    FUNCTION InsertRow(
                                 part_no         IN VARCHAR2,
                               loc_sid         IN NUMBER,
                               inv_qty         IN NUMBER) RETURN NUMBER ;
    FUNCTION UpdateRow(
                                 part_no         IN VARCHAR2,
                               loc_sid         IN NUMBER,
                               inv_qty         IN NUMBER) RETURN NUMBER ;
    FUNCTION DeleteRow(
                                 part_no         IN VARCHAR2,
                               loc_sid         IN NUMBER) RETURN NUMBER;


    /* amd_rsp diff functions */
    FUNCTION doRspSumDiff(
             part_no     IN VARCHAR2,
             rsp_location  VARCHAR2,
             override_type in varchar2, /* added 10/29/2007 by dse */
             qty_on_hand        IN NUMBER,
             rsp_level               IN NUMBER,
             action_code IN VARCHAR2) RETURN NUMBER;

    FUNCTION RspInsertRow(
                        PART_NO IN VARCHAR2,
                       LOC_SID IN NUMBER,
                       RSP_INV IN NUMBER,
                       RSP_LEVEL IN NUMBER) RETURN NUMBER;

    FUNCTION RspUpdateRow(
                        PART_NO IN VARCHAR2,
                       LOC_SID IN NUMBER,
                       RSP_INV IN NUMBER,
                       RSP_LEVEL IN NUMBER) RETURN NUMBER;

    FUNCTION RspDeleteRow(
                           PART_NO    IN VARCHAR2,
                          LOC_SID  IN NUMBER)RETURN NUMBER;


    /* amd_in_repair diff functions */
    FUNCTION doRepairInvsSumDiff(
             part_no IN VARCHAR2,
             site_location IN VARCHAR2,
             qty_on_hand IN NUMBER,
             action_code IN VARCHAR2) RETURN NUMBER ;

    FUNCTION InsertRow(
                        PART_NO         IN VARCHAR2,
                         LOC_SID         IN NUMBER,
                         REPAIR_DATE     IN DATE,
                         REPAIR_QTY      IN NUMBER,
                         ORDER_NO       IN VARCHAR2,
                       REPAIR_NEED_DATE     IN DATE) RETURN NUMBER ;
    FUNCTION UpdateRow(
                        PART_NO         IN VARCHAR2,
                         LOC_SID         IN NUMBER,
                         REPAIR_DATE     IN DATE,
                         REPAIR_QTY      IN NUMBER,
                         ORDER_NO       IN VARCHAR2,
                       REPAIR_NEED_DATE IN DATE) RETURN NUMBER ;
    FUNCTION inRepairDeleteRow(
                        PART_NO         IN VARCHAR2,
                         LOC_SID         IN NUMBER,
                         ORDER_NO           IN VARCHAR2) RETURN NUMBER ;


    /* amd_in_transits diff functions */
    FUNCTION InsertRow(
                        TO_LOC_SID              IN NUMBER,
                       QUANTITY                IN NUMBER,
                       DOCUMENT_ID            IN VARCHAR2,
                       PART_NO                IN VARCHAR2,
                       FROM_LOCATION        IN VARCHAR2,
                       IN_TRANSIT_DATE        IN DATE,
                       SERVICEABLE_FLAG        IN VARCHAR2) RETURN NUMBER ;
    FUNCTION UpdateRow(
                        TO_LOC_SID            IN NUMBER,
                       QUANTITY                IN NUMBER,
                       DOCUMENT_ID            IN VARCHAR2,
                       PART_NO                IN VARCHAR2,
                       FROM_LOCATION        IN VARCHAR2,
                       IN_TRANSIT_DATE        IN DATE,
                       SERVICEABLE_FLAG        IN VARCHAR2) RETURN NUMBER ;
    FUNCTION DeleteRow(
                        DOCUMENT_ID            IN VARCHAR2,
                       PART_NO                IN VARCHAR2,
                       TO_LOC_SID            IN NUMBER) RETURN NUMBER ;


    /* amd_in_transits_sum diff function */
    FUNCTION InsertRow(
                        PART_NO                   IN VARCHAR2,
                       SITE_LOCATION            IN VARCHAR2,
                       QUANTITY                IN NUMBER,
                       SERVICEABLE_FLAG        IN VARCHAR2) RETURN NUMBER ;

    FUNCTION UpdateRow(
                        PART_NO                IN VARCHAR2,
                       SITE_LOCATION            IN VARCHAR2,
                       QUANTITY                IN NUMBER,
                       SERVICEABLE_FLAG        IN VARCHAR2) RETURN NUMBER ;

    FUNCTION DeleteRow(
                        PART_NO                IN VARCHAR2,
                       SITE_LOCATION            IN VARCHAR2,
                       SERVICEABLE_FLAG        IN VARCHAR2) RETURN NUMBER ;


    PROCEDURE loadOnHandInvs ;

    PROCEDURE loadInRepair ;

    PROCEDURE updateSpoTotalInventory;

    -- added 9/2/2005 by dse
    FUNCTION getOrderCreateDate(voucher IN VARCHAR2) RETURN DATE ;
    PROCEDURE setOrderCreateDate(voucher IN VARCHAR2, orderCreateDate IN DATE) ;
    FUNCTION getScdeduledReceiptDateFrom(voucher IN VARCHAR2) RETURN DATE ;
    FUNCTION getScdeduledReceiptDateTo(voucher IN VARCHAR2) RETURN DATE ;
    PROCEDURE setScheduledReceiptDate(voucher IN VARCHAR2, fromDate IN DATE, toDate DATE) ;
    PROCEDURE setScheduledReceiptDateCalDays(voucher IN VARCHAR2, days IN NUMBER) ;
    -- added 9/8/2005 by dse
    FUNCTION getScheduledReceiptDateCalDays(voucher IN VARCHAR2) RETURN NUMBER ;

    -- added 9/10/2005 by dse
    PROCEDURE getOnOrderParams(voucher IN VARCHAR2,
              orderCreateDate           OUT DATE,
              schedReceiptDateFrom       OUT DATE,
              schedReceiptDateTo       OUT DATE,
              schedReceiptCalDays       OUT NUMBER) ;
    PROCEDURE setOnOrderParams(voucher IN VARCHAR2,
              orderCreateDate            IN DATE,
              schedReceiptDateFrom        IN DATE,
              schedReceiptDateTo        IN DATE,
              schedReceiptCalDays        IN NUMBER) ;
    FUNCTION isVoucher(voucher IN VARCHAR2) RETURN BOOLEAN ;
    PROCEDURE clearOnOrderParams ;
    FUNCTION numberOfOnOrderParams RETURN NUMBER ;
    TYPE ref_cursor IS REF CURSOR ;
    FUNCTION getVouchers RETURN ref_cursor ;
    -- added 6/9/2006 by dse
    procedure version ;
    -- added 4/6/2007 by dse
    function getNextLine(gold_order_number in amd_on_order.gold_order_number%type) return number ;
    function getCurrentLine(gold_order_number in amd_on_order.gold_order_number%type, order_date in amd_on_order.order_date%type, loc_sid in amd_on_order.loc_sid%type) return number ;

    -- added 2/6/2008 by dse
    function getVersion return varchar2 ;
    procedure setDebug(switch in varchar2) ;

    procedure setDateThreshold(date_in in varchar2,date_format in varchar2 := 'MM/DD/YYYY') ;
    function getDateThreshold return date ;

    function isInvalidDateYorN(date_in in date) return varchar2 ; -- added 2/16/09


END Amd_Inventory;
/


DROP PACKAGE AMD_OWNER.AMD_LOAD;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_load as
    /*
        PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.28 $
         $Date:   17 Feb 2015
     $Workfile:   amd_load.pks  $

      Rev 1.28  17 Feb 2015 DSE removed bssm_owner qualifier
      
      Rev 1.27  19 Feb 2012 Added setPsmsThreshold zf297a
      
      Rev 1.26   03 Aug 2011 11:45:18   zf297a
   Add interfaces setUseBizDays, getUseBizDays.  and added additional set functions that could be used in SQL queries to set the various values
   
      Rev 1.25   25 Nov 2008 22:29:18   zf297a
   Add interfaces setStartDebugRec and getStartDebugRec.  startDebugRec starts the loadGold procedure to dump the current index and part to the amd_load_details table.  This is to be used for debugging purposes only.
   
      Rev 1.24   07 Jul 2008 09:15:38   zf297a
   Added interface for setDebugThreshold and getDebugThreshold
   
      Rev 1.23   30 Jun 2008 15:23:08   zf297a
   Added interfaces for setDebug and getDebug
   
      Rev 1.22   23 May 2008 13:10:02   zf297a
   Added interface for function getVersion.
   
      Rev 1.21   Aug 09 2007 10:47:44   c402417
   Added procedure LoadWecm.
   
      Rev 1.20   10 Apr 2007 09:04:12   zf297a
   Made partNo varchar2 for getOffBaseTurnaround and getOffBaseRepairCost
   
      Rev 1.19   02 Apr 2007 10:53:36   zf297a
   Removed mtbdr_computed from the getOriginalBssmData interface.  Added constants: CLEANED_DATA, ORIGINAL_DATA, and CURRENT_NSN and get functions for each of the constants.
   
   Changed procedure getCalculatedData to a function taking nsn and part_no as arguments and returning mtbdr_computed.
   
   Added function getOrderLeadTime which takes a trimmed cat1 part number as an arguments and returns the order lead time from cat1.
   
      Rev 1.18   14 Feb 2007 13:47:18   zf297a
   Added amc_demand to the interface for getOriginalBssmData, added amc_demand_cleaned to the interface for getCleanedBssmData, and added new interface for getCalculatedData which will handle mtbdr_computed which is not a cleaned field, but it does appear on lock_sid 2.
   
      Rev 1.17   Jan 17 2007 16:23:08   c402417
   Added Procedure LoadRblPairs right after  Procedure LoadGold .
   
      Rev 1.16   Oct 31 2006 14:45:08   zf297a
   added interface validatePartStructure
   
      Rev 1.15   Jun 09 2006 11:44:42   zf297a
   added interface version

      Rev 1.14   Mar 20 2006 08:57:00   zf297a
   Added  "Future use" comments

      Rev 1.13   Mar 16 2006 15:07:46   zf297a
   Added exception no_active_job

      Rev 1.12   Mar 16 2006 10:36:08   zf297a
   Exposed functions and procedures to allow for easy unit testing.

      Rev 1.11   Mar 05 2006 21:19:14   zf297a
   Added interfaces for loadGoldPsmsMain, preProcess, postProcess, postDiffProcess, prepAmdDatabase, disableAmdConstraints, truncateAmdTables, and enableAmdConstraints to simplify the amd_loader.ksh script.

      Rev 1.10   Aug 16 2005 14:12:30   zf297a
   removed loadCurrentBackorder

      Rev 1.9   Aug 04 2005 13:34:44   zf297a
   Added interfaces for Users diff.

      Rev 1.8   Aug 04 2005 07:06:14   zf297a
   Made functions     GetOffBaseRepairCost and GetOffBaseTurnAround public.

      Rev 1.7   Jul 26 2005 12:31:44   zf297a
   added function getBemsId.  This function will return a bems_id for an employee_no as defined in amd_use1.  The function will remove any semi colon or trailing alpha character.  If the the employee_no is the 'clock number' it will retrieve the bems_id via the emp_id of the amd_people_all_v.

      Rev 1.6   Jul 19 2005 14:22:50   zf297a
   added procedure loadUsers - populates the amd_users table and sends inserts, updates, and deletes via the a2a_pgk.spoUser procedure.

      Rev 1.5   Jun 09 2005 14:58:58   c970183
   Added insert, update, and delete routines for the amd_planners diff and the amd_planner_logons diff.

      Rev 1.4   May 17 2005 10:20:14   c970183
   Added PVCS keywords
*/
    --
    -- SCCSID: amd_load.sql  1.21  Modified: 10/25/04 10:35:34
    --
    -- Date     By     History
    -- -------- -----  ---------------------------------------------------
    -- 09/28/01 FF     Initial implementation
    -- 10/22/01 FF     Removed references to venc, venn from LoadGold().
    -- 10/23/01 FF     Changed exception in LoadTempNsns() and passed GOLD
    --                 smr_code if nothing else.
    -- 10/30/01 FF     Fixed getPrime() to look at all records for a '17P','17B'
    --                 match.
    -- 11/02/01 FF     Fixed logic in LoadTempNsns() to include GetPrime() and
    --                 associate logic.
    -- 11/12/01 FF     Fixed LoadGold() to use the part as prime for ANY NSL
    --                 that gets an nsn from BSSM other than of the form NSL#.
    -- 11/15/01 FF     Mod LoadGold() and LoadMain() to let equiv parts get
    --                 values from prime for item_type,order_quantity,
    --                 planner_code and smr_code.
    -- 11/19/01 FF     Mod LoadTempNsns to ignore the last 2 char's of the nsn
    --                 if they are not numeric.
    -- 11/21/01 FF     Removed references to gold_mfgr_cage.
    -- 11/29/01 FF     Fixed LoadTempNsns() and added lock_sid=0 condition
    --                 to cursor in LoadTempNsns().
    -- 12/10/01 FF     Fixed cursor in LoadTempNsns() to link with
    --                 amd_spare_parts.
    -- 12/21/01 FF     Added acquisition_advice_code.
    -- 01/28/02 FF     Added "FROM" column as temp nsns to LoadTempNsns().
    -- 02/19/02 FF     Added logic for manuf_cage to GetPrime().
    -- 02/25/02 FF     Fixed GetPrime() priority logic.
    -- 03/05/02 FF     Added logic to unit_cost code to look at po's with 9
    --                 characters only.
    -- 03/18/02 FF     The noun field is no longer truncated.
    -- 04/03/02 FF     Populated mic in tmp_amd_spare_parts.
    -- 06/04/02 FF     Removed debug record limiter.
    -- 06/14/02 FF     Changed references to PSMS to use synonyms.
    -- 07/05/02 FF     Changed references to PSMV to use synonyms.
    -- 10/14/02 FF     Mod'ed loadGold() to blindly assign the part as a prime
    --                 only if sequenceTheNsl() returned an nsn of type NSL.
    -- 11/05/02 FF     Get unit_cost from gold.prc1 instead of tmp_main. This
    --                 is now done in loadGold() instead of loadMain().
    -- 02/21/03 FF     Added performLogicalDelete() to allow NSL's to get
    --                 their own sid.
    -- 09/22/04 TP       Changed how we pull SMR Code from PSMS to GOLD .
    --

    -- expose the following functions and procedures to allow for easy routine validation and unit testing
    no_active_job exception ;
    

    FUNCTION  IsValidSmr(pSmrCode VARCHAR2) RETURN BOOLEAN;
    FUNCTION  GetSmr(pPart VARCHAR2, pCage VARCHAR2) RETURN VARCHAR2;
    FUNCTION  GetPrime(pNsn CHAR) RETURN VARCHAR2;
    FUNCTION  getMic(pNsn VARCHAR2) RETURN VARCHAR2;
    FUNCTION  getUnitCost(pPartNo VARCHAR2) RETURN NUMBER;
    FUNCTION  GetItemType(pSmrCode VARCHAR2) RETURN VARCHAR2;
    FUNCTION  getMmac(pNsn VARCHAR2) RETURN VARCHAR2;
    FUNCTION  onNsl(pPartNo VARCHAR2) RETURN BOOLEAN;

     procedure getOriginalBssmData(nsn in amd_nsns.nsn%type,
         part_no in bssm_parts.PART_NO%type,
         condemn_avg out amd_national_stock_items.condemn_avg%type,
         criticality out amd_national_stock_items.criticality%type,
         nrts_avg out amd_national_stock_items.nrts_avg%type,
         rts_avg out amd_national_stock_items.rts_avg%type,
         amc_demand out amd_national_stock_items.amc_demand%type) ;

    procedure getCleanedBssmData(nsn in amd_nsns.nsn%type,
        part_no                 in bssm_parts.part_no%type,
        condemn_avg_cleaned     out amd_national_stock_items.condemn_avg_cleaned%type,
        criticality_cleaned     out amd_national_stock_items.criticality_cleaned%type,
        mtbdr_cleaned             out amd_national_stock_items.mtbdr_cleaned%type,
        nrts_avg_cleaned         out amd_national_stock_items.nrts_avg_cleaned%type,
        rts_avg_cleaned         out amd_national_stock_items.rts_avg_cleaned%type,
        order_lead_time_cleaned out amd_national_stock_items.order_lead_time_cleaned%type,
        planner_code_cleaned     out amd_national_stock_items.planner_code_cleaned%type,
        smr_code_cleaned         out amd_national_stock_items.smr_code_cleaned%type,
        unit_cost_cleaned         out amd_national_stock_items.unit_cost_cleaned%type,
        cost_to_repair_off_base_cleand out amd_national_stock_items.cost_to_repair_off_base_cleand%type,
        time_to_repair_off_base_cleand out amd_national_stock_items.time_to_repair_off_base_cleand%type,
        amc_demand_cleaned out amd_national_stock_items.amc_demand_cleaned%type) ;

    PROCEDURE getRmadsData (part_no in amd_rmads_source_tmp.part_no%type, qpei_weighted out amd_rmads_source_tmp.QPEI_WEIGHTED%type,
        mtbdr out amd_rmads_source_tmp.MTBDR%type) ;

    PROCEDURE GetPsmsData(pPartNo VARCHAR2, pCage VARCHAR2,
              pSlifeDay OUT NUMBER, pUnitVol  OUT NUMBER, pSmrCode  OUT VARCHAR2);


    procedure LoadGold;
    procedure LoadRblPairs;
    procedure LoadPsms;
    procedure LoadMain;
    procedure LoadWecm;
    procedure LoadTempNsns;
    procedure loadUsers ;

    -- For future use
    -- The following procedures: loadGoldPsmsMain, preProcess, postProcess, and postDiffProcess,
    -- may be used to replace the bulky sql scripts currently used by amd_loader.ksh
    procedure loadGoldPsmsMain(startStep in number := 1, endStep in number := 3) ;
    procedure preProcess(startStep in number := 1, endStep in number := 3) ;
    procedure postProcess(startStep in number := 1, endStep in number := 18) ;
    procedure postDiffProcess(startStep in number := 1, endStep in number := 3) ;
    -- For future use
    -- The following procedures: prepAmdDatabase, disableAmdConstraints, truncateAmdTables, and
    -- enableAmdConstraints can be be used in conjunction with the above procedures
    procedure prepAmdDatabase ;
    procedure disableAmdConstraints ;
    procedure truncateAmdTables ;
    procedure enableAmdConstraints ;


    SUCCESS constant number := 0 ;
    FAILURE constant number := 4 ;

    CLEANED_DATA           constant varchar2(1) := '2' ;
    function getCLEANED_DATA return varchar2 ;        
    ORIGINAL_DATA          constant varchar2(1) := '0' ;
    function getORIGINAL_DATA return varchar2 ;
    CURRENT_NSN            constant varchar2(1) := 'C' ;
    function getCURRENT_NSN return varchar2 ;

    -- for amd_planners diff
    function insertRow(planner_code in varchar2) return number ;
    function updateRow(planner_code in varchar2) return number ;
    function deleteRow(planner_code in varchar2) return number ;

    -- for amd_planner_logons diff
    function insertplannerlogons(planner_code in varchar2, logon_id in varchar2, data_source in varchar2) return number ;
    function updatePlannerLogons(planner_code in varchar2, logon_id in varchar2, data_source in varchar2) return number ;
    function deletePlannerLogons(planner_code in varchar2, logon_id in varchar2, data_source in varchar2) return number ;

    function getBemsId(employeeNo in amd_use1.EMPLOYEE_NO%type) return amd_users.BEMS_ID%type ;

    function GetOffBaseRepairCost(pPartNo varchar2) return amd_part_locs.cost_to_repair%type ;
    function GetOffBaseTurnAround (pPartno varchar2) return amd_part_locs.time_to_repair%type ;

    type resultSetCursor is REF cursor ;
    function getNewUsers return resultSetCursor ;
    function insertUsersRow(bems_id in varchar2, stable_email in varchar2, last_name in varchar2, first_name in varchar2) return number ;
    function updateUsersRow(bems_id in varchar2, stable_email in varchar2, last_name in varchar2, first_name in varchar2) return number ;
    function deleteUsersRow(bems_id in varchar2) return number ;
    
    -- added 6/9/2006 by DSE
    procedure version ;
    
    -- added 10/30/2006 by DSE
    procedure validatePartStructure ;

    -- added 2/12/2007 by DSE
    -- send in nsn and part to get lock_sid 2
    -- send in mtbdr_computed for lock_sid = 0 
    -- send out mtbdr_computed for lock_sid = 2  (see Note below)
    --      Note: This field is calculated by BestSpares from demand and flight hours and is preferred by the user over 
    --      the RMADS MTBDR value.  It is not cleanable by the user, but can be recalculated by the user if they clean 
    --      flight hours.  BestSpares stores MTBDR_COMPUTED on Lock_SID = 2 when there is any cleaning info for the part
    --      and removes the values on Lock_SID = 0.  If there is no cleaning info for the part then MTBDR_COMPUTED is stored
    --      on Lock_SID = 0.   
    function getCalculatedData(nsn in amd_nsns.nsn%type,
         part_no in bssm_parts.PART_NO%type) return amd_national_stock_items.mtbdr_computed%type ;
          
    -- add 3/28/2007 by dse
    function getOrderLeadTime(part in cat1.part%type) return number ;
    
    function getVersion return varchar2 ;

        procedure setPsmsThreshold(value in number := null) ; -- added 2/19/2012 by dse
    
    procedure setBulkInsertThreshold(value in number) ; -- added 6/25/2008 by dse
    function setBulkInsertThreshold(value in varchar2) return varchar2 ; -- added 8/3/2011 by dse
    function getBulkInsertThreshold return number ; -- added 6/25/2008 by dse
    
    procedure setDebug(value in varchar2) ; -- added 6/30/2008 by dse
    function setDebug(value in varchar2) return varchar2 ; -- added 8/3/2011 by dse
    function getDebug return varchar2 ; -- added 6/30/2008 by dse

    procedure setUseBizDays(value in varchar2) ; -- added 8/3/2011 by dse
    function setUseBizDays(value in varchar2) return varchar2 ; -- added 8/3/2011 by dse

    function getUseBizDays return varchar2 ; -- added 8/3/2011 by dse
    
    procedure setDebugThreshold(value in number := null) ;
    
    function getDebugThreshold return number ;
    
    procedure setStartDebugRec(value in number) ; -- added 11/25/2008
    function getStartDebugRec return number ; -- added 11/25/2008

end amd_load;
/


DROP PACKAGE AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.14  $
        $Date:   26 Jul 2013
    $Workfile:   AMD_LOCATION_PART_LEADTIME_PKG.pks  $
          rev 1.14 remove an a2a table dependency
/*   
/*      Rev 1.12   24 Feb 2009 11:18:12   zf297a
/*   Removed a2a code.
/*   
/*      Rev 1.11   18 Feb 2008 14:50:04   zf297a
/*   Added interface for function getVersion
/*   
/*      Rev 1.10   07 Nov 2007 17:25:30   zf297a
/*   Added type locationPartLeadTimeTab.
/*   
/*      Rev 1.9   Oct 25 2006 09:56:32   zf297a
/*   Made the constanst anchored declarations - ie used %type attribute.
/*   
/*      Rev 1.8   Oct 25 2006 09:19:06   zf297a
/*   Added interfaces for functions to return constants:
/*   getVIRTUAL_COD_SPO_LOCATION
/*   getVIRTUAL_UAB_SPO_LOCATION
/*   getUK_LOCATION         
/*   getBASC_LOCATION
/*   getLEADTIMETYPE
/*   getBULKLIMIT 
/*   
/*   
/*      Rev 1.7   Jun 12 2006 13:22:08   zf297a
/*   added symbolic constants for UK_LOCATION and BASC_LOCATION.
/*   
/*      Rev 1.6   Jun 09 2006 11:50:52   zf297a
/*   added interface version
/*   
/*      Rev 1.5   Mar 03 2006 12:18:56   zf297a
/*   Removed IsLatestRun and GetBatchRunStart.  GetBatchRunStart is being replaced by amd_batch_pkg.getLastStartTime since it will always return the last start time of the last job that has been run even if it has already completed.  That way if data has changed since the start of the last batch job, then it should be sent in an a2a transaction.  This may cause the same data to be sent again but that is not a problem.
/*   
/*      Rev 1.4   Feb 15 2006 14:00:46   zf297a
/*   Added cur ref, record type and a common process routine so that the data gets loaded the same no matter what selection criteria is used.
/*   
/*      Rev 1.3   Jan 04 2006 10:07:38   zf297a
/*   Made loadAllA2A and loadA2AByDate conform to the a2a_pkg.initA2A procedures.
/*   
/*      Rev 1.2   Jan 03 2006 12:45:50   zf297a
/*   Added date range to procedure loadA2AByDate
/*   
/*      Rev 1.1   Dec 29 2005 16:29:58   zf297a
/*   Added loadA2AByDate procedure
/*   
/*      Rev 1.0   Nov 30 2005 12:40:00   zf297a
/*   Initial revision.
/*   
/*      Rev 1.0   Nov 30 2005 12:31:04   zf297a
/*   Initial revision.
*/    

    VIRTUAL_COD_SPO_LOCATION CONSTANT amd_spare_networks.spo_location%type := 'VIRTUAL COD' ;
    VIRTUAL_UAB_SPO_LOCATION CONSTANT amd_spare_networks.spo_location%type := 'VIRTUAL UAB' ;
    UK_LOCATION              CONSTANT amd_spare_networks.LOC_ID%type  := 'EY8780' ;
    BASC_LOCATION             CONSTANT amd_spare_networks.loc_id%type  := 'EY1746' ;
    
    LEADTIMETYPE              CONSTANT varchar2(6) := 'REPAIR' ;
    
    BULKLIMIT                            CONSTANT NUMBER := 100000 ;
    SUCCESS                            CONSTANT NUMBER := 0 ;
    FAILURE                            CONSTANT NUMBER := 4 ;
    
    
    FUNCTION IsPartRepairable(pNsiSid amd_national_stock_items.nsi_sid%TYPE ) RETURN VARCHAR2 ;
    FUNCTION IsPartRepairable(pPartNo amd_spare_parts.part_no%TYPE ) RETURN VARCHAR2 ;
    -- pragma restrict_references (IsPartRepairable, WNDS) ;
    FUNCTION GetAvgRepairCycleTime(pNsn amd_nsns.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) RETURN ramp.avg_repair_cycle_time%TYPE ;
    FUNCTION GetRampData(pNsn amd_nsns.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) RETURN ramp%ROWTYPE ;
    pragma restrict_references (GetRampData, WNDS) ;
    pragma restrict_references (GetAvgRepairCycleTime, WNDS) ;
    
    
    -- load procedure will truncate tmp_amd_location_part_leadtime prior to loading
    
    FUNCTION InsertRow(
            pPartNo                      amd_location_part_leadtime.part_no%TYPE,
            pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
            pTimeToRepair                 amd_location_part_leadtime.time_to_repair%TYPE)
            return NUMBER ;
    
    FUNCTION Updaterow(
            pPartNo                      amd_location_part_leadtime.part_no%TYPE,
            pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
            pTimeToRepair                 amd_location_part_leadtime.time_to_repair%TYPE)
            RETURN NUMBER ;
    
    
    FUNCTION DeleteRow(
            pPartNo                      amd_location_part_leadtime.part_no%TYPE,
            pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
            pTimeToRepair                 amd_location_part_leadtime.time_to_repair%TYPE)
            RETURN NUMBER ;
    
    
    
    PROCEDURE LoadTmpAmdLocPartLeadtime ;
    PROCEDURE LoadAmdLocPartLeadtime ;
    PROCEDURE LoadInitial ;

    -- added 6/9/2006 by dse
    procedure version ;

    function getVersion return varchar2 ; -- added 2/18/2008 by dse
    
    -- added get functions to return constants 10/25/2006 by dse
    function getVIRTUAL_COD_SPO_LOCATION return amd_spare_networks.spo_location%type ;
    function getVIRTUAL_UAB_SPO_LOCATION return amd_spare_networks.spo_location%type ;
    function getUK_LOCATION              return amd_spare_networks.LOC_ID%type ;
    function getBASC_LOCATION             return amd_spare_networks.LOC_ID%type ;    
    function getLEADTIMETYPE              return varchar2 ;
    function getBULKLIMIT                     return number ;

END AMD_LOCATION_PART_LEADTIME_PKG ;
 
/


DROP PACKAGE AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.Amd_Location_Part_Override_Pkg AS
 /*
      $Author:   zf297a  $
    $Revision:   1.32  $
        $Date:   13 Feb 2015
    $Workfile:   AMD_LOCATION_PART_OVERRIDE_PKG.pks  $
        Rev 1.32 commented out spo references
/*   
/*      Rev 1.31   10 Jun 2009 13:28:24   zf297a
/*   Convert tsl_override_type and override_reason to a variables that get initialized from data in amd_spo_types_v.
/*   
/*      Rev 1.30   24 Feb 2009 11:43:54   zf297a
/*   Removed A2A code
/*   
/*      Rev 1.29   19 Feb 2009 09:45:38   zf297a
/*   Defined get/set for loadFMSdata Y/N switch.
/*   
/*      Rev 1.28   14 Feb 2009 16:05:50   zf297a
/*   Changed the interface for loadWhse - endStep defaults now to 4.
/*   
/*      Rev 1.26   13 Feb 2009 13:49:14   zf297a
/*   Add set/get's interfaces for counters
/*   
/*      Rev 1.25   13 Mar 2008 15:32:48   zf297a
/*   Added interfaces getVersion, getDebugYorN, and setDebug.  Changed the constant from OVERRIDE_TYPE to TSL_OVERRIDE_TYPE to make the code more meaningful.  Made type locPartOverrideTab public.
/*   
/*      Rev 1.24   01 Nov 2007 09:03:54   zf297a
/*   Created interface for procedure loadRspTslA2A
/*   
/*      Rev 1.23   11 Oct 2007 12:50:30   zf297a
/*   Added interface loadCAN and modified interface LoadTmpAmdLocPartOverride by changing the end_step's default to 7.
/*   
/*      Rev 1.22   06 Aug 2007 10:10:36   zf297a
/*   Added ignoreStLouis flag which can be used to ignore the St Louis tables when that system is down.
/*   
/*      Rev 1.21   13 Jun 2007 20:05:24   zf297a
/*   Fixed the name of checkForDeletedSpoPrimeParts
/*   
/*      Rev 1.20   13 Jun 2007 14:04:46   zf297a
/*   Added interface checkForDeletedSpoPrimePart.
/*   
/*      Rev 1.19   12 Apr 2007 15:30:26   zf297a
/*   renamed loadZeroTsls to loadZeroRspTsls
/*   
/*      Rev 1.18   12 Apr 2007 14:41:48   zf297a
/*   Added interface loadZeroTsls
/*   
/*      Rev 1.17   10 Apr 2007 21:34:20   zf297a
/*   replaced loadUkandAUS with two distinct procedures loadUK and loadAUS
/*   
/*      Rev 1.16   03 Apr 2007 14:43:26   zf297a
/*   Added startStep and endStep arguments to loadTmpAmdLocationPartOverride with default values of 1 and 5 respectively.
/*   
/*   Make the following procedures public to allow for unit testing:
/*   loadUKandAUS
/*   loadFslMob
/*   loadBasc
/*   loadWhse
/*   
/*   For procedure loadWhse add arguments startStep and endStep with default values of 1 and 5 respectively.
/*   
/*   
/*   
/*   
/*      Rev 1.15   01 Mar 2007 12:40:46   zf297a
/*   Added interface for sendZeroTslsForSpoPrimePart
/*   
/*      Rev 1.14   26 Jan 2007 09:47:16   zf297a
/*   Added procedure interface for deleteRspTslA2A
/*   
/*      Rev 1.13   Dec 13 2006 12:00:16   zf297a
/*   Added interfaces isTmpA2AOkay and isTmpA2AOkayYorN
/*   
/*      Rev 1.12   Dec 05 2006 14:53:46   zf297a
/*   Changed interface for processTsl - removed unnessary paramater pDoAllA2A since the cursor has already done the filtering.
/*   
/*      Rev 1.11   Oct 25 2006 10:53:04   zf297a
/*   Defined constants with anchored declarations using the %type attribute.  Made loadOverrideUsers a public procedure.
/*   
/*      Rev 1.10   Aug 24 2006 10:33:28   zf297a
/*   Added a constant for the loc_sid warehouse value
/*   
/*      Rev 1.9   Jun 09 2006 11:55:42   zf297a
/*   added interface version
/*   
/*      Rev 1.8   Apr 28 2006 13:15:54   zf297a
/*   Added the interface for loadRspZeroTslA2A
/*   
/*      Rev 1.7   Apr 21 2006 13:50:40   zf297a
/*   Added isInTmpA2A, isInTmpA2AYorN, loadZeroTslByDate, and InsertTmpA2ALPO
/*   
/*      Rev 1.6   Feb 24 2006 15:08:32   zf297a
/*   Modified the interfaces for some TSL procedures and load procedures.
/*   
/*      Rev 1.5   Feb 15 2006 21:22:54   zf297a
/*   Added ref cursor's, type's and common process routines.
/*   
/*      Rev 1.4   Jan 03 2006 12:56:26   zf297a
/*   Added date range to procedures loadZeroTslA2AByDate and loadA2AByDate
/*   
/*      Rev 1.3   Jan 03 2006 09:13:06   zf297a
/*   Changed name from loadByDate to loadA2AByDate
/*   
/*      Rev 1.2   Dec 30 2005 01:20:08   zf297a
/*   add loadByDate
/*
/*      Rev 1.1   Nov 10 2005 11:10:46   zf297a
/*   Added interfaces getInsertCnt, getDeleteCnt, and getUpdateCnt.  Changed the interface for LoadAllA2A to have an optional boolean argument that can control the use of "test data".
/*
/*      Rev 1.0   Oct 18 2005 19:12:48   c394547
/*   Initial revision.
         */

--    TSL_OVERRIDE_TYPE            amd_spo_types_v.tsl_fixed_override%type := 'TSL-FIXED' ;
--    OVERRIDE_REASON          amd_spo_types_v.fixed_tsl_load_override_reason%type := 'Fixed TSL Load' ;
    THE_WAREHOUSE              CONSTANT amd_spare_networks.spo_location%type := 'FD2090' ;
    THE_WAREHOUSE_LOC_SID      CONSTANT amd_spare_networks.LOC_SID%type := 256 ;
    
    BULKLIMIT CONSTANT NUMBER := 100000 ;
    COMMITAFTER CONSTANT NUMBER := 100000 ;
    SUCCESS                            CONSTANT NUMBER := 0 ;
    FAILURE                            CONSTANT NUMBER := 4 ;
    debug boolean := true ; -- set via param changes: key is debugLocPartOverride value of 1 is TRUE 
                            -- otherwise gets set to FALSE
    ignoreStLouis   boolean := false ;
    function ignoreStLouisYorN return varchar2 ;
    
    
    TYPE locPartOverrideRec IS RECORD (
         part_no AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
         site_location AMD_SPARE_NETWORKS.SPO_LOCATION%TYPE,
         override_type VARCHAR2(32),
         override_quantity AMD_LOCATION_PART_OVERRIDE.TSL_OVERRIDE_QTY%TYPE,
         override_reason VARCHAR2(64),
         tsl_override_user AMD_LOCATION_PART_OVERRIDE.TSL_OVERRIDE_USER%TYPE,
         begin_date DATE,
         end_date DATE,
         action_code AMD_LOCATION_PART_OVERRIDE.ACTION_CODE%TYPE,
         last_update_dt AMD_LOCATION_PART_OVERRIDE.LAST_UPDATE_DT%TYPE
    ) ;
    type locPartOverrideTab is table of locPartOverrideRec ;
    
    
    PROCEDURE LoadInitial ;
    PROCEDURE LoadTmpAmdLocPartOverride( startStep in number := 1, endStep in number := 7) ;
    
    
    FUNCTION InsertRow(
            pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
            pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
            pTslOverrideQty                 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
            pTslOverrideUser             AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
            RETURN NUMBER ;
    
    FUNCTION Updaterow(
            pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
            pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
            pTslOverrideQty                 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
            pTslOverrideUser             AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
            RETURN NUMBER ;
    
    
    
    FUNCTION DeleteRow(
            pPartNo                      AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
            pLocSid                      AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
            pTslOverrideQty                 AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE ,
            pTslOverrideUser             AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE )
            RETURN NUMBER ;
    
            -- return Y or N
    FUNCTION IsNumeric(pString VARCHAR2) RETURN VARCHAR2 ;
    --PRAGMA RESTRICT_REFERENCES(IsNumeric, WNDS) ;
    
    -- testing
    FUNCTION GetFirstLogonIdForPart(pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE) RETURN AMD_PLANNER_LOGONS.logon_id%TYPE ;

    -- added 02/13/09 by dse
    function getGtZeroCnt return number ;
    procedure setGtZeroCnt(value in number) ;
    function getTmpInsertCnt return number ;
    procedure setTmpInsertCnt(value in number) ;
    function getTmpUpdateCnt return number ;
    procedure setTmpUpdateCnt(value in number) ;
    
    procedure setUpdateCnt(value in number) ;
    procedure setDeleteCnt(value in number) ;
    procedure setInsertCnt(value in number) ;

    -- added 11/7/05 dse
    FUNCTION getInsertCnt RETURN NUMBER ;
    FUNCTION getUpdateCnt RETURN NUMBER ;
    FUNCTION getDeleteCnt RETURN NUMBER ;
    
    -- added 02/23/2006 dse
    -- these functions allow  stand alone SQL to use the package constants
--    FUNCTION getTSL_OVERRIDE_TYPE RETURN VARCHAR2 ;
--    FUNCTION getOVERRIDE_REASON RETURN VARCHAR2 ;
    FUNCTION getBULKLIMIT RETURN NUMBER ;
    FUNCTION getCOMMITAFTER RETURN NUMBER ;
    FUNCTION getSUCCESS RETURN NUMBER ;
    FUNCTION getFAILURE RETURN NUMBER ;
    FUNCTION getTHE_WAREHOUSE RETURN VARCHAR2 ;
     
        
    
    -- added 6/9/2006 by dse
    procedure version ;
    
    -- added 9/1/2006 by dse        
    procedure LoadOverrideUsers ;
    


    procedure loadRampData ; -- added 2/14/09 by dse

    
    -- added 4/2/2007 by dse
    procedure LoadUk ;
    procedure LoadAUS ;
    procedure LoadBasc ;
    procedure loadCAN ; -- added 10/11/2007 by dse

    PROCEDURE LoadWhse(startStep in number := 1, endStep in number := 4) ;


    -- added 3/13/2008 by dse
    function getVersion return varchar2 ;
    function getDebugYorN return varchar2 ;
    procedure setDebug(switch in varchar2) ;
 
    procedure setLoadFMSdata(value in varchar2) ;
        
    function getLoadFMSdata return varchar2 ;
           
END Amd_Location_Part_Override_Pkg ;
/


DROP PACKAGE AMD_OWNER.AMD_LP_OVERRIDE_CONSUMABL_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.Amd_lp_override_consumabl_Pkg AS
 /*
      $Author:   zf297a  $
    $Revision:   1.19  $
        $Date:   14 Jul 2009 10:52:30  $
    $Workfile:   AMD_LP_OVERRIDE_CONSUMABL_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_LP_OVERRIDE_CONSUMABL_PKG.pks.-arc  $
/*
/*      Rev 1.19   14 Jul 2009 10:52:30   zf297a
/*   Updated spo type literals
/*
/*      Rev 1.18   10 Jun 2009 13:45:20   zf297a
/*   Change rop_type and roq_type from constants to variables so they can be initialized from amd_spo_types_v.
/*
/*      Rev 1.17   24 Feb 2009 13:20:22   zf297a
/*   Removed a2a code.
/*
/*      Rev 1.16   05 Dec 2008 12:43:54   zf297a
/*   Added interfaces getTslOverrideUser, setUseLoadWhseX, and getUseLoadWhseX.
/*
/*      Rev 1.15   10 Oct 2008 00:53:40   zf297a
/*   Changed interface for isTestPart and isTestPartYorN .. use amd_test_parts instead of amd_sent_to_a2a
/*
/*      Rev 1.14   19 Mar 2008 00:00:26   zf297a
/*   Added interfaces isValidTslData and isValidTslDataYorN
/*
/*      Rev 1.13   17 Mar 2008 10:36:52   zf297a
/*   Added interfaces getLoadZeroTslsYorN and setLoadZeroTsls.
/*
/*      Rev 1.12   12 Mar 2008 15:21:26   zf297a
/*   Added interfaces: getInsertData and setInsertData, which is to be used to control the boolean variable insertData.  This variable controls whether data actually gets inserted into a table and consequently it can be used for testing purposes to see the flow of control without updating the tables.
/*
/*      Rev 1.11   07 Jan 2008 09:35:22   zf297a
/*   Added enhanced debugging: a record defining the debug data, a cursor used to retrieve the debug data, functions and procedures to set debugging on or off and to retrieve or delete the debug data.
/*
/*      Rev 1.10   08 Nov 2007 22:50:32   zf297a
/*   Added NONWESM_SOURCE.
/*
/*      Rev 1.8   24 Oct 2007 17:30:10   zf297a
/*   Added interfaces for the following constants:
/*   ROQ_TYPE
/*   ROP_TYPE
/*   GOLD_SOURCE
/*   WESM_SOURCE
/*   WHSE_LOCSID
/*   WHSE_LOCID
/*
/*      Rev 1.7   12 Oct 2007 17:00:46   zf297a
/*   Changed interface name from loadZeroTsls to loadDefaultTsls.
/*   Added interfaces loadBasc, loadUK, loadAustrailia, and loadCanada
/*
/*      Rev 1.6   11 Oct 2007 22:42:00   zf297a
/*   Added interface for procedure loadZeroTsls
/*
/*      Rev 1.5   19 Sep 2007 17:27:48   zf297a
/*   Added DELETE_ACTION constant as an alias for amd_defaults.DELETE_ACTION
/*
/*      Rev 1.4   18 Sep 2007 21:19:44   zf297a
/*   Made constants that were in the package body public and made alias's  VIRTURAL_UAB and VIRTUAL_COD.
/*
/*      Rev 1.3   16 Aug 2007 14:16:18   zf297a
/*   Added interface for procedure version
/*
/*      Rev 1.2   16 Aug 2007 12:27:52   zf297a
/*   Added interface for procedure loadAllA2A
/*
/*      Rev 1.1   19 Jul 2007 14:36:10   zf297a
/*   Added inerfaces for loadVirtualLocations and loadLocPartOverrides.
/*
/*      Rev 1.0   06 Jul 2007 17:27:12   zf297a
/*   Initial revision.
*/

    type tmpLocPartOveridConsumablesTab is table of tmp_locpart_overid_consumables%rowtype ;

    type debugRec is record  (
        timestamp date,
        msg AMD_LOAD_DETAILS.KEY_2%type
    ) ;

    type msgRec is record (
        msg amd_load_details.key_2%type
    ) ;

    type debugCur is ref cursor return debugRec ;

    type msgCur is ref cursor return msgRec ;

    ROQ_TYPE AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_TYPE%type := 'ROQ-FIXED' ;
    function getROQ_TYPE return amd_locpart_overid_consumables.tsl_override_type%type ;
    ROP_TYPE AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_TYPE%type := 'ROP-FIXED' ;
    function getROP_TYPE return amd_locpart_overid_consumables.tsl_override_type%type ;
    GOLD_SOURCE constant AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type := 'GOLD' ;
    function getGOLD_SOURCE return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type ;
    WESM_SOURCE constant AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type := 'WESM' ;
    function getWESM_SOURCE return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type ;
    NONWESM_SOURCE constant AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type := 'NONWESM' ;
    function getNONWESM_SOURCE return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type ;
    WHSE_LOCSID constant number := 256 ;
    function getWHSE_LOCSID return number ;
    WHSE_LOCID constant varchar2(6) := 'FD2090' ;
    function getWHSE_LOCID return number ;

    VIRTUAL_UAB constant amd_spare_networks.SPO_LOCATION%type := amd_location_part_leadtime_pkg.VIRTUAL_UAB_SPO_LOCATION ;
    VIRTUAL_COD constant amd_spare_networks.SPO_LOCATION%type := amd_location_part_leadtime_pkg.VIRTUAL_COD_SPO_LOCATION ;
    DELETE_ACTION constant amd_spare_networks.action_code%type := amd_defaults.DELETE_ACTION ;

    function getDebugYorN return varchar2 ;
    procedure setDebug(switch in varchar2) ;

    function getInsertDataYorN return varchar2 ;
    procedure setInsertData(switch in varchar2) ;

    procedure loadLvls ;
    procedure loadBasc ; -- added 10/11/2007 by dse
    procedure loadUK ; -- added 10/11/2007 by dse
    procedure loadAustrailia ; -- added 10/11/2007 by dse
    procedure loadCanada ; -- added 10/11/2007 by dse
    procedure loadRamp ;
    procedure loadWhse ;
    procedure loadWesm ;
    procedure loadVirtualLocations ;
    procedure loadLocPartOverrides ;

    function getRop(economic_order_qty in number, approved_lvl_qty in number , reorder_point in number) return number ;
    function getRoq(economic_order_qty in number, approved_lvl_qty in number, reorder_point in number) return number ;

    function doLPOverrideConsumablesDiff(part_no in varchar2, spo_location in varchar2, tsl_override_type in varchar2,
        tsl_override_user in varchar2, tsl_override_source in varchar2, tsl_override_qty in number, loc_sid in number, action_code in varchar2) return number ;

    procedure initialize(action_code in varchar2 := null) ;



    procedure version ;

    function isTestPart(part_no in amd_test_parts.part_no%type) return boolean ; -- added 1/4/2008 by dse
    function isTestPartYorN(part_no in amd_test_parts.part_no%type) return varchar2 ; -- added 1/4/2008 by dse

    function getDebugCur return debugCur ;

    function getDebugCur(fromDate in date, toDate in date := sysdate) return debugCur ;
    function getDebugCur(textFilter in varchar2) return debugCur ;

    function listDebugMsgs return msgCur ;
    function listDebugMsgs(fromDate in date, toDate in date := sysdate) return msgCur ;
    function listDebugMsgs(textFilter in varchar2) return msgCur ;

    procedure deleteDebugMsgs ;

    function getVersion return varchar2 ;
    -- added 3/17/2008 by dse
    function getLoadZeroTslsYorN return varchar2 ;
    procedure setLoadZeroTsls(switch in varchar2) ;
    -- added 3/18/2008 by dse
    function isValidTslData(
        override_type in amd_locpart_overid_consumables.tsl_OVERRIDE_TYPE%type,
        override_quantity in amd_locpart_overid_consumables.tsl_OVERRIDE_qty%type) return boolean ;
    function isValidTslDataYorN(
        override_type in amd_locpart_overid_consumables.tsl_OVERRIDE_TYPE%type,
        override_quantity in amd_locpart_overid_consumables.tsl_OVERRIDE_qty%type) return varchar2 ;

    function getTslOverrideUser(spo_prime_part_no in amd_spare_parts.spo_prime_part_no%type)
        return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_USER%type ; -- added 12/5/2008 by dse

    procedure setUseLoadWhseX(value in varchar2) ; -- added 12/5/2008 by dse
    function getUseLoadWhseX return varchar2 ; -- added 12/5/2008 by dse


end Amd_lp_override_consumabl_Pkg ;
 
/


DROP PACKAGE AMD_OWNER.AMD_MAINT_TASK_DISTRIBS_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_maint_task_distribs_pkg
as
    /*

       $Author:   c970183  $
     $Revision:   1.6  $
         $Date:   Jun 13 2005 09:02:46  $
     $Workfile:   amd_maint_task_distribs_pkg.pks  $
	      $Log:   \\www-amssc-01\pds\archives\SDS-AMD\Database\Packages\amd_maint_task_distribs_pkg.pks-arc  $

      Rev 1.6   Jun 13 2005 09:02:46   c970183
   Added PVCS keywords
*/

	   -------------------------------------------------------------------
	   --  Date	  		  By			History
	   --  ----			  --			-------
	   --  10/25/01		  ks			initial implementation
	   --  06/01/05		  ks			change reference to rampData
	   -------------------------------------------------------------------


   	    -- mob, fsl, ror only, no warehouse
	    -- previous amd RepairRate always defaulted. may be in error. need rereview.
		-- 		  actual and projected may be considered incorrect in this manner too
		--		  since defaults always used. kept consistent with previous load for now.
		-- repair rate requires 5,6 position smr for default from existing system.
		-- if no 6 position smr, no record currently created.

  	   	  -- actual and projected designations for mtd
  	   ACTUAL constant varchar2(1) := 'A';
  	   PROJECTED constant varchar2(1) := 'P';
	   COMMIT_AFTER constant number := 10000;
  	   	  -- loadMtd needs to run after amd_part_locs loading
  	   procedure loadAmdMtd;


end amd_maint_task_distribs_pkg;
 
/


DROP PACKAGE AMD_OWNER.AMD_NSL_SEQUENCE_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_nsl_sequence_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.8  $
     $Date:   16 Oct 2007 10:05:38  $
    $Workfile:   amd_nsl_sequence_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_nsl_sequence_pkg.pks-arc  $

      Rev 1.8   16 Oct 2007 10:05:38   zf297a
   Added version interface

      Rev 1.7   Dec 01 2005 09:36:48   zf297a
   added pvcs keywords
*/
   --
   -- SCCSID: amd_nsl_sequence_pkg.sql  1.8  Modified: 03/05/03 13:24:55
   --
	/*
		Purpose: Use the following function to sequence
		an NSL.
		Douglas S. Elder	10/14/01	Initial Implementation
		Fernando Fajardo  11/27/01 Added GetNslFromAmd() and
		                           mod to GetNslFromBssm().
		Fernando Fajardo  11/29/01 Fixed GetNslFromAmd().
		Fernando Fajardo  12/18/01 Added distinct keyword to 'select' statement.
		Fernando Fajardo  09/18/02 Added nsn_type='C' qualifier
                                 to GetNslFromAmd().
		Fernando Fajardo  10/14/02 Added anp.unassignment_date is null qualifier
                                 to GetNslFromAmd().
		Fernando Fajardo  11/25/02 Changed datatype of RAW_DATA constant to
											to varchar2 for performance.
		Fernando Fajardo  02/21/03 Fixed GetNslFromAmd() to look for NSL's only.
	*/

	function SequenceTheNSL(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.nsn%type ;

    procedure version ; -- added 10/16/2007 by dse

end amd_nsl_sequence_pkg ;
 
/


DROP PACKAGE AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_on_order_date_filters_pkg AS
/******************************************************************************
       $Author:   zf297a  $
     $Revision:   1.4  $
         $Date:   Jun 09 2006 12:34:00  $
     $Workfile:   AMD_ON_ORDER_DATE_FILTERS_PKG.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_ON_ORDER_DATE_FILTERS_PKG.pks.-arc  $
/*
/*      Rev 1.4   Jun 09 2006 12:34:00   zf297a
/*   added interface version
/*
/*      Rev 1.3   May 17 2006 14:58:36   zf297a
/*   removed start_date - not needed
/*
/*      Rev 1.2   May 17 2006 14:21:24   zf297a
/*   Added setScheduledReceiptDateCalDays and
/*   getScheduledReceiptDateCalDays
/*
/*      Rev 1.1   May 17 2006 13:25:08   zf297a
/*   Implemented procedures and functions using amd_on_order_date_filters table.
/*
/*      Rev 1.0   May 17 2006 12:24:26   zf297a
/*   Initial revision.
******************************************************************************/

	sched_receipt_date_exception EXCEPTION ;

	FUNCTION getOrderCreateDate(filter_name in amd_on_order_date_filters.FILTER_NAME%type, voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE ;
	PROCEDURE setOrderCreateDate(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  					voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
								orderCreateDate IN amd_on_order_date_filters.ORDER_CREATE_DATE%type) ;

	FUNCTION getScheduledReceiptDateFrom(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			 				voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE ;

	FUNCTION getScheduledReceiptDateTo(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			 				voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE ;

	PROCEDURE setScheduledReceiptDates(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										fromDate IN DATE, toDate DATE) ;

	procedure getScheduledReceiptDateCalDays(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										calendar_days out amd_on_order_date_filters.CALENDAR_DAYS%type ) ;

	PROCEDURE setScheduledReceiptDateCalDays(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										calendar_days IN NUMBER) ;

	PROCEDURE getOnOrderDateFilters(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
			  orderCreateDate 		  OUT amd_on_order_date_filters.ORDER_CREATE_DATE%type,
			  schedReceiptDateFrom 	  OUT amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_FROM%type,
			  schedReceiptDateTo 	  OUT amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_TO%type,
			  schedReceiptCalDays 	  OUT amd_on_order_date_filters.CALENDAR_DAYS%type) ;

	PROCEDURE setOnOrderDateFilters(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
			  orderCreateDate 		  in amd_on_order_date_filters.ORDER_CREATE_DATE%type,
			  schedReceiptDateFrom 	  in amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_FROM%type,
			  schedReceiptDateTo 	  in amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_TO%type,
			  schedReceiptCalDays 	  in amd_on_order_date_filters.CALENDAR_DAYS%type) ;

	FUNCTION isVoucher(voucher IN VARCHAR2) RETURN BOOLEAN ;
	PROCEDURE clearOnOrderParams(filter_name in amd_on_order_date_filters.FILTER_NAME%type) ;
	FUNCTION numberOfOnOrderParams(filter_name in amd_on_order_date_filters.FILTER_NAME%type) RETURN NUMBER ;
	TYPE ref_cursor IS REF CURSOR ;
	FUNCTION getVouchers RETURN ref_cursor ;

	-- added 6/9/2006 by dse
	procedure version ;

END amd_on_order_date_filters_pkg;
 
/


DROP PACKAGE AMD_OWNER.AMD_PARTPRIME_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_PARTPRIME_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.7  $
     $Date:   15 Oct 2008 09:03:02  $
    $Workfile:   AMD_PARTPRIME_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PARTPRIME_PKG.pks.-arc  $
/*
/*      Rev 1.7   15 Oct 2008 09:03:02   zf297a
/*   Added procedure setDebug
/*
/*      Rev 1.6   26 Sep 2008 17:48:52   zf297a
/*   Changed name of function getPrimePartAmd to getAmdPrimePart.  Added interface for isSpoPrimePart, isSpoPrimePartYorN, and  getTwoWayRblPrimePart.
/*
/*      Rev 1.5   22 Sep 2008 19:38:40   zf297a
/*   added interfaces setSpoPrimePart , updateAllSpoPrimeParts, and updateSpoPrimePart
/*
/*      Rev 1.4   23 May 2008 13:20:56   zf297a
/*   Added interface for function getVersion.
/*
/*      Rev 1.3   15 May 2008 21:43:04   zf297a
/*   Added set/get for the threshold variable.
/*
/*      Rev 1.2   30 Jan 2007 14:26:26   zf297a
/*   added interface for updatePlannerCodesForSubParts
/*
/*      Rev 1.1   Jun 09 2006 12:07:00   zf297a
/*   added interface version
/*
/*      Rev 1.0   Dec 01 2005 09:41:48   zf297a
/*   Initial revision.
*/
   	  /* The following "getSuperPrime" functions
	  	 first checks for a super relationship in bssm_rbl_pairs.
		 if super relationship not available or super relationship part does not meet
		 minimum a2a requirement (i.e. exists in AMD_SENT_TO_A2A with action_code != 'D')
		 it will use the prime in amd_national_stock_items - however at this point
		 it does not check if the prime in amd_national_stock_items meets minimum a2a requirement */
	   FUNCTION getSuperPrimePart(pPart VARCHAR2) RETURN VARCHAR2 ;
   	   FUNCTION getSuperPrimePartByNsiSid(pNsiSid NUMBER) RETURN VARCHAR2 ;
	   FUNCTION getSuperPrimeNsiSid(pPart VARCHAR2) RETURN NUMBER ;




	   FUNCTION getAmdPrimePart(pNsn VARCHAR2) RETURN VARCHAR2 ; -- changed 9/26/2008 by dse

	   FUNCTION getNsn(pPart VARCHAR2)
		 RETURN VARCHAR2 ;

		 -- added 6/9/2006 by dse
		 procedure version ;


     -- added 5/15/2008 by dse
     procedure setThreshold(value in number) ;
     function getThreshold return number ;

     function getVersion return varchar2 ; -- added 5/23/2008 by dse

     procedure setSpoPrimePart(part_no in amd_spare_parts.part_no%type,
        spo_prime_part_no in amd_spare_parts.spo_prime_part_no%type) ; -- added 9/22/2008 by dse

	procedure updateSpoPrimePart(last_update_dt
		in amd_spare_parts.last_update_dt%type
		:= amd_batch_pkg.getLastStartTime) ;

     procedure updateAllSpoPrimeParts ; -- added 9/22/2008 by dse


    function getTwoWayRblPrimePart(pNsn VARCHAR2) return varchar2 ; -- added 9/26/2008 by dse

	function isSpoPrimePart(pPart VARCHAR2) return boolean ; -- added 9/26/2008 by dse
    function isSpoPrimePartYorN(pPart VARCHAR2) return varchar2 ; -- added 9/26/2008 by dse

    procedure setDebug(switch in varchar2) ; -- added 10/11/2008 by dse
END ;
 
/


DROP PACKAGE AMD_OWNER.AMD_PART_FACTORS_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_PART_FACTORS_PKG
AS
   /*
        $Author: Douglas S. Elder
   $Revision:   1.9
          $Date:   16 May 2017
      $Workfile:   AMD_PART_FACTORS_PKG.pks  $

          Rev 1.9 16 May 2017 used the old deleteRow long param list to be compatible with the current Java
          separately
          
          Rev 1.8 02 Jul 2016 made LoadTmpAmdPartFactorsByLocType public so it can be executed and tested
          separately

          Rev 1.7 fixed deleteRow - only needs the key to amd_part_factors

  /*      Rev 1.6   02 Jul 2009 13:14:00   zf297a
  /*   Added type mtd_rec and interfaces for convertMtdToDataSys
  /*   and getCapabilityLevel
  /*
  /*      Rev 1.5   24 Feb 2009 13:46:12   zf297a
  /*   Removed a2a code.
  /*
  /*      Rev 1.4   13 Jan 2009 15:28:20   zf297a
  /*   Define an exception to be used for maintenance task distribution calculations.
  /*   Defined interfaces setDebug, getDebug, and getVersion.
  /*
  /*      Rev 1.3   Jun 09 2006 12:02:52   zf297a
  /*   added interface version
  /*
  /*      Rev 1.2   Jan 03 2006 13:03:18   zf297a
  /*   Added date range to procedure loadA2AByDate
  /*
  /*      Rev 1.1   Jan 03 2006 08:07:42   zf297a
  /*   Added procedure loadA2AByDate
  /*
  /*      Rev 1.0   Oct 31 2005 08:04:54   zf297a
  /*   Initial revision.
  */



   TYPE mtd_rec IS RECORD
   (
      rts       NUMBER,
      nrts      NUMBER,
      condemn   NUMBER
   );

   maint_task_distrib_exception              EXCEPTION;
   DEFAULT_WHSE_COND                CONSTANT NUMBER := .005;
   CRITICALITY_REPAIRABLE_DEFAULT   CONSTANT amd_national_stock_items.criticality%TYPE
      := .5 ;
   --  consumable not defined yet, placeholder for when defined
   CRITICALITY_CONSUMABLE_DEFAULT   CONSTANT amd_national_stock_items.criticality%TYPE
      := 0 ;

   -- calcs done to 4 decimal places
   DP                               CONSTANT NUMBER := 4;
   COMMITAFTER                      CONSTANT NUMBER := 100000;
   SUCCESS                          CONSTANT NUMBER := 0;
   FAILURE                          CONSTANT NUMBER := 4;



   PROCEDURE LoadTmpAmdPartFactors;

   PROCEDURE LoadInitial;



   /* current spec says to send a auto default nrts, rts, cond to vub, vcd, basc,
      others - mob, fsl, ctlatl, uk will use #'s from best spares.
      Below function will have to be maintained at this point for which
      locations are autodefaulted and which are not */
   FUNCTION IsAutoDefaulted (pLocRow amd_spare_networks%ROWTYPE)
      RETURN BOOLEAN;

   FUNCTION InsertRow (
      pPartNo                amd_part_factors.part_no%TYPE,
      pLocSid                amd_part_factors.loc_sid%TYPE,
      pPassUpRate            amd_part_factors.pass_up_rate%TYPE,
      pRts                   amd_part_factors.rts%TYPE,
      pCmdmdRate             amd_part_factors.cmdmd_rate%TYPE,
      pCriticality           amd_national_stock_items.criticality%TYPE,
      pCriticalityChanged    amd_national_stock_items.criticality_changed%TYPE,
      pCriticalityCleaned    amd_national_stock_items.criticality_cleaned%TYPE)
      RETURN NUMBER;

   FUNCTION UpdateRow (
      pPartNo                amd_part_factors.part_no%TYPE,
      pLocSid                amd_part_factors.loc_sid%TYPE,
      pPassUpRate            amd_part_factors.pass_up_rate%TYPE,
      pRts                   amd_part_factors.rts%TYPE,
      pCmdmdRate             amd_part_factors.cmdmd_rate%TYPE,
      pCriticality           amd_national_stock_items.criticality%TYPE,
      pCriticalityChanged    amd_national_stock_items.criticality_changed%TYPE,
      pCriticalityCleaned    amd_national_stock_items.criticality_cleaned%TYPE)
      RETURN NUMBER;


   FUNCTION DeleteRow (pPartNo    amd_part_factors.part_no%TYPE,
                       pLocSid    amd_part_factors.loc_sid%TYPE)
      RETURN NUMBER;

   FUNCTION DeleteRow (
      pPartNo                amd_part_factors.part_no%TYPE,
      pLocSid                amd_part_factors.loc_sid%TYPE,
      pPassUpRate            amd_part_factors.pass_up_rate%TYPE,
      pRts                   amd_part_factors.rts%TYPE,
      pCmdmdRate             amd_part_factors.cmdmd_rate%TYPE,
      pCriticality           amd_national_stock_items.criticality%TYPE,
      pCriticalityChanged    amd_national_stock_items.criticality_changed%TYPE,
      pCriticalityCleaned    amd_national_stock_items.criticality_cleaned%TYPE)
      RETURN NUMBER;

   FUNCTION GetRepairIndicator (pNsn        bssm_base_parts.nsn%TYPE,
                                pSran       bssm_base_parts.sran%TYPE,
                                pLockSid    bssm_locks.LOCK_SID%TYPE)
      RETURN VARCHAR2;

   PRAGMA RESTRICT_REFERENCES (GetRepairIndicator, WNDS);

   -- added 6/9/2006 by dse
   PROCEDURE version;

   PROCEDURE setDebug (VALUE IN VARCHAR2);

   FUNCTION getDebug
      RETURN VARCHAR2;

   FUNCTION getVersion
      RETURN VARCHAR2;

   FUNCTION ConvertMtdToDataSys (pLocId              amd_spare_networks.LOC_ID%TYPE,
                                 pCapabilityLevel    VARCHAR2,
                                 pRepairInd          VARCHAR2,
                                 pNrts               NUMBER,
                                 pRts                NUMBER,
                                 pCondemn            NUMBER)
      RETURN mtd_rec;

   FUNCTION GetCapabilityLevel (pLocId amd_spare_networks.loc_id%TYPE)
      RETURN bssm_bases.capabilty_level%TYPE;

   FUNCTION LoadTmpAmdPartFactorsByLocType (
      pLocType   IN amd_spare_networks.loc_type%TYPE)
      RETURN NUMBER;
END AMD_PART_FACTORS_PKG;
/


DROP PACKAGE AMD_OWNER.AMD_PART_LOCS_LOAD_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_PART_LOCS_LOAD_PKG
AS
    /*

       $Author:   zf297a  $
     $Revision:   1.8 $
         $Date:   Jun 09 2006 12:12:08  $
     $Workfile:   amd_part_locs_load_pkg.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_part_locs_load_pkg.pks-arc  $

      Rev 1.8   07 Dec 2011 Added function getVersion

      Rev 1.7   Jun 09 2006 12:12:08   zf297a
   added interface version

      Rev 1.6   Jun 13 2005 09:19:04   c970183
   Added PVCS keywords

*/

  	   	-------------------------------------------------------------------
		--
		-- SCCSID: amd_part_locs_load_pkg.sql  1.1  Modified: 08/14/02 17:11:22
		--
	   	--  Date	  	  By			History
	   	--  ----		  --			-------
	   	--  10/10/01	  	  ks		initial implementation
	   	--  12/11/01	  	  dse		Added named param for amd_preferred_pkg.GetUnitCost(.....
	   	--  8/14/02		  ks            change fsl query to be more efficient.
		--  6/01/05		  ks		changes to support AMD 1.7.1 - change to RSP_ON_HAND, RSP_OBJECTIVE
		--					change rampData_rec to be whole record,
		--					mod to queries for bssm, eg. lock_sid use '0' instead of 0
		-------------------------------------------------------------------


		-- added ROR to previous part_locations, since table now combines old amd_repair_levels
	   	-- too, which had MOB, FSL, ROR. also adding each part to warehouse as part/loc list since
	   	-- child table amd_part_loc_time_periods may provide ROP/ROQ info for warehouse, especially
	   	-- for consumables.
  OFFBASE_LOCID constant varchar2(30) := 'OFFBASE';
  COMMIT_AFTER constant number := 10000;
  -- data fields match cursor and database field names
  -- wrm relates to rsp
  /*
  type rampData_rec is record (
  	   date_processed date,
	   avg_repair_cycle_time number,
	   percent_base_condem number,
	   percent_base_repair number,
	   wrm_level number,
	   wrm_balance number );
  function GetRampData(pNsn ramp.nsn%type, pLocId amd_spare_networks.loc_id%type) return rampData_rec;
  function GetRampData(pNsn ramp.nsn%type, pLocSid amd_spare_networks.loc_sid%type) return rampData_rec;
  */

  function GetRampData(pNsn ramp.nsn%type, pLocId amd_spare_networks.loc_id%type) return ramp%ROWTYPE ;
  function GetRampData(pNsn ramp.nsn%type, pLocSid amd_spare_networks.loc_sid%type) return ramp%ROWTYPE ;
  procedure LoadAmdPartLocations;

  -- added 6/9/2006 by dse
  procedure version ;
-- added 12/7/2011 by dse
    function getVersion return varchar2 ;

END AMD_PART_LOCS_LOAD_PKG;
 
/


DROP PACKAGE AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG AS
 /*
      $Author:   zf297a  $
	$Revision:   1.12  $
        $Date:   17 Jan 2012  $
    $Workfile:   AMD_PART_LOC_FORECASTS_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PART_LOC_FORECASTS_PKG.pks.-arc  $

         Rev 1.12 added getVersion interface
/*
/*      Rev 1.11   24 Feb 2009 13:56:40   zf297a
/*   Removed A2A code
/*
/*      Rev 1.10   07 Nov 2007 17:07:28   zf297a
/*   Added type partLocForecastsTab.
/*
/*      Rev 1.9   Nov 01 2006 11:37:44   zf297a
/*   Added interfaces for hasValidDate and hasValidDateYorN
/*
/*      Rev 1.8   Aug 18 2006 15:44:40   zf297a
/*   Added interface doExtforecast and made insertTmpA2A_EF_AllPeriods public.
/*
/*      Rev 1.7   Jul 26 2006 10:10:42   zf297a
/*   Made getLatestRblRunBssm public.  Made getCurrentPeriod, setCurrentPeriod, getLatestRblRunAmd, and setLatestRblRunAmd public.
/*
/*      Rev 1.6   Jul 26 2006 09:43:34   zf297a
/*   Made getCurrentPeriod a public routine.
/*
/*      Rev 1.5   Jun 09 2006 12:16:58   zf297a
/*   added interface version
/*
/*      Rev 1.4   May 12 2006 14:38:56   zf297a
/*   added action_code to type partLocForecastsRec.
/*
/*      Rev 1.3   Feb 15 2006 21:52:10   zf297a
/*   Added a ref cursor, a type, and a common process routine.
/*
/*      Rev 1.1   Jan 03 2006 07:56:40   zf297a
/*   Added procedure loadA2AByDate
/*
/*      Rev 1.0   Dec 01 2005 09:44:12   zf297a
/*   Initial revision.
*/
	PARAMS_LATEST_RBL_RUN_DATE VARCHAR2(50) := 'ext_forecast_last_rbl_run_date' ;
	PARAMS_CURRENT_PERIOD_DATE VARCHAR2(50) := 'ext_forecast_current_period' ;
	ROLLING_PERIOD_MONTHS CONSTANT NUMBER := 60 ;
	PARAM_USER VARCHAR2(50) := 'bsrm_loader' ;
	DEMAND_FORECAST_TYPE VARCHAR2(10) := 'External' ;
	-- decimal precision for forecast_qty --
	DP CONSTANT NUMBER := 4 ;

	SUCCESS							CONSTANT NUMBER := 0 ;
	FAILURE							CONSTANT NUMBER := 4 ;
	type partLocForecastsRec is record (
		 part_no amd_part_loc_forecasts.PART_NO%type,
		 spo_location amd_spare_networks.SPO_LOCATION%type,
		 forecast_qty amd_part_loc_forecasts.FORECAST_QTY%type,
		 action_code amd_part_loc_forecasts.action_code%type
	) ;
    type partLocForecastsTab is table of partLocForecastsRec ;

	type partLocForecastsCur is ref cursor return partLocForecastsRec ;

	FUNCTION getLatestRblRunBssm(lockName in bssm_locks.NAME%type) RETURN DATE ;

	FUNCTION getLatestRblRunAmd RETURN DATE ;
	PROCEDURE setLatestRblRunAmd(pRblRunDate DATE) ;

	FUNCTION getCurrentPeriod RETURN DATE ;
	PROCEDURE setCurrentPeriod(pCurrentPeriodDate DATE) ;

	FUNCTION GetFirstDateOfMonth(pDate DATE) RETURN DATE ;
	pragma restrict_references(GetFirstDateOfMonth, WNDS) ;

	/*
	 returns 1 if not empty, 0 if empty, -1 if any problem e.g.table not oracle table
	*/
	-- FUNCTION IsTableEmpty(pTableName VARCHAR2) RETURN NUMBER  ;

	FUNCTION InsertRow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE )
			return NUMBER ;

	FUNCTION Updaterow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE )
			RETURN NUMBER ;


	FUNCTION DeleteRow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE )
			RETURN NUMBER ;

	PROCEDURE LoadInitial ;

	PROCEDURE LoadLatestRblRun ;
	PROCEDURE LoadTmpAmdPartLocForecasts_Add ;
	-- added 8/17/2006
	procedure doExtForecast ;

	-- added 6/9/2006 by dse
	procedure version ;
	-- added 1/17/2012 by dse
    function getVersion return varchar2 ;

	-- added 11/1/2006 by dse
	FUNCTION hasValidDate(lockName in bssm_locks.NAME%type) RETURN boolean ;
	-- added 11/1/2006 by dse
	function hasValidDateYorN(lockName in bssm_locks.NAME%type) RETURN varchar2 ;


END AMD_PART_LOC_FORECASTS_PKG ;
 
/


DROP PACKAGE AMD_OWNER.AMD_PREFERRED_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_preferred_pkg
is
    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.11  $
         $Date:   12 Aug 2008 08:49:44  $
     $Workfile:   amd_preferred_pkg.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_preferred_pkg.pks-arc  $

      Rev 1.11   12 Aug 2008 08:49:44   zf297a
   Added interfaces for function getVersion and procedure version.

      Rev 1.10   31 Jul 2008 11:21:56   zf297a
   Added interface for getPlannerCodeByPart

      Rev 1.9   May 06 2005 08:07:42   c970183
   changed dla_warehouse_stock and dla_warehouse_stock_cleaned to current_backorder and current_backorder_cleaned.  added pvcs keywords
   	  */
 	  /*
		Purpose: Provide a set of API's to retrieve data that
		has, cleaned or defaulted or both values.  The
		cleaned data is preferred over the raw data and the
		raw data is preferred over the defaulted data.

		Douglas S. Elder / Chung D. Lu	10/14/01	Initial Implementation

		Douglas S. Elder 				12/11/01	Removed mfgr column from all routines

		Douglas S. Elder 				12/11/01	Added ByNsn and ByPart suffixed
		functions for GetOrderLeadTime and GetUnitCost to be used in SQL statements:
		Select GetUnitCostByPart(.....) from dual
		Douglas S. Elder 				01/14/02	Eliminated Pragma statement


	*/

	function GetAddIncrement(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.add_increment%type;
	function GetAddIncrement(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.add_increment%type;
	function GetAmcBaseStock(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.amc_base_stock%type;
	function GetAmcBaseStock(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.amc_base_stock%type;
	function GetAmcDaysExperience(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.amc_days_experience%type;
	function GetAmcDaysExperience(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.amc_days_experience%type;
	function GetAmcDemand(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.amc_demand%type;
	function GetAmcDemand(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.amc_demand%type;
	function GetCapabilityRequirement(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.capability_requirement%type;
	function GetCapabilityRequirement(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.capability_requirement%type;
	function GetCondemnAvg(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.condemn_avg%type;
	function GetCondemnAvg(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.condemn_avg%type;
	function GetCostToRepairOffBase(pNsi_sid in amd_part_locs.nsi_sid%type, pLoc_sid in amd_part_locs.loc_sid%type) return amd_part_locs.cost_to_repair%type;
	function GetCostToRepairOffBase(pNsn in amd_nsns.nsn%type, pLoc_id in amd_spare_networks.loc_id%type) return amd_part_locs.cost_to_repair%type ;
	function GetCurrentPrimeInd(pNsi_sid in amd_nsi_parts.nsi_sid%type, pPart_no in amd_nsi_parts.part_no%type) return amd_nsi_parts.prime_ind%type;
	function GetCurrentPrimeInd(pNsn in amd_nsns.nsn%type, pPart_no in amd_nsi_parts.part_no%type) return amd_nsi_parts.prime_ind%type;
	function GetCriticality(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.criticality%type;
	function GetCriticality(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.criticality%type;
	function GetDistribUom(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.distrib_uom%type;
	function GetDistribUom(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.distrib_uom%type;
	function GetDlaDemand(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.dla_demand%type;
	function GetDlaDemand(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.dla_demand%type;
	function GetDlaWarehouseStock(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.current_backorder%type;
	function GetDlaWarehouseStock(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.current_backorder%type;
	function GetFedcCost(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.fedc_cost%type;
	function GetFedcCost(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.fedc_cost%type;
	function GetItemType(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.item_type%type;
	function GetItemType(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.item_type%type;
	function GetMicCodeLowest(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.mic_code_lowest%type;
	function GetMicCodeLowest(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.mic_code_lowest%type;
	function GetMtbdr(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.mtbdr%type;
	function GetMtbdr(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.mtbdr%type;
	function GetNomenclature(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_spare_parts.nomenclature%type;
	function GetNomenclature(pNsn in amd_nsns.nsn%type) return amd_spare_parts.nomenclature%type;
	function GetNrtsAvg(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.nrts_avg%type;
	function GetNrtsAvg(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.nrts_avg%type;
	function GetOrderLeadTime(pNsn in amd_spare_parts.nsn%type) return amd_spare_parts.order_lead_time%type ;
	function GetOrderLeadTimeByNsn(pNsn in amd_spare_parts.nsn%type) return amd_spare_parts.order_lead_time%type ;
	function GetOrderLeadTime(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.order_lead_time%type ;
	function GetOrderLeadTimeByPart(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.order_lead_time%type ;
	function GetOrderQuantity(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.order_quantity%type;
	function GetOrderQuantity(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.order_quantity%type;
	function GetOrderUom(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.order_uom%type ;
	function GetPlannerCode(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.planner_code%type;
	function GetPlannerCode(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.planner_code%type;
    function getPlannerCodeByPart(part_no in amd_spare_parts.part_no%type) return amd_national_stock_items.planner_code%type ;
	function GetPrimeInd(pNsi_sid in amd_nsi_parts.nsi_sid%type, pPart_no in amd_nsi_parts.part_no%type) return amd_nsi_parts.prime_ind%type;
	function GetPrimeInd(pNsn in amd_nsns.nsn%type, pPart_no in amd_nsi_parts.part_no%type) return amd_nsi_parts.prime_ind%type;
	function GetQpeiWeighted(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.qpei_weighted%type;
	function GetQpeiWeighted(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.qpei_weighted%type;
	function GetRtsAvg(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.rts_avg%type;
	function GetRtsAvg(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.rts_avg%type;
	function GetRuInd(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.ru_ind%type;
	function GetRuInd(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.ru_ind%type;
	function GetScrapValue(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.scrap_value%type ;
	function GetShelfLife(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.shelf_life%type ;
	function GetSmrCode(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.smr_code%type;
	function GetSmrCode(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.smr_code%type;
	function GetTimeToRepairOffBase(pNsi_sid in amd_part_locs.nsi_sid%type, pLoc_sid in amd_part_locs.loc_sid%type) return amd_part_locs.time_to_repair%type;
	function GetTimeToRepairOffBase(pNsn in amd_nsns.nsn%type, pLoc_id in amd_spare_networks.loc_id%type) return amd_part_locs.time_to_repair%type ;
	function GetTimeToRepairOnBaseAvg(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.time_to_repair_on_base_avg%type;
	function GetTimeToRepairOnBaseAvg(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.time_to_repair_on_base_avg%type;
	function GetUnitCost(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_spare_parts.unit_cost%type;
	function GetUnitCost(pNsn in amd_nsns.nsn%type) return amd_spare_parts.unit_cost%type;
	function GetUnitCostByNsn(pNsn in amd_nsns.nsn%type) return amd_spare_parts.unit_cost%type;
	function GetUnitCost(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.unit_cost%type;
	function GetUnitCostByPart(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.unit_cost%type;
	function GetUnitVolume(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.unit_volume%type ;

	-- pPreferred1 takes priority over pPreferred2 and pPreferred2 takes priority over pPreferred3
	function GetPreferredValue(pPreferred1 in varchar2, pPreferred2 in varchar2) return varchar2 ;
	function GetPreferredValue(pPreferred1 in varchar2, pPreferred2 in varchar2, pPreferred3 in varchar2) return varchar2 ;
	function GetPreferredValue(pPreferred1 in number, pPreferred2 in number) return number ;
	function GetPreferredValue(pPreferred1 in number, pPreferred2 in number, pPreferred3 in number) return number ;
      function getVersion return varchar2 ; -- added 8/12/2008 by dse
      PROCEDURE version ; -- added 8/12/2008 by dse

end amd_preferred_pkg ;
 
/


DROP PACKAGE AMD_OWNER.AMD_REQS_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.Amd_Reqs_Pkg AS
	/*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.7  $
         $Date:   15 Jan 2009 15:57:06  $
     $Workfile:   AMD_REQS_PKG.pks  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_REQS_PKG.pks-arc  $
/*
/*      Rev 1.7   15 Jan 2009 15:57:06   zf297a
/*   converted from loc_sid to spo_location for amd_backorder_sum
/*
/*      Rev 1.6   Nov 29 2006 13:40:36   c402417
/*   Modified functions for Backorder Diff using spo_prime_part_no due to modified table amd_backorder_sum.
/*
/*      Rev 1.5   Jun 28 2006 13:15:06   zf297a
/*   Added the interfaces for the amd_backorder_spo_sum diff
/*
/*      Rev 1.4   Jun 09 2006 12:25:06   zf297a
/*   added interface version
/*
/*      Rev 1.3   Apr 28 2006 13:51:00   zf297a
/*   updated package end statment: end amd_reqs_pkg ;
/*
/*      Rev 1.2   12 Aug 2005 10:48:46   c402417
/*   Added amd_reqs and amd_backorder_sum diff fucntions
/*
/*      Rev 1.1   May 06 2005 09:07:02   c970183
/*   fixed deleteRow and added PVCS keywords

*/
	   -------------------------------------------------------------------
	   -- SCCSID: amd_reqs_pkg.sql 1.2 Modified: 06/26/02 10:36:43
	   --
	   --  Date	  		  By			History
	   --  ----			  --			-------
	   --  12/10/01		  ks			initial implementation
	   --  06/26/02		  ks			modified action code from not Deleted to in
	   --  				  		add or change - performance issue
	   -------------------------------------------------------------------

	SUCCESS							CONSTANT  NUMBER := 0;
	FAILURE							   CONSTANT  NUMBER := 4;

	PROCEDURE LoadAmdReqs;
	 /* amd_reqs  diff  function */

	FUNCTION InsertRow(
			 		   		  	REQ_ID 			 		IN VARCHAR2,
								PART_NO					IN VARCHAR2,
								LOC_SID					IN NUMBER,
								QUANTITY_DUE			   IN NUMBER) RETURN NUMBER;

	FUNCTION UpdateRow(
			 		   			 REQ_ID					   	  IN VARCHAR2,
								 PART_NO					  IN VARCHAR2,
								 LOC_SID 					  IN NUMBER,
								 QUANTITY_DUE				  IN NUMBER) RETURN NUMBER;

	FUNCTION DeleteRow(
			 		   			 REQ_ID						   IN VARCHAR2,
								 PART_NO					   IN VARCHAR2,
								 LOC_SID					   IN NUMBER) RETURN NUMBER;


	/* amd_backorder_sum diff function */

	FUNCTION InsertRowBackorder(
			 		   	 SPO_PRIME_PART_NO	In varchar2,
						 spo_location							   IN varchar2,
						 QTY								   IN NUMBER) RETURN NUMBER;

	FUNCTION UpdateRowBackorder(
			 		   	 SPO_PRIME_PART_NO		In varchar2,
						 spo_location							   IN varchar2,
						 QTY								   IN NUMBER) RETURN NUMBER;


	FUNCTION DeleteRowBackorder(
			 		   	 SPO_PRIME_PART_NO		In varchar2,
						 spo_location							   IN varchar2) RETURN NUMBER;

	-- added 6/9/2006 by dse
	procedure version ;

	-- added 6/28/2006 by dse
	FUNCTION InsertRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type,
						 qty		IN amd_backorder_spo_sum.QTY%type) RETURN NUMBER ;
	FUNCTION UpdateRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type,
						 qty		IN amd_backorder_spo_sum.QTY%type) RETURN NUMBER ;
	FUNCTION DeleteRowSpoSum(
	  		   			 spo_prime_part_no	IN amd_backorder_spo_sum.SPO_PRIME_PART_NO%type) RETURN NUMBER ;

END Amd_Reqs_Pkg;
 
/


DROP PACKAGE AMD_OWNER.AMD_RMADS_SOURCE_TMP_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_rmads_source_tmp_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
     $Date:   Dec 01 2005 09:46:34  $
    $Workfile:   amd_rmads_source_tmp_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_rmads_source_tmp_pkg.pks-arc  $
/*
/*      Rev 1.1   Dec 01 2005 09:46:34   zf297a
/*   Add pvcs keywords
*/

	procedure LoadRmadsIntoAnsi;

end amd_rmads_source_tmp_pkg;
 
/


DROP PACKAGE AMD_OWNER.AMD_SPARE_NETWORKS_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_spare_networks_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
        $Date:   Nov 30 2005 09:34:38  $
    $Workfile:   amd_spare_networks_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_spare_networks_pkg.pks-arc  $
/*
/*      Rev 1.1   Nov 30 2005 09:34:38   zf297a
/*   added pvcs keywords
*/

  PROCEDURE auto_load_spare_networks;
END amd_spare_networks_pkg;
 
/


DROP PACKAGE AMD_OWNER.AMD_SPARE_PARTS_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.Amd_Spare_Parts_Pkg AS
    /*
       $Author:   zf297a  $
     $Revision:   1.44  $
         $Date:   26 Jul 2013
     $Workfile:   AMD_SPARE_PARTS_PKG.pks  $

      Rev 1.44 removed a2a dependencies
         
      Rev 1.43   24 Oct 2008 10:43:50   zf297a
   Made mDebug private by putting it in the package body.
   Added interfaces setDebug and getDebugYorN.
   
      Rev 1.42   23 Oct 2008 21:28:50   zf297a
   Added out parameter is_spo_part to the interface of updateFlags.
   
      Rev 1.41   22 Sep 2008 15:47:14   zf297a
   Made updateFlags public
   
      Rev 1.40   27 Mar 2008 12:08:14   zf297a
   Made constant unable_to_get_prime_part unique for Oracle 10g
   
      Rev 1.39   20 Nov 2007 10:24:46   zf297a
   Added wesm_indicator as the last argument for insertRow and updateRow.  Made function getQtyDue public so it can be used in an SQL statement - in particular so it can be used in cursor curDue of procedure loadCurrentBackorder.
   
      Rev 1.38   14 Feb 2007 13:57:08   zf297a
   Added amcDemand and amcDemandCleaned to the interface of insertRow and updateRow.
   
      Rev 1.37   Jun 09 2006 12:29:34   zf297a
   added interface version
   
      Rev 1.36   Mar 08 2006 09:26:18   zf297a
   Added mtbdr_computed.

      Rev 1.35   Jun 16 2005 15:53:18   c970183
   Changed errorMsg to be the same as the errorMsg in the a2a_pkg: this uses a unique pError_location number to pinpoint the block of code that has the exception.  Also, added some user defined exception instead of return codes.

      Rev 1.34   Jun 03 2005 12:50:10   c970183
   Added the procedure loadCurrentBackOrder for amd_national_stock_items.current_backorder

      Rev 1.33   May 16 2005 11:59:52   c970183
   Moved time_to_repair_off_base and cost_to_repair_off_base from amd_part_locs to amd_national_stock_items.  Created "changed indicators" for both of these fields.

      Rev 1.32   May 02 2005 12:53:12   c970183
   Added error code for 'deleteRow'

      Rev 1.30   Apr 22 2005 08:09:26   c970183
   added addtional debug code

      Rev 1.29   Apr 18 2005 10:54:44   c970183
   Added new parameters to insertRow and updateRow.  Leveraged the old routines by just defining the new parameters as global member variables and invoking the old insertRow and updateRow methods.   Change the insert and update of amd_national_stock_items to use the new global member variables.

      Rev 1.28   Mar 24 2005 14:37:06   c970183
   added ver 1.40 - 1.45 changes.  Plus fixed a2a trans

      Rev 1.27   Mar 24 2005 09:36:22   c970183
   Added qpei_weighted, order_lead_time_cleaned, unit_cost_cleaned, planner_code_cleaned, smr_code_cleaned, cost_to_repair_off_base_cleand to InsertRow and UpdateRow

      Rev 1.23   30 Aug 2002 11:46:26   c970183
   Fixed updating of the prime_part_no.   When a prime_part_no and its equivalent parts got deleted and reinserted,  the logic caused the amd_national_stock_items.prime_part_no column to get set to a null value.  To accomodate this condition code has been added to the equivalent part section that checks for an existing amd_nsi_parts.part_no with its prime_ind set to 'Y'.  If found it makes sure that the same part_no appears in amd_national_stock_items.prime_part_no.

      Rev 1.22   07 Aug 2002 08:58:24   c970183
   Set unassignment_date to sysdate for deleted parts.

      Rev 1.21   11 Apr 2002 09:26:18   c970183
   Put SCCS keywords back into the file

      Rev 1.20   08 Apr 2002 12:14:48   c970183
   Added acquisition_advice_code

      Rev 1.19   05 Apr 2002 09:30:28   c970183
   Added return code: unable to chg nsn_type and constants for amd_nsns.nsn_type

      Rev 1.18   04 Apr 2002 13:25:28   c970183
   Added mic_code_lowest to the InsertRow and UpdateRow routines.

      Rev 1.17   28 Mar 2002 12:41:58   c970183
   added comment and log regarding sleep/insert exception handler

      SCCSID:    %M%    %I%    Modified: %G%  %U%
      10/02/01 Douglas Elder   Initial implementation
      03/21/02 Douglas Elder    Added Sleep(5) to insure
                                  a unique key for amd_nsi_parts
      03/28/02 Douglas Elder    Added insertagain_err code - since the sleep
                                        is now only executed for insert exceptions
      04/04/02 Douglas Elder    Added Mic Code to insert and update
      04/05/02 Douglas Elder    Added return code: unable to chg nsn_type
                                        and constants for amd_nsns.nsn_type
     */
    -- return values from InsertRow, UpdateRow, and DeleteRow

    SUCCESS                            CONSTANT NUMBER := 0 ;
    FAILURE                            CONSTANT NUMBER := 4 ;

    -- amd_nsns.nsn_type values

    TEMPORARY_NSN                         CONSTANT VARCHAR2(1) := 'T' ;
    CURRENT_NSN                             CONSTANT VARCHAR2(1) := 'C' ;

    /* NOTE: Most of these return values should not occur, but
        if they do occur there is probably a coding error that
        needs to be corrected.  The return value should help
        to isolate the section of code that caused the problem.
        The return value and associated data are recorded in the
        amd_load_details table
        */

    PART_NOT_PRIME                    CONSTANT NUMBER := 8 ;
    UNABLE_TO_PRIME_INFO            CONSTANT NUMBER := 12 ;
    UNABLE_TO_INSERT_SPARE_PART        CONSTANT NUMBER := 16 ;
    UNABLE_TO_INSERT_AMD_NSNS        CONSTANT NUMBER := 20 ;
    UNABLE_TO_INSERT_AMD_NSI_PARTS    CONSTANT NUMBER := 24 ;
    CANNOT_UPDT_NSN_NAT_STCK_ITEMS    CONSTANT NUMBER := 28 ;
    cannotGetNsiSid                    exception ;
    CANNOT_UPDATE_SPARE_PARTS_NSN    CONSTANT NUMBER := 36 ;
    CANNOT_UPADATE_NAT_STCK_ITEMS     CONSTANT NUMBER := 40 ;
    CANNOT_UPDATE_AMD_NSNS            CONSTANT NUMBER := 44 ;
    CANNOT_GET_UNIT_COST_CLEANED    CONSTANT NUMBER := 48 ;
    CHK_NSN_AND_PRIME_ERR            CONSTANT NUMBER := 52 ;
    UNABLE_TO_DELT_PART_NOT_FOUND     CONSTANT NUMBER := 56 ;
    UNABLE_TO_DLET_NAT_STK_ITEM        CONSTANT NUMBER := 60 ;
    UNABLE_TO_RESET_NAT_STK_ITEM    CONSTANT NUMBER := 64 ;
    INSERT_PRIMEPART_ERR            CONSTANT NUMBER := 68 ;
    INS_PRIME_PART_ERR                CONSTANT NUMBER := 72 ;
    UPDATE_NATSTK_ERR                CONSTANT NUMBER := 76 ;
    INS_EQUIV_PART_ERR                CONSTANT NUMBER := 80 ;
    INS_AMD_NSI_PARTS_ERR            CONSTANT NUMBER := 84 ;
    UPD_AMD_SPARE_PARTS_NSN            CONSTANT NUMBER := 88 ;
    LOGICAL_INSERT_FAILED            CONSTANT NUMBER := 92 ;
    partAlreadyExists                exception ;
    INSERTROW_FAILED                CONSTANT NUMBER := 100 ;
    UNASSIGN_PRIME_PART_ERR            CONSTANT NUMBER := 104 ;
    UNASSIGN_OLD_PRIME_PART_ERR        CONSTANT NUMBER := 108 ;
    UPD_NSI_PARTS_ERR                CONSTANT NUMBER := 116 ;
    ASSIGN_NEW_PRIME_PART_ERR        CONSTANT NUMBER := 120 ;
    UPDATE_ERR                        CONSTANT NUMBER := 124 ;
    UNABLE_TO_GET_PRIME_PART        CONSTANT NUMBER := 128 ;
    UPDT_PRIME_PART_ERR                CONSTANT NUMBER := 132 ;
    MAKE_NEW_PRIME_PART_ERR            CONSTANT NUMBER := 136 ;
    UNASSIGN_EQUIV_PART_ERR            CONSTANT NUMBER := 140 ;
    UPD_NSN_SPARE_PARTS_ERR            CONSTANT NUMBER := 144 ;
    ASSIGN_PRIME_TO_EQUIV_ERR        CONSTANT NUMBER := 148 ;
    UPD_PRIME_PART_ERR                CONSTANT NUMBER := 152 ;
    UNABLE_TO_GET_NSI_SID            CONSTANT NUMBER := 156 ;
    UNABLE_TO_PREP_DATA                CONSTANT NUMBER := 160 ;
    UNABLE_TO_GET_NUM_ACTIVE_PARTS    CONSTANT NUMBER := 164 ;
    UNABLE_TO_PROC_INS_OR_DLET        CONSTANT NUMBER := 170 ;
    UNABLE_TO_SET_TACTICAL_IND        CONSTANT NUMBER := 174 ;
    UNABLE_TO_SET_SMR_CODE            CONSTANT NUMBER := 178 ;
    UNABLE_TO_SET_UNIT_COST            CONSTANT NUMBER := 182 ;
    ADD_PLANNER_CODE_ERR            CONSTANT NUMBER := 186 ;
    ADD_UOM_CODE_ERR                CONSTANT NUMBER := 190 ;
    UPDT_ERR_NATIONAL_STK_ITEMS        CONSTANT NUMBER := 194 ;
    ASSIGN_NEW_EQUIV_PART_ERR        CONSTANT NUMBER := 198 ;
    UPDT_NULL_PRIME_COLS_ERR        CONSTANT NUMBER := 202 ;
    INSERT_NEW_NSN_ERR                CONSTANT NUMBER := 206 ;
    UPDT_NSN_PRIME_ERR                CONSTANT NUMBER := 210 ;
    CREATE_NATSTKITEM_ERR            CONSTANT NUMBER := 214 ;
    PREP_DATA_FOR_UPDT_ERR            CONSTANT NUMBER := 218 ;
    UPDT_SPAREPART_ERR                CONSTANT NUMBER := 222 ;
    UPDT_PRIMEPART_ERR                CONSTANT NUMBER := 226 ;
    UPDT_NATSTKITEM_ERR                CONSTANT NUMBER := 230 ;
    NEW_NSN_ERR                        CONSTANT NUMBER := 234 ;
    GET_NSISID_BY_PART_ERR            CONSTANT NUMBER := 238 ;
    NEW_NSN_ERROR                    CONSTANT NUMBER := 242 ;
    CHK_NSN_AND_PRIME_ERR2            CONSTANT NUMBER := 246 ;
    INSERTAGAIN_ERR                    CONSTANT NUMBER := 248 ;
    UNABLE_TO_CHG_NSN_TYPE            CONSTANT NUMBER := 252 ;
    UNABLE_TO_UNASSIGN_PART            CONSTANT NUMBER := 256 ;
    UNABLE_TO_GET_PRIME_PART_X        CONSTANT NUMBER := 260 ;
    UPDT_NULL_PRIME_COLS_ERR2        CONSTANT NUMBER := 264 ;
    CANNOT_UPDATE_ORDER_LEAD_TIME   CONSTANT NUMBER := 268 ;
    UPDT_ERRX                        CONSTANT NUMBER := 270 ;
    CANNOT_UPDATE_PART_PRICING        CONSTANT NUMBER := 274 ;
    DELETE_ERR                        CONSTANT NUMBER := 278 ;



    FUNCTION InsertRow
                (pPart_no IN VARCHAR2,
                pMfgr IN VARCHAR2,
                pDate_icp IN DATE,
                pDisposal_cost IN NUMBER,
                pErc IN VARCHAR2,
                pIcp_ind IN VARCHAR2,
                pNomenclature IN VARCHAR2,
                pOrder_lead_time IN NUMBER,
                pOrder_quantity IN NUMBER,
                pOrder_uom IN VARCHAR2,
                pPrime_ind IN VARCHAR2,
                pScrap_value IN NUMBER,
                pSerial_flag IN VARCHAR2,
                pShelf_life IN NUMBER,
                pUnit_cost IN NUMBER,
                pUnit_volume IN NUMBER,
                pNsn IN VARCHAR2,
                pNsn_type IN VARCHAR2,
                pItem_type IN VARCHAR2,
                pSmr_code IN VARCHAR2,
                pPlanner_code IN VARCHAR2,
                pMic_code_lowest IN VARCHAR2,
                pAcquisition_advice_code IN VARCHAR2,
                pMmac IN VARCHAR2,
                pUnitOfIssue IN VARCHAR2,
                pMtbdr in number,
                pMtbdr_computed in number,
                  pQpeiWeighted in number,
                  pCondemnAvgCleaned in number,
                  pCriticalityCleaned in number,
                  pMtbdrCleaned in number,
                  pNrtsAvgCleaned in number,
                  pCosToRepairOffBaseCleand in number,
                  pTimeToRepairOffBaseCleand in  number,
                  pOrderLeadTimeCleaned in number,
                  pPlannerCodeCleaned in amd_national_stock_items.planner_code_cleaned%type,
                  pRtsAvgCleaned in number,
                  pSmrCodeCleaned in amd_national_stock_items.smr_code_cleaned%type,
                  pUnitCostCleaned in number,
                  pCondemnAvg in number,
                  pCriticality in number,
                  pNrtsAvg in number,
                  pRtsAvg in number,
                pCostToRepairOffBase in number,
                pTimeToRepairOffBase in number,
                pAmcDemand in number,
                pAmcDemandCleaned in number,
                pWesmIndicator in  varchar2) return number ;



    FUNCTION UpdateRow
                (pPart_no IN VARCHAR2,
                pMfgr IN VARCHAR2,
                pDate_icp IN DATE,
                pDisposal_cost IN NUMBER,
                pErc IN VARCHAR2,
                pIcp_ind IN VARCHAR2,
                pNomenclature IN VARCHAR2,
                pOrder_lead_time IN NUMBER,
                pOrder_quantity IN NUMBER,
                pOrder_uom IN VARCHAR2,
                pPrime_ind IN VARCHAR2,
                pScrap_value IN NUMBER,
                pSerial_flag IN VARCHAR2,
                pShelf_life IN NUMBER,
                pUnit_cost IN NUMBER,
                pUnit_volume IN NUMBER,
                pNsn IN VARCHAR2,
                pNsn_type IN VARCHAR2,
                pItem_type IN VARCHAR2,
                pSmr_code IN VARCHAR2,
                pPlanner_code IN VARCHAR2,
                pMic_code_lowest IN VARCHAR2,
                pAcquisition_advice_code IN VARCHAR2,
                pMmac IN VARCHAR2,
                pUnitOfIssue IN VARCHAR2,
                pMtbdr in number,
                pMtbdr_computed in number,
                  pQpeiWeighted in number,
                  pCondemnAvgCleaned in number,
                  pCriticalityCleaned in number,
                  pMtbdrCleaned in number,
                  pNrtsAvgCleaned in number,
                  pCosToRepairOffBaseCleand in number,
                  pTimeToRepairOffBaseCleand in  number,
                  pOrderLeadTimeCleaned in number,
                  pPlannerCodeCleaned in amd_national_stock_items.planner_code_cleaned%type,
                  pRtsAvgCleaned in number,
                  pSmrCodeCleaned in amd_national_stock_items.smr_code_cleaned%type,
                  pUnitCostCleaned in number,
                  pCondemnAvg in number,
                  pCriticality in number,
                  pNrtsAvg in number,
                  pRtsAvg in number,
                pCostToRepairOffBase in number,
                pTimeToRepairOffBase in number,
                pAmcDemand in number,
                pAmcDemandCleaned in number,
                pWesmIndicator in varchar2) return number ;


    function DeleteRow(
                            pPart_no in varchar2,
                            pNomenclature in varchar2,
                            pMfgr in varchar2 ) return number ;

    procedure loadCurrentBackOrder(debug in boolean := False) ;

    function getQtyDue(primePartNo in varchar2) return number ; -- added 11/20/2007 by dse

    
    -- added 6/9/2006 by dse
    procedure version ;
    
    
    function getVersion return varchar2 ; -- added 4/15/2008 by dse
    
    procedure updateFlags(pPart_no in amd_spare_parts.part_no%type, 
        is_spo_part out amd_spare_parts.is_spo_part%type) ; -- added 9/22/2008

    procedure setDebug(switch in varchar2) ; -- added 10/24/2008 by dse
   
    function getDebugYorN return varchar2 ; -- added 10/24/2008 by dse

-- 4/6/2012 DSE added former a2a functions
   FUNCTION isValidRepairablePart (partNo                 IN VARCHAR2,
                                  preferredSmrCode       IN VARCHAR2,
                                  preferredMtbdr         IN NUMBER,
                                  preferredPlannerCode   IN VARCHAR2,
                                  showReason             IN BOOLEAN := FALSE)
     RETURN BOOLEAN;
     
       FUNCTION isValidRepairablePart (partNo       IN AMD_SPARE_PARTS.part_no%TYPE,
                                  showReason   IN BOOLEAN := FALSE)
       RETURN BOOLEAN;

      FUNCTION isValidConsumablePart (part_no IN VARCHAR2)
      RETURN BOOLEAN;

END Amd_Spare_Parts_Pkg ;
 
/


DROP PACKAGE AMD_OWNER.AMD_TEST_DATA;

CREATE OR REPLACE PACKAGE AMD_OWNER.Amd_Test_Data  AS
    /*
        PVCS Keywords

       $Author:   c402417  $
     $Revision:   1.12  $
         $Date:   Nov 22 2005 11:06:10  $
     $Workfile:   AMD_TEST_DATA.pks  $
          $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_test_data.pks-arc  $
   
      Rev 1.12   Nov 22 2005 11:06:10   c402417
   Removed obsolete codes.

*/
    PROCEDURE setTestProperty(value IN NUMBER) ;
    FUNCTION getTestProperty RETURN NUMBER ;

    /* Cleans out amd_spare_parts and all related tables
        so they are ready for an initial load.
    */
    FUNCTION DeleteAmdSpareParts RETURN BOOLEAN ;

    /* Cleans out specific amd_spare_parts and all related tables
        so they are ready for an initial load.
    */
    FUNCTION DeleteAmdSparePart(pNsi_sid IN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE) RETURN BOOLEAN ;

    /* Cleans out the amd_param_changes and amd_params
        table
    */
    FUNCTION DeleteParameters RETURN BOOLEAN ;

    /* Loads the amd_params and amd_param_changes with some
        initial values.
    */
    FUNCTION CreateParameters RETURN BOOLEAN ;

    /* Tests InsertRow and UpdateRow of the
        amd_spare_parts_pkg.
    */
    FUNCTION test_amd_spare_parts_pkg RETURN BOOLEAN ;

    /* This procedure is necessary, since some back to back
        tests could cause a dup key to be produced, when part
        of the key uses the System Data - sysdate.
    */
    PROCEDURE sleep(secs IN NUMBER) ;
    /* A Pl/SQL specific version of a Diff function
        for amd_spare_parts
        */
    FUNCTION Diff RETURN NUMBER ;
    FUNCTION PrimeCheckForTmpAmdSpareParts RETURN BOOLEAN ;
    FUNCTION PrimeCheckForAmdNsiParts RETURN BOOLEAN ;


    FUNCTION TestDefaults RETURN BOOLEAN ;

    FUNCTION TestGetNsiSid RETURN BOOLEAN ;

    FUNCTION revision RETURN VARCHAR2 ;

    PROCEDURE helloWorld ;

    PROCEDURE genXml ;

    --PROCEDURE orderInfoXml ;

    --PROCEDURE orderInfoLineXml ;

    PROCEDURE fix_national_stock_items ;

END;
 
/


DROP PACKAGE AMD_OWNER.AMD_TMAPI_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_tmapi_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.2  $
     $Date:   Dec 01 2005 09:48:18  $
    $Workfile:   amd_tmapi_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_TMAPI_PKG.PKS-arc  $

      Rev 1.2   Dec 01 2005 09:48:18   zf297a
   added pvcs keywords
*/
	   -------------------------------------------------------------------
	   --  Date	  		  By			History
	   --  ----			  --			-------
	   --  12/03/01		  ks			initial implementation
	   -------------------------------------------------------------------

	   -- when need extra help for sql queries for tmapi

	function GetPriority(pNsn amd_spare_parts.nsn%type, pPartNo amd_spare_parts.part_no%type) return number;
	pragma restrict_references(DEFAULT,WNDS) ;
end amd_tmapi_pkg;
 
/


DROP PACKAGE AMD_OWNER.AMD_UTILS;

CREATE OR REPLACE PACKAGE AMD_OWNER.Amd_Utils AS
/*
       $Author:   zf297a  $
     $Revision:   1.43  $
         $Date:   24 Jun 2009 09:30:50  $
     $Workfile:   amd_utils.pks  $
	 $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_utils.pks-arc  $

      Rev 1.43   24 Jun 2009 09:30:50   zf297a
   Added interface for convertToBase and groupPriority.

      Rev 1.42   24 Mar 2009 15:37:06   zf297a
   Changed the interface for getSpoPrimePartNo and added interface for isSpoPartYorN.

      Rev 1.41   24 Mar 2009 15:20:56   zf297a
   Added interfaces for getDebug, setDebug, getDebugCnt, setDebugCnt, getDebugThreshold, setDebugThreshold, getLastLoadDetail, and emptyTraceTables.

      Rev 1.40   09 Sep 2008 15:21:28   zf297a
   added interfaces:
   function isDiffYorN(oldText in varchar2, newText in varchar2) return varchar2 ;
   function isDiffYorN(oldNum in number, newNum in number) return varchar2 ;
   function isDiffYorN(oldDate in date, newDate in Date) return varchar2 ;


      Rev 1.39   23 May 2008 13:12:34   zf297a
   Added interface for function validatePlannerCode.

      Rev 1.38   22 May 2008 16:44:26   zf297a
   Added interface for getVersion.

      Rev 1.37   22 May 2008 09:03:36   zf297a
   Defined interfaces for isForeignMilitarySale and isForeignMilitarySaleYorN

      Rev 1.36   19 Sep 2007 16:57:26   zf297a
   Added new interfaces for isPartConsumable and isPartConsumablesYorN.  Added new interfaces IsRepairableSmrCode and isRepairSmrCodeYorN.

      Rev 1.35   19 Jul 2007 13:28:02   zf297a
   Added the following interfaces:
   isWesmPart(part_no)
   isWesmPartYorN(part_no)
   getPrimePartNo(nsn) returns the prime_part_no from amd_national_stock_items

      Rev 1.34   25 May 2007 14:21:56   zf297a
   Added transformNsn

      Rev 1.33   24 May 2007 14:44:56   zf297a
   Added interfaces isPartConsumable and isPartConsumableYorN

      Rev 1.32   03 Apr 2007 14:36:48   zf297a
   Define interface cleanTraceTables

      Rev 1.31   22 Mar 2007 10:14:48   zf297a
   Added interface for isSpoPrimePart

      Rev 1.30   21 Mar 2007 11:39:24   zf297a
   Defined interfaces for functions:
   isPartActiveYorN
   isPartActive
   isNsnActiveYorN
   isNsnActive


      Rev 1.29   Nov 09 2006 08:45:52   zf297a
   Added interface rank

      Rev 1.27   Sep 25 2006 15:16:06   zf297a
   added interface for isDiff with date parameters

      Rev 1.26   Sep 18 2006 13:14:18   zf297a
   added overloaded boolean functions isDiff

      Rev 1.25   Sep 12 2006 10:56:32   zf297a
   added interface for isNumber and isNumberYorN

      Rev 1.24   Aug 23 2006 09:43:48   zf297a
   Defined interface for boolean function isPartRepairable and
   the interface for varchar2 function isPartRepairableYorN.

      Rev 1.23   Jul 13 2006 12:12:42   zf297a
   Added interface for getSpoPrimePartNo.

      Rev 1.22   Jun 09 2006 11:27:30   zf297a
   added version interface

      Rev 1.21   Jun 01 2006 10:55:58   zf297a
   Added writeMsg

      Rev 1.19   Nov 09 2005 11:25:46   zf297a
   Added interface for isPrimePartYorN.

      Rev 1.18   Sep 09 2005 00:20:36   zf297a
   Changed splitString and joinString to use a single character delimiter.

      Rev 1.17   Sep 07 2005 09:44:42   zf297a
   Added the arrayOfWords 'type' and interfaces splitString and joinString.

      Rev 1.16   Sep 02 2005 15:05:32   zf297a
   Added interfaces for getLocType,  isPrimePart, getPrimePart, getEquivalentParts, equivalentParts

      Rev 1.17   Aug 19 2005 12:41:06   zf297a
   Added functions bizDays2CalendarDays, months2CalendarDays, and getSiteLocation.

      Rev 1.16   Aug 19 2005 11:35:16   c378632
   add GetNsiSidFromPartNo

      Rev 1.15   07 Jun 2005 22:13:08   c378632
   add GetLocationInfo, GetSpoLocation, GetPartNo

      Rev 1.14   May 17 2005 10:03:58   c970183
   Removed redundant version of InsertErrorMessage

      Rev 1.13   May 13 2005 14:19:00   c970183
   For the insertErrorMsg procedure all parameters are now optional.  The load_no will still get set, the key5 variable will get set if it is null to the sysdate, and the comments column will get set to sqlcode and sqlerrm.

      Rev 1.12   May 02 2005 13:35:34   c970183
   Removed the global mDebug - each package should have their own mDebug flag which determines if the debug code is executed.

      Rev 1.11   Apr 21 2005 08:17:08   c970183
   Created debugMsg which can be controlled via mDebug and mDebugThreshold.  Both params can be controlled by the package user or the amd_param_changes table.  The data from amd_param_changes is loaded at package initialization, therefore the settings given by the package user have a higher priority since they can be overriden at any time during the session.

      Rev 1.9   05 Sep 2002 10:16:34   c970183
   Added $Log$ keyword and changed variable name from sendorAddress to senderAddress

	--
	-- SCCSID: %M%  %I%  Modified: %G% %U%
	--
	-- Date     By     History
	-- -------- -----  ---------------------------------------------------
	-- 10/14/01 FF     Initial implementation
	-- 10/17/01 DSE		Added GetNsiSid functions
	-- 10/24/01 ks		added GetLocSid
	-- 10/28/01 ks		added GetLocType, GetLocId
	-- 10/30/01 dse		added a variation of InsertErrorMsg with all
						the fields for amd_load_details
	-- 09/05/02 dse		added sendMail procedure
	-- 9/3/04 dse		added stronger data typing for GetLoadNo and InsertErrorMsg
	-- 06/07/05 ks		add GetLocationInfo, GetSpoLocation, GetPartNo
	-- 06/09/05 ks		add GetNsiSidFromPartNo
	   					(signatures often equivalent for other GetNsiSid -
						received too many functions match this call)
*/

type equivalent_parts is ref cursor return amd_spare_parts%rowtype ;
type parts is table of amd_spare_parts%Rowtype ;
type arrayOfWords is varray(50) of varchar2(512) ;

subtype orderOfUsage is varchar2(3) ;
type orderOfUsages is table of orderOfUsage index by orderOfUsage ;

mDebugThreshold NUMBER := 1000 ; -- this can be controlled by the user of the package
				                 -- or by amd_param_changes / debugUtilsThreshold

-- when this routine has been executed pDebugThreshold times, it will not create any more
-- output
PROCEDURE debugMsg(pMsg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE,
			  pPackage IN AMD_LOAD_DETAILS.KEY_1%TYPE := 'amd_utils',
			  pLocation IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE := 999,
			  pMsg2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
			  pMsg3 IN AMD_LOAD_DETAILS.key_3%TYPE := '',
			  pMsg4 IN AMD_LOAD_DETAILS.key_4%TYPE := '') ;


FUNCTION GetLoadNo(
							pSourceName AMD_LOAD_STATUS.SOURCE%TYPE,
							pTableName AMD_LOAD_STATUS.TABLE_NAME%TYPE) RETURN NUMBER ;

FUNCTION FormatNsn(
							pNsn VARCHAR2,
							pType VARCHAR2 DEFAULT 'AMD') RETURN VARCHAR2;

PROCEDURE InsertErrorMsg (
							pLoad_no IN AMD_LOAD_DETAILS.load_no%TYPE := NULL,
							pData_line_no IN AMD_LOAD_DETAILS.data_line_no%TYPE := NULL,
							pData_line IN AMD_LOAD_DETAILS.data_line%TYPE := NULL,
							pKey_1 IN AMD_LOAD_DETAILS.key_1%TYPE := NULL,
							pKey_2 IN AMD_LOAD_DETAILS.key_2%TYPE := NULL,
							pKey_3 IN AMD_LOAD_DETAILS.key_3%TYPE := NULL,
							pKey_4 IN AMD_LOAD_DETAILS.key_4%TYPE := NULL,
							pKey_5 IN AMD_LOAD_DETAILS.key_5%TYPE := NULL,
							pComments IN AMD_LOAD_DETAILS.comments%TYPE := NULL ) ;

	-- source is amd_nsns
	FUNCTION GetNsiSid(pNsn IN AMD_NSNS.nsn%TYPE) RETURN AMD_NSNS.nsi_sid%TYPE ;
	PRAGMA RESTRICT_REFERENCES(GetNsiSid,WNDS) ;


	-- source is amd_nsi_parts
	FUNCTION GetNsiSid(pPart_no IN AMD_NSI_PARTS.part_no%TYPE) RETURN AMD_NSI_PARTS.nsi_sid%TYPE ;
	PRAGMA RESTRICT_REFERENCES(GetNsiSid,WNDS) ;

	FUNCTION GetLocSid(pLocId AMD_SPARE_NETWORKS.loc_id%TYPE) RETURN AMD_SPARE_NETWORKS.loc_sid%TYPE;
	FUNCTION GetLocType(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_type%TYPE;
	FUNCTION GetLocId(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_id%TYPE;
	PROCEDURE sendMail(senderAddress   VARCHAR2, receiverAddress VARCHAR2, subject VARCHAR2, mesg VARCHAR2) ;

	-- added 06/07/05
	-- GetPartNo only return active parts
	FUNCTION GetPartNo(pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE)	RETURN AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE ;
	FUNCTION GetSpoLocation(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) 	RETURN AMD_SPARE_NETWORKS.spo_location%TYPE ;
	PRAGMA RESTRICT_REFERENCES (GetPartNo, WNDS) ;
	PRAGMA RESTRICT_REFERENCES (GetSpoLocation, WNDS) ;
	FUNCTION GetLocationInfo(pLocSid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN	AMD_SPARE_NETWORKS%ROWTYPE ;

	-- added 06/09/05
	FUNCTION GetNsiSidFromPartNo(pPart AMD_NSI_PARTS.part_no%TYPE) RETURN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE ;

	-- added 08/19/05
	FUNCTION bizDays2CalendarDays(bizDays IN INTEGER) RETURN INTEGER ;
	FUNCTION months2CalendarDays(months IN DECIMAL) RETURN NUMBER ;
	FUNCTION getSiteLocation(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_id%TYPE ;

	-- added 9/1/2005
	FUNCTION getLocType(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_type%TYPE ;

	FUNCTION isPrimePart(part_no AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN ;
	-- added 11/9/2005
	function isPrimePartYorN(part_no amd_spare_parts.part_no%type) return varchar2 ;
	-- for any part number return the prime part - if the input is the prime it will return itself
	function getPrimePart(part_no amd_nsi_parts.part_no%type) return amd_national_stock_items.prime_part_no%type ;

	-- for any part number, return a cursor with all the equivalent parts (could return 0 rows)
	function getEquivalentParts(part_no amd_spare_parts.part_no%type) return equivalent_parts ;

	function equivalentParts(part_no amd_spare_parts.part_no%type) return parts PIPELINED ;

	-- added 9/7/2005
	function splitString(text in varchar2, delim in varchar2 := ',') return arrayOfWords ;
	function joinString(words in arrayOfWords, delim in varchar2 := ',') return varchar2 ;

	-- added 10/7/2005 by DSE
	function getCageCode(part_no in varchar2) return varchar2 ;

	-- added 10/12/2005 by DSE
	function getUnitCostDefaulted(part_no in varchar2) return amd_spare_parts.unit_cost_defaulted%type ;

	-- added 03/03/2006 by DSE
	function boolean2Varchar2(theValue in boolean, YorN in boolean := false) return varchar2 ;

	-- added 6/1/2006 by DSE
	-- record a note in amd_load_details
	procedure writeMsg(
		pSourceName in varchar2,
		pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
		pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
		pKey1 IN VARCHAR2 := '',
		pKey2 IN VARCHAR2 := '',
		pKey3 IN VARCHAR2 := '',
		pKey4 in varchar2 := '',
		pData IN VARCHAR2 := '',
		pComments IN VARCHAR2 := '')  ;

	-- added 6/9/2006 by DSE
	procedure version ;

	-- added 7/13/2006 by DSE
	FUNCTION getSpoPrimePartNo(part_no AMD_spare_parts.part_no%TYPE) RETURN AMD_spare_parts.SPO_PRIME_PART_NO%TYPE ;

	-- add 8/22/2006 by DSE
	function isPartRepairable(part_no amd_spare_parts.part_no%type) return boolean ;
	function isPartRepairableYorN(part_no amd_spare_parts.part_no%type) return varchar2 ;

	-- added 9/12/2006 by DSE
	function isNumber( p_string in varchar2 ) return boolean ;
	-- added 9/12/2006 by DSE
	function isNumberYorN( p_string in varchar2) return varchar2 ;


	-- added 9/18/2006 by DSE
	function isDiff(oldText in varchar2, newText in varchar2) return boolean ;
	-- added 9/18/2006 by DSE
	function isDiff(oldNum in number, newNum in number) return boolean ;
	-- added 9/25/2006 by DSE
	function isDiff(oldDate in date, newDate in Date) return boolean ;

	-- added 10/13/2006 by DSE
	function getNsn(part_no in amd_spare_parts.part_no%type) return amd_spare_parts.nsn%type ;

	-- added 11/09/2006
	function rank(orderOfUsage in varchar2) return number ;

	-- added 11/22/2006
	function isOneWay(orderOfUse in orderOfUsages) return boolean ;
	function isOneWayYorN(orderOfUse in orderOfUsages) return varchar2 ;

    -- added 3/21/2007
    function isPartActiveYorN(part_no in amd_spare_parts.PART_NO%type) return varchar2 ;
    function isPartActive(part_no in amd_spare_parts.part_no%type) return boolean ;
    function isNsnActiveYorN(nsn in amd_nsns.NSN%type) return varchar2 ;
    function isNsnActive(nsn in amd_nsns.NSN%type) return boolean ;

    -- added 3/22/2007
    function isSpoPrimePart(part_no in amd_spare_parts.part_no%type) return boolean ;
	function isSpoPrimePartYorN(part_no in amd_spare_parts.part_no%type) return varchar2 ;

    -- added 4/3/2007 by dse
    procedure cleanTraceTables ;

    -- added 9/19/2007 by dse
   function isPartConsumable(preferred_smr_code amd_national_stock_items.smr_code%type,
        preferred_planner_code amd_national_stock_items.planner_code%type,
        nsn amd_national_stock_items.nsn%type) return boolean ;
   function isPartConsumableYorN(preferred_smr_code amd_national_stock_items.smr_code%type,
        preferred_planner_code amd_national_stock_items.planner_code%type,
        nsn amd_national_stock_items.nsn%type) return varchar2 deterministic ;

    -- this was written to be used by a trigger to avoid ora-04091 - table name is mutating
   	function isRepairableSmrCode(preferred_smr_code amd_national_stock_items.smr_code%type) return boolean ;
   	function isRepairableSmrCodeYorN(preferred_smr_code amd_national_stock_items.smr_code%type)
                return varchar2 deterministic ;

    -- added 5/24/2007 by dse

    function isPartConsumable(part_no amd_spare_parts.part_no%type) return boolean ;
    function isPartConsumableYorN(part_no amd_spare_parts.part_no%type) return varchar2 ;

    -- added 7/13/2007 by tp
    function isWesmPart(part_no in amd_national_stock_items.prime_part_no%type) return boolean;
    function isWesmPartYorN(part_no in amd_national_stock_items.prime_part_no%type) return varchar2;


    function transformNsn(nsn in varchar2) return varchar2  ;

    function getPrimePartNo(nsn in varchar2) return varchar2 ;

    -- added 5/22/2008 by dse
    function isForeignMilitarySale(segment_code in varchar2) return boolean ;
    function isForeignMilitarySaleYorN(segment_code in varchar2) return varchar2 ;

    function getVersion return varchar2 ;

    function validatePlannerCode(planner_code in amd_planners.planner_code%type)
        return amd_planners.PLANNER_CODE%type ; -- added 5/23/2008 by dse

    function isDiffYorN(oldText in varchar2, newText in varchar2) return varchar2 ;
    function isDiffYorN(oldNum in number, newNum in number) return varchar2 ;
    function isDiffYorN(oldDate in date, newDate in Date) return varchar2 ;

    function getDebugYorN return varchar2 ;
    procedure setDebug(value in varchar2) ;

    function getDebugCnt return number ;
    procedure setDebugCnt(value in number) ;

    function getDebugThreshold return number ;
    procedure setDebugThreshold(value in number) ;

    function getLastLoadDetail return number ;

    procedure emptyTraceTables ;

    function isSpoPartYorN(part_no in amd_spare_parts.part_no%type) return amd_spare_parts.is_spo_part%type ;

    function convertToBase(value in number, base in number) return varchar2 ;
 	function groupPriority(rank in number) return varchar2 ;



END Amd_Utils;
 
/


DROP PACKAGE AMD_OWNER.AMD_VALIDATION_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_validation_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.3  $
     $Date:   Dec 01 2005 09:50:48  $
    $Workfile:   amd_validation_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_validation_pkg.pks-arc  $

      Rev 1.3   Dec 01 2005 09:50:48   zf297a
   added pvcs keywords
*/
    /*
     	10/01/01 Douglas Elder and Chung Lu  Initial implementation
     */

	SUCCESS					constant number := 0 ;
	FAILURE					constant number := 3 ;
	INSERT_PLANNER_CODE_ERR	constant number := 6 ;
	INSERT_UOM_ERR			constant number := 9 ;

	/* return SUCCESS if planner_code exists in amd_planners
		and return FAILURE if it does not.
	*/
	function IsValidUomCode(pUom_code amd_uoms.uom_code%type) return boolean ;

	/* return SUCCESS if planner_code exists in amd_planners
		and return FAILURE if it does not.
	*/
	function IsValidPlannerCode(pPlanner_code amd_planners.planner_code%type) return boolean ;

	/* return SUCCESS if planner_code is added to amd_planners
		and return FAILURE if it is not.
	*/
    function AddUomCode(pUom_code amd_uoms.uom_code%type ) return number ;
	/* return SUCCESS if planner_code is added to amd_planners
		and return FAILURE if it is not.
	*/
    function AddPlannerCode(pPlanner_code amd_planners.planner_code%type ) return number ;

	/* return Y if the unit_cost and smr_code are not null, else return N */
    function GetTacticalInd(pUnit_cost in amd_spare_parts.unit_cost%type, pSmr_code in amd_national_stock_items.smr_code%type) return amd_spare_parts.tactical%type ;
end amd_validation_pkg ;
 
/


DROP PACKAGE AMD_OWNER.AMD_WARNINGS_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.amd_warnings_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.3  $
     $Date:   30 Jan 2009 09:11:10  $
    $Workfile:   amd_warnings_pkg.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_warnings_pkg.pks.-arc  $
/*
/*      Rev 1.3   30 Jan 2009 09:11:10   zf297a
/*   Add t_array binary indexed array type and the split function interface to split a string into a t_array.
/*
/*      Rev 1.2   29 Jan 2009 15:05:28   zf297a
/*   Added args to sendWarnings with default values.  Added a function sendWarnings that returns the number of warnings for the current batch job.
/*
/*      Rev 1.1   16 Jan 2009 23:25:12   zf297a
/*   Added interface for procedure insertWarningMsg
/*
/*      Rev 1.0   16 Jan 2009 10:56:44   zf297a
/*   Initial revision.

    This package is used to compile warnings during a batch load of AMD.
*/

	TYPE t_array IS TABLE OF VARCHAR2(255)
		INDEX BY BINARY_INTEGER;

	FUNCTION SPLIT (p_in_string VARCHAR2, p_delim VARCHAR2) RETURN t_array;
	procedure addWarnings(warning in varchar2);
	function warningsExistForCurJob return boolean ;
	function warningsExistForCurJobYorN return varchar2 ;

	procedure sendWarnings(toEmailAddr in varchar2,
		subject in varchar2 := 'AMD Load Warnings',
		fromEmailAddr in varchar2 := 'AMDLOAD') ;

	/* do the same thing as sendWarnings and return
	 * the number of messages sent - zero means nothing was sent
	 */
	function sendWarnings(toEmailAddr in varchar2,
		subject in varchar2 := 'AMD Load Warnings',
		fromEmailAddr in varchar2 := 'AMDLOAD') return number ;

	procedure insertWarningMsg (
		pData_line_no IN amd_load_warnings.data_line_no%TYPE := NULL,
		pData_line IN amd_load_warnings.data_line%TYPE := NULL,
		pKey_1 IN amd_load_warnings.key_1%TYPE := NULL,
		pKey_2 IN amd_load_warnings.key_2%TYPE := NULL,
		pKey_3 IN amd_load_warnings.key_3%TYPE := NULL,
		pKey_4 IN amd_load_warnings.key_4%TYPE := NULL,
		pKey_5 IN amd_load_warnings.key_5%TYPE := NULL,
		pWarning IN amd_load_warnings.warning%TYPE := NULL ) ;


end amd_warnings_pkg ;
 
/


DROP PACKAGE AMD_OWNER.CONSUMABLES_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.consumables_Pkg AS
    
/*
      $Author:   zf297a  $
    $Revision:   1.8 $
        $Date:   26 Jul 2013
    $Workfile:   consumables_PKG.pks  $
    
         Rev 1.8 removed a2a dependencies
/*   
/*      Rev 1.7   13 Oct 2008 09:17:22   zf297a
/*   Added setDebug interface
/*   
/*      Rev 1.6   28 Aug 2008 15:33:34   zf297a
/*   Added interface getVersion
/*   
/*      Rev 1.5   12 Aug 2008 08:05:58   zf297a
/*   Added new interface isPartValidYorN with additional arguments: part_no,  smr_code, nsn, planner_code, and mtbdr.
/*   
/*      Rev 1.4   19 Sep 2007 16:53:54   zf297a
/*   Added new public interface isPartValid.
/*   
/*      Rev 1.3   16 Aug 2007 14:25:48   zf297a
/*   Added interface for procedure version.
/*   
/*      Rev 1.2   01 Jun 2007 11:30:08   zf297a
/*   put showReason in spec so that it can easily be turned on for all routines and removed it from all interfaces.
/*   Added new interface insertPartInfo with action code and all data that is needed to perform the action.
/*   
/*      Rev 1.1   30 May 2007 09:06:00   zf297a
/*   Added interface for isPlannerCodeValid and isPlannerCodeValidYorN
/*   
/*      Rev 1.0   29 May 2007 12:53:24   zf297a
/*   Initial revision.
*/    

    showReason boolean := false ;

    -- added 8/7/2008 by dse
    function isPartValidYorN(part_no in varchar2,    
        smr_code     in    amd_national_stock_items.smr_code%type,
        nsn          in    amd_spare_parts.nsn%type,
        planner_code in    amd_national_stock_items.planner_code%type,
        mtbdr        in    amd_national_stock_items.MTBDR%type ) return varchar2 ;

    function isPartValid(part_no in varchar2) return boolean ;
    function isPartValidYorN(part_no in varchar2) return varchar2 ;
    -- added 9/19/2007 by dse
    function isPartValid(part_no in varchar2,    
        smr_code     in    amd_national_stock_items.smr_code%type,
        nsn          in    amd_spare_parts.nsn%type,
        planner_code in    amd_national_stock_items.planner_code%type,
        mtbdr        in    amd_national_stock_items.MTBDR%type ) return boolean ;
        
    procedure insertPartInfo(part_no in varchar2, action_code in varchar2) ;
    
    procedure insertPartInfo(action_code in varchar2, part_no in varchar2, nomenclature in varchar2,
           mfgr in varchar2,  unit_issue in varchar2, smr_code in varchar2, nsn in varchar2, planner_code in varchar2,
           third_party_flag in varchar2, mtbdr in number, price in number) ;
    
    function isPlannerCodeValid(plannerCode in amd_national_stock_items.planner_code%type) return boolean ;
    function isPlannerCodeValidYorN(plannerCode in amd_national_stock_items.planner_code%type) return varchar2 ;
    
    
    procedure version ;
    function getVersion return varchar2 ; -- added 8/28/2008 by dse
    procedure setDebug(switch in varchar2) ; -- added 10/11/2008 by dse
    
end consumables_pkg ;
 
/


DROP PACKAGE AMD_OWNER.EMAIL_HANDLER_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.email_handler_pkg is

/*
      $Author:   zf297a  $
    $Revision:   1.1  $
        $Date:   10 Apr 2009 15:31:08  $
    $Workfile:   email_handler_pkg.sql  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Scripts\AMD 3.7 Implementation\AMD 3.7.2 Implementation\email_handler_pkg.sql.-arc  $
/*
/*      Rev 1.1   10 Apr 2009 15:31:08   zf297a
/*   added missing package body
/*
/*      Rev 1.1   23 Jan 2009 17:59:06   zf297a
/*   Added interface for a more flexible send procedure
/*
/*      Rev 1.0   16 Jan 2009 11:02:16   zf297a
/*   Initial revision.
*/

	type array is table of varchar2(255);

	procedure send( p_sender_email in varchar2,
		p_from         in varchar2,
		p_to           in array default array(),
		p_cc           in array default array(),
		p_bcc          in array default array(),
		p_subject      in varchar2,
		p_body         in long );

    procedure send_email(subject in varchar2,
        to_userid in varchar2 := NULL,
        v_body in varchar2 := NULL,
        from_name in varchar2 := NULL,
        to_name in varchar2 := NULL,
        content_type in varchar2 := NULL);
        
    procedure setDebug(flag in char) ;                     

end email_handler_pkg ;
/


DROP PACKAGE AMD_OWNER.REPAIRABLES_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.repairables_Pkg AS
 --
 -- SCCSID:   %M%   %I%   Modified: %G%  %U%
 --
 /*
      $Author:   zf297a  $
    $Revision:   1.74  $
     $Date:   26 Jul 2013

         rev 1.74 removed all a2a dependencies
         
         Rev 1.73 renamed the package repairables_pkg
         
/*      Rev 1.72   12 Aug 2008 08:15:44   zf297a
/*   Added interface isPartValidYorN with additional arguments: part_no, preferred smr_code, preferred mtbdr, and preferred planner_code.
/*   
/*      Rev 1.71   31 Jul 2008 11:16:42   zf297a
/*   Changed interface for getAssignedPlannerCode ... just use part_no as an argument.
/*   
/*      Rev 1.70   27 Jun 2008 12:09:00   zf297a
/*   Added get/set's for deleteChildrenThreshold
/*   
/*      Rev 1.69   15 May 2008 19:43:52   zf297a
/*   removed mDebug from the package spec.  debug now only gets set with the setDebug procedure and retrived with the getDebugYorN function.
/*   
/*      Rev 1.68   30 Jan 2008 10:50:12   zf297a
/*   Added set/get for the debug and debug thresholds.  Added function to retrieve the version.
/*   
/*      Rev 1.67   Nov 14 2007 16:36:28   c402417
/*   Add procedures InsertTimeToRepair and InsertPartLeadTime.
/*   
/*      Rev 1.66   06 Nov 2007 15:06:20   zf297a
/*   Added table types to be used by bulk collects.
/*   
/*      Rev 1.65   27 Sep 2007 18:54:10   zf297a
/*   Changed interface for loadAllA2A added interface for initA2APartAlt.
/*   
/*      Rev 1.64   19 Sep 2007 17:14:40   zf297a
/*   Added new interface for insertPartInfo.  This interface allows for all the data to be passed to the procedure versus it needing to retrieve it.
/*   Added new interface isPartValid.  This interface allows for all the data to be passed to the function versus it needing to retrieve it.
/*   Added new procedure insertTmpA2APartInfo.  This procedure allows for a row to be inserted into the tmp_a2a_part_info table after having been verified to be repairable or consumable and a valid part for the SPO.
/*   
/*      Rev 1.63   25 Jun 2007 08:16:04   zf297a
/*   Changed the value for the rcm_ind's constants and prefixed its name with RCM.
/*   
/*      Rev 1.62   04 Jun 2007 13:01:36   zf297a
/*   Added interfaces lpOverrideExists and lpOverrideExistsYorN
/*   
/*      Rev 1.61   25 May 2007 13:32:26   zf297a
/*   Added constants CONSUMABLE and REPAIRABLE to the spec.  Added the following functions:
/*   getValidRcmInd
/*   isPlannerCodeValidlannerCode
/*   isPlannerCodeValidYorNlannerCode
/*   getAcquisitionAdviceCodeart_no
/*   isNsnInRblPairssn
/*   isNsnInRblPairsYorNsn
/*   isNsnInIsgPairssn
/*   isNsnInIsgPairsYorNsn
/*   isNsnValidart_no
/*   isNsnValidYorNart_no
/*   demandExistsart_no
/*   demandExistsYorNart_no
/*   inventoryExistsart_no
/*   inventoryExistsYorNart_no
/*   
/*   
/*      Rev 1.60   12 Apr 2007 11:54:22   zf297a
/*   Added interfaces for isSpoPrimePartActive, which returns true if the given spo_prime_part_no is in amd_sent_to_a2a as a part_no that has an action_code not equal to D.
/*   Added interface isSpoPrimePartYorN.
/*   
/*      Rev 1.59   12 Apr 2007 10:23:48   zf297a
/*   Added interfaces isPartActive, which returns true if the part does not have an action_code of D in amd_sent_to_a2a.  Added interface isPartActiveYorN and getSentToA2AActionCode.
/*   
/*      Rev 1.58   29 Mar 2007 12:42:54   zf297a
/*   Added interfaces for tmpA2ALocPartOverrideAddOk, tmpA2AInvInfoAddOk, tmpA2ARepairInvInfoAddOk, and tmpA2AInTransitsAddOk
/*   
/*      Rev 1.57   29 Mar 2007 09:12:22   zf297a
/*   Added interface tmpA2AOrderInfoLineAddOk
/*   
/*      Rev 1.56   29 Mar 2007 00:06:36   zf297a
/*   Added interfaces tmpA2APartInfoAddOk and tmpA2APartInfoAddYorN.
/*   
/*      Rev 1.55   21 Mar 2007 11:35:50   zf297a
/*   Added interfaces for functions:
/*   partExistsInDataSystems
/*   partExistsInDataSystemsYorN
/*   isDataSysPartMarkedDeleted
/*   isDataSysPartMarkedDeletedYorN
/*   
/*   
/*      Rev 1.54   06 Mar 2007 09:55:36   zf297a
/*   Removed insertTmpA2AOrderInfo
/*   added insertTmpA2AOrderInfoLine
/*   
/*      Rev 1.53   27 Feb 2007 16:41:40   zf297a
/*   Added interface includeOrderYorN
/*   
/*      Rev 1.52   21 Feb 2007 20:22:52   zf297a
/*   Added mtbdr_computed to the  PartInfoRec
/*   
/*      Rev 1.51   Oct 26 2006 12:07:22   zf297a
/*   Added interface for procedure deleteSentToA2AChildren.
/*   
/*      Rev 1.50   Oct 25 2006 10:36:20   zf297a
/*   Defined constants using anchored declarations via the %type attribute.
/*   Added interfaces for get functions to return the constants.
/*   
/*      Rev 1.49   Oct 20 2006 12:17:42   zf297a
/*   Add a new interface for boolean function isPartSent and for varchar2 function isPartSentYorN.
/*   
/*      Rev 1.48   Aug 31 2006 11:36:36   zf297a
/*   Added interface for initA2ADemands
/*   
/*      Rev 1.47   Aug 18 2006 15:36:46   zf297a
/*   Added interface for processExtForecast and added 2 interfaces for initA2AExtForecasts.  Defined extForecastCur type.
/*   
/*      Rev 1.46   Aug 10 2006 14:29:32   zf297a
/*   Added an optional param that will display the reason a part is not valid if the param is set to true or Y for the boolean function isPartValid and the varchar2 function, isPartValidYorN, that returns Y or N
/*   
/*      Rev 1.45   Aug 04 2006 12:55:38   zf297a
/*   Added interface getDueDate and changed the interface includeOrder by adding part_no as an argument
/*   
/*      Rev 1.44   Aug 04 2006 11:08:46   zf297a
/*   Made the boolean function includeOrder public
/*   
/*      Rev 1.43   Jul 11 2006 14:33:28   c402417
/*   Modified TYPE inTransitsCur from AMD_IN_TRANSITS to AMD_IN_TRANSITS_SUM.
/*   
/*      Rev 1.42   Jun 07 2006 20:59:10   zf297a
/*   added version procedure
/*   
/*      Rev 1.41   May 12 2006 13:57:14   zf297a
/*   Removed deletesOk from the wasPartSent interface.  Now using a global variable mblnSendAllData, which has its own getter and setter.
/*   Changed all init routines to include DELETED action codes and to use all part_no's contained in amd_sent_to_a2a that also have a spo_prime_part_no.
/*   
/*      Rev 1.40   May 12 2006 10:23:10   zf297a
/*   Allowed for A2A part delete transactions to be sent again
/*   
/*      Rev 1.39   Apr 27 2006 14:51:40   zf297a
/*   Changed interface for loadAll by adding an optional system_id
/*   
/*      Rev 1.38   Mar 03 2006 14:42:46   zf297a
/*   added loadAll procedure - this sends all the a2a data
/*   
/*      Rev 1.37   Feb 15 2006 13:39:06   zf297a
/*   Added cur ref's for all init and byDate routines + a common process routine to make sure everything is done the same no matter what selection criteria is used.
/*   
/*      Rev 1.36   Jan 04 2006 09:01:44   zf297a
/*   Added two overloaded procedures initA2ABackorderInfo which can accept a list of parts or a range of dates like the othe initA2A procedures.
/*   
/*      Rev 1.35   Jan 03 2006 12:44:14   zf297a
/*   Added date range to procedures 
/*   initA2AInvInfo
/*   initA2ARepairInvInfo
/*   initA2AInTransits
/*   initA2ARepairInfo
/*   initA2AOrderInfo
/*   initA2APartInfo
/*   initA2ABomDetail
/*   
/*   
/*      Rev 1.34   Dec 30 2005 01:32:08   zf297a
/*   added initA2ABomDetail by date
/*   
/*      Rev 1.33   Dec 29 2005 16:37:54   zf297a
/*   added initA2A by date procedures for PartInfo, OrderInfo, InvInfo, RepairInfo, InTransits, and RepairInvInfo
/*   
/*      Rev 1.32   Nov 30 2005 10:52:02   zf297a
/*   Added interface for BomDetail
/*
/*      Rev 1.31   Nov 10 2005 10:12:18   zf297a
/*   Added interface deleteInvalidParts
/*
/*      Rev 1.30   Nov 09 2005 11:09:56   zf297a
/*   Added interfaces:  wasPartSentYorN, isPartValidYorN, isPlannerCodeAssign2UserIdYorN, and isNslYorN.
/*
/*      Rev 1.29   Oct 27 2005 15:46:38   c402417
/*   Added expected_completion_date in fucntion InsertRepairInfo.
/*
/*      Rev 1.28   Oct 27 2005 10:21:38   zf297a
/*   Added interfaces deletePartInfo, which can be used to generate deletes for all parts or a set of test parts.  Added interface getTimeToRepair, so this previously private function is now a public function and so it can be tested using Toad's debugger.
/*
/*      Rev 1.27   Oct 19 2005 10:21:34   zf297a
/*   removed interface for insertTmpA2AOrderInfoLine and changed the interface for insertTmpA2AOrderInfo.   insertTmpA2AOrderInfo will now insert both the tmp_a2a_order_info and tmp_a2a_order_info_line.
/*
/*      Rev 1.26   Oct 10 2005 09:32:16   zf297a
/*   Added price to insertPartInfo and updatePartInfo
/*
/*      Rev 1.25   Oct 07 2005 12:18:22   zf297a
/*   Added cage_code to tmp_a2a_order_info and tmp_a2a_part_lead_time.  Created a separate procedure to init tmp_a2a_part_lead_time.
/*
/*      Rev 1.24   Sep 09 2005 11:11:22   zf297a
/*   Changed insertInvInfo to use spo_location, which comes from amd_spare_networks.spo_location.  However, the a2a transactions still refers to it as site_location so that name is left along for the tmp_a2a_inv_info table.
/*
/*      Rev 1.24   Aug 19 2005 12:36:10   zf297a
/*   removed functions bizDays2CalendarDays, months2CalendarDays, and getSiteLocation and put them in amd_utils
/*
/*      Rev 1.23   Aug 16 2005 14:28:56   zf297a
/*   Made getSiteLocation public
/*
/*      Rev 1.22   Aug 15 2005 14:46:22   zf297a
/*   added initA2ASpoUsers
/*
/*      Rev 1.20   Aug 10 2005 09:59:10   zf297a
/*   Added functions convertCleanedOrderLeadTime and convertOrderLeadTime.
/*
/*      Rev 1.19   Aug 04 2005 14:40:36   zf297a
/*   Added interface for insertTmpA2ASpoUsers.
/*
/*      Rev 1.18   Jul 20 2005 07:46:18   zf297a
/*   using only bems_id for a2a for spo users
/*
/*      Rev 1.17   Jul 19 2005 14:18:02   zf297a
/*   added spoUser procedure to create the a2a transactions for the spo_user
/*
/*      Rev 1.16   Jul 11 2005 12:38:40   zf297a
/*   added function initA2AInvInfo
/*
/*      Rev 1.15   Jul 11 2005 12:29:04   zf297a
/*   fixed name of initA2AInTransits
/*
/*      Rev 1.14   Jul 11 2005 12:26:22   zf297a
/*   added function initA2AInTransits
/*
/*      Rev 1.13   Jul 11 2005 12:14:54   zf297a
/*   added function initA2ARepairInfo
/*
/*      Rev 1.12   Jul 11 2005 11:47:48   zf297a
/*   added procedure insertTmpA2AInTransits
/*
/*      Rev 1.11   Jul 11 2005 11:16:52   zf297a
/*   Made wasPartSent and isPartValid public functions
/*
/*      Rev 1.9   Jul 11 2005 10:37:38   zf297a
/*   added procedure to insertTmpA2AOrderInfo and insertTmpA2AOrderInfoLine
/*
/*      Rev 1.8   Jun 22 2005 15:03:32   c970183
/*   Made the interface for the inita2aPartInfo more flexible.
/*
/*      Rev 1.7   Jun 10 2005 11:20:04   c970183
/*   Streamlined insertSiteRespAssetMgr, insertInvInfo, and insertRepairInfo.
/*
/*      Rev 1.6   May 18 2005 08:57:04   c970183
/*   Added getIndenture public method.  Modified inita2a to use getIndenture.
/*
/*      Rev 1.5   May 13 2005 14:39:32   c970183
/*   For a given part_no create an update transaction in tmp_a2a_part_info.  action_code may be overridden too.
/*
/*      Rev 1.4   Apr 22 2005 08:05:10   c970183
/*   Added debug code.  Added mArgs: a global variable containing the list of arguments to any public function or procedure.
/*
/*      Rev 1.2   27 Aug 2004 14:33:06   c970183
/*   Added s 'NEW BUY', 'REPAIR', and 'ORDER'.
/*
/*      Rev 1.1   12 Aug 2004 14:30:48   c970183
/*   added insert, update, and delete functions for a2a tables.  implemented insert functions for part data.
/*
/*      Rev 1.0   Jul 19 2004 14:10:48   c970183
/*   Initial revision.
    */
     SUCCESS           CONSTANT NUMBER := 0 ;
     FAILURE           CONSTANT NUMBER := 4 ;
     NEW_BUY           CONSTANT varchar2(20) := 'NEW-BUY' ;
     REPAIR            CONSTANT varchar2(20) := 'REPAIR' ;
     AN_ORDER           CONSTANT varchar2(5) := 'ORDER' ;
     OPEN_STATUS       CONSTANT varchar2(1)   := 'O' ;
     THIRD_PARTY_FLAG CONSTANT varchar2(1) := '?' ;
     RCM_REPAIRABLE   CONSTANT varchar2(1) := 'T' ; -- used for rcm_ind
     RCM_CONSUMABLE   CONSTANT varchar2(1) := 'F' ; -- used for rcm_ind
     
     APPLICATION_ERROR EXCEPTION ;
    
     
      TYPE partInfoRec IS RECORD (
           mfgr           AMD_SPARE_PARTS.mfgr%TYPE, 
          part_no      AMD_SPARE_PARTS.part_no%TYPE,
          NOMENCLATURE AMD_SPARE_PARTS.nomenclature%TYPE,
          nsn           AMD_SPARE_PARTS.nsn%TYPE,
          order_lead_time AMD_SPARE_PARTS.order_lead_time%TYPE,
          order_lead_time_defaulted AMD_SPARE_PARTS.order_lead_time_defaulted%TYPE,
          unit_cost                    AMD_SPARE_PARTS.unit_cost%TYPE,
          unit_cost_defaulted        AMD_SPARE_PARTS.unit_cost_defaulted%TYPE,
          unit_of_issue                AMD_SPARE_PARTS.unit_of_issue%TYPE,
          unit_cost_cleaned            AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE,
          order_lead_time_cleaned    AMD_NATIONAL_STOCK_ITEMS.order_lead_time_cleaned%TYPE,
          planner_code                AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE,
          planner_code_cleaned        AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE,
          mtbdr                        AMD_NATIONAL_STOCK_ITEMS.mtbdr%TYPE,
          mtbdr_cleaned                AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE,
          mtbdr_computed            AMD_NATIONAL_STOCK_ITEMS.mtbdr_computed%type,
          smr_code                    AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE,
          smr_code_cleaned            AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE,
          smr_code_defaulted        AMD_NATIONAL_STOCK_ITEMS.smr_code_defaulted%TYPE,
          nsi_sid                    AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE,
          TIME_TO_REPAIR_OFF_BASE_CLEAND AMD_NATIONAL_STOCK_ITEMS.TIME_TO_REPAIR_OFF_BASE_CLEAND%TYPE,
          last_update_dt            AMD_SPARE_PARTS.last_update_dt%TYPE,
          action_code                AMD_SPARE_PARTS.action_code%TYPE
    ) ;
    
    TYPE part2Delete IS RECORD (
           part_no AMD_SPARE_PARTS.part_no%TYPE,
          nomenclature AMD_SPARE_PARTS.nomenclature%TYPE
    ) ;
    
    
     TYPE partCur IS REF CURSOR RETURN partInfoRec ;
     type partTab is table of partInfoRec ;
     
     TYPE onHandInvSumCur IS REF CURSOR RETURN AMD_ON_HAND_INVS_SUM%ROWTYPE ;
     type onHandInvSumTab is table of amd_on_hand_invs_sum%rowtype ;
     
     TYPE repairInvInfoCur IS REF CURSOR RETURN AMD_REPAIR_INVS_SUM%ROWTYPE ;
     type repairInvInfoTab is table of amd_repair_invs_sum%rowtype ;
     
     TYPE inTransitsCur IS REF CURSOR RETURN AMD_IN_TRANSITS_SUM%ROWTYPE ;
     type inTransitsTab is table of amd_in_transits_sum%rowtype ;
     
     TYPE inRepairCur IS REF CURSOR RETURN AMD_IN_REPAIR%ROWTYPE ;
     type inRepairTab is table of amd_in_repair%rowtype ;
     
     TYPE onOrderCur IS REF CURSOR RETURN AMD_ON_ORDER%ROWTYPE ;
     type onOrderTab is table of amd_on_order%rowtype ;
     
     TYPE part2DeleteCur IS REF CURSOR RETURN part2Delete ;
     type part2DeleteTab is table of part2Delete ;
     
     TYPE bomDetailCur IS REF CURSOR RETURN AMD_SENT_TO_A2A%ROWTYPE ;
     type bomDetailTab is table of amd_sent_to_a2a%rowtype ;
     
     TYPE backOrderCur IS REF CURSOR RETURN AMD_BACKORDER_SUM%ROWTYPE ;
     type backOrderTab is table of amd_backorder_sum%rowtype ;
     
     type extForecastCur is ref cursor return amd_part_loc_forecasts%rowtype ;
     type extForecastTab is table of amd_part_loc_forecasts%rowtype ;
     
     PROCEDURE processParts(parts IN partCur) ;
     PROCEDURE processPartLeadTimes(parts IN partCur) ;
     PROCEDURE processOnHandInvSum(onHandInvSum IN onHandInvSumCur) ;
     PROCEDURE processRepairInvInfo(repairInvInfo IN repairInvInfoCur) ;
     PROCEDURE processInTransits(inTransit IN inTransitsCur) ;
     PROCEDURE processInRepair(inRepair IN inRepairCur) ;
     PROCEDURE processOnOrder(onOrder IN onOrderCur) ;
     PROCEDURE deletePartInfo(partInfo IN part2DeleteCur) ;
     PROCEDURE processBomDetail(bomDetail IN bomDetailCur) ;
     PROCEDURE processBackOrder(backOrder IN backOrderCur) ;
     PROCEDURE processExtForecast(extForecast IN extForecastCur) ;
    
    
    
    
     FUNCTION getIndenture(smr_code_preferred IN AMD_NATIONAL_STOCK_ITEMS.SMR_CODE%TYPE) RETURN varchar2 ;
    
     FUNCTION getAssignedPlannerCode(part_no IN amd_spare_parts.part_no%TYPE) RETURN AMD_PLANNERS.planner_code%TYPE  ;
    
     FUNCTION createPartInfo(part_no IN VARCHAR2,
            action_code IN VARCHAR2 := Amd_Defaults.UPDATE_ACTION) RETURN NUMBER ;
    
     procedure InsertPartInfo(part_no in varchar2, action_code in varchar2) ;
     
           
     FUNCTION InsertPartInfo(
            mfgr IN VARCHAR2,
           part_no IN VARCHAR2,
           unit_issue IN VARCHAR2,
           nomenclature IN VARCHAR2,
           smr_code IN VARCHAR2,
           nsn IN VARCHAR2,
           planner_code IN VARCHAR2,
           third_party_flag IN VARCHAR2,
           mtbdr      IN NUMBER,
           indenture IN VARCHAR2,
           price IN NUMBER) RETURN NUMBER;

     PROCEDURE insertPartInfo(
           part_no IN VARCHAR2,
           nomenclature IN VARCHAR2,
           action_code IN VARCHAR2,
            mfgr IN VARCHAR2 := NULL,
           unit_issue IN VARCHAR2 := NULL,
           smr_code IN VARCHAR2 := NULL,
           nsn IN VARCHAR2 := NULL,
           planner_code IN VARCHAR2 := NULL,
           third_party_flag IN VARCHAR2 := NULL,
           mtbdr      IN NUMBER := NULL,
           indenture IN VARCHAR2 := NULL,
           price IN NUMBER := NULL) ; 
    
     FUNCTION UpdatePartInfo(
           mfgr IN VARCHAR2,
           part_no IN VARCHAR2,
           unit_issue IN VARCHAR2,
           nomenclature IN VARCHAR2,
           smr_code IN VARCHAR2,
           nsn IN VARCHAR2,
           planner_code IN VARCHAR2,
           third_party_flag IN VARCHAR2,
           mtbdr      IN NUMBER,
           indenture IN VARCHAR2,
           price IN NUMBER) RETURN NUMBER;
    
     FUNCTION DeletePartInfo(
           part_no IN VARCHAR2, nomenclature IN VARCHAR2) RETURN NUMBER ;
    


     FUNCTION InsertPartLeadTime(
            part_no IN VARCHAR2,
           lead_time_type IN VARCHAR2,
           lead_time IN NUMBER) RETURN NUMBER;
    
     PROCEDURE insertPartLeadTime(
            part_no IN amd_spare_parts.PART_NO%type,
            lead_time_type varchar2,
            lead_time IN number,
            action_code IN amd_spare_parts.action_code%TYPE) ;
            
     FUNCTION UpdatePartLeadTime(
            part_no IN VARCHAR2,
           lead_time_type IN VARCHAR2,
           lead_time IN NUMBER) RETURN NUMBER;
    
     FUNCTION DeletePartLeadTime(
            part_no IN VARCHAR2) RETURN NUMBER;
    
     FUNCTION InsertPartPricing(
            part_no IN VARCHAR2,
           price_type IN VARCHAR2,
           unit_cost IN NUMBER) RETURN NUMBER;
    
     FUNCTION UpdatePartPricing(
            part_no IN VARCHAR2,
           price_type IN VARCHAR2,
           unit_cost IN NUMBER) RETURN NUMBER;
    
     FUNCTION DeletePartPricing(
            part_no IN VARCHAR2) RETURN NUMBER ;
    
    
     FUNCTION InsertLocPartLeadTime(
            part_no IN VARCHAR2,
           loc_sid IN NUMBER,
           location_name IN VARCHAR2,
           lead_time_type IN VARCHAR2,
           time_to_repair IN NUMBER) RETURN NUMBER;
    
     FUNCTION UpdateLocPartLeadTime(
            part_no IN VARCHAR2,
           loc_sid IN NUMBER,
           location_name IN VARCHAR2,
           lead_time_type IN VARCHAR2,
           time_to_repair IN NUMBER) RETURN NUMBER;
    
     FUNCTION DeleteLocPartLeadTime(
            part_no IN VARCHAR2,
           loc_sid IN NUMBER,
           location_name IN NUMBER) RETURN NUMBER;
    
           
    
     procedure initA2ADemands ;
    
    
    
     FUNCTION initA2APartInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
    
     FUNCTION initA2AOrderInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
    
     FUNCTION initA2ARepairInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
    
    
     FUNCTION initA2AInvInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
    
     FUNCTION initA2ARepairInvInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER ;
     
    
      PROCEDURE insertRepairInvInfo(part_no IN amd_spare_parts.part_no%TYPE,
        site_location IN varchar2,
        inv_qty IN number,
        action_code IN amd_spare_parts.action_code%TYPE)  ;
    
     PROCEDURE insertInvInfo(part_no IN amd_spare_parts.part_no%TYPE,
        spo_location IN varchar2 ,
        qty_on_hand IN number,
        action_code IN amd_spare_parts.action_code%TYPE)  ;
    
     PROCEDURE insertRepairInfo(part_no IN amd_spare_parts.part_no%TYPE,
        loc_sid IN NUMBER,
        doc_no IN varchar2, -- order_sid
        repair_date IN date,
        status IN varchar2,
        quantity IN number /* repair_qty */,
        expected_completion_date IN date,
        action_code IN amd_spare_parts.action_code%TYPE) ;
    
    
    
    
      FUNCTION wasPartSent(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN ;
      FUNCTION wasPartSentYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 ;
      
      FUNCTION isPartValid (partNo IN AMD_SPARE_PARTS.part_no%TYPE, showReason in boolean := false) RETURN BOOLEAN ;
      FUNCTION isPartValidYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE, showReason in varchar2 := 'N') RETURN VARCHAR2 ;
      
      function isPartValid(partNo IN VARCHAR2, 
        preferredSmrCode IN VARCHAR2, preferredMtbdr IN NUMBER, preferredPlannerCode IN VARCHAR2, 
        showReason in boolean := false) RETURN BOOLEAN ;
      function isPartValidYorN(partNo IN VARCHAR2, preferredSmrCode IN VARCHAR2, 
        preferredMtbdr IN NUMBER, preferredPlannerCode IN VARCHAR2, showReason in varchar2 := 'F') RETURN varchar2 ;

      FUNCTION isPlannerCodeAssigned2UserId(plannerCode IN VARCHAR2) RETURN BOOLEAN ;
      FUNCTION isPlannerCodeAssign2UserIdYorN(plannerCode IN VARCHAR2) RETURN VARCHAR2 ;
      FUNCTION isNsl(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN ;
      FUNCTION isNslYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 ;
      -- added 4/12/2007 by dse
      function isPartActive(part_no in amd_sent_to_a2a.part_no%type) return boolean ;
      -- added 4/12/2007 by dse
      function isPartActiveYorN(part_no in amd_sent_to_a2a.part_no%type) return varchar2 ;
      -- added 4/12/2007 by dse
      function getSentToA2AActionCode(part_no in amd_sent_to_a2a.part_no%type) return varchar2 ;
      -- added 4/12/2007 by dse
      function isSpoPrimePartActive(spo_prime_part_no in amd_sent_to_a2a.spo_prime_part_no%type) return boolean ;
      -- added 4/12/2007 by dse
      function isSpoPrimePartActiveYorN(spo_prime_part_no in amd_sent_to_a2a.spo_prime_part_no%type) return varchar2 ;
    
       PROCEDURE spoUser(bems_id IN varchar2,
      action_code IN amd_spare_parts.ACTION_CODE%TYPE) ;
    
    
     PROCEDURE initA2APartLeadTime(useTestParts IN BOOLEAN := FALSE) ;
     
     PROCEDURE initA2ABomDetail(useTestParts IN BOOLEAN := FALSE) ;
    
     PROCEDURE deletePartInfo(useTestParts IN BOOLEAN := FALSE) ;
    
     FUNCTION getTimeToRepair(loc_sid  IN AMD_IN_REPAIR.loc_sid%TYPE,
               part_no IN VARCHAR2) RETURN AMD_PART_LOCS.time_to_repair%TYPE ;
     PROCEDURE insertTimeToRepair(part_no IN AMD_SPARE_PARTS.part_no%TYPE,
              nsi_sid IN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE,
              time_to_repair_off_base_cleand IN AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base_cleand%TYPE); 
    
     PROCEDURE deleteInvalidParts (testOnly IN BOOLEAN := FALSE) ;
    
              
     START_DT constant DATE := TO_DATE('01/01/1990','MM/DD/YYYY') ;
     
     PROCEDURE initA2AInvInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
     PROCEDURE initA2ARepairInvInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
     PROCEDURE initA2AInTransits(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
     PROCEDURE initA2ARepairInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
     PROCEDURE initA2AOrderInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
     PROCEDURE initA2APartInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
     PROCEDURE initA2ABomDetail(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE ) ;
     
     PROCEDURE initA2ABackorderInfo(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE ) ;
     PROCEDURE initA2ABackorderInfo(useTestParts IN BOOLEAN := FALSE ) ;
     
     PROCEDURE initA2AExtForecast(from_dt IN DATE := start_dt, to_dt IN DATE := SYSDATE) ;
     PROCEDURE initA2AExtForecast(useTestParts IN BOOLEAN := FALSE ) ;
    
     FUNCTION getSendAllData RETURN BOOLEAN ;
     PROCEDURE setSendAllData(theIndicator IN BOOLEAN) ;
     PROCEDURE version ;

     FUNCTION includeOrderYorN(gold_order_number IN AMD_ON_ORDER.gold_order_number%TYPE, 
                             order_date IN AMD_ON_ORDER.order_date%TYPE,
                          part_no in amd_on_order.part_no%type) RETURN Varchar2 ;
     
     FUNCTION includeOrder(gold_order_number IN AMD_ON_ORDER.gold_order_number%TYPE, 
                             order_date IN AMD_ON_ORDER.order_date%TYPE,
                          part_no in amd_on_order.part_no%type) RETURN BOOLEAN ;
                          
     FUNCTION getDueDate(part_no in AMD_ON_ORDER.PART_NO%TYPE, order_date in AMD_ON_ORDER.ORDER_DATE%TYPE)  RETURN DATE ;
    -- added 10/20/2006 by dse
     function isPartSent(part_no in amd_sent_to_a2a.part_no%type) return boolean ;
    -- added 10/20/2006 by dse
     function isPartSentYorN(part_no in amd_sent_to_a2a.part_no%type) return varchar2 ;
     -- added functions to return constants 10/25/2006 by dse
     function getStart_dt return date ;
     function getNEW_BUY return varchar2 ; 
     function getREPAIR  return varchar2 ;
     function getAN_ORDER return varchar2 ;
     function getOPEN_STATUS return varchar2 ;
     function getTHIRD_PARTY_FLAG return varchar2;
     -- added 10/26/2006 by dse
     procedure deleteSentToA2AChildren ;
     
     -- added 3/21/2007 by dse
    function partExistsInDataSystems(pPartNo in datasys_part_v.part%type) return boolean ;
    function partExistsInDataSystemsYorN(pPartNo in datasys_part_v.part%type) return varchar2 ;
    function isDataSysPartMarkedDeleted(pPartNo in datasys_part_v.part%type) return boolean ;
    function isDataSysPartMarkedDeletedYorN(pPartNo in datasys_part_v.part%type) return varchar2 ;
    
    -- added 3/28/2007 by DSE
    function tmpA2APartInfoAddOk(part_no in amd_spare_parts.part_no%type) return boolean ; 
    function tmpA2APartInfoAddYorN(part_no in amd_spare_parts.part_no%type) return varchar2 ; 

    -- added 3/29/2007 by DSE
    function tmpA2AOrderInfoLineAddOk(gold_order_number in amd_on_order.gold_order_number%type, 
        from_dt in amd_on_order.order_date%type := START_DT,
        to_dt in amd_on_order.order_date%type := sysdate) return boolean ;
        
    function tmpA2ALocPartOverrideAddOk(part_no in amd_location_part_override.part_no%type) return boolean ;
    
    function tmpA2AInvInfoAddOk(part_no in AMD_ON_HAND_INVS_SUM.PART_NO%type, spo_location in amd_on_hand_invs_sum.SPO_LOCATION%type := null ) return boolean ;
    
    function tmpA2ARepairInvInfoAddOk(part_no in amd_repair_invs_sum.part_no%type,
        site_location in amd_repair_invs_sum.site_location%type := null) return boolean ;
     
     function tmpA2AInTransitsAddOk(part_no in amd_in_transits.part_no%type) return boolean ;
     
     FUNCTION getValidRcmInd(rcmInd IN VARCHAR2) RETURN VARCHAR2 ;
     
    function isPlannerCodeValid(plannerCode in amd_national_stock_items.planner_code%type,
        showReason in boolean := false) return boolean ;
    function isPlannerCodeValidYorN(plannerCode in amd_national_stock_items.planner_code%type,
        showReason in boolean := false) return varchar2 ;
    function getAcquisitionAdviceCode(part_no in amd_spare_parts.part_no%type) return varchar2 ;
    function isNsnInRblPairs(nsn in amd_spare_parts.nsn%type, showReason in boolean := false) return boolean ;
    function isNsnInRblPairsYorN(nsn in amd_spare_parts.nsn%type, showReason in boolean := false) return varchar2 ;
    function isNsnInIsgPairs(nsn in amd_spare_parts.nsn%type, showReason in boolean := false) return boolean ;
    function isNsnInIsgPairsYorN(nsn in amd_spare_parts.nsn%type, showReason in boolean := false) return varchar2 ;
    function isNsnValid(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return boolean ;
    function isNsnValidYorN(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return varchar2 ;
    function demandExists(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return boolean ;
    function demandExistsYorN(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return varchar2 ;
    function inventoryExists(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return boolean ;
    function inventoryExistsYorN(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return varchar2 ;

    -- add 6/4/2007 by dse        
    function lpOverrideExists(part_no in datasys_lp_override_v.PART%type, site_location in datasys_lp_override_v.SITE_LOCATION%type) return boolean ;
    function lpOverrideExistsYorN(part_no in datasys_lp_override_v.PART%type, site_location in datasys_lp_override_v.SITE_LOCATION%type) return varchar2 ;
    
    -- added 9/19/2007 by dse

      -- added 9/27/07
      procedure initA2APartAlt ;
      -- added 1/30/08
      function getVersion return varchar2 ;
      function getDebugYorN return varchar2 ;
      procedure setDebug(switch in varchar2) ;
      function getDebugThreshold return number ;
      procedure setDebugThreshold(value in number) ;
      function getInsertAddUpdRepairInfoCnt return number ;
      procedure setInsertAddUpdRepairInfoCnt (value in number) ;
      procedure resetDebugCnts ;
      procedure setDebugDeleteThreshold(value in number) ;
      procedure setDebugRepairInfoThreshold(value in number) ;
      procedure setAllThresholds(value in number) ;
      
      procedure setDeleteChildrenThreshold(value in number) ; -- added 6/27/2008 by dse
        
      function getDeleteChildrenThreshold return number ; -- added 6/27/2008 by dse

      

      
END repairables_Pkg ;
 
/


DROP PACKAGE AMD_OWNER.USER_PLANNER_PKG;

CREATE OR REPLACE PACKAGE AMD_OWNER.USER_PLANNER_PKG AS

 /*
      $Author:   zf297a  $
    $Revision:   1.1  $
        $Date:   01 Dec 2008 12:05:46  $
    $Workfile:   USER_PLANNER_PKG.pks  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\USER_PLANNER_PKG.pks.-arc  $
/*
/*      Rev 1.1   01 Dec 2008 12:05:46   zf297a
/*   Planner_code was removed from amd_site_asset_mgr.
/*
/*      Rev 1.0   02 Oct 2008 14:22:20   zf297a
/*   Initial revision.
*/
    ACTIVE_STATUS constant varchar2(1)  := 'A' ;
    DUPLICATE constant number := 4 ;
    INVALID_ACTION_CODE constant number := 8 ;
    INVALID_BEMS_ID constant number := 12 ;
    INVALID_PLANNER_CODE constant number := 16 ;
    SUCCESS constant number := 0 ;
    return_code number ;

    function isValidPlannerCode(planner_code in amd_planners.planner_code%type) return boolean ;
    function isValidPlannerCodeYorN(planner_code in amd_planners.planner_code%type) return varchar2 ;

    function isValidBemsId(bems_id in amd_people_all_v.bems_id%type) return boolean ;
    function isValidBemsIdYorN(bems_id in amd_people_all_v.bems_id%type) return varchar2 ;

    function insertAmdUse1Row(userid in amd_use1.userid%type,
                user_name in amd_use1.user_name%type,
                employee_no in amd_use1.employee_no%type,
                phone in amd_use1.phone%type,
                ims_designator_code in amd_use1.ims_designator_code%type,
                employee_status in amd_use1.employee_status%type) return number ;

    function insertUimsRow(userid in uims.userid%type,
                designator_code in uims.designator_code%type,
                alt_ims_des_code_b in uims.alt_ims_des_code_b%type,
                alt_es_des_code_b in uims.alt_es_des_code_b%type,
                alt_sup_des_code_b in uims.alt_sup_des_code_b%type) return number ;

   function insertSiteAssetMgr(bems_id in amd_site_asset_mgr.bems_id%type) return number ;

   function deleteSiteAssetMgr(bems_id in amd_site_asset_mgr.bems_id%type) return number ;

    procedure version ;

    function getVersion return varchar2 ;


END USER_PLANNER_PKG ;
 
/


DROP PUBLIC SYNONYM AMD_BASIC_DEFAULT_PKG;

CREATE PUBLIC SYNONYM AMD_BASIC_DEFAULT_PKG FOR AMD_OWNER.AMD_BASIC_DEFAULT_PKG;


DROP PUBLIC SYNONYM AMD_BATCH_PKG;

CREATE PUBLIC SYNONYM AMD_BATCH_PKG FOR AMD_OWNER.AMD_BATCH_PKG;


DROP PUBLIC SYNONYM AMD_BEST_SPARES_INPUT_PKG;

CREATE PUBLIC SYNONYM AMD_BEST_SPARES_INPUT_PKG FOR AMD_OWNER.AMD_BEST_SPARES_INPUT_PKG;


DROP PUBLIC SYNONYM AMD_CLEANED_FROM_BSSM_PKG;

CREATE PUBLIC SYNONYM AMD_CLEANED_FROM_BSSM_PKG FOR AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG;


DROP PUBLIC SYNONYM AMD_CLEAN_DATA;

CREATE PUBLIC SYNONYM AMD_CLEAN_DATA FOR AMD_OWNER.AMD_CLEAN_DATA;


DROP PUBLIC SYNONYM AMD_DEFAULTS;

CREATE PUBLIC SYNONYM AMD_DEFAULTS FOR AMD_OWNER.AMD_DEFAULTS;


DROP PUBLIC SYNONYM AMD_DEFAULT_EFFECTIVITY_PKG;

CREATE PUBLIC SYNONYM AMD_DEFAULT_EFFECTIVITY_PKG FOR AMD_OWNER.AMD_DEFAULT_EFFECTIVITY_PKG;


DROP PUBLIC SYNONYM AMD_DEMAND;

CREATE PUBLIC SYNONYM AMD_DEMAND FOR AMD_OWNER.AMD_DEMAND;


DROP PUBLIC SYNONYM AMD_EFFECTIVITY_PKG;

CREATE PUBLIC SYNONYM AMD_EFFECTIVITY_PKG FOR AMD_OWNER.AMD_EFFECTIVITY_PKG;


DROP PUBLIC SYNONYM AMD_EFFECTIVITY_TCTO_PKG;

CREATE PUBLIC SYNONYM AMD_EFFECTIVITY_TCTO_PKG FOR AMD_OWNER.AMD_EFFECTIVITY_TCTO_PKG;


DROP PUBLIC SYNONYM AMD_FROM_BSSM_PKG;

CREATE PUBLIC SYNONYM AMD_FROM_BSSM_PKG FOR AMD_OWNER.AMD_FROM_BSSM_PKG;


DROP PUBLIC SYNONYM AMD_INVENTORY;

CREATE PUBLIC SYNONYM AMD_INVENTORY FOR AMD_OWNER.AMD_INVENTORY;


DROP PUBLIC SYNONYM AMD_LOAD;

CREATE PUBLIC SYNONYM AMD_LOAD FOR AMD_OWNER.AMD_LOAD;


DROP PUBLIC SYNONYM AMD_LOCATION_PART_LEADTIME_PKG;

CREATE PUBLIC SYNONYM AMD_LOCATION_PART_LEADTIME_PKG FOR AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG;


DROP PUBLIC SYNONYM AMD_LOCATION_PART_OVERRIDE_PKG;

CREATE PUBLIC SYNONYM AMD_LOCATION_PART_OVERRIDE_PKG FOR AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG;


DROP PUBLIC SYNONYM AMD_LP_OVERRIDE_CONSUMABL_PKG;

CREATE PUBLIC SYNONYM AMD_LP_OVERRIDE_CONSUMABL_PKG FOR AMD_OWNER.AMD_LP_OVERRIDE_CONSUMABL_PKG;


DROP PUBLIC SYNONYM AMD_MAINT_TASK_DISTRIBS_PKG;

CREATE PUBLIC SYNONYM AMD_MAINT_TASK_DISTRIBS_PKG FOR AMD_OWNER.AMD_MAINT_TASK_DISTRIBS_PKG;


DROP PUBLIC SYNONYM AMD_NSL_SEQUENCE_PKG;

CREATE PUBLIC SYNONYM AMD_NSL_SEQUENCE_PKG FOR AMD_OWNER.AMD_NSL_SEQUENCE_PKG;


DROP PUBLIC SYNONYM AMD_ON_ORDER_DATE_FILTERS_PKG;

CREATE PUBLIC SYNONYM AMD_ON_ORDER_DATE_FILTERS_PKG FOR AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG;


DROP PUBLIC SYNONYM AMD_PARTPRIME_PKG;

CREATE PUBLIC SYNONYM AMD_PARTPRIME_PKG FOR AMD_OWNER.AMD_PARTPRIME_PKG;


DROP PUBLIC SYNONYM AMD_PART_FACTORS_PKG;

CREATE PUBLIC SYNONYM AMD_PART_FACTORS_PKG FOR AMD_OWNER.AMD_PART_FACTORS_PKG;


DROP PUBLIC SYNONYM AMD_PART_LOCS_LOAD_PKG;

CREATE PUBLIC SYNONYM AMD_PART_LOCS_LOAD_PKG FOR AMD_OWNER.AMD_PART_LOCS_LOAD_PKG;


DROP PUBLIC SYNONYM AMD_PART_LOC_FORECASTS_PKG;

CREATE PUBLIC SYNONYM AMD_PART_LOC_FORECASTS_PKG FOR AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG;


DROP PUBLIC SYNONYM AMD_PREFERRED_PKG;

CREATE PUBLIC SYNONYM AMD_PREFERRED_PKG FOR AMD_OWNER.AMD_PREFERRED_PKG;


DROP PUBLIC SYNONYM AMD_REQS_PKG;

CREATE PUBLIC SYNONYM AMD_REQS_PKG FOR AMD_OWNER.AMD_REQS_PKG;


DROP PUBLIC SYNONYM AMD_RMADS_SOURCE_TMP_PKG;

CREATE PUBLIC SYNONYM AMD_RMADS_SOURCE_TMP_PKG FOR AMD_OWNER.AMD_RMADS_SOURCE_TMP_PKG;


DROP PUBLIC SYNONYM AMD_SPARE_NETWORKS_PKG;

CREATE PUBLIC SYNONYM AMD_SPARE_NETWORKS_PKG FOR AMD_OWNER.AMD_SPARE_NETWORKS_PKG;


DROP PUBLIC SYNONYM AMD_SPARE_PARTS_PKG;

CREATE PUBLIC SYNONYM AMD_SPARE_PARTS_PKG FOR AMD_OWNER.AMD_SPARE_PARTS_PKG;


DROP PUBLIC SYNONYM AMD_TEST_DATA;

CREATE PUBLIC SYNONYM AMD_TEST_DATA FOR AMD_OWNER.AMD_TEST_DATA;


DROP PUBLIC SYNONYM AMD_TMAPI_PKG;

CREATE PUBLIC SYNONYM AMD_TMAPI_PKG FOR AMD_OWNER.AMD_TMAPI_PKG;


DROP PUBLIC SYNONYM AMD_UTILS;

CREATE PUBLIC SYNONYM AMD_UTILS FOR AMD_OWNER.AMD_UTILS;


DROP PUBLIC SYNONYM AMD_VALIDATION_PKG;

CREATE PUBLIC SYNONYM AMD_VALIDATION_PKG FOR AMD_OWNER.AMD_VALIDATION_PKG;


DROP PUBLIC SYNONYM AMD_WARNINGS_PKG;

CREATE PUBLIC SYNONYM AMD_WARNINGS_PKG FOR AMD_OWNER.AMD_WARNINGS_PKG;


DROP PUBLIC SYNONYM CONSUMABLES_PKG;

CREATE PUBLIC SYNONYM CONSUMABLES_PKG FOR AMD_OWNER.CONSUMABLES_PKG;


DROP PUBLIC SYNONYM EMAIL_HANDLER_PKG;

CREATE PUBLIC SYNONYM EMAIL_HANDLER_PKG FOR AMD_OWNER.EMAIL_HANDLER_PKG;


DROP PUBLIC SYNONYM REPAIRABLES_PKG;

CREATE PUBLIC SYNONYM REPAIRABLES_PKG FOR AMD_OWNER.REPAIRABLES_PKG;


DROP PUBLIC SYNONYM USER_PLANNER_PKG;

CREATE PUBLIC SYNONYM USER_PLANNER_PKG FOR AMD_OWNER.USER_PLANNER_PKG;


GRANT EXECUTE ON AMD_OWNER.AMD_BASIC_DEFAULT_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BATCH_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BEST_SPARES_INPUT_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_CLEAN_DATA TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEFAULT_EFFECTIVITY_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEMAND TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_EFFECTIVITY_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_EFFECTIVITY_TCTO_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_FROM_BSSM_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_INVENTORY TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOAD TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LP_OVERRIDE_CONSUMABL_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_MAINT_TASK_DISTRIBS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_NSL_SEQUENCE_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PARTPRIME_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_FACTORS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_LOCS_LOAD_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_REQS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_RMADS_SOURCE_TMP_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_NETWORKS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_PARTS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_TEST_DATA TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_TMAPI_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_VALIDATION_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_WARNINGS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.CONSUMABLES_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.EMAIL_HANDLER_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.REPAIRABLES_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BASIC_DEFAULT_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BATCH_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BEST_SPARES_INPUT_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_CLEAN_DATA TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEFAULTS TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEFAULT_EFFECTIVITY_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEMAND TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_EFFECTIVITY_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_EFFECTIVITY_TCTO_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_FROM_BSSM_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_INVENTORY TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOAD TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LP_OVERRIDE_CONSUMABL_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_MAINT_TASK_DISTRIBS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_NSL_SEQUENCE_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PARTPRIME_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_FACTORS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_LOCS_LOAD_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PREFERRED_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_REQS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_RMADS_SOURCE_TMP_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_NETWORKS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_PARTS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_TEST_DATA TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_TMAPI_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_UTILS TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_VALIDATION_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_WARNINGS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.CONSUMABLES_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.EMAIL_HANDLER_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.REPAIRABLES_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.USER_PLANNER_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_INVENTORY TO BSRM_LOADER;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_NETWORKS_PKG TO BSRM_LOADER;

GRANT EXECUTE ON AMD_OWNER.USER_PLANNER_PKG TO BSRM_LOADER;

GRANT EXECUTE ON AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG TO BSSM_OWNER WITH GRANT OPTION;

GRANT EXECUTE ON AMD_OWNER.AMD_UTILS TO BSSM_OWNER WITH GRANT OPTION;
DROP PACKAGE BODY AMD_OWNER.AMD_BASIC_DEFAULT_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_basic_default_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
     $Date:   Dec 01 2005 09:27:36  $
    $Workfile:   amd_basic_default_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_basic_default_pkg.pkb-arc  $
/*
/*      Rev 1.1   Dec 01 2005 09:27:36   zf297a
/*   added pvcs keywords
*/
procedure setGroup(pNsiSid number) is
	nsigroupsid	number ;

	cursor cur_sel_tail_no is
	select tail_no
	from amd_aircrafts
	where tail_no != 'DUMMY';
begin

	insert into amd_nsi_effects(nsi_sid, tail_no, effect_type, user_defined,		derived)
	select a.nsi_sid, b.tail_no, 'B', 'S', 'N'
	from amd_national_stock_items a, amd_aircrafts b
	where a.nsi_sid = pNsiSid;


	insert into amd_nsi_groups(fleet_size_name, split_effect)
		values('All Aircraft','N');

	select amd_nsi_group_sid_seq.currval into nsigroupsid from dual ;

	update amd_national_stock_items set
		nsi_group_sid = nsigroupsid,
		latest_config = 'Y',
		effect_by = 'S'
		where nsi_sid = pNsiSid;
end ;

procedure setAllGroups is
	cursor cur_sel_nsi_sid is
	select nsi_sid
	from amd_national_stock_items
	where nsi_group_sid is null;
begin
	for rec in cur_sel_nsi_sid  LOOP
		setGroup(rec.nsi_sid);
	end loop;
end;

end amd_basic_default_pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_BATCH_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Batch_Pkg AS
	/*7
      $Author:   zf297a  $
    $Revision:   1.14  $
	    $Date:   23 Mar 2007 13:18:22  $
    $Workfile:   AMD_BATCH_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_BATCH_PKG.pkb.-arc  $
/*
/*      Rev 1.14   23 Mar 2007 13:18:22   zf297a
/*   Do a commit after every insert and update so that this information is immediately available to anyone checking on a job status.
/*
/*      Rev 1.13   Jul 11 2006 09:04:10   zf297a
/*   Changed start_job to view any job with an job_abort field that is not null as being "terminated".
/*
/*      Rev 1.12   Jun 09 2006 11:34:48   zf297a
/*   implemented version
/*
/*      Rev 1.11   May 05 2006 09:24:34   zf297a
/*   Fixed invocation of getLastStartTime to used the named parameter notation for system_id since the batch_job_number is not available, otherwise Oracle will issue a
/*   "ORA-06502: PL/SQL: numeric or value error: character to number conversion error"  when the system_id is passed as the first positional parameter - i.e. it thinks it is the batch_job_number, but it is NOT, hence the number conversion error since system_id is always a VARCHAR2.
/*
/*      Rev 1.10   May 01 2006 12:10:02   zf297a
/*   Fixed isJobComplete
/*
/*      Rev 1.9   Apr 05 2006 14:09:42   zf297a
/*   Fixed getLastStartTime - will return null if there are no jobs in the system.
/*
/*      Rev 1.8   Mar 23 2006 10:52:06   zf297a
/*   Added an exception handler to truncateIfOld and updated the error location numbers.
/*
/*      Rev 1.7   Mar 23 2006 08:21:20   zf297a
/*   Implemented procedure truncateIfOld - this procedure will only truncate a table if there is no active batch job for the given system_id or if  there is an active job and the table has been updated since the job started.
/*
/*      Rev 1.6   Mar 21 2006 08:38:12   zf297a
/*   Fixed getLastStartData
/*
/*      Rev 1.5   Mar 19 2006 01:49:06   zf297a
/*   Implemented isStepComplete function
/*
/*      Rev 1.3   Mar 16 2006 14:25:00   zf297a
/*   Implemented step functions and procedures
/*
/*      Rev 1.2   Mar 03 2006 12:33:58   zf297a
/*   Implemented functions getLastStartTime, getLastEndTime, and isJobComplete.
/*
/*      Rev 1.1   Nov 22 2005 08:09:22   zf297a
/*   Restored body using previous package dump.
*/

	procedure ErrorMsg(
					pSqlfunction in amd_load_status.SOURCE%type,
					pTableName in amd_load_status.TABLE_NAME%type := '',
					pError_location amd_load_details.DATA_LINE_NO%type,
					pKey_1 in amd_load_details.KEY_1%type := '',
			 		pKey_2 in amd_load_details.KEY_2%type := '',
					pKey_3 in amd_load_details.KEY_3%type := '',
					pKey_4 in amd_load_details.KEY_4%type := '',
					pKeywordValuePairs in varchar2 := '') is
		key5 amd_load_details.KEY_5%type := pKeywordValuePairs ;
	begin
		rollback;
		if key5 = '' then
		   key5 := pSqlFunction || '/' || pTableName ;
		else
			key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
		end if ;
		-- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
		-- do not exceed the length of the column's that the data gets inserted into
		-- This is for debugging and logging, so efforts to make it not be the source of more
		-- errors is VERY important
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(
						pSourceName => substr(pSqlfunction,1,20),
						pTableName  => substr(pTableName,1,20)),
				pData_line_no => pError_location,
				pData_line    => 'amd_batch_pkg.',
				pKey_1 => substr(pKey_1,1,50),
				pKey_2 => substr(pKey_2,1,50),
				pKey_3 => substr(pKey_3,1,50),
				pKey_4 => substr(pKey_4,1,50),
				pKey_5 => to_char(sysdate,'MM/DD/YYYY HH:MM:SS') ||
						   ' ' || substr(key5,1,50),
				pComments => substr('sqlcode('||sqlcode||') sqlerrm('||sqlerrm||')',1,2000));
		commit;
	end ErrorMsg;

  procedure validateJob(batch_job_number in out amd_batch_jobs.BATCH_JOB_NUMBER%type, system_id in amd_batch_jobs.SYSTEM_ID%type) is

  begin
  	   if batch_job_number is null then
	   	  batch_job_number := getActiveJob(system_id) ;
		  if batch_job_number is null then
		  	 batch_job_number := getLastCompleteJob(system_id) ;
		  end if ;
	   else
	   	   if not isJob(batch_job_number, system_id) then
		   	  	  RAISE_APPLICATION_ERROR(-20130,'Job ' || batch_job_number || ',' || system_id || ' is not a valid job.') ;
		   end if ;
	   end if ;
  end validateJob ;

  procedure validateActiveJob(batch_job_number in out amd_batch_jobs.BATCH_JOB_NUMBER%type, system_id in amd_batch_jobs.SYSTEM_ID%type ) is
  begin

  	   if batch_job_number is null then
	   	  batch_job_number := getActiveJob(system_id) ;
		  if batch_job_number is null then
		  	 RAISE_APPLICATION_ERROR(-20140,'There is no active job for system_id=' || system_id || '.') ;
		  end if ;
	  else
	   	   if isJob(batch_job_number, system_id) then
		   	  if not isJobActive(batch_job_number, system_id) then
		   	  	  RAISE_APPLICATION_ERROR(-20150,'Job ' || batch_job_number || ',' || system_id || ' is not an active job.') ;
			  end if ;
		   else
		   	  RAISE_APPLICATION_ERROR(-20160,'Job ' || batch_job_number || ',' || system_id || ' is not a valid job.') ;
		   end if ;
	  end if ;

  end validateActiveJob ;

  procedure start_job(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP, description in amd_batch_jobs.description%type := null) is  			job_number NUMBER ;
  BEGIN
  	   SELECT MAX(batch_job_number) INTO job_number
	   FROM AMD_BATCH_JOBS
	   WHERE start_time IS NOT NULL
	   AND (end_time IS NOT NULL or job_aborted is not null)
	   and system_id = start_job.system_id ;
	   IF job_number IS NULL THEN
	   	  job_number := 0 ;
	   ELSE
	   	   job_number := job_number + 1 ;
	   END IF ;
	   INSERT INTO AMD_BATCH_JOBS
	   (batch_job_number, system_id, description, start_time)
	   VALUES (job_number, start_job.system_id, start_job.description, SYSDATE) ;

       commit ;

  EXCEPTION
  		   WHEN standard.DUP_VAL_ON_INDEX THEN
		   	 RAISE_APPLICATION_ERROR(-20170,'Job ' || job_number || ',' || system_id || ' must be ended before another job can start') ;
  END start_job ;

  procedure abort_job(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) is
  			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := abort_job.batch_job_number ;
  begin
  	   validateActiveJob(theJob, system_id) ;

	   <<abortActiveStep>>
	   begin
	   		abort_step(theJob, system_id) ;
	   exception when standard.no_data_found then
	   			 null ; -- no steps for job
	   end abortActiveStep ;

	   -- can only abort an active job
	   update amd_batch_jobs
	   set end_time = sysdate,
	   job_aborted = 'Y'
	   where batch_job_number = theJob
	   and system_id = abort_job.system_id
	   and start_time is not null
	   and end_time is null
	   and job_aborted is null ;

       commit ;

  exception
  			when others then
			  	 ErrorMsg(pSqlfunction => 'update',
						pTableName => 'amd_batch_jobs',
						pError_location => 10,
						pKey_1 => to_char(theJob),
						pKey_2 => system_id ) ;
				 raise ;
  end abort_job ;

  function isJob(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type,
  			system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean is
			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type ;
  begin
  	   select batch_job_number into theJob
	   from amd_batch_jobs
	   where batch_job_number = isJob.batch_job_number
	   and system_id = isJob.system_id ;

	   return true ;

  exception
  	   when standard.no_data_found then
	   		return false ;
	   when others then
	  	 ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_batch_jobs',
				pError_location => 20,
				pKey_1 => to_char(batch_job_number),
				pKey_2 => system_id ) ;
		 raise ;
  end isJob ;

  function hasActiveSteps(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type,
	   		system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean is

			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := hasActiveSteps.batch_job_number ;
			numberOfSteps number := 0 ;

  begin
  	   validateActiveJob(theJob, system_id) ;

	   SELECT COUNT(*) INTO numberOfSteps
	   FROM AMD_BATCH_JOB_STEPS
	   WHERE batch_job_number = theJob
	   and system_id = hasActiveSteps.system_id
	   and start_time is not null
	   AND end_time IS NULL
	   and step_aborted is null ;

	   return numberOfSteps > 0 ;

  exception
  		   when standard.no_data_found then
		   		return false ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 30,
					pKey_1 => to_char(theJob),
					pKey_2 => system_id ) ;
			 raise ;
  end hasActiveSteps ;

  function isJobActive(batch_job_number in amd_batch_jobs.batch_job_number%type := null,
  		   system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean is
  begin
  	   return not isJobComplete(batch_job_number, system_id) ;
  end isJobActive ;

  function getLastCompleteJob(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_jobs.batch_job_number%type is
  		   theJob amd_batch_jobs.batch_job_number%type ;
  begin
  	   select max(batch_job_number) into theJob
	   from amd_batch_jobs
	   where system_id = getLastCompleteJob.system_id
	   and start_time is not null
	   and end_time is not null
	   and job_aborted is null ;
	   return theJob ;
  exception
  			when standard.no_data_found then
				 return null ;
			when others then
			  	 ErrorMsg(pSqlfunction => 'select',
						pTableName => 'amd_batch_jobs',
						pError_location => 40,
						pKey_1 => system_id) ;
				 raise ;
  end getLastCompleteJob ;

  function getActiveJob(system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_jobs.batch_job_number%type is
  		   theJob amd_batch_jobs.BATCH_JOB_NUMBER%type ;
  begin
  	   -- any system is allowed only one active job
  	   select max(batch_job_number) into theJob
	   from   amd_batch_jobs
	   where  system_id = getActiveJob.system_id
	   and start_time is not null
	   and end_time is null
	   and job_aborted is null ;

	   return theJob ;
  exception
     when standard.no_data_found then
	 	  return null ; -- no job active
     when others then
	  	 ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_batch_jobs',
				pError_location => 50,
				pKey_1 => system_id ) ;
		 raise ;
  end getActiveJob ;

  procedure end_job(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) is
  			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := end_job.batch_job_number ;
			active_steps NUMBER ;
  BEGIN
  	   validateActiveJob(theJob, system_id) ;

	   IF hasActiveSteps(theJob, system_id) then
	   	   end_step(theJob, system_id) ;
	   end if ;

	   UPDATE AMD_BATCH_JOBS
	   SET end_time = SYSDATE
	   WHERE batch_job_number = theJob
	   and system_id = end_job.system_id
	   and start_time is not null
	   and end_time is null
	   and job_aborted is null ;

       commit ;

  exception
  	when others then
	  	 ErrorMsg(pSqlfunction => 'update',
				pTableName => 'amd_batch_jobs',
				pError_location => 60,
				pKey_1 => to_char(theJob),
				pKey_2 => system_id ) ;
		 raise ;
  END end_job ;

  -- if there is no job in the system it will return a null value
  function getLastStartTime(batch_job_number in amd_batch_jobs.batch_job_number%type := null, system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP)
	   			return amd_batch_jobs.START_TIME%type is

				theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := getLastStartTime.batch_job_number ;
				theTime amd_batch_jobs.START_TIME%type := null ;
  begin
  	   validateJob(theJob, system_id) ;
	   if theJob is not null then
	  	   select start_time into theTime
		   from amd_batch_jobs
		   where batch_job_number = theJob
		   and system_id = getLastStartTime.system_id
		   and start_time is not null
		   and job_aborted is  null ;
	   end if ;
	   return theTime ;
  exception
  			when standard.NO_DATA_FOUND then
				 return null ;
			when others then
			  	 ErrorMsg(pSqlfunction => 'select',
						pTableName => 'amd_batch_jobs',
						pError_location => 70,
						pKey_1 => to_char(theJob),
						pKey_2 => system_id ) ;
				 raise ;
  end getLastStartTime ;

  function getLastEndTime(batch_job_number in amd_batch_jobs.batch_job_number%type := null,system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP)
  			return amd_batch_jobs.END_TIME%type is
  			theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := getLastEndTime.batch_job_number ;
			theTime amd_batch_jobs.END_TIME%type ;
  begin
  	   validateJob(theJob, system_id) ;

  	   select end_time into theTime
	   from amd_batch_jobs
	   where batch_job_number = theJob
	   and system_id = getLastEndTime.system_id
	   and start_time is not null
	   and end_time is not null
	   and job_aborted is null ;

	   return theTime ;

  exception
  			when standard.NO_DATA_FOUND then
				 return null ;
			when others then
			  	 ErrorMsg(pSqlfunction => 'select',
						pTableName => 'amd_batch_jobs',
						pError_location => 80,
						pKey_1 => to_char(theJob),
						pKey_2 => system_id ) ;
				 raise ;
  end getLastEndTime ;

  function isJobComplete(batch_job_number in amd_batch_jobs.BATCH_JOB_NUMBER%type := null,
	   			system_id in amd_batch_jobs.system_id%type := ASSET_MANAGEMENT_DESKTOP) return boolean is
		   theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := isJobComplete.batch_job_number ;
  		   isComplete boolean := false ;
		   completeJob amd_batch_jobs.BATCH_JOB_NUMBER%type ;
  begin
       validateJob(theJob, system_id) ;

	   if theJob is null then
	   	  return true ;
	   else
	   	   if isJob(batch_job_number => theJob, system_id => system_id) then
		 	   select batch_job_number into completeJob
			   from amd_batch_jobs
			   where batch_job_number = theJob
			   and system_id = isJobComplete.system_id
			   and start_time is not null
			   and end_time is not null
			   and job_aborted is null ;
		   else
		   	  return true ;
		   end if ;
	  end if ;

	  return true ;

  exception
  		   when standard.no_data_found then
		   		return false ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_jobs',
					pError_location => 90,
					pKey_1 => to_char(theJob),
					pKey_2 => system_id ) ;
			 raise ;
  end isJobComplete ;

  function didStepStart(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null,
  		 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
		 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null,
		 description in amd_batch_job_steps.DESCRIPTION%type := null,
		 package_name in amd_batch_job_steps.PACKAGE_NAME%type := null,
		 procedure_name in amd_batch_job_steps.PROCEDURE_NAME%type := null,
		 function_name in amd_batch_job_steps.FUNCTION_NAME%type := null) return boolean is

		 theJob amd_batch_job_steps.BATCH_JOB_NUMBER%type := didStepStart.batch_job_number ;
		 theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type := didStepStart.batch_step_number ;
  begin
  	   validateActiveJob(theJob, system_id) ;

  	   if description is not null then
	      -- only start the step if it has not yet completed
	   	  if isStepComplete(theJob, system_id, description) then
		  	 return false ;
		  else
		  	 start_step(batch_job_number => batch_job_number, system_id => system_id,
			   batch_step_number => batch_step_number, description => description,
			   package_name => package_name, procedure_name => procedure_name,
			   function_name => function_name) ;
		  end if ;
	   else
	  	 start_step(batch_job_number => batch_job_number, system_id => system_id,
		   batch_step_number => batch_step_number,
		   package_name => package_name, procedure_name => procedure_name,
		   function_name => function_name) ;
	   end if ;
  	   return true ;
  end didStepStart ;

  procedure start_step(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null,
  		 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
		 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null,
		 description in amd_batch_job_steps.DESCRIPTION%type := null,
		 package_name in amd_batch_job_steps.PACKAGE_NAME%type := null,
		 procedure_name in amd_batch_job_steps.PROCEDURE_NAME%type := null,
		 function_name in amd_batch_job_steps.FUNCTION_NAME%type := null) is

		 theJob amd_batch_job_steps.BATCH_JOB_NUMBER%type := start_step.batch_job_number ;
		 theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type := start_step.batch_step_number ;
  begin
  	  validateActiveJob(theJob, system_id) ;

	  if theStep is null then
		  <<getNextStep>>
		 begin
		 	 theStep := getActiveStep(theJob, system_id) ;
			 -- there was an activeStep that did not complete
			 -- show that it was aborted
			 if theStep is not null then
			 	abort_step(theJob, system_id, theStep) ;
			 end if ;

		  	 select nvl(max(batch_step_number),0) into theStep
			 from amd_batch_job_steps
			 where batch_job_number = theJob
			 and system_id = start_step.system_id
			 and start_time is not null
			 and end_time is not null
			 and step_aborted is null ;

			 theStep := theStep + 1 ;
	     exception
		 		  when standard.no_data_found then
				  	   theStep := 1 ;
				  when others then
				  	 ErrorMsg(pSqlfunction => 'select',
							pTableName => 'amd_batch_job_steps',
							pError_location => 100,
							pKey_1 => to_char(theJob),
							pKey_2 => system_id,
							pKey_3 => to_char(theStep) ) ;
					 raise ;
   		 end getNextStep ;
	  end if ;

  	   insert into amd_batch_job_steps
	   (batch_job_number, system_id, batch_step_number, description, package_name, procedure_name, function_name, start_time)
	   values (theJob, start_step.system_id, theStep, start_step.description, start_step.package_name, start_step.procedure_name, start_step.function_name, sysdate) ;

       commit ;

  exception
  		   when standard.DUP_VAL_ON_INDEX then
			  	 ErrorMsg(pSqlfunction => 'insert',
						pTableName => 'amd_batch_job_steps',
						pError_location => 110,
						pKey_1 => to_char(theJob),
						pKey_2 => system_id,
						pKey_3 => to_char(theStep) ) ;
				raise ;
			when others then
			  	 ErrorMsg(pSqlfunction => 'insert',
						pTableName => 'amd_batch_jobs',
						pError_location => 120,
						pKey_1 => to_char(theJob),
						pKey_2 => system_id) ;
				raise ;
  end start_step ;

  procedure abort_step(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
  			 system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		 batch_step_number in amd_batch_job_steps.batch_step_number%type := null) is
		 theJob amd_batch_job_steps.batch_job_number%type := abort_step.batch_job_number ;
		 theStep amd_batch_job_steps.batch_step_number%type := abort_step.batch_step_number ;
  begin
  	   validateActiveJob(theJob, system_id) ;

	   if theStep is null then
  	   	  theStep := getActiveStep(batch_job_number, system_id) ;
		  if theStep is null then
		  	 return ; -- no step active
		  end if ;
	   end if ;

	   update amd_batch_job_steps
	   set step_aborted = 'Y',
	   end_time = sysdate
	   where batch_job_number = theJob
	   and system_id = abort_step.system_id
	   and batch_step_number = theStep ;

       commit ;

  exception
  		   when others then
			  	 ErrorMsg(pSqlfunction => 'update',
						pTableName => 'amd_batch_job_steps',
						pError_location => 130,
						pKey_1 => to_char(theJob),
						pKey_2 => system_id,
						pKey_3 => to_char(theStep) ) ;
				raise ;
  end abort_step ;

  procedure end_step(batch_job_number in amd_batch_job_steps.BATCH_JOB_NUMBER%type := null,
		 	 system_id in amd_batch_job_steps.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP,
			 batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type := null) is

		theJob amd_batch_job_steps.batch_job_number%type := end_step.batch_job_number ;
		theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type := end_step.batch_step_number ;
  begin
  	   validateActiveJob(theJob, system_id) ;

  	   if theStep is null then
	   	  theStep := getActiveStep(theJob, system_id) ;
		  if theStep is null then
		  	 return ;
		  end if ;
	   end if;
  	   update amd_batch_job_steps
	   set end_time = sysdate
	   where batch_job_number = theJob
	   and system_id = end_step.system_id
	   and batch_step_number = theStep
	   and end_time is null ;

       commit ;
  exception
    when standard.no_data_found then
		 return ; -- no step to end
  	when others then
	  	 ErrorMsg(pSqlfunction => 'update',
				pTableName => 'amd_batch_job_steps',
				pError_location => 140,
				pKey_1 => batch_job_number,
				pKey_2 => system_id) ;
		 raise ;

  end end_step ;

  function getActiveStep(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.BATCH_STEP_NUMBER%type is

			theJob amd_batch_job_steps.batch_job_number%type := getActiveStep.batch_job_number ;
			theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
  begin
  	   validateActiveJob(theJob, system_id) ;

	   select batch_step_number into theStep
	   from amd_batch_job_steps
	   where batch_job_number = theJob
	   and system_id = getActiveStep.system_id
	   and start_time is not null
	   and end_time is null
	   and step_aborted is null ;

  	   return theStep ;

  exception
  		   when standard.no_data_found then
		   		return null ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 150,
					pKey_1 => to_char(theJob),
					pKey_2 => system_id,
					pKey_3 => to_char(theStep)) ;
			 raise ;
  end getActiveStep ;

  function isStepComplete(batch_job_number in amd_batch_job_steps.batch_job_number%type,
  		   system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		   batch_step_number in amd_batch_job_steps.BATCH_STEP_NUMBER%type) return boolean is

			theStep amd_batch_job_steps.batch_step_number%type ;
  begin
  	   select batch_step_number into theStep
	   from amd_batch_job_steps
	   where batch_job_number = isStepComplete.batch_job_number
	   and system_id = isStepComplete.system_id
	   and batch_step_number = isStepComplete.batch_step_number
	   and start_time is not null
	   and end_time is not null
	   and step_aborted is null ;
	   return true ;
  exception
	   when no_data_found then
	   		return false ;
	   when others then
	  	 ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_batch_job_steps',
				pError_location => 160,
				pKey_1 => to_char(batch_job_number),
				pKey_2 => system_id,
				pKey_3 => to_char(batch_step_number)) ;
		 raise ;
  end isStepComplete ;

  function isStepComplete(batch_job_number in amd_batch_job_steps.batch_job_number%type,
  		   system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP,
		   description in amd_batch_job_steps.description%type) return boolean is

	   theJob amd_batch_job_steps.BATCH_JOB_NUMBER%type := isStepComplete.batch_job_number ;

	   cursor completedSteps  is
		   select batch_step_number
		   from amd_batch_job_steps
		   where batch_job_number = theJob
		   and system_id = isStepComplete.system_id
		   and description = isStepComplete.description
		   and start_time is not null
		   and end_time is not null
		   and step_aborted is null ;


  begin
  	   if theJob is null then
	   	  -- assumption - there is an active job running
	   	  validateActiveJob(theJob, system_id) ;
	   end if ;

	   -- assumption - description is unique per each step
	   -- step may have been run more than once
	   for rec in completedSteps loop
	   	   return true ;
	   end loop ;
	   return false ;
  exception
	   when others then
	  	 ErrorMsg(pSqlfunction => 'select',
				pTableName => 'amd_batch_job_steps',
				pError_location => 170,
				pKey_1 => to_char(batch_job_number),
				pKey_2 => system_id,
				pKey_3 => description) ;
		 raise ;
  end isStepComplete ;

  function getLastCompleteStep(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
  			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.batch_step_number%type is

			theJob amd_batch_job_steps.batch_job_number%type := getLastCompleteStep.batch_job_number ;
			theStep amd_batch_job_steps.batch_step_number%type ;
  begin
  	   validateJob(theJob, system_id) ;

  	   select max(batch_step_number) into theStep
	   from amd_batch_job_steps
	   where batch_job_number = theJob
	   and system_id = getLastCompleteStep.system_id
	   and start_time is not null
	   and end_time is not null
	   and step_aborted is null ;
  exception
  		   when standard.no_data_found then
		   		return null ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 180,
					pKey_1 => to_char(theJob),
					pKey_2 => system_id) ;
			 raise ;
  end getLastCompleteStep ;

  function getLastStepStartTime(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
  			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.start_time%type is

		theJob amd_batch_job_steps.batch_job_number%type := getLastStepStartTime.batch_job_number ;
		theStep amd_batch_job_steps.batch_step_number%type  ;
		theTime amd_batch_job_steps.START_TIME%type ;
  begin
  	   validateJob(theJob, system_id) ;

	   theStep := getActiveStep(theJob, system_id) ;
	   if theStep is null then
	   	  theStep := getLastCompleteStep(theJob, system_id) ;
		  if theStep is null then
		  	 return null ;
		  end if ;
	   end if ;

  	   select start_time into theTime
	   from amd_batch_job_steps
	   where batch_job_number = theJob
	   and system_id = getLastStepStartTime.system_id
	   and batch_step_number = theStep
	   and start_time is not null
	   and step_aborted is null ;
	   return theTime ;
  exception
  		   when standard.no_data_found then
		   		return null ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 190,
					pKey_1 => to_char(theJob),
					pKey_2 => system_id,
					pKey_3 => to_char(theStep) ) ;
			 raise ;
  end getLastStepStartTime ;

  function getLastStepEndTime(batch_job_number in amd_batch_job_steps.batch_job_number%type := null,
   			system_id in amd_batch_job_steps.system_id%type := ASSET_MANAGEMENT_DESKTOP) return amd_batch_job_steps.start_time%type is

			theJob amd_batch_job_steps.batch_job_number%type := getLastStepEndTime.batch_job_number ;
			theStep amd_batch_job_steps.BATCH_STEP_NUMBER%type ;
			theTime amd_batch_job_steps.END_TIME%type ;
  begin
  	  validateJob(theJob, system_id) ;

	  theStep := getActiveStep(theJob, system_id) ;
	  if theStep is null then
	  	 theStep := getLastCompleteStep(theJob, system_id) ;
		 if theStep is null then
		 	return null ; -- no steps for this job!
		 end if ;
	 end if ;
	 select end_time into theTime
	 from amd_batch_job_steps
	 where batch_job_number = theJob
	 and system_id = getLastStepEndTime.system_id
	 and batch_step_number = theStep
	 and start_time is not null
	 and end_time is not null
	 and step_aborted is null ;
	 return theTime ;
  exception
  		   when standard.no_data_found then
		   		return null ;
		   when others then
		  	 ErrorMsg(pSqlfunction => 'select',
					pTableName => 'amd_batch_job_steps',
					pError_location => 200,
					pKey_1 => to_char(theJob),
					pKey_2 => system_id,
					pKey_3 => to_char(theStep) ) ;
			 raise ;
  end getLastStepEndTime ;

  procedure deleteJob(batch_job_number in amd_batch_jobs.batch_job_number%type := null,
  			 system_id in amd_batch_jobs.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP) is

		theJob amd_batch_jobs.BATCH_JOB_NUMBER%type := deleteJob.batch_job_number ;
  begin
  	   validateJob(theJob, system_id) ;

	  <<deleteSteps>>
	  begin
		  delete from amd_batch_job_steps
		  where batch_job_number = theJob
		  and system_id = deleteJob.system_id ;
	  exception
	  		   when standard.no_data_found then
			   		return ;
			   when others then
			  	 ErrorMsg(pSqlfunction => 'delete',
						pTableName => 'amd_batch_job_steps',
						pError_location => 210,
						pKey_1 => to_char(theJob),
						pKey_2 => system_id ) ;
				 raise ;
	  end deleteSteps ;

	  delete from  amd_batch_jobs
	  where batch_job_number = theJob
	  and system_id = deleteJob.system_id ;
  exception
			   when others then
			  	 ErrorMsg(pSqlfunction => 'delete',
						pTableName => 'amd_batch_jobs',
						pError_location => 220,
						pKey_1 => to_char(theJob),
						pKey_2 => system_id ) ;
				 raise ;
  end deleteJob ;

  procedure truncateIfOld(tablename in varchar2, system_id in amd_batch_jobs.SYSTEM_ID%type := ASSET_MANAGEMENT_DESKTOP) is
  			type cv_type is ref cursor ;
			cv cv_type ;
			maxDate date ;
  begin
  	   if getActiveJob(system_id) is null then
	   	  	 Mta_Truncate_Table(tablename,'reuse storage');
	   else
	   	   open cv for
		   		'select max(last_update_dt) from ' || tablename ;
		   fetch cv into maxDate ;
		   if maxDate is null or getLastStartTime(system_id => system_id) > maxDate then
		   	  Mta_Truncate_Table(tablename,'reuse storage');
		   end if ;
		   close cv ;
	   end if ;
  exception
			   when others then
			  	 ErrorMsg(pSqlfunction => 'fetch',
						pTableName => tablename,
						pError_location => 230,
						pKey_1 => system_id ) ;
				 raise ;
  end truncateIfOld ;

  procedure version is
  begin
		 amd_utils.writeMsg(pSourceName => 'amd_batch_pkg', pTableName => 'amd_batch_pkg',
		 		pError_location => 240, pKey1 => 'amd_batch_pkg', pKey2 => '$Revision:   1.14  $') ;
  end version ;

END Amd_Batch_Pkg;

/


DROP PACKAGE BODY AMD_OWNER.AMD_BEST_SPARES_INPUT_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_best_spares_input_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
	    $Date:   Nov 30 2005 12:20:50  $
    $Workfile:   AMD_BEST_SPARES_INPUT_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_BEST_SPARES_INPUT_PKG.pkb-arc  $
/*
/*      Rev 1.1   Nov 30 2005 12:20:50   zf297a
/*   added PVCS keywords
*/
	procedure getBliss
	is
		cursor bliss is
			select
				replaced.nsn || '	' ||
				replaced.PRIME_PART_NO || '	' ||
				REPLACED_BY.nsn || '	' || replaced_by.PRIME_PART_NO as info
			from
				AMD_RELATED_NSI_PAIRS arnp,
				amd_national_stock_items replaced,
				amd_national_stock_items replaced_by
			where
				arnp.REPLACED_BY_NSI_SID = replaced_by.NSI_SID and
				arnp.REPLACED_NSI_SID = replaced.NSI_SID and
				replaced_by.LATEST_CONFIG = 'Y';
	begin
			dbms_output.put_line('OLD_NSN	OLD_PN	NEW_NSN	NEW_PN');
			for blissRec in bliss
			loop
				dbms_output.put_line(blissRec.info);
			end loop;
	end getBliss;

	procedure getAsCapablePercent(pDate date DEFAULT sysdate) is
		cursor asCap is
			select
				time_period_start,
				nsn || '	' ||
				loc_id || '	' ||
				to_char(add_months(time_period_start, -2), 'MM/DD/YYYY') || '	' ||
				to_char(time_period_end, 'MM/DD/YYYY') || '	' ||
				to_char(as_capable_percent, 999.99) as info
			from
				amd_nsi_loc_distribs anld,
				amd_spare_networks asn,
				amd_national_stock_items ansi
			where
				anld.nsi_sid = ansi.nsi_sid and
				asn.loc_sid = anld.loc_sid and
				time_period_start > pDate;
	begin
			dbms_output.put_line('NSN	SRAN	START_DATE	END_DATE	PERCENT_AS_CAPABLE');
			for asCapRec in asCap
			loop
				if (to_char(asCapRec.time_period_start, 'MON') in ('MAR', 'JUN', 'SEP', 'DEC')) then
					dbms_output.put_line(asCapRec.info);
				end if;
			end loop;
	end getAsCapablePercent;

	procedure getUpgradeable is
		cursor upg is
			select
				replaced.nsn || '	' || replaced_by.nsn as info
			from
				amd_related_nsi_pairs arnp,
				amd_national_stock_items replaced,
				amd_national_stock_items replaced_by
			where arnp.REPLACED_NSI_SID = replaced.NSI_SID and
				arnp.REPLACED_BY_NSI_SID = replaced_by.NSI_SID and
				arnp.UPGRADEABLE = 'Y';
	begin
			dbms_output.put_line('OLD_NSN	NEW_NSN');
			for upgRec in upg
			loop
				dbms_output.put_line(upgRec.info);
			end loop;
	end getUpgradeable;
end amd_best_spares_input_pkg;
/


DROP PACKAGE BODY AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG
IS
   /*
    PVCS Keywords

      $Author:   Douglas S. Elder
    $Revision:   1.19
        $Date:   14 Nov 2017
    $Workfile:   amd_cleaned_from_bssm_pkg.pkb  $
      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_cleaned_from_bssm_pkg.pkb-arc  $

     rev 1.19   14 Nov 2017 added exception handlers for select's of bssm_parts which one of the select was returning more
                            than one row
     Rev 1.18   03 Jul 2008 23:34:22   zf297a
  Removed unnecessary dbms_output

     Rev 1.17   11 May 2007 12:09:38   zf297a
  Renamed gold_mfgr_cage to pbl_flag for BSSM V604

     Rev 1.16   14 Feb 2007 13:55:02   zf297a
  removed dbms_output from checkPartModFlag

     Rev 1.15   09 Feb 2007 11:15:06   zf297a
  For all cleaned fields only return a value if ilock sid 2 data is different from lock sid 1 data.

     Rev 1.14   Jul 11 2006 11:30:04   zf297a
  Removed quotes from package name.

     Rev 1.13   Jun 09 2006 12:47:26   zf297a
  implemented version

     Rev 1.12   Dec 06 2005 09:35:34   zf297a
  Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS

     Rev 1.11   Oct 06 2005 10:09:10   zf297a
  added code to return planner_code

     Rev 1.10   Aug 04 2005 14:23:52   zf297a
  Made sure all queries using lock_sid compare against a character string versus a number so that the index is used.

     Rev 1.9   Jun 21 2005 07:58:32   c970183
  Added more excepton handlers.  Terminated the routine for all critical exceptions that should not occur.

     Rev 1.8   May 17 2005 11:05:56   c970183
  added new cleaned fields.  added fields that are not part of amd, but could provide an easy way to get field from bssm

     Rev 1.7   May 17 2005 10:26:46   c970183
  Changed dla_wareshouse_stock to current_backorder

     Rev 1.6   May 06 2005 07:45:26   c970183
  Changed dla_warehouse_stock to current_backorder.  added pvcs keywords.
     */



   ERRSOURCE   CONSTANT VARCHAR2 (20) := 'amdCleanedFromBssm';

   TYPE tab_modflag IS TABLE OF VARCHAR2 (50)
      INDEX BY BINARY_INTEGER;

   gModflag1Map         tab_modflag;
   gModflag2Map         tab_modflag;
   gSetflagBaseMap      tab_modflag;

   PROCEDURE CheckPartModFlag (
      pModflagMap     IN     tab_modflag,
      pModflagValue   IN     bssm_parts.modflag1%TYPE,
      pLockSidTwo     IN     bssm_parts%ROWTYPE,
      pOutCleanable   IN OUT partFields);

   FUNCTION GetBaseCleanable (pLockSidTwo bssm_base_parts%ROWTYPE)
      RETURN partBaseFields;

   FUNCTION GetCleanable (pLockSidTwo IN bssm_parts%ROWTYPE)
      RETURN partFields;

   -- function GetCleanable(pLockSidZero bssm_parts%rowtype, pLockSidTwo bssm_parts%rowtype) return partFields;
   FUNCTION GetCurrentAmdNsn (pNsiSid amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.nsn%TYPE;

   FUNCTION NotEqual (pField1 VARCHAR2, pField2 VARCHAR2)
      RETURN BOOLEAN;

   PROCEDURE UpdateAmdPartCleaned (pNsn          amd_national_stock_items.nsn%TYPE,
                                   pCleanable    partFields);

   PROCEDURE UpdateAmdBaseCleaned (pNsn          bssm_base_parts.nsn%TYPE,
                                   pSran         bssm_base_parts.sran%TYPE,
                                   pCleanable    partBaseFields);


   PROCEDURE writeMsg (
      pTableName        IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
      pError_location   IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
      pKey1             IN VARCHAR2 := '',
      pKey2             IN VARCHAR2 := '',
      pKey3             IN VARCHAR2 := '',
      pKey4             IN VARCHAR2 := '',
      pData             IN VARCHAR2 := '',
      pComments         IN VARCHAR2 := '')
   IS
   BEGIN
      Amd_Utils.writeMsg (pSourceName       => 'amd_cleaned_from_bssm_pkg',
                          pTableName        => pTableName,
                          pError_location   => pError_location,
                          pKey1             => pKey1,
                          pKey2             => pKey2,
                          pKey3             => pKey3,
                          pKey4             => pKey4,
                          pData             => pData,
                          pComments         => pComments);
   END writeMsg;

   PROCEDURE errorMsg (sqlFunction         IN VARCHAR2,
                       tableName           IN VARCHAR2,
                       errorLocation       IN NUMBER,
                       key1                IN VARCHAR2 := '',
                       key2                IN VARCHAR2 := '',
                       key3                IN VARCHAR2 := '',
                       key4                IN VARCHAR2 := '',
                       key5                IN VARCHAR2 := '',
                       keywordvaluepairs   IN VARCHAR2 := '')
   IS
   BEGIN
      ROLLBACK;
      amd_utils.inserterrormsg (
         pload_no        => amd_utils.getloadno (psourcename   => sqlfunction,
                                                 ptablename    => tablename),
         pdata_line_no   => errorlocation,
         pdata_line      => 'amd_cleaned_from_bssm_pkg',
         pkey_1          => key1,
         pkey_2          => key2,
         pkey_3          => key3,
         pkey_4          => key4,
         pkey_5          =>    key5
                            || ' '
                            || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS')
                            || ' '
                            || keywordvaluepairs,
         pcomments       =>    sqlfunction
                            || '/'
                            || tablename
                            || ' sqlcode('
                            || SQLCODE
                            || ') sqlerrm('
                            || SQLERRM
                            || ')');
      COMMIT;
      RETURN;
   END errorMsg;

   PROCEDURE CheckPartModFlag (
      pModflagMap     IN     tab_modflag,
      pModflagValue   IN     bssm_parts.modflag1%TYPE,
      pLockSidTwo     IN     bssm_parts%ROWTYPE,
      pOutCleanable   IN OUT partFields)
   IS
      bitNumber    BINARY_INTEGER;
      lockSidOne   bssm_parts%ROWTYPE;

      FUNCTION equal (fld1 IN VARCHAR2, fld2 IN VARCHAR2)
         RETURN BOOLEAN
      IS
         result   BOOLEAN := FALSE;
      BEGIN
         IF fld1 IS NULL
         THEN
            result := fld2 IS NULL;
         ELSE
            IF fld2 IS NOT NULL
            THEN
               result := fld1 = fld2;
            END IF;
         END IF;

         RETURN result;
      END equal;

      FUNCTION equal (num1 IN NUMBER, num2 IN NUMBER)
         RETURN BOOLEAN
      IS
         result   BOOLEAN := FALSE;
      BEGIN
         IF num1 IS NULL
         THEN
            result := num2 IS NULL;
         ELSE
            IF num2 IS NOT NULL
            THEN
               result := num1 = num2;
            END IF;
         END IF;

         RETURN result;
      END equal;
   BEGIN
      SELECT bp.*
        INTO lockSidOne
        FROM bssm_parts bp
       WHERE bp.nsn = pLockSidTwo.nsn AND bp.lock_sid = '1';

      bitNumber := pModflagMap.FIRST;

      WHILE (bitNumber IS NOT NULL)
      LOOP
         IF (BITAND (pModflagValue, bitNumber) > 0)
         THEN
            IF (    pModflagMap (bitNumber) = ACQUISITION_ADVICE_CODE
                AND NOT equal (lockSidOne.acquisition_advice_code,
                               pLockSidTwo.acquisition_advice_code))
            THEN
               pOutCleanable.acquisition_advice_code :=
                  pLockSidTwo.acquisition_advice_code;
            ELSIF (    pModflagMap (bitNumber) = ADD_INCREMENT
                   AND NOT equal (lockSidOne.add_increment,
                                  pLockSidtwo.add_increment))
            THEN
               pOutCleanable.add_increment := pLockSidTwo.add_increment;
            ELSIF (    pModflagMap (bitNumber) = AMC_BASE_STOCK
                   AND NOT equal (lockSidOne.amc_base_stock,
                                  pLockSidTwo.amc_base_stock))
            THEN
               pOutCleanable.amc_base_stock := pLockSidTwo.amc_base_stock;
            ELSIF (    pModflagMap (bitNumber) = AMC_DAYS_EXPERIENCE
                   AND NOT equal (lockSidOne.amc_days_experience,
                                  pLockSidTwo.amc_days_experience))
            THEN
               pOutCleanable.amc_days_experience :=
                  pLockSidTwo.amc_days_experience;
            ELSIF (    pModflagMap (bitNumber) = AMC_DEMAND
                   AND NOT equal (lockSidOne.amc_demand,
                                  pLockSidTwo.amc_demand))
            THEN
               pOutCleanable.amc_demand := pLockSidTwo.amc_demand;
            ELSIF (    pModflagMap (bitNumber) = CAPABILITY_REQUIREMENT
                   AND NOT equal (lockSidOne.capability_requirement,
                                  pLockSidTwo.capability_requirement))
            THEN
               pOutCleanable.capability_requirement :=
                  pLockSidTwo.capability_requirement;
            ELSIF (    pModflagMap (bitNumber) = CONDEMN_AVG
                   AND NOT equal (lockSidOne.condemn, pLockSidTwo.condemn))
            THEN
               pOutCleanable.condemn_avg := pLockSidTwo.condemn;
            ELSIF (    pModflagMap (bitNumber) = CRITICALITY
                   AND NOT equal (lockSidOne.criticality,
                                  pLockSidTwo.criticality))
            THEN
               pOutCleanable.criticality := pLockSidTwo.criticality;
            ELSIF (    pModflagMap (bitNumber) = DLA_DEMAND
                   AND NOT equal (lockSidOne.dla_demand,
                                  pLockSidTwo.dla_demand))
            THEN
               pOutCleanable.dla_demand := pLockSidTwo.dla_demand;
            ELSIF (    pModflagMap (bitNumber) = CURRENT_BACKORDER
                   AND NOT equal (lockSidOne.current_backorder,
                                  pLockSidTwo.current_backorder))
            THEN
               pOutCleanable.current_backorder :=
                  pLockSidTwo.CURRENT_BACKORDER;
            ELSIF (    pModflagMap (bitNumber) = FEDC_COST
                   AND NOT equal (lockSidOne.fedc_cost,
                                  pLockSidTwo.fedc_cost))
            THEN
               pOutCleanable.fedc_cost := pLockSidTwo.fedc_cost;
            ELSIF (    pModflagMap (bitNumber) = pbl_flag
                   AND NOT equal (lockSidOne.pbl_flag, pLockSidTwo.pbl_flag))
            THEN
               pOutCleanable.pbl_flag := pLockSidTwo.pbl_flag;
            ELSIF (    pModflagMap (bitNumber) = ITEM_TYPE
                   AND NOT equal (lockSidOne.item_type,
                                  pLockSidTwo.item_type))
            THEN
               pOutCleanable.item_type :=
                  amd_from_bssm_pkg.ConvertItemType (pLockSidTwo.item_type);
            ELSIF (    pModflagMap (bitNumber) = MFGR
                   AND NOT equal (lockSidOne.mfgr, pLockSidTwo.mfgr))
            THEN
               pOutCleanable.mfgr := pLockSidTwo.mfgr;
            ELSIF (    pModflagMap (bitNumber) = MIC_CODE_LOWEST
                   AND NOT equal (lockSidOne.mic_code, pLockSidTwo.mic_code))
            THEN
               pOutCleanable.mic_code_lowest := pLockSidTwo.mic_code;
            ELSIF (    pModflagMap (bitNumber) = MTBDR
                   AND NOT equal (lockSidOne.mtbdr, pLockSidTwo.mtbdr))
            THEN
               pOutCleanable.mtbdr := pLockSidTwo.mtbdr;
            ELSIF (    pModflagMap (bitNumber) = MIN_PURCHASE_QUANTITY
                   AND NOT equal (lockSidOne.min_purchase_quantity,
                                  pLockSidTwo.min_purchase_quantity))
            THEN
               pOutCleanable.min_purchase_quantity :=
                  pLockSidTwo.min_purchase_quantity;
            ELSIF (    pModflagMap (bitNumber) = NOMENCLATURE
                   AND NOT equal (lockSidOne.nomenclature,
                                  pLockSidTwo.nomenclature))
            THEN
               pOutCleanable.nomenclature := pLockSidTwo.nomenclature;
            ELSIF (    pModflagMap (bitNumber) = NRTS_AVG
                   AND NOT equal (lockSidOne.nrts, pLockSidTwo.nrts))
            THEN
               pOutCleanable.nrts_avg := pLockSidTwo.nrts;
            ELSIF (    pModflagMap (bitNumber) = COST_TO_REPAIR_OFF_BASE
                   AND NOT equal (lockSidOne.off_base_repair_cost,
                                  pLockSidTwo.off_base_repair_cost))
            THEN
               pOutCleanable.cost_to_repair_off_base :=
                  pLockSidTwo.off_base_repair_cost;
            ELSIF (    pModflagMap (bitNumber) = TIME_TO_REPAIR_OFF_BASE
                   AND NOT equal (lockSidOne.off_base_turnaround,
                                  pLockSidTwo.off_base_turnaround))
            THEN
               pOutCleanable.time_to_repair_off_base :=
                  pLockSidTwo.off_base_turnaround;
            ELSIF (    pModflagMap (bitNumber) = TIME_TO_REPAIR_ON_BASE_AVG
                   AND NOT equal (lockSidOne.on_base_turnaround,
                                  pLockSidTwo.on_base_turnaround))
            THEN
               pOutCleanable.time_to_repair_on_base_avg :=
                  pLockSidTwo.on_base_turnaround;
            ELSIF (    pModflagMap (bitNumber) = ORDER_LEAD_TIME
                   AND NOT equal (lockSidOne.order_lead_time,
                                  pLockSidTwo.order_lead_time))
            THEN
               pOutCleanable.order_lead_time := pLockSidTwo.order_lead_time;
            ELSIF (    pModflagMap (bitNumber) = ORDER_UOM
                   AND NOT equal (lockSidOne.order_uom,
                                  pLockSidTwo.order_uom))
            THEN
               pOutCleanable.order_uom := pLockSidTwo.order_uom;
            ELSIF (    pModflagMap (bitNumber) = PLANNER_CODE
                   AND NOT equal (lockSidOne.planner_code,
                                  pLockSidTwo.planner_code))
            THEN
               pOutCleanable.planner_code := pLockSidTwo.planner_code;
            ELSIF (    pModflagMap (bitNumber) = RTS_AVG
                   AND NOT equal (lockSidOne.rts, pLockSidTwo.rts))
            THEN
               pOutCleanable.rts_avg := pLockSidTwo.rts;
            ELSIF (    pModflagMap (bitNumber) = RU_IND
                   AND NOT equal (lockSidOne.ru_ind, pLockSidTwo.ru_ind))
            THEN
               pOutCleanable.ru_ind := pLockSidTwo.ru_ind;
            ELSIF (    pModflagMap (bitNumber) = SMR_CODE
                   AND NOT equal (lockSidOne.smr_code, pLockSidTwo.smr_code))
            THEN
               pOutCleanable.smr_code := pLockSidTwo.smr_code;
            ELSIF (    pModflagMap (bitNumber) = UNIT_COST
                   AND NOT equal (lockSidOne.unit_cost,
                                  pLockSidTwo.unit_cost))
            THEN
               pOutCleanable.unit_cost := pLockSidTwo.unit_cost;
            END IF;
         END IF;

         bitNumber := pModflagMap.NEXT (bitNumber);
      END LOOP;
   END CheckPartModflag;

   FUNCTION GetCleanable (pLockSidTwo IN bssm_parts%ROWTYPE)
      RETURN partFields
   IS
      cleanable   partFields := NULL;
   BEGIN
      CheckPartModFlag (gModflag1Map,
                        pLockSidTwo.modflag1,
                        pLockSidTwo,
                        cleanable);
      CheckPartModFlag (gModflag2Map,
                        pLockSidTwo.modflag2,
                        pLockSidTwo,
                        cleanable);
      RETURN cleanable;
   END GetCleanable;

   /*
   -- not used currently, switched back to other methodology of using bit comparisons
   -- order important when passing to this function, lockSidTwo must be second
     function GetCleanable(pLockSidZero bssm_parts%rowtype, pLockSidTwo bssm_parts%rowtype) return partFields is
    recPart partFields := null;
   begin
    if (NotEqual(pLockSidTwo.add_increment, pLockSidZero.add_increment)) then
     recPart.add_increment := pLockSidTwo.add_increment;
    end if;
    if (NotEqual(pLockSidTwo.amc_base_stock,pLockSidZero.amc_base_stock)) then
     recPart.amc_base_stock := pLockSidTwo.amc_base_stock;
    end if;
    if (NotEqual(pLockSidTwo.amc_days_experience, pLockSidZero.amc_days_experience)) then
     recPart.amc_days_experience := pLockSidTwo.amc_days_experience;
    end if;
    if (NotEqual(pLockSidTwo.amc_demand, pLockSidZero.amc_demand)) then
     recPart.amc_demand := pLockSidTwo.amc_demand;
    end if;
    if (NotEqual(pLockSidTwo.capability_requirement,pLockSidZero.capability_requirement)) then
     recPart.capability_requirement := pLockSidTwo.capability_requirement;
    end if;
    if (NotEqual(pLockSidTwo.condemn, pLockSidZero.condemn)) then
     recPart.condemn_avg := pLockSidTwo.condemn;
    end if;
    if (NotEqual(pLockSidTwo.criticality,pLockSidZero.criticality)) then
     recPart.criticality := amd_from_bssm_pkg.ConvertCriticality(pLockSidTwo.criticality);
    end if;
    if (NotEqual(pLockSidTwo.dla_demand,pLockSidZero.dla_demand)) then
     recPart.dla_demand := pLockSidTwo.dla_demand;
    end if;
    if (NotEqual(pLockSidTwo.dla_warehouse_stock, pLockSidZero.dla_warehouse_stock)) then
     recPart.dla_warehouse_stock := pLockSidTwo.dla_warehouse_stock;
    end if;
    if (NotEqual(pLockSidTwo.fedc_cost,pLockSidZero.fedc_cost)) then
     recPart.fedc_cost := pLockSidTwo.fedc_cost;
    end if;
    if (NotEqual(pLockSidTwo.item_type,pLockSidZero.item_type)) then
     recPart.item_type := amd_from_bssm_pkg.ConvertItemType(pLockSidTwo.item_type);
    end if;
    if (NotEqual(pLockSidTwo.mic_code, pLockSidZero.mic_code)) then
     recPart.mic_code_lowest := pLockSidTwo.mic_code;
    end if;
    if (NotEqual(pLockSidTwo.mtbdr,pLockSidZero.mtbdr)) then
     recPart.mtbdr := pLockSidTwo.mtbdr;
    end if;
    if (NotEqual(pLockSidTwo.nomenclature, pLockSidZero.nomenclature)) then
     recPart.nomenclature := pLockSidTwo.nomenclature;
    end if;
    if (NotEqual(pLockSidTwo.nrts, pLockSidZero.nrts)) then
     recPart.nrts_avg := pLockSidTwo.nrts;
    end if;
    if (NotEqual(pLockSidTwo.off_base_repair_cost, pLockSidZero.off_base_repair_cost)) then
     recPart.cost_to_repair_off_base := pLockSidTwo.off_base_repair_cost;
    end if;
    if (NotEqual(pLockSidTwo.off_base_turnaround, pLockSidZero.off_base_turnaround)) then
     recPart.time_to_repair_off_base := pLockSidTwo.off_base_turnaround;
    end if;
    if (NotEqual(pLockSidTwo.on_base_turnaround, pLockSidZero.on_base_turnaround)) then
     recPart.time_to_repair_on_base_avg := pLockSidTwo.on_base_turnaround;
    end if;
    if (NotEqual(pLockSidTwo.order_lead_time, pLockSidZero.order_lead_time)) then
     recPart.order_lead_time := pLockSidTwo.order_lead_time;
    end if;
    if (NotEqual(pLockSidTwo.order_uom, pLockSidZero.order_uom)) then
     recPart.order_uom := pLockSidTwo.order_uom;
    end if;
    if (NotEqual(pLockSidTwo.planner_code, pLockSidZero.planner_code)) then
     recPart.planner_code := pLockSidTwo.planner_code;
    end if;
    if (NotEqual(pLockSidTwo.rts, pLockSidZero.rts)) then
     recPart.rts_avg := pLockSidTwo.rts;
    end if;
    if (NotEqual(pLockSidTwo.ru_ind, pLockSidZero.ru_ind)) then
     recPart.ru_ind := pLockSidTwo.ru_ind;
    end if;
    if (NotEqual(pLockSidTwo.smr_code, pLockSidZero.smr_code)) then
     recPart.smr_code := pLockSidTwo.smr_code;
    end if;
    if (NotEqual(pLockSidTwo.unit_cost, pLockSidZero.unit_cost)) then
     recPart.unit_cost := pLockSidTwo.unit_cost;
       end if;
    return recPart;
   end GetCleanable;
   */

   FUNCTION GetBaseCleanable (pLockSidTwo bssm_base_parts%ROWTYPE)
      RETURN partBaseFields
   IS
      -- prior to today 11/12/01, bob said even for bssm_base_parts table, cannot
      -- have lock_sid 2 w/o lock_sid 0.  however test with today demonstrated a lock_sid 2
      -- was created w/o lock_sid 0. may have to abort comparison of lock_sid 2 to lock_sid 0.
      -- all base specific fields are in gSetflagBaseMap
      cleanable   partBaseFields := NULL;
      bitNumber   BINARY_INTEGER;
   BEGIN
      bitNumber := gSetflagBaseMap.FIRST;

      WHILE (bitNumber IS NOT NULL)
      LOOP
         IF (BITAND (pLockSidTwo.setflag, bitNumber) > 0)
         THEN
            IF (gSetflagBaseMap (bitNumber) = REPAIR_LEVEL_CODE)
            THEN
               cleanable.repair_level_code := pLockSidTwo.repair_indicator;
            ELSIF (gSetflagBaseMap (bitNumber) = REMOVAL_IND)
            THEN
               cleanable.removal_ind := pLockSidTwo.replacement_indicator;
            END IF;
         END IF;

         bitNumber := gSetflagBaseMap.NEXT (bitNumber);
      END LOOP;

      RETURN cleanable;
   END GetBaseCleanable;


   FUNCTION GetBaseValues (pNsn     bssm_base_parts.nsn%TYPE,
                           pSran    bssm_base_parts.sran%TYPE)
      RETURN partBaseFields
   IS
      -- lockSidZero bssm_base_parts%rowtype := null;
      lockSidTwo       bssm_base_parts%ROWTYPE := NULL;
      recBase          partBaseFields := NULL;
      currentBssmNsn   bssm_parts.nsn%TYPE;
   BEGIN
      -- will throw exception if not found, important when nsn coming from amd
      currentBssmNsn := amd_from_bssm_pkg.GetCurrentBssmNsn (pNsn);

      SELECT bbp.*
        INTO lockSidTwo
        FROM bssm_base_parts bbp
       WHERE lock_sid = '2' AND sran = pSran AND bbp.nsn = currentBssmNsn;

      recBase := GetBaseCleanable (lockSidTwo);
      /*
       select bbp.*
         into lockSidZero
        from bssm_base_parts bbp
        where
               lock_sid = 0      and
               sran = pSran      and
           bbp.nsn = currentBssmNsn;
       if (NotEqual(lockSidTwo.replacement_indicator,lockSidZero.replacement_indicator)) then
       recBase.removal_ind := lockSidTwo.replacement_indicator;
       end if;
       if (NotEqual(lockSidTwo.repair_indicator, lockSidZero.repair_indicator)) then
       recBase.repair_level_code := lockSidTwo.repair_indicator;
       end if;
       */
      RETURN recBase;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN recBase;
   END GetBaseValues;

   -- below not really used, just for convenience if want to query by field name
   FUNCTION GetBaseValues (pNsn          bssm_base_parts.nsn%TYPE,
                           pSran         bssm_base_parts.sran%TYPE,
                           pFieldName    VARCHAR2)
      RETURN VARCHAR2
   IS
      recBase   partBaseFields := NULL;
   BEGIN
      recBase := GetBaseValues (pNsn, pSran);

      IF (pFieldName = REMOVAL_IND)
      THEN
         RETURN recBase.removal_ind;
      ELSIF (pFieldName = REPAIR_LEVEL_CODE)
      THEN
         RETURN recBase.repair_level_code;
      END IF;
   END GetBaseValues;

   FUNCTION GetCurrentAmdNsn (pNsiSid amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.nsn%TYPE
   IS
      currentNsn   amd_national_stock_items.nsn%TYPE;
   BEGIN
      SELECT nsn
        INTO currentNsn
        FROM amd_national_stock_items
       WHERE nsi_sid = pNsiSid;

      RETURN currentNsn;
   -- let it throw exception if not found
   END GetCurrentAmdNsn;

   FUNCTION GetValuesX (pNsn       bssm_parts.nsn%TYPE,
                        pPartNo    bssm_parts.part_no%TYPE)
      RETURN partFields
   IS
      recPart          partFields := NULL;
      -- lockSidZero bssm_parts%rowtype := null;
      lockSidTwo       bssm_parts%ROWTYPE := NULL;
      currentBssmNsn   bssm_parts.nsn%TYPE;
   BEGIN
      -- pNsn comes from amd or bssm,amd may be ahead of nsn in bssm_parts => get current bssm nsn
      -- will throw exception if not available
      currentBssmNsn := amd_from_bssm_pkg.GetCurrentBssmNsn (pNsn);

      SELECT bp.*
        INTO lockSidTwo
        FROM bssm_parts bp
       WHERE bp.nsn = currentBssmNsn AND lock_sid = '2';


      recPart := GetCleanable (lockSidTwo);
      /*
      select bp.*
          into lockSidZero
          from bssm_parts bp
          where
             bp.nsn = currentBssmNsn and
             lock_sid = 0;

      recPart := GetCleanable(lockSidZero, lockSidTwo);
      */



      recPart.part_no := pPartNo;
      RETURN recPart;
   EXCEPTION
      -- will occur if cannot current bssm nsn or no lock_sid 2 entry
      WHEN NO_DATA_FOUND
      THEN
         recPart := NULL;

        <<getViaPart>>
         DECLARE
            nsn   bssm_parts.nsn%TYPE := NULL;
            cnt   NUMBER := 0;

            CURSOR bssmPartInfoOriginal (partNo VARCHAR2)
            IS
               SELECT nsn
                 INTO getViaPart.nsn
                 FROM bssm_parts
                WHERE part_no = pPartNo AND lock_sid = '0';
         BEGIN
           <<locksid0>>
            BEGIN
               FOR rec IN bssmPartInfoOriginal (pPartNo)
               LOOP
                  cnt := cnt + 1;

                  IF cnt = 1
                  THEN
                     getViaPart.nsn := rec.nsn;
                  END IF;
               END LOOP;

               IF cnt > 1
               THEN
                  DBMS_OUTPUT.put_line (
                        'GetValuesX: part_no='
                     || pPartNo
                     || ' lock_sid=0'
                     || ' returned '
                     || cnt
                     || ' rows');
               END IF;
            EXCEPTION
               WHEN OTHERS
               THEN
                  errorMsg (sqlFunction     => 'select',
                            tablename       => 'bssm_parts',
                            key1            => pPartNo,
                            key2            => '0',
                            errorLocation   => 1);
                  DBMS_OUTPUT.put_line (
                        'GetValuesX: part_no='
                     || pPartNo
                     || ' lock_sid=0'
                     || ' sqlcode('
                     || SQLCODE
                     || ') sqlerrm('
                     || SQLERRM
                     || ')');
                  RETURN recpart;
            END locksid0;

            DECLARE
               cnt   NUMBER := 0;

               CURSOR bssmPartInfoCleaned (nsnParam VARCHAR2)
               IS
                  SELECT acquisition_advice_code,
                         add_increment,
                         amc_base_stock,
                         amc_days_experience,
                         amc_demand,
                         capability_requirement,
                         condemn,
                         criticality,
                         current_backorder,
                         dla_demand,
                         fedc_cost,
                         item_type,
                         mfgr,
                         mic_code,
                         min_purchase_quantity,
                         mtbdr,
                         nomenclature,
                         nrts,
                         nsn,
                         order_lead_time,
                         order_uom,
                         part_no,
                         pbl_flag,
                         planner_code,
                         rts,
                         ru_ind,
                         smr_code,
                         unit_cost
                    FROM bssm_parts bp
                   WHERE bp.nsn = nsnParam AND lock_sid = '2';
            BEGIN
               FOR rec IN bssmPartInfoCleaned (getViaPart.nsn)
               LOOP
                  IF cnt = 1
                  THEN
                     recPart.acquisition_advice_code :=
                        rec.acquisition_advice_code;
                     recPart.add_increment := rec.add_increment;
                     recPart.amc_base_stock := rec.amc_base_stock;
                     recPart.amc_days_experience := rec.amc_days_experience;
                     recPart.amc_demand := rec.amc_demand;
                     recPart.capability_requirement :=
                        rec.capability_requirement;
                     recPart.condemn_avg := rec.condemn;
                     recPart.criticality := rec.criticality;
                     recPart.current_backorder := rec.current_backorder;
                     recPart.dla_demand := rec.dla_demand;
                     recPart.fedc_cost := rec.fedc_cost;
                     recPart.item_type := rec.item_type;
                     recPart.mfgr := rec.mfgr;
                     recPart.mic_code_lowest := rec.mic_code;
                     recPart.min_purchase_quantity :=
                        rec.min_purchase_quantity;
                     recPart.mtbdr := rec.mtbdr;
                     recPart.nomenclature := rec.nomenclature;
                     recPart.nrts_avg := rec.nrts;
                     recPart.nsn := rec.nsn;
                     recPart.order_lead_time := rec.order_lead_time;
                     recPart.order_uom := rec.order_uom;
                     recPart.part_no := rec.part_no;
                     recPart.pbl_flag := rec.pbl_flag;
                     recPart.planner_code := rec.planner_code;
                     recPart.rts_avg := rec.rts;
                     recPart.ru_ind := rec.ru_ind;
                     recPart.smr_code := rec.smr_code;
                     recPart.unit_cost := rec.unit_cost;
                  END IF;
               END LOOP;

               IF cnt > 1
               THEN
                  DBMS_OUTPUT.put_line (
                        'GetValuesX: nsn='
                     || getViaPart.nsn
                     || ' lock_sid=2'
                     || ' returned '
                     || cnt
                     || ' rows.');
               END IF;
            EXCEPTION
               WHEN OTHERS
               THEN
                  errorMsg (sqlFunction     => 'select',
                            tablename       => 'bssm_parts',
                            key1            => pPartNo,
                            key2            => '2',
                            errorLocation   => 2);
                  DBMS_OUTPUT.put_line (
                        'GetValuesX: part_no='
                     || pPartNo
                     || ' lock_sid=2'
                     || ' sqlcode('
                     || SQLCODE
                     || ') sqlerrm('
                     || SQLERRM
                     || ')');
                  RETURN recpart;
            END locksid2;


            recPart := GetCleanable (lockSidTwo);

            recPart.nsn := pNsn;
            recPart.part_no := pPartNo;

            RETURN recPart;
         EXCEPTION
            WHEN STANDARD.NO_DATA_FOUND
            THEN
               RETURN recPart;
         END getViaPart;
   END GetValuesX;

   -- if field not cleaned, GetBssmPartsRec return value will be null for that particular field.
   FUNCTION GetValues (pNsn bssm_parts.nsn%TYPE)
      RETURN partFields
   IS
      recPart          partFields := NULL;
      -- lockSidZero bssm_parts%rowtype := null;
      lockSidTwo       bssm_parts%ROWTYPE := NULL;
      currentBssmNsn   bssm_parts.nsn%TYPE;
   BEGIN
      -- pNsn comes from amd or bssm,amd may be ahead of nsn in bssm_parts => get current bssm nsn
      -- will throw exception if not available
      currentBssmNsn := amd_from_bssm_pkg.GetCurrentBssmNsn (pNsn);

      SELECT bp.*
        INTO lockSidTwo
        FROM bssm_parts bp
       WHERE bp.nsn = currentBssmNsn AND lock_sid = '2';

      recPart := GetCleanable (lockSidTwo);
      /*
      select bp.*
          into lockSidZero
          from bssm_parts bp
          where
             bp.nsn = currentBssmNsn and
             lock_sid = 0;

      recPart := GetCleanable(lockSidZero, lockSidTwo);
      */



      RETURN recPart;
   EXCEPTION
      -- will occur if cannot current bssm nsn or no lock_sid 2 entry
      WHEN NO_DATA_FOUND
      THEN
         -- return null record
         RETURN recPart;
   END GetValues;

   -- not really used anymore, here for convenience
   FUNCTION GetValues (pNsn bssm_parts.nsn%TYPE, pFieldName VARCHAR2)
      RETURN VARCHAR2
   IS
      recPart   partFields := NULL;
   BEGIN
      -- implicit conversion of numbers, dates to return type of varchar2.
      -- gets all cleaned values as a group, will be null if not cleaned
      recPart := GetValues (pNsn);

      IF (pFieldName = ADD_INCREMENT)
      THEN
         RETURN recPart.add_increment;
      ELSIF (pFieldName = AMC_BASE_STOCK)
      THEN
         RETURN recPart.amc_base_stock;
      ELSIF (pFieldName = AMC_DAYS_EXPERIENCE)
      THEN
         RETURN recPart.amc_days_experience;
      ELSIF (pFieldName = AMC_DEMAND)
      THEN
         RETURN recPart.amc_demand;
      ELSIF (pFieldName = CAPABILITY_REQUIREMENT)
      THEN
         RETURN recPart.capability_requirement;
      ELSIF (pFieldName = CONDEMN_AVG)
      THEN
         RETURN recPart.condemn_avg;
      ELSIF (pFieldName = CRITICALITY)
      THEN
         RETURN recPart.criticality;
      ELSIF (pFieldName = DLA_DEMAND)
      THEN
         RETURN recPart.dla_demand;
      ELSIF (pFieldName = CURRENT_BACKORDER)
      THEN
         RETURN recPart.current_backorder;
      ELSIF (pFieldName = FEDC_COST)
      THEN
         RETURN recPart.fedc_cost;
      ELSIF (pFieldName = ITEM_TYPE)
      THEN
         RETURN recPart.item_type;
      ELSIF (pFieldName = MIC_CODE_LOWEST)
      THEN
         RETURN recPart.mic_code_lowest;
      ELSIF (pFieldName = MTBDR)
      THEN
         RETURN recPart.mtbdr;
      ELSIF (pFieldName = MIN_PURCHASE_QUANTITY)
      THEN
         RETURN recPart.min_purchase_quantity;
      ELSIF (pFieldName = NOMENCLATURE)
      THEN
         RETURN recPart.nomenclature;
      ELSIF (pFieldName = NRTS_AVG)
      THEN
         RETURN recPart.nrts_avg;
      ELSIF (pFieldName = COST_TO_REPAIR_OFF_BASE)
      THEN
         RETURN recPart.cost_to_repair_off_base;
      ELSIF (pFieldName = TIME_TO_REPAIR_OFF_BASE)
      THEN
         RETURN recPart.time_to_repair_off_base;
      ELSIF (pFieldName = TIME_TO_REPAIR_ON_BASE_AVG)
      THEN
         RETURN recPart.time_to_repair_on_base_avg;
      ELSIF (pFieldName = ORDER_LEAD_TIME)
      THEN
         RETURN recPart.order_lead_time;
      ELSIF (pFieldName = ACQUISITION_ADVICE_CODE)
      THEN
         RETURN recPart.acquisition_advice_code;
      ELSIF (pFieldName = ORDER_UOM)
      THEN
         RETURN recPart.order_uom;
      ELSIF (pFieldName = PLANNER_CODE)
      THEN
         RETURN recPart.planner_code;
      ELSIF (pFieldName = RTS_AVG)
      THEN
         RETURN recPart.rts_avg;
      ELSIF (pFieldName = RU_IND)
      THEN
         RETURN recPart.ru_ind;
      ELSIF (pFieldName = SMR_CODE)
      THEN
         RETURN recPart.smr_code;
      ELSIF (pFieldName = UNIT_COST)
      THEN
         RETURN recPart.unit_cost;
      ELSE
         -- asking for field that is not cleanable
         RETURN NULL;
      END IF;
   END GetValues;



   FUNCTION NotEqual (pField1 VARCHAR2, pField2 VARCHAR2)
      RETURN BOOLEAN
   IS
   BEGIN
      IF ( (pField1 IS NULL) AND (pField2 IS NULL))
      THEN
         RETURN FALSE;
      ELSIF (pField1 = pField2)
      THEN
         RETURN FALSE;
      ELSE
         RETURN TRUE;
      END IF;
   END NotEqual;


   -- thought below approach would be faster than cursor and reusing above procedures
   PROCEDURE NullAmdAllCleanedFields
   IS
   BEGIN
     <<updateAmdNationalStockItems>>
      BEGIN
         UPDATE amd_national_stock_items
            SET add_increment_cleaned = NULL,
                amc_base_stock_cleaned = NULL,
                amc_days_experience_cleaned = NULL,
                amc_demand_cleaned = NULL,
                capability_requirement_cleaned = NULL,
                condemn_avg_cleaned = NULL,
                criticality_cleaned = NULL,
                dla_demand_cleaned = NULL,
                current_backorder_cleaned = NULL,
                fedc_cost_cleaned = NULL,
                item_type_cleaned = NULL,
                mic_code_lowest_cleaned = NULL,
                mtbdr_cleaned = NULL,
                nomenclature_cleaned = NULL,
                nrts_avg_cleaned = NULL,
                order_lead_time_cleaned = NULL,
                order_uom_cleaned = NULL,
                cost_to_repair_off_base_cleand = NULL,
                time_to_repair_off_base_cleand = NULL,
                time_to_repair_on_base_avg_cl = NULL,
                planner_code_cleaned = NULL,
                rts_avg_cleaned = NULL,
                ru_ind_cleaned = NULL,
                smr_code_cleaned = NULL,
                unit_cost_cleaned = NULL,
                last_update_dt = SYSDATE;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction     => 'update',
                      tablename       => 'amd_national_stock_items',
                      errorLocation   => 10);
            RAISE;
      END updateAmdNationalStockItems;

      BEGIN
         UPDATE amd_part_locs
            SET removal_ind_cleaned = NULL,
                repair_level_code = NULL,
                last_update_dt = SYSDATE;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction     => 'update',
                      tablename       => 'amd_national_stock_items',
                      errorLocation   => 20);
            RAISE;
      END updatePartLocs;
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tablename       => 'amd_national_stock_items/amd_part_locs',
                   errorLocation   => 30);
         RAISE;
   END NullAmdAllCleanedFields;

   PROCEDURE NullAmdBaseCleanedFields (pNsn     bssm_base_parts.nsn%TYPE,
                                       pSran    bssm_base_parts.sran%TYPE)
   IS
      cleanableNull   partBaseFields := NULL;
   BEGIN
      UpdateAmdBaseCleaned (pNsn, pSran, cleanableNull);
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tableName       => 'amd_part_locs',
                   errorLocation   => 40,
                   key1            => pNsn,
                   key2            => pSran);
         RAISE;
   END NullAmdBaseCleanedFields;

   PROCEDURE NullAmdPartCleanedFields (pNsn bssm_parts.nsn%TYPE)
   IS
      cleanableNull   partFields := NULL;
   BEGIN
      UpdateAmdPartCleaned (pNsn, cleanableNull);
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tableName       => 'amd_national_stock_items',
                   errorLocation   => 50,
                   key1            => pNsn);
         RAISE;
   END NullAmdPartCleanedFields;

   PROCEDURE UpdateAmdAllBaseCleaned
   IS
      -- appears lots of lock_sid 2 recs created with no change of info.
      -- to speed up, only list those that have a change for our
      -- fields of concern (testing went from 4500 records to 88).
      CURSOR nsnSranListFromBssm_cur
      IS
         SELECT nsn,
                sran,
                repair_indicator,
                replacement_indicator
           FROM bssm_base_parts
          WHERE lock_sid = '2'
         MINUS
         SELECT nsn,
                sran,
                repair_indicator,
                replacement_indicator
           FROM bssm_base_parts
          WHERE lock_sid = '0';

      cleanableBase   partBaseFields := NULL;
   BEGIN
      FOR nsnSranBssm IN nsnSranListFromBssm_cur
      LOOP
         BEGIN
            cleanableBase := GetBaseValues (nsnSranBssm.nsn, nsnSranBssm.sran);
            UpdateAmdBaseCleaned (nsnSranBssm.nsn,
                                  nsnSranBssm.sran,
                                  cleanableBase);
         EXCEPTION
            WHEN OTHERS
            THEN
               errorMsg (sqlFunction     => 'update',
                         tablename       => 'amd_part_locs',
                         errorLocation   => 60);
               RAISE;
         END;
      END LOOP;

      COMMIT;
   END UpdateAmdAllBaseCleaned;

   PROCEDURE UpdateAmdBaseCleaned (pNsn          bssm_base_parts.nsn%TYPE,
                                   pSran         bssm_base_parts.sran%TYPE,
                                   pCleanable    partBaseFields)
   IS
      nsiSid   amd_national_stock_items.nsi_sid%TYPE;
      locSid   amd_spare_networks.loc_sid%TYPE;
   BEGIN
      -- removal indicator be cleaned.  amd_part_locs is determined by this and therefore current
      -- (i.e. no action_code delete).  since dropped and reloaded, reloading will take into
      -- account when cleaned.  choose not to delete record on fly when cleaned - affects
      -- quite a few children.
      -- i.e. wait till next load
      nsiSid := amd_utils.GetNsiSid (pNsn => pNsn);
      -- associate warehouse to 'W' in GetLocSid
      locSid := amd_from_bssm_pkg.GetLocSid (pSran);

      IF (nsiSid IS NOT NULL AND locSid IS NOT NULL)
      THEN
         UPDATE amd_part_locs
            SET repair_level_code_cleaned = pCleanable.repair_level_code,
                removal_ind_cleaned = pCleanable.removal_ind,
                last_update_dt = SYSDATE
          WHERE nsi_sid = nsiSid AND loc_sid = locSid;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         NULL;
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tablename       => 'amd_part_locs',
                   errorLocation   => 70);
         RAISE;
   END UpdateAmdBaseCleaned;

   PROCEDURE UpdateAmdAllPartCleaned
   IS
      CURSOR listFromBssm_cur
      IS
         SELECT *
           FROM bssm_parts
          WHERE lock_sid = '2';

      cleanablePart   partFields := NULL;
   -- lockSidZero bssm_parts%rowtype;
   BEGIN
      -- do those from bssm_parts.
      -- kind of slow so not using GetValues

      FOR lockSidTwo IN listFromBssm_cur
      LOOP
         BEGIN
            cleanablePart := GetCleanable (lockSidTwo);
            UpdateAmdPartCleaned (lockSidTwo.nsn, cleanablePart);
         /*
          begin
           select *
              into lockSidZero
              from bssm_parts
              where nsn = lockSidTwo.nsn
              and lock_sid = 0;
              -- order important for GetCleanable parameters
           cleanablePart := GetCleanable(lockSidZero, lockSidTwo);
           UpdateAmdPartCleaned(lockSidTwo.nsn, cleanablePart);
          exception
             -- possibilities occur where lock_sid 2 record and no lock_sid 0 record.
           when no_data_found then
             null;
          end;
         */
         EXCEPTION
            WHEN OTHERS
            THEN
               errorMsg (sqlFunction     => 'update',
                         tablename       => 'amd_national_stock_items',
                         errorLocation   => 80,
                         key1            => lockSidTwo.nsn);
               RAISE;
         END;
      END LOOP;

      COMMIT;
   END UpdateAmdAllPartCleaned;

   PROCEDURE UpdateAmdPartCleaned (pNsn          amd_national_stock_items.nsn%TYPE,
                                   pCleanable    partFields)
   IS
      nsiSid       amd_national_stock_items.nsi_sid%TYPE;
      currentNsn   amd_national_stock_items.nsn%TYPE;
   BEGIN
      nsiSid := amd_utils.GetNsiSid (pNsn => pNsn);

      -- some or most maybe null
      UPDATE amd_national_stock_items
         SET add_increment_cleaned = pCleanable.add_increment,
             amc_base_stock_cleaned = pCleanable.amc_base_stock,
             amc_days_experience_cleaned = pCleanable.amc_days_experience,
             amc_demand_cleaned = pCleanable.amc_demand,
             capability_requirement_cleaned =
                pCleanable.capability_requirement,
             condemn_avg_cleaned = pCleanable.condemn_avg,
             criticality_cleaned = pCleanable.criticality,
             dla_demand_cleaned = pCleanable.dla_demand,
             current_backorder = pCleanable.current_backorder,
             fedc_cost_cleaned = pCleanable.fedc_cost,
             item_type_cleaned = pCleanable.item_type,
             mic_code_lowest_cleaned = pCleanable.mic_code_lowest,
             mtbdr_cleaned = pCleanable.mtbdr,
             nomenclature_cleaned = pCleanable.nomenclature,
             nrts_avg_cleaned = pCleanable.nrts_avg,
             order_lead_time_cleaned = pCleanable.order_lead_time,
             order_uom_cleaned = pCleanable.order_uom,
             cost_to_repair_off_base_cleand =
                pCleanable.cost_to_repair_off_base,
             time_to_repair_off_base_cleand =
                pCleanable.time_to_repair_off_base,
             time_to_repair_on_base_avg_cl =
                pCleanable.time_to_repair_on_base_avg,
             planner_code_cleaned = pCleanable.planner_code,
             rts_avg_cleaned = pCleanable.rts_avg,
             ru_ind_cleaned = pCleanable.ru_ind,
             smr_code_cleaned = pCleanable.smr_code,
             unit_cost_cleaned = pCleanable.unit_cost,
             last_update_dt = SYSDATE
       WHERE nsi_sid = nsiSid;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         -- this would occur when cannot find nsi_sid or current nsn
         NULL;
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tableName       => 'amd_national_stock_items',
                   errorLocation   => 70,
                   key1            => pNsn,
                   key2            => TO_CHAR (nsiSid));
         RAISE;
   END UpdateAmdPartCleaned;

   ------- trigger oriented procedures ---------
   PROCEDURE UpdateAmdPartByTrigger (pLockSidTwo bssm_parts%ROWTYPE)
   IS
      cleanablePart   partFields := NULL;
   BEGIN
      cleanablePart := GetCleanable (pLockSidTwo);
      UpdateAmdPartCleaned (pLockSidTwo.nsn, cleanablePart);
   EXCEPTION
      -- part of trigger, don't want to fail
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tablename       => 'amd_national_stock_items',
                   errorLocation   => 80,
                   key1            => pLockSidTwo.nsn);
         RAISE;
   END UpdateAmdPartByTrigger;


   PROCEDURE UpdateAmdBaseByTrigger (pLockSidTwo bssm_base_parts%ROWTYPE)
   IS
      cleanable   partBaseFields := NULL;
   BEGIN
      cleanable := GetBaseCleanable (pLockSidTwo);
      UpdateAmdBaseCleaned (pLockSidTwo.nsn, pLockSidTwo.sran, cleanable);
   EXCEPTION
      -- part of trigger, don't want to fail
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tableName       => 'amd_part_locs',
                   errorLocation   => 90,
                   key1            => pLockSidTwo.nsn,
                   key2            => pLockSidTwo.sran);
         RAISE;
   END UpdateAmdBaseByTrigger;


   PROCEDURE OnPartResetByTrigger (pLockSidTwo bssm_parts%ROWTYPE)
   IS
      -- bob's code on reset deletes lock_sid 2 then updates lock_sid 0
      bssmPartRec   bssm_parts%ROWTYPE;
   BEGIN
      -- on reset, values are not considered "cleaned" anymore, source systems caught up.
      NullAmdPartCleanedFields (pLockSidTwo.nsn);
      -- since amd should catch up at the same time of it's load,
      -- grab only those that currently bssm is the only source for (may be off by 10%).
      -- if want to be safer run amd_from_bssm_pkg.loadamdfrombssmraw to alleviate
      -- possible off by 10%.
      amd_from_bssm_pkg.UpdateAmdNsi (pLockSidTwo);
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         errorMsg (sqlFunction     => 'update',
                   tableName       => 'amd_national_stock_items',
                   errorLocation   => 100,
                   key1            => pLockSidTwo.nsn);
         RAISE;
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tableName       => 'amd_national_stock_items',
                   errorLocation   => 110,
                   key1            => pLockSidTwo.nsn);
         RAISE;
   END OnPartResetByTrigger;

   PROCEDURE OnBaseResetByTrigger (pLockSidTwo bssm_base_parts%ROWTYPE)
   IS
      -- bob's code on reset deletes lock_sid 2 then updates lock_sid 0
      bssmBaseRec   bssm_base_parts%ROWTYPE;
   BEGIN
      -- on reset, values are not considered "cleaned" anymore, source systems caught up.
      NullAmdBaseCleanedFields (pLockSidTwo.nsn, pLockSidTwo.sran);
      -- since amd should catch up at the same time of it's load,
      -- grab only those that currently bssm is the only source for (may be off by 10%).
      -- if want to be safer run amd_from_bssm_pkg.loadamdfrombssmraw to alleviate
      -- possible off by 10%.
      amd_from_bssm_pkg.UpdateAmdPartLocs (pLockSidTwo);
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         errorMsg (sqlFunction     => 'update',
                   tableName       => 'amd_part_locs',
                   errorLocation   => 120,
                   key1            => pLockSidTwo.nsn);
         RAISE;
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction     => 'update',
                   tableName       => 'amd_part_locs',
                   errorLocation   => 130,
                   key1            => pLockSidTwo.nsn);
         RAISE;
   END OnBaseResetByTrigger;

   PROCEDURE version
   IS
   BEGIN
      writeMsg (pTableName        => 'amd_cleaned_from_bssm_pkg',
                pError_location   => 140,
                pKey1             => 'amd_cleaned_from_bssm_pkg',
                pKey2             => '$Revision:   1.19  $');
   END version;
BEGIN
   /*  this is an alternative method than comparing lock_sid 2 with lock_sid 0
   to determine cleaned data.  marginally more difficult to maintain as not as intuitive
   as comparing lock_sids - best spares uses this approach of reading modflag1 and modflag2
   to determine if something has been cleaned.  this is here because a trigger, for
   example on bssm_parts, cannot requery the table to get the lock_sid 0 value
   used for comparison - get mutating error.  this and associated functions
   can go away if triggers not used for update of cleaned data - or everything can be updated
   to use this and skip the lock_sid 2 vs lock_sid 0 comparison.

        2 fields, modflag1 and modflag2 contain the bits of those fields that
   have been cleaned. Created 2 pl/sql arrays to relate this.
   Using characteristic of sparseness in pl/sql array to hold
   "power" values to their associated field names (probably could've used
   constants instead).
   This means the indexvalue of pl/sql array is also the bit value
   related to the field as defined in best spares application. Little
   easier to cycle thru list this way.
   When bitAnd'ed with corresponding modflag1 or modflag2, will note
   cleaned field. the definitions of the modflag1 and modflag2 come from
   the SparesCommon.h file.
   Changed SparesCommon.h definition names to match database field names.
   Easier to read/maintain than hardcode calculated values by
   using power function - will match up well with SparesCommon.h if needed
   updated or added.
   eg. mtbdr    from sparesCommon.h
             #define MOD1_MTBRD (1 << 28)
       below
         gModflag1Map(POWER(2,28)) := MTBDR

 */



   -- modflag1
   gModflag1Map (POWER (2, 9)) := pbl_flag; -- no cleaned spot in amd, but still get it
   gModflag1Map (POWER (2, 10)) := MFGR; -- no cleaned spot in amd, but still get it
   gModflag1Map (POWER (2, 11)) := ADD_INCREMENT;
   gModflag1Map (POWER (2, 12)) := COST_TO_REPAIR_OFF_BASE; -- OFF_BASE_REPAIR_COST
   gModflag1Map (POWER (2, 13)) := ORDER_UOM;                      /* UNITS */
   gModflag1Map (POWER (2, 14)) := PLANNER_CODE;
   gModflag1Map (POWER (2, 15)) := MIC_CODE_LOWEST;
   gModflag1Map (POWER (2, 16)) := SMR_CODE;
   gModflag1Map (POWER (2, 19)) := MONTHLY_DEMAND_RATE;    -- not an amd field
   gModflag1Map (POWER (2, 21)) := NOMENCLATURE;
   gModflag1Map (POWER (2, 22)) := WUC;  -- no cleaned spot in amd, but get it
   gModflag1Map (POWER (2, 23)) := CURRENT_BACKORDER;
   gModflag1Map (POWER (2, 24)) := DLA_DEMAND;
   gModflag1Map (POWER (2, 25)) := AMC_DEMAND;
   gModflag1Map (POWER (2, 26)) := AMC_DAYS_EXPERIENCE;
   gModflag1Map (POWER (2, 27)) := AMC_BASE_STOCK;
   gModflag1Map (POWER (2, 28)) := MTBDR;
   gModflag1Map (POWER (2, 29)) := MIN_PURCHASE_QUANTITY;


   -- modflag2
   gModflag2Map (POWER (2, 10)) := UNIT_COST;
   gModflag2Map (POWER (2, 11)) := FEDC_COST;
   gModflag2Map (POWER (2, 12)) := RU_IND;
   gModflag2Map (POWER (2, 13)) := ITEM_TYPE;
   gModflag2Map (POWER (2, 14)) := CAPABILITY_REQUIREMENT;         -- CATEGORY
   gModflag2Map (POWER (2, 15)) := CRITICALITY;
   gModflag2Map (POWER (2, 16)) := RTS_AVG;                             -- RTS
   gModflag2Map (POWER (2, 17)) := NRTS_AVG;                           -- NRTS
   gModflag2Map (POWER (2, 18)) := CONDEMN_AVG;                     -- CONDEMN
   gModflag2Map (POWER (2, 19)) := TIME_TO_REPAIR_ON_BASE_AVG; -- ON_BASE_TURNAROUND, TBASE
   gModflag2Map (POWER (2, 20)) := TIME_TO_REPAIR_OFF_BASE; -- OFF_BASE_TURNAROUND,TDEPOT
   gModflag2Map (POWER (2, 21)) := ORDER_LEAD_TIME;                -- TCONDEMN
   gModflag2Map (POWER (2, 26)) := ACQUISITION_ADVICE_CODE;


   -- decide to separate base specific into their own array,
   -- but still matches bob's "power".
   gSetflagBaseMap (POWER (2, 0)) := REPAIR_LEVEL_CODE;
   gSetflagBaseMap (POWER (2, 1)) := REMOVAL_IND;
-- following not passed on to amd at this time, i.e. no cleaned hole in amd
/*
 gSetflagBaseMap(POWER(2,2)) := MAXIMUM_STOCK;
 gSetflagBaseMap(POWER(2,3)) := MINIMUM_STOCK;
 gSetflagBaseMap(POWER(2,8)) := RSP_ON_HAND;
 gSetflagBaseMap(POWER(2,9)) := RSP_OBJECTIVE;

 gSetflagBaseMap(POWER(2,22) := HOLDING_COST;
 gSetflagBaseMap(POWER(2,23) := BACKORDER_FIXED_COST;
 gSetflagBaseMap(POWER(2,24) := BACKORDER_VARIABLE_COST;
 gSetflagBaseMap(POWER(2,25) := ORDER_COST;
*/



END AMD_CLEANED_FROM_BSSM_PKG;
/


DROP PACKAGE BODY AMD_OWNER.AMD_CLEAN_DATA;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_clean_data as
    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.6  $
         $Date:   Jun 09 2006 12:42:54  $
     $Workfile:   amd_clean_data.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_clean_data.pkb-arc  $

      Rev 1.6   Jun 09 2006 12:42:54   zf297a
   implemented version

      Rev 1.6   Aug 23 2005 12:22:38   zf297a
   Implemented interfaces using the nsn and part_no  that is retrieving cleaned data via the amd_load / diff process.  This will allow the routine to attempt to retrieve the cleaned_data via the part_no if it is not found via the nsn.

      Rev 1.5   Aug 03 2005 10:33:58   zf297a
   Fixed CheckCache - checked if nsn is NULL

      Rev 1.4   May 06 2005 08:15:38   c970183
   changed dla_warehouse_stock and dla_warehouse_stock_cleaned to current_backorder and current_backorder_cleaned.  added pvcs keywords
   	  */

/*
 	These routines will make it easy to retrieve cleaned data from BSSM
 	Douglas S. Elder and Chung D. Lu  	10/03/01	Initial implementation

	Douglas S. Elder					11/6/01		The cache will work best
		when the data is sorted by nsn asc, prime_ind desc
 */

 	cleanRec		amd_cleaned_from_bssm_pkg.partFields := null ;

	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_clean_data',
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;

	procedure CheckCache(pNsn in varchar2) is
	begin
		if cleanRec.nsn != pNsn or cleanRec.nsn is null then
			cleanRec := amd_cleaned_from_bssm_pkg.GetValues(pNsn) ;
		end if ;
	exception when NO_DATA_FOUND then
		cleanRec := null ;
	end CheckCache ;

	procedure checkCache(pNsn in varchar2, pPartNo in varchar2) is
	begin
		if (cleanRec.nsn != pNsn and cleanRec.part_no != pPartNo)  or cleanRec.nsn is null then
			cleanRec := amd_cleaned_from_bssm_pkg.GetValuesX(pNsn, pPartNo) ;
		end if ;
	exception when NO_DATA_FOUND then
		cleanRec := null ;
	end CheckCache ;

   	-- ks - base specific clean fields, not in pkg body yet
	function RemovalInd(pNsn in varchar2, pLocSid in number ) return varchar2 is
	begin
		return null ; -- todo
	end ;

	function RepairLevelCode(pNsn in varchar2, pLocSid in number) return varchar2 is
	begin
		return null ; -- todo
	end ;
	--

	function GetAddIncrement(pNsn in varchar2) return amd_national_stock_items.add_increment_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.add_increment ;
	end ;
	function GetAmcBaseStock(pNsn in varchar2) return amd_national_stock_items.amc_base_stock_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.amc_base_stock ;
	end ;
	function GetAmcDaysExperience(pNsn in varchar2) return amd_national_stock_items.amc_days_experience_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.amc_days_experience ;
	end ;
	function GetAmcDemand(pNsn in varchar2) return amd_national_stock_items.amc_demand_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.amc_demand ;
	end ;
	function GetCapabilityRequirement(pNsn in varchar2) return amd_national_stock_items.capability_requirement_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.capability_requirement ;
	end ;
	function GetCondemnAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.condemn_avg_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.condemn_avg ;
	end ;
	function GetCostToRepairOffBase(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.cost_to_repair_off_base_cleand%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.cost_to_repair_off_base ;
	end ;
	function GetCriticality(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.criticality_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.criticality ;
	end ;
	function GetDlaDemand(pNsn in varchar2) return amd_national_stock_items.dla_demand_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.dla_demand ;
	end ;
	function GetCurrentBackorder(pNsn in varchar2) return amd_national_stock_items.current_backorder_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.current_backorder ;
	end ;
	function GetFedcCost(pNsn in varchar2) return amd_national_stock_items.fedc_cost_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.fedc_cost ;
	end ;
	function GetItemType(pNsn in varchar2) return amd_national_stock_items.item_type_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return cleanRec.item_type ;
	end ;
	function GetMicCodeLowest(pNsn in varchar2) return amd_national_stock_items.mic_code_lowest_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.mic_code_lowest ;
	end ;
	function GetMtbdr(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.mtbdr_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.mtbdr ;
	end ;
	function GetNomenclature(pNsn in varchar2) return amd_national_stock_items.nomenclature_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.nomenclature ;
	end ;
	function GetNrtsAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.nrts_avg_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.nrts_avg ;
	end ;
	function GetOrderLeadTime(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.order_lead_time_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.order_lead_time ;
	end ;
	function GetOrderUom(pNsn in varchar2) return amd_national_stock_items.order_uom_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.order_uom ;
	end ;

	function GetPlannerCode(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.planner_code_cleaned%type is
	begin
		--return	amd_cleaned_from_bssm_pkg.GetValues(pNsn => pNsn, pFieldName => amd_cleaned_from_bssm_pkg.PLANNER_CODE) ;
		CheckCache(pNsn, pPartNo) ;
		return cleanRec.planner_code ; -- todo
	end ;
	function GetPrimeInd(pNsn in varchar2, pPart_no in varchar2, pMfgr in varchar2) return amd_nsi_parts.prime_ind_cleaned%type is
	begin
		-- return	amd_cleaned_from_bssm_pkg.GetValues(pNsn => pNsn, pFieldName => amd_cleaned_from_bssm_pkg.PRIME_IND) ;
		return null ; -- todo
	end ;
	function GetRuInd(pNsn in varchar2) return amd_national_stock_items.ru_ind_cleaned%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.ru_ind ;
	end ;
	function GetRtsAvg(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.rts_avg_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.rts_avg ;
	end ;
	function GetSmrCode(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.smr_code_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.smr_code ;
	end ;
	function GetTimeToRepairOffBase(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.time_to_repair_off_base_cleand%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.time_to_repair_off_base ;
	end ;
	function GetTimeToRepairOnBaseAvg(pNsn in varchar2) return amd_national_stock_items.time_to_repair_on_base_avg_cl%type is
	begin
		CheckCache(pNsn) ;
		return	cleanRec.time_to_repair_on_base_avg ;
	end ;
	function GetUnitCost(pNsn in varchar2, pPartNo in varchar2) return amd_national_stock_items.unit_cost_cleaned%type is
	begin
		CheckCache(pNsn, pPartNo) ;
		return	cleanRec.unit_cost ;
	end ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_clean_data',
		 		pError_location => 10, pKey1 => 'amd_clean_data', pKey2 => '$Revision:   1.6  $') ;
	end version ;

end amd_clean_data ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_DEFAULTS;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_defaults
AS
   /*

       $Author:   zf297a  $
     $Revision:   1.46
         $Date:   19 May 2017
     $Workfile:   amd_defaults.pkb  $

       Rev 1.46 5/19/17 dse added getLikeNewNsn

       Rev 1.45 9/21/15 dse added getProgramId

       Rev 1.44 2/23/15 dse added getStartLocId

       rev 1.43 2/4/15 dse added getIcpInd, getSourceCode, getSourceOfSupply, and getNonStockageList

       rev 1.42 removed a2a dependencies

        Rev 1.41   09 Jul 2008 14:43:06   zf297a
     Implemented interfaces:
     function getCONSUMABLE_PLANNER_CODE return  amd_planners.PLANNER_CODE%type ;
     function getCONSUMABLE_LOGON_ID return
      amd_users.BEMS_ID%type ;
     function getREPAIRABLE_PLANNER_CODE return  amd_planners.PLANNER_CODE%type ;
     function getREPAIRABLE_LOGON_ID return  amd_users.BEMS_ID%type ;

     and initialized CONSUMABLE_PLANNER_CODE,
     CONSUMABLE_LOGON_ID,
     REPAIRABLE_PLANNER_CODE,
     and REPAIRABLE_LOGON_ID.

        Rev 1.40   22 May 2008 16:48:26   zf297a
     Implemeted interface for getVersion.

        Rev 1.39   22 May 2008 11:02:26   zf297a
     For variables AMD_AUS_SC, AMD_BASC_SC, AMD_CAN_SC, and AMD_UK_SC use their default literal or initialize by getting data from the amd_param_changes table.  Load the fmsSegCodes varray with these values.

        Rev 1.38   14 Nov 2007 12:08:22   zf297a
     implemented interface for getTIME_TO_REPAIR_OFFBASE

        Rev 1.37   24 Oct 2007 17:36:58   zf297a
     Implemnted ROP / ROQ get functions

        Rev 1.36   12 Oct 2007 17:23:58   zf297a
     implemented get functions for new constants.

        Rev 1.35   11 Oct 2007 23:35:06   zf297a
     Check for TSL_CONSUMABL_CALENDAR_DAYS in amd_param_changes using name tsl_consumabl_calendar_days, if not found default to 210.
     Implemented function getTSL_CONSUMABL_CALENDAR_DAYS.

        Rev 1.34   11 Oct 2007 12:43:10   zf297a
     implemented interface getAMD_CAN_LOC_ID

        Rev 1.33   28 Jun 2007 12:25:16   zf297a
     Implemented getDATE_LVL_LOAED_MODIFIER: this number is used by the load query for consumable gold.lvls.

        Rev 1.32   12 Apr 2007 09:31:36   zf297a
     implemented interfaces for PSMS_COMMIT_TRESHOLD, GOLD_COMMIT_TRESHOLD, TEMP_NSNS_COMMIT_THRESHOLD, MAIN_COMMIT_THRESHOLD, and PARTSTUC_COMMIT_THRESHOLD.

        Rev 1.31   03 Apr 2007 14:33:30   zf297a
     Implemented the following interfaces:
     getNSN_LOGON_ID
     getNSL_LOGON_ID
     getNSN_PLANNER_CODE
     getNSL_PLANNER_CODE
     getCLEAN_DATA_DAY
     checkDefaultPlanners
     checkDefaultLogonIds

        Rev 1.30   22 Mar 2007 16:46:14   zf297a
     Implemented getAMD_AUS_LOC_ID  function

        Rev 1.29   Oct 26 2006 12:13:38   zf297a
     Removed writeMsg - since some of the default functions are used in sql queries there cannot be DML that inserts or updates.   Test the STRICT flag to see if an exception should be raised when default values cannot be verified against amd tables.  Added code to initialize the STRICT flag via the amd_param_changes table.

        Rev 1.28   Oct 24 2006 14:19:42   zf297a
     Fixed getNsnLogonId and getNslLogonId to validate the logon_id against amd_planner_logons using a select with an exists clause because more than one row could exist for a give logon_id and planner_code since there are multiple data_sources.
     Changed the dbms_output message to a writeMsg so any error messages get logged to amd_load_details.
     Added dbms_output.put_line to version.

        Rev 1.27   Jun 09 2006 12:55:38   zf297a
     implemented version

        Rev 1.26   Jan 05 2006 12:23:28   zf297a
     Fixed getNslLogonId - was using the NSN_PLANNER_CODE instead of the NSL_PLANNER_CODE

        Rev 1.25   Dec 02 2005 10:18:10   zf297a
     Fixed getNsnPlannerCode, getNslPlannerCode, getNsnLogonId, and getNslLogonId so that they always return a default value. NOTE: if the literal is returned, it may not be a valid planner_code or logon_id.  In that case the data may no go to the SPO correctly unless RJBplanner.xml and RichellBodine.xml is sent manully to the SPO!

        Rev 1.24   Nov 30 2005 10:57:38   zf297a
     added getBom, getBomQuantity, and used these new functions to get data from the amd_param_changes table, if there is not data found bom defaults to 'C17' and bom_quantity defaults to 1.

        Rev 1.23   Nov 01 2005 12:32:52   zf297a
     Added some more "getter" functions for other constants.

        Rev 1.22   Nov 01 2005 12:21:34   zf297a
     Simplified the name of the "getter's" to getCONSTANT where CONSTANT is the identifier for the associated constant.

        Rev 1.21   Nov 01 2005 11:50:32   zf297a
     Added "getter 's" (get functions) for some of the constant's so they can be used in ordinary SQL instead of only in PL/SQL code.

        Rev 1.20   Sep 13 2005 11:04:22   zf297a
     Implemented interfaces for isParamKey and addParamKey.

        Rev 1.19   Aug 15 2005 11:43:36   zf297a
     Removed all debugMsg's since they were causing more trouble than they were worth.

        Rev 1.18   Aug 09 2005 11:50:20   zf297a
     Removed debugMsg that reports a missing logon_id / planner_code in amd_planner_logons since this caused an error with DataStage's query since it was inserting data into amd_load_details, which is not allowed for only a DataStage query.

        Rev 1.17   Aug 05 2005 11:27:02   zf297a
     Removed raise_application errors and made them into debugMsg's.  This is better than having a hard error here, since  execution should continue and the reported condition can be corrected at another time.

        Rev 1.16   Jul 27 2005 10:24:38   zf297a
     Streamlined code for default planner_codes and logon_id's

        Rev 1.15   Jul 26 2005 15:10:28   zf297a
     added additional edits for the default logon_id's

        Rev 1.14   Jul 08 2005 09:36:32   zf297a
     Added PVCS keyword $Log$ and copied the PVCS history log into the header comments.

    Rev 1.13
    Locked by:      zf297a
    Checked in:     Jul 08 2005 09:08:36
    Last modified:  Jul 08 2005 09:08:36
    Author id: zf297a     lines deleted/added/moved: 2/11/0
    added the public function getLogonId
    -----------------------------------
    Rev 1.12
    Checked in:     Jul 08 2005 08:58:34
    Last modified:  Jul 08 2005 08:58:34
    Author id: zf297a     lines deleted/added/moved: 6/11/0
    Added the public function getPlannerCode
    -----------------------------------
    Rev 1.11
    Checked in:     Jul 05 2005 13:54:12
    Last modified:  Jul 05 2005 13:54:12
    Author id: zf297a     lines deleted/added/moved: 2/6/0
    added $Log$ PVCS keyword
    -----------------------------------
    Rev 1.10
    Checked in:     Jul 05 2005 13:50:52
    Last modified:  Jul 05 2005 13:50:52
    Author id: zf297a     lines deleted/added/moved: 3/56/0
    Added NSN_PLANNER_CODE and NSL_PLANNER_CODE and their corresponding logon_id's: NSN_LOGON_ID and NSL_LOGON_ID.
    -----------------------------------
    Rev 1.9
    Checked in:     Mar 27 2002 12:22:38
    Last modified:  Mar 27 2002 12:22:38
    Author id: c970183     lines deleted/added/moved: 0/6/0
    Added PVCS keywords
    -----------------------------------
    Rev 1.8
    Checked in:     Nov 30 2001 06:28:40
    Last modified:  Nov 02 2001 10:22:08
    Author id: c372701     lines deleted/added/moved: 26/130/0
    gw - 11/29/01 - Updates due to system problems on the Version Manager NT Server. - Done to reflect latest changes - per Doug Elder
    -----------------------------------
    Rev 1.7
    Checked in:     Oct 28 2001 15:08:28
    Last modified:  Oct 28 2001 12:40:22
    Author id: c378632     lines deleted/added/moved: 0/12/0
    unit_cost_factor_offbase
    time_to_repair_offbase
    -----------------------------------
    Rev 1.6
    Checked in:     Oct 28 2001 11:31:26
    Last modified:  Oct 28 2001 11:21:32
    Author id: c378632     lines deleted/added/moved: 0/12/0
    time_to_repair_onbase,
    cost_to_repair_onbase
    -----------------------------------
    Rev 1.5
    Checked in:     Oct 25 2001 09:57:38
    Last modified:  Oct 25 2001 09:57:04
    Author id: c970183     lines deleted/added/moved: 48/178/0
    Made action codes, consumable, and repairable constants.
    -----------------------------------
    Rev 1.4
    Checked in:     Oct 25 2001 09:48:00
    Last modified:  Oct 25 2001 09:48:00
    Author id: c970183     lines deleted/added/moved: 196/48/0
    Added constants repairable and consumable.
    -----------------------------------
    Rev 1.3
    Checked in:     Oct 25 2001 07:14:08
    Last modified:  Oct 25 2001 07:13:40
    Author id: c970183     lines deleted/added/moved: 2/20/0
    Added routines to initialize the Action Codes from the amd_param_changes table
    -----------------------------------
    Rev 1.2
    Checked in:     Oct 23 2001 14:33:58
    Last modified:  Oct 23 2001 14:28:42
    Author id: c970183     lines deleted/added/moved: 45/175/0
    Made implementation updates
    -----------------------------------
    Rev 1.1
    Checked in:     Oct 18 2001 07:00:10
    Last modified:  Oct 18 2001 06:59:22
    Author id: c970183     lines deleted/added/moved: 172/51/0
    Changed to use new amd_param_changes table
    -----------------------------------
    Rev 1.0
    Checked in:     Oct 11 2001 08:19:52
    Last modified:  Oct 11 2001 07:33:40
    Author id: c372701     lines deleted

     The order_lead_time_........ variables will be initialized by the
     package body's 'begin' block.  This will happen the first time
     the package is referenced.
     */



   order_lead_time_consumable       amd_spare_parts.order_lead_time_defaulted%TYPE
      := NULL;
   order_lead_time_repairable       amd_spare_parts.order_lead_time_defaulted%TYPE
      := NULL;
   engine_part_reduction_factor     NUMBER := NULL;
   non_engine_part_reductn_factor   NUMBER := NULL;
   consumable_reduction_factor      NUMBER := NULL;

   FUNCTION getLikeNewNSN
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN LIKE_NEW_NSN;
   END getLikeNewNSN;

   PROCEDURE writeMsg (
      pTableName        IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
      pError_location   IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
      pKey1             IN VARCHAR2 := '',
      pKey2             IN VARCHAR2 := '',
      pKey3             IN VARCHAR2 := '',
      pKey4             IN VARCHAR2 := '',
      pData             IN VARCHAR2 := '',
      pComments         IN VARCHAR2 := '')
   IS
   BEGIN
      Amd_Utils.writeMsg (pSourceName       => 'amd_defaults',
                          pTableName        => pTableName,
                          pError_location   => pError_location,
                          pKey1             => pKey1,
                          pKey2             => pKey2,
                          pKey3             => pKey3,
                          pKey4             => pKey4,
                          pData             => pData,
                          pComments         => pComments);
   END writeMsg;

   PROCEDURE debugMsg (sqlFunction         IN VARCHAR2,
                       tableName           IN VARCHAR2,
                       rptLocation         IN NUMBER,
                       key1                IN VARCHAR2 := '',
                       key2                IN VARCHAR2 := '',
                       key3                IN VARCHAR2 := '',
                       key4                IN VARCHAR2 := '',
                       key5                IN VARCHAR2 := '',
                       keywordValuePairs   IN VARCHAR2 := '')
   IS
   BEGIN
      Amd_Utils.InsertErrorMsg (
         pLoad_no        => Amd_Utils.GetLoadNo (pSourceName   => sqlFunction,
                                                 pTableName    => tableName),
         pData_line_no   => rptLocation,
         pData_line      => 'amd_defaults',
         pKey_1          => key1,
         pKey_2          => key2,
         pKey_3          => key3,
         pKey_4          => key4,
         pKey_5          =>    key5
                            || ' '
                            || TO_CHAR (SYSDATE, 'MM/DD/YY HH:MM:SS')
                            || ' '
                            || keywordValuePairs,
         pComments       =>    'sqlcode('
                            || SQLCODE
                            || ') sqlerrm('
                            || SQLERRM
                            || ')');
      COMMIT;
      RETURN;
   END debugMsg;

   -- put a wrapper around debugMsg so it will only write one message to amd_load_details
   PROCEDURE displayOnce (sqlFunction         IN VARCHAR2,
                          tableName           IN VARCHAR2,
                          rptLocation         IN NUMBER,
                          key1                IN VARCHAR2 := '',
                          key2                IN VARCHAR2 := '',
                          key3                IN VARCHAR2 := '',
                          key4                IN VARCHAR2 := '',
                          key5                IN VARCHAR2 := '',
                          keywordValuePairs   IN VARCHAR2 := '')
   IS
      -- rptLocation must be unique for a given package for this to work
      CURSOR loadDetails
      IS
         SELECT load_no
           FROM amd_load_details
          WHERE     amd_load_details.DATA_LINE = 'amd_defaults'
                AND amd_load_details.DATA_LINE_NO = rptLocation;

      recExists   BOOLEAN := FALSE;
   BEGIN
      FOR rec IN loadDetails
      LOOP
         recExists := TRUE;
         EXIT;
      END LOOP;

      IF NOT recExists
      THEN
         debugMsg (sqlFunction         => sqlFunction,
                   tableName           => tableName,
                   rptLocation         => rptLocation,
                   key1                => key1,
                   key2                => key2,
                   key3                => key3,
                   key4                => key4,
                   key5                => key5,
                   keywordValuePairs   => keywordValuePairs);
      END IF;
   END displayOnce;

   FUNCTION isParamKey (key IN VARCHAR2)
      RETURN BOOLEAN
   IS
      theKey   amd_params.PARAM_KEY%TYPE;
   BEGIN
      SELECT param_key
        INTO theKey
        FROM amd_params
       WHERE param_key = key;

      RETURN TRUE;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN FALSE;
   END isParamKey;

   PROCEDURE addParamKey (key IN VARCHAR2, description IN VARCHAR2)
   IS
      PROCEDURE doUpdate
      IS
      BEGIN
         UPDATE amd_params
            SET param_description = description
          WHERE param_key = key;
      EXCEPTION
         WHEN OTHERS
         THEN
            writeMsg (pTableName        => 'amd_params',
                      pError_location   => 4,
                      pKey1             => key,
                      pKey2             => description);
            RAISE;
      END doUpdate;
   BEGIN
      INSERT INTO amd_params (param_key, param_description)
           VALUES (key, description);
   EXCEPTION
      WHEN STANDARD.DUP_VAL_ON_INDEX
      THEN
         doUpdate;
      WHEN OTHERS
      THEN
         writeMsg (pTableName        => 'amd_params',
                   pError_location   => 4,
                   pKey1             => key,
                   pKey2             => description);
         RAISE;
   END addParamKey;

   PROCEDURE setParamValue (key IN VARCHAR2, VALUE IN VARCHAR2)
   IS
   BEGIN
      INSERT INTO amd_param_changes (param_key,
                                     param_value,
                                     effective_date,
                                     user_id)
           VALUES (key,
                   VALUE,
                   SYSDATE,
                   USER);
   END setParamValue;

   FUNCTION GetParamValue (key IN VARCHAR2)
      RETURN amd_param_changes.param_value%TYPE
   IS
      VALUE   amd_param_changes.param_value%TYPE := NULL;
   BEGIN
      SELECT param_value
        INTO VALUE
        FROM amd_param_changes
       WHERE     param_key = key
             AND effective_date = (SELECT MAX (effective_date)
                                     FROM amd_param_changes
                                    WHERE param_key = key);

      RETURN VALUE;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN NULL;
   END GetParamValue;

   FUNCTION GetOrderLeadTime (
      pItem_type   IN amd_national_stock_items.item_type%TYPE)
      RETURN amd_spare_parts.order_lead_time_defaulted%TYPE
   IS
      FUNCTION IsConsumable
         RETURN BOOLEAN
      IS
      BEGIN
         RETURN (UPPER (pItem_type) = amd_defaults.CONSUMABLE);
      END IsConsumable;

      FUNCTION IsRepairable
         RETURN BOOLEAN
      IS
      BEGIN
         RETURN (UPPER (pItem_type) = amd_defaults.REPAIRABLE);
      END IsRepairable;
   BEGIN
      IF IsConsumable
      THEN
         RETURN order_lead_time_consumable;
      ELSIF IsRepairable
      THEN
         RETURN order_lead_time_repairable;
      ELSE
         RETURN NULL;
      END IF;
   END GetOrderLeadTime;

   FUNCTION GetSmrCode (pNsn            IN VARCHAR2,
                        pPart_no        IN VARCHAR2,
                        pMfgr           IN VARCHAR2,
                        pPlanner_code   IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN NULL; /* todo The field in the
         amd_national_stock_items may not be used
         so this function can be left as is until
         further notice.
         */
   END GetSmrCode;

   FUNCTION GetUnitCost (
      pNsn            IN amd_spare_parts.nsn%TYPE,
      pPart_no        IN amd_spare_parts.part_no%TYPE,
      pMfgr           IN amd_spare_parts.mfgr%TYPE,
      pSmr_code       IN amd_national_stock_items.smr_code%TYPE,
      pPlanner_code   IN amd_national_stock_items.planner_code%TYPE)
      RETURN amd_spare_parts.unit_cost_defaulted%TYPE
   IS
      gfp_price             fedc.gfp_price%TYPE := NULL;
      unit_cost_defaulted   amd_spare_parts.unit_cost_defaulted%TYPE := NULL;

      FUNCTION GetGfpPriceFromFedc (pPart_number   IN fedc.part_number%TYPE,
                                    pVendor_code   IN fedc.vendor_code%TYPE)
         RETURN fedc.gfp_price%TYPE
      IS
         min_gfp_price   fedc.gfp_price%TYPE := NULL;
         max_gfp_price   fedc.gfp_price%TYPE := NULL;
      BEGIN
         BEGIN
            SELECT MIN (gfp_price), MAX (gfp_price)
              INTO min_gfp_price, max_gfp_price
              FROM fedc
             WHERE part_number = pPart_number AND vendor_code = pVendor_code;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
         END GetViaPartNumberVendorCode;

         /*
           If it didn't match on part_number/cage try part_number/nsn
         */
         IF min_gfp_price IS NULL AND max_gfp_price IS NULL
         THEN
            BEGIN
               SELECT MIN (gfp_price), MAX (gfp_price)
                 INTO min_gfp_price, max_gfp_price
                 FROM fedc
                WHERE     part_number = pPart_number
                      AND nsn = amd_utils.FormatNSN (pNsn, 'Dash');
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN NULL;
            END GetViaPartNumberNsn;
         END IF;

         IF min_gfp_price != max_gfp_price
         THEN
            RETURN NULL;
         ELSE
            RETURN min_gfp_price;
         END IF;
      END GetGfpPriceFromFedc;

      FUNCTION IsEnginePart (
         pPlanner_code   IN amd_national_stock_items.planner_code%TYPE)
         RETURN BOOLEAN
      IS
      BEGIN
         RETURN (pPlanner_code = 'PSA' OR pPlanner_code = 'PSB');
      END IsEnginePart;

      /*
       A quasi-repairable item would be like a frayed rope,
       it can be fixed temporarily but the rope is eventually
       consumed - so in this context the item more closely
       resembles a consumable item.
      */
      FUNCTION IsQuasiRepariable (
         pSmr_code   IN amd_national_stock_items.smr_code%TYPE)
         RETURN BOOLEAN
      IS
      BEGIN
         IF LENGTH (pSmr_code) >= 6
         THEN
            RETURN UPPER (SUBSTR (pSmr_code, 6, 1)) = 'P';
         ELSE
            RETURN FALSE;
         END IF;
      END IsQuasiRepariable;

      FUNCTION IsConsumable (
         pSmr_code   IN amd_national_stock_items.smr_code%TYPE)
         RETURN BOOLEAN
      IS
      BEGIN
         IF LENGTH (pSmr_code) >= 6
         THEN
            RETURN UPPER (SUBSTR (pSmr_code, 6, 1)) = 'N';
         ELSE
            RETURN FALSE;
         END IF;
      END IsConsumable;
   BEGIN                                                        -- GetUnitCost
      gfp_price :=
         GetGfpPriceFromFedc (pPart_number => pPart_no, pVendor_code => pMfgr);

      IF gfp_price IS NOT NULL
      THEN
         IF IsQuasiRepariable (pSmr_code) OR IsConsumable (pSmr_code)
         THEN
            unit_cost_defaulted := gfp_price * consumable_reduction_factor;
         ELSE
            IF IsEnginePart (pPlanner_code)
            THEN
               unit_cost_defaulted := gfp_price * engine_part_reduction_factor;
            ELSE
               unit_cost_defaulted :=
                  gfp_price * non_engine_part_reductn_factor;
            END IF;
         END IF;
      END IF;

      RETURN unit_cost_defaulted; /* defaults to null if there
             isn't a fedc gfp_price.
             */
   END GetUnitCost;

   FUNCTION GetOffBaseRepairCost (pUnitCost IN NUMBER)
      RETURN NUMBER
   IS
   BEGIN
      -- todo
      -- off base repair cost is currently 10% of unit cost.  put the .10 in params table
      RETURN NULL;
   END GetOffBaseRepairCost;

   FUNCTION getPlannerCode (nsn IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      IF amd_utils.isPartConsumable (
            amd_utils.getPartNo (amd_utils.getNsiSid (pNsn => nsn)))
      THEN
         RETURN CONSUMABLE_PLANNER_CODE;
      ELSIF amd_utils.isPartRepairable (
               amd_utils.getPartNo (amd_utils.getNsiSid (pNsn => nsn)))
      THEN
         RETURN REPAIRABLE_PLANNER_CODE;
      ELSE
         RETURN NULL;
      END IF;
   END getPlannerCode;

   FUNCTION getLogonId (nsn IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      IF amd_utils.isPartConsumable (
            amd_utils.getPartNo (amd_utils.getNsiSid (pNsn => nsn)))
      THEN
         RETURN CONSUMABLE_LOGON_ID;
      ELSIF amd_utils.isPartRepairable (
               amd_utils.getPartNo (amd_utils.getNsiSid (pNsn => nsn)))
      THEN
         RETURN REPAIRABLE_LOGON_ID;
      ELSE
         RETURN NULL;
      END IF;
   END getLogonId;

   -- define getter routines for constants so they can be used outside of pl/sql in ordinary sql
   -- dse 11/01/05
   FUNCTION getDELETE_ACTION
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN DELETE_ACTION;
   END getDELETE_ACTION;

   FUNCTION getINSERT_ACTION
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN INSERT_ACTION;
   END getINSERT_ACTION;

   FUNCTION getUPDATE_ACTION
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN UPDATE_ACTION;
   END getUPDATE_ACTION;

   FUNCTION getCONSUMABLE
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN CONSUMABLE;
   END getCONSUMABLE;

   FUNCTION getREPAIRABLE
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN REPAIRABLE;
   END getREPAIRABLE;

   FUNCTION getAMD_WAREHOUSE_LOCID
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN AMD_WAREHOUSE_LOCID;
   END getAMD_WAREHOUSE_LOCID;

   FUNCTION getBSSM_WAREHOUSE_SRAN
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN BSSM_WAREHOUSE_SRAN;
   END getBSSM_WAREHOUSE_SRAN;

   FUNCTION getAMD_UK_LOC_ID
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN AMD_UK_LOC_ID;
   END getAMD_UK_LOC_ID;

   FUNCTION getAMD_UK_SC
      RETURN VARCHAR2
   IS                                               -- added 10/11/2007 by dse
   BEGIN
      RETURN AMD_UK_SC;
   END getAMD_UK_SC;

   FUNCTION getAMD_CAN_SC
      RETURN VARCHAR2
   IS                                               -- added 10/11/2007 by dse
   BEGIN
      RETURN AMD_CAN_SC;
   END getAMD_CAN_SC;

   FUNCTION getAMD_AUS_SC
      RETURN VARCHAR2
   IS                                               -- added 10/11/2007 by dse
   BEGIN
      RETURN AMD_AUS_SC;
   END getAMD_AUS_SC;

   FUNCTION getAMD_AUS_LOC_ID
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN AMD_AUS_LOC_ID;
   END getAMD_AUS_LOC_ID;

   FUNCTION getAMD_CAN_LOC_ID
      RETURN VARCHAR2
   IS                                               -- added 10/11/2007 by dse
   BEGIN
      RETURN AMD_CAN_LOC_ID;
   END getAMD_CAN_LOC_ID;


   FUNCTION getAMD_BASC_LOC_ID
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN AMD_BASC_LOC_ID;
   END getAMD_BASC_LOC_ID;

   FUNCTION getAMD_BASC_SC
      RETURN VARCHAR2
   IS                                               -- added 10/11/2007 by dse
   BEGIN
      RETURN AMD_BASC_SC;
   END getAMD_BASC_SC;

   FUNCTION getAMD_WARNER_ROBINS_LOC_ID
      RETURN VARCHAR2
   IS                                               -- added 10/11/2007 by dse
   BEGIN
      RETURN AMD_WARNER_ROBINS_LOC_ID;
   END getAMD_WARNER_ROBINS_LOC_ID;

   FUNCTION getAMD_VUB_LOC_ID
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN AMD_VUB_LOC_ID;
   END getAMD_VUB_LOC_ID;

   PROCEDURE version
   IS
   BEGIN
      writeMsg (pTableName        => 'amd_defaults',
                pError_location   => 10,
                pKey1             => 'amd_defaults',
                pKey2             => '$Revision:   1.46  $');
      DBMS_OUTPUT.put_line ('amd_defaults: $Revision:   1.46  $');
   END version;

   FUNCTION getVersion
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN '$Revision:   1.46  $';
   END getVersion;

   PROCEDURE checkDefaultPlanners
   IS
      planner_code   amd_planners.PLANNER_CODE%TYPE;
      work           NUMBER;
      msg            VARCHAR2 (2000);
      work_msg       VARCHAR2 (2000);

      error          BOOLEAN := FALSE;
   BEGIN
      BEGIN
         SELECT planner_code
           INTO planner_code
           FROM amd_planners
          WHERE     planner_code = NSN_PLANNER_CODE
                AND action_code <> amd_defaults.DELETE_ACTION;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            work_msg :=
                  'The default nsn planner code of '
               || NSN_PLANNER_CODE
               || ' does not exist in amd_planners.';
            DBMS_OUTPUT.put_line (work_msg);
            msg := work_msg;
            error := TRUE;
      END;

      BEGIN
         SELECT planner_code
           INTO planner_code
           FROM amd_planners
          WHERE     planner_code = NSL_PLANNER_CODE
                AND action_code <> amd_defaults.DELETE_ACTION;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            work_msg :=
                  'The default nsl planner code of '
               || NSL_PLANNER_CODE
               || ' does not exist in amd_planners.';
            DBMS_OUTPUT.put_line (work_msg);
            msg := msg || '.  ' || work_msg;
            error := TRUE;
      END;

      BEGIN
         SELECT 1
           INTO work
           FROM DUAL
          WHERE EXISTS
                   (SELECT NULL
                      FROM amd_planner_logons
                     WHERE     planner_code = NSN_PLANNER_CODE
                           AND action_code <> amd_defaults.DELETE_ACTION);
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            work_msg :=
                  'The default nsn planner code of '
               || NSN_PLANNER_CODE
               || ' does not exist in amd_planner_logons.';
            DBMS_OUTPUT.put_line (work_msg);
            msg := msg || '.  ' || work_msg;
            error := TRUE;
      END;

      BEGIN
         SELECT 1
           INTO work
           FROM DUAL
          WHERE EXISTS
                   (SELECT NULL
                      FROM amd_planner_logons
                     WHERE     planner_code = NSL_PLANNER_CODE
                           AND action_code <> amd_defaults.DELETE_ACTION);
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            work_msg :=
                  'The default nsl planner code of '
               || NSL_PLANNER_CODE
               || ' does not exist in amd_planner_logons.';
            DBMS_OUTPUT.put_line (work_msg);
            msg := msg || '.  ' || work_msg;
            error := TRUE;
      END;

      IF error
      THEN
         raise_application_error (-20010, msg);
      END IF;
   END checkDefaultPlanners;

   PROCEDURE checkDefaultLogonIds
   IS
      bems_id    amd_users.bems_id%TYPE;
      work       NUMBER;
      msg        VARCHAR2 (2000);
      work_msg   VARCHAR2 (2000);

      error      BOOLEAN := FALSE;
   BEGIN
      BEGIN
         SELECT bems_id
           INTO bems_id
           FROM amd_users
          WHERE     bems_id = NSN_LOGON_ID
                AND action_code <> amd_defaults.DELETE_ACTION;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            work_msg :=
                  'The default nsn logon id of '
               || NSN_LOGON_ID
               || ' does not exist in amd_users.';
            DBMS_OUTPUT.put_line (work_msg);
            msg := work_msg;
            error := TRUE;
      END;

      BEGIN
         SELECT bems_id
           INTO bems_id
           FROM amd_users
          WHERE     bems_id = NSL_LOGON_ID
                AND action_code <> amd_defaults.DELETE_ACTION;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            work_msg :=
                  'The default nsl logon id of '
               || NSL_LOGON_ID
               || ' does not exist in amd_users.';
            DBMS_OUTPUT.put_line (work_msg);
            msg := msg || '.  ' || work_msg;
            error := TRUE;
      END;

      BEGIN
         SELECT 1
           INTO work
           FROM DUAL
          WHERE EXISTS
                   (SELECT NULL
                      FROM amd_planner_logons
                     WHERE     logon_id = NSN_LOGON_ID
                           AND action_code <> amd_defaults.DELETE_ACTION);
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            work_msg :=
                  'The default nsn logon id of '
               || NSN_LOGON_ID
               || ' does not exist in amd_planner_logons.';
            DBMS_OUTPUT.put_line (work_msg);
            msg := msg || '.  ' || work_msg;
            error := TRUE;
      END;

      BEGIN
         SELECT 1
           INTO work
           FROM DUAL
          WHERE EXISTS
                   (SELECT NULL
                      FROM amd_planner_logons
                     WHERE     logon_id = NSL_LOGON_ID
                           AND action_code <> amd_defaults.DELETE_ACTION);
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            work_msg :=
                  'The default nsl logon id of '
               || NSL_LOGON_ID
               || ' does not exist in amd_planner_logons.';
            DBMS_OUTPUT.put_line (work_msg);
            msg := msg || '.  ' || work_msg;
            error := TRUE;
      END;

      IF error
      THEN
         raise_application_error (-20020, msg);
      END IF;
   END checkDefaultLogonIds;

   FUNCTION getNSN_PLANNER_CODE
      RETURN amd_planners.PLANNER_CODE%TYPE
   IS
   BEGIN
      RETURN NSN_PLANNER_CODE;
   END getNSN_PLANNER_CODE;

   FUNCTION getNSN_LOGON_ID
      RETURN amd_users.BEMS_ID%TYPE
   IS
   BEGIN
      RETURN NSN_LOGON_ID;
   END getNSN_LOGON_ID;

   FUNCTION getNSL_PLANNER_CODE
      RETURN amd_planners.PLANNER_CODE%TYPE
   IS
   BEGIN
      RETURN NSL_PLANNER_CODE;
   END getNSL_PLANNER_CODE;

   FUNCTION getNSL_LOGON_ID
      RETURN amd_users.BEMS_ID%TYPE
   IS
   BEGIN
      RETURN NSL_LOGON_ID;
   END getNSL_LOGON_ID;

   FUNCTION getCONSUMABLE_PLANNER_CODE
      RETURN amd_planners.PLANNER_CODE%TYPE
   IS
   BEGIN
      RETURN CONSUMABLE_PLANNER_CODE;
   END getCONSUMABLE_PLANNER_CODE;

   FUNCTION getCONSUMABLE_LOGON_ID
      RETURN amd_users.BEMS_ID%TYPE
   IS
   BEGIN
      RETURN CONSUMABLE_LOGON_ID;
   END getCONSUMABLE_LOGON_ID;

   FUNCTION getREPAIRABLE_PLANNER_CODE
      RETURN amd_planners.PLANNER_CODE%TYPE
   IS
   BEGIN
      RETURN REPAIRABLE_PLANNER_CODE;
   END getREPAIRABLE_PLANNER_CODE;

   FUNCTION getREPAIRABLE_LOGON_ID
      RETURN amd_users.BEMS_ID%TYPE
   IS
   BEGIN
      RETURN REPAIRABLE_LOGON_ID;
   END getREPAIRABLE_LOGON_ID;


   FUNCTION getCLEAN_DATA_DAY
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN CLEAN_DATA_DAY;
   END getCLEAN_DATA_DAY;

   -- added 4/12/2007 by dse
   FUNCTION getPSMS_COMMIT_THRESHOLD
      RETURN NUMBER
   IS
   BEGIN
      RETURN PSMS_COMMIT_THRESHOLD;
   END getPSMS_COMMIT_THRESHOLD;

   -- added 4/12/2007 by dse
   FUNCTION getMAIN_COMMIT_THRESHOLD
      RETURN NUMBER
   IS
   BEGIN
      RETURN MAIN_COMMIT_THRESHOLD;
   END getMAIN_COMMIT_THRESHOLD;

   -- added 4/12/2007 by dse
   FUNCTION getTEMP_NSNS_COMMIT_THRESHOLD
      RETURN NUMBER
   IS
   BEGIN
      RETURN TEMP_NSNS_COMMIT_THRESHOLD;
   END getTEMP_NSNS_COMMIT_THRESHOLD;

   -- added 4/12/2007 by dse
   FUNCTION getGOLD_COMMIT_THRESHOLD
      RETURN NUMBER
   IS
   BEGIN
      RETURN GOLD_COMMIT_THRESHOLD;
   END getGOLD_COMMIT_THRESHOLD;

   -- added 4/12/2007 by dse
   FUNCTION getPARTSTRUC_COMMIT_THRESHOLD
      RETURN NUMBER
   IS
   BEGIN
      RETURN PARTSTRUC_COMMIT_THRESHOLD;
   END getPARTSTRUC_COMMIT_THRESHOLD;

   -- added 6/28/2007 by dse
   FUNCTION getDATE_LVL_LOADED_MODIFIER
      RETURN NUMBER
   IS
   BEGIN
      RETURN DATE_LVL_LOADED_MODIFIER;
   END getDATE_LVL_LOADED_MODIFIER;

   FUNCTION getTSL_CONSUMABL_CALENDAR_DAYS
      RETURN NUMBER
   IS                                               -- added 10/11/2007 by dse
   BEGIN
      RETURN TSL_CONSUMABL_CALENDAR_DAYS;
   END getTSL_CONSUMABL_CALENDAR_DAYS;

   FUNCTION getROP
      RETURN NUMBER
   IS
   BEGIN
      RETURN ROP;
   END getROP;

   FUNCTION getROQ
      RETURN NUMBER
   IS
   BEGIN
      RETURN ROQ;
   END getROQ;

   FUNCTION getTIME_TO_REPAIR_OFFBASE
      RETURN amd_part_locs.time_to_repair%TYPE
   IS
   BEGIN
      RETURN TIME_TO_REPAIR_OFFBASE;
   END getTIME_TO_REPAIR_OFFBASE;

   FUNCTION getIcpInd
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN ICP_IND;
   END getIcpInd;

   FUNCTION getSourceCode
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN SOURCE_CODE;
   END getSourceCode;

   FUNCTION getSourceOfSupply
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN SOURCE_of_Supply;
   END getSourceOfSupply;



   FUNCTION getNonStockageList
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN NON_STOCKAGE_LIST;
   END getNonStockageList;

   FUNCTION getStartLocId
      RETURN NUMBER
   IS
   BEGIN
      RETURN START_LOC_ID;
   END getStartLocId;

   FUNCTION getProgramId
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN PROGRAM_ID;
   END getProgramId;
/*
 The following begin block is executed the first time this package is
 referenced.  It initialializes all the default variables from a table.
 The package will stay in memory until the application using it is finished.
 */
BEGIN
   DECLARE
      FUNCTION getStrict
         RETURN BOOLEAN
      IS
         param   AMD_PARAM_CHANGES.PARAM_VALUE%TYPE;
      BEGIN
         param := getParamValue ('strictDefaults');
         RETURN (param = '1' OR UPPER (param) = 'Y');
      END getStrict;

      FUNCTION GetCondemnAvg
         RETURN amd_national_stock_items.condemn_avg%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('condemn_avg'));
      END GetCondemnAvg;

      FUNCTION GetConsumableReductionFactor
         RETURN consumable_reduction_factor%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('consumable_reduction_factor'));
      END GetConsumableReductionFactor;

      FUNCTION GetDisposalCost
         RETURN amd_spare_parts.disposal_cost%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('disposal_cost'));
      END GetDisposalCost;

      FUNCTION GetDistribUom
         RETURN amd_national_stock_items.distrib_uom%TYPE
      IS
      BEGIN
         RETURN GetParamValue ('distrib_uom');
      END GetDistribUom;

      FUNCTION GetEnginePartReductionFactor
         RETURN engine_part_reduction_factor%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('engine_part_reduction_factor'));
      END GetEnginePartReductionFactor;

      FUNCTION GetNonEnginePartReductnFactor
         RETURN engine_part_reduction_factor%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('non_engine_part_reductn_factor'));
      END GetNonEnginePartReductnFactor;

      FUNCTION GetNrtsAvg
         RETURN amd_national_stock_items.nrts_avg%TYPE
      IS
      BEGIN
         RETURN GetParamValue ('nrts_avg');
      END GetNrtsAvg;

      FUNCTION GetOffBaseTurnAround
         RETURN amd_part_locs.time_to_repair%TYPE
      IS
      BEGIN
         RETURN GetParamValue ('off_base_turn_around');
      END GetOffBaseTurnAround;

      FUNCTION GetOrderLeadTimeConsumable
         RETURN amd_spare_parts.order_lead_time_defaulted%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('order_lead_time_consumable'));
      END GetOrderLeadTimeConsumable;

      FUNCTION GetOrderLeadTimeRepairable
         RETURN amd_spare_parts.order_lead_time_defaulted%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('order_lead_time_repairable'));
      END GetOrderLeadTimeRepairable;

      FUNCTION GetOrderQuantity
         RETURN amd_national_stock_items.order_quantity%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('order_quantity'));
      END GetOrderQuantity;

      FUNCTION GetOrderUom
         RETURN amd_spare_parts.order_uom%TYPE
      IS
      BEGIN
         RETURN GetParamValue ('order_uom');
      END GetOrderUom;

      FUNCTION GetQpeiWeighted
         RETURN amd_national_stock_items.qpei_weighted%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('qpei_weighted'));
      END GetQpeiWeighted;

      FUNCTION GetRtsAvg
         RETURN amd_national_stock_items.rts_avg%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('rts_avg'));
      END GetRtsAvg;

      FUNCTION GetScrapValue
         RETURN amd_spare_parts.scrap_value%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('scrap_value'));
      END GetScrapValue;

      FUNCTION GetShelfLife
         RETURN amd_spare_parts.shelf_life%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('shelf_life'));
      END GetShelfLife;

      FUNCTION GetTimeToRepairOnBaseAvg
         RETURN amd_national_stock_items.time_to_repair_on_base_avg_df%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('time_to_repair_on_base_avg'));
      END GetTimeToRepairOnBaseAvg;

      FUNCTION GetUnitVolume
         RETURN amd_spare_parts.unit_volume%TYPE
      IS
      BEGIN
         RETURN TO_NUMBER (GetParamValue ('unit_volume'));
      END GetUnitVolume;

      FUNCTION GetUseBssmToGetNsls
         RETURN VARCHAR2
      IS
      BEGIN
         RETURN GetParamValue ('use_bssm_to_get_nsls');
      END GetUseBssmToGetNsls;

      FUNCTION GetCostToRepairOnbase
         RETURN VARCHAR2
      IS
      BEGIN
         RETURN GetParamValue ('cost_to_repair_onbase');
      END GetCostToRepairOnbase;

      FUNCTION GetTimeToRepairOnbase
         RETURN VARCHAR2
      IS
      BEGIN
         RETURN GetParamValue ('time_to_repair_onbase');
      END GetTimeToRepairOnbase;

      FUNCTION GetUnitCostFactorOffbase
         RETURN VARCHAR2
      IS
      BEGIN
         RETURN GetParamValue ('unit_cost_factor_offbase');
      END GetUnitCostFactorOffbase;

      FUNCTION GetTimeToRepairOffbase
         RETURN VARCHAR2
      IS
      BEGIN
         RETURN GetParamValue ('time_to_repair_offbase');
      END GetTimeToRepairOffbase;

      FUNCTION getNsnPlannerCode
         RETURN amd_planners.PLANNER_CODE%TYPE
      IS
         wk_planner_code   amd_planners.planner_code%TYPE := NULL;
         planner_code      amd_planners.planner_code%TYPE := NULL;
      BEGIN
         wk_planner_code := TRIM (GetParamValue ('nsn_planner_code'));

         IF wk_planner_code IS NULL
         THEN
            wk_planner_code := 'RJB'; -- this may not be in amd_planners, but this is the current default
         END IF;

        <<validatePlannerCode>>
         BEGIN
            SELECT planner_code
              INTO getNsnPlannerCode.planner_code
              FROM amd_planners
             WHERE planner_code = wk_planner_code;
         EXCEPTION
            WHEN STANDARD.NO_DATA_FOUND
            THEN
               DBMS_OUTPUT.put_line (
                     'amd_defaults 10: Default NSN Planner_code '
                  || wk_planner_code
                  || ' is not in amd_planners.');

               IF STRICT
               THEN
                  raise_application_error (
                     -20000,
                        'amd_defaults: Default NSN Planner_code '
                     || wk_planner_code
                     || ' is not in amd_planners.');
               END IF;
         END validatePlannerCode;

         RETURN wk_planner_code;
      END getNsnPlannerCode;

      FUNCTION getNslPlannerCode
         RETURN amd_planners.PLANNER_CODE%TYPE
      IS
         wk_planner_code   amd_planners.PLANNER_CODE%TYPE := NULL;
         planner_code      amd_planners.PLANNER_CODE%TYPE := NULL;
      BEGIN
         wk_planner_code := TRIM (GetParamValue ('nsl_planner_code'));

         IF wk_planner_code IS NULL
         THEN
            wk_planner_code := 'NSD';
         END IF;

        <<validatePlannerCode>>
         BEGIN
            SELECT planner_code
              INTO getNslPlannerCode.planner_code
              FROM amd_planners
             WHERE planner_code = wk_planner_code;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               DBMS_OUTPUT.put_line (
                     'amd_defaults 20: Default NSL Planner_code '
                  || wk_planner_code
                  || ' is not in amd_planners.');

               IF STRICT
               THEN
                  raise_application_error (
                     -20001,
                        'amd_defaults: Default NSL Planner_code '
                     || wk_planner_code
                     || ' is not in amd_planners.');
               END IF;
         END validatePlannerCode;

         RETURN wk_planner_code;
      END getNslPlannerCode;

      FUNCTION getConsumablePlannerCode
         RETURN amd_planner_logons.planner_code%TYPE
      IS
         planner_code   amd_planner_logons.PLANNER_CODE%TYPE;
      BEGIN
         SELECT planner_code
           INTO getConsumablePlannerCode.PLANNER_CODE
           FROM amd_default_planners_v
          WHERE default_type = 'CONSUMABLE';

         RETURN planner_code;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            RETURN 'UNC';
      END getConsumablePlannerCode;

      FUNCTION getRepairablePlannerCode
         RETURN amd_planner_logons.planner_code%TYPE
      IS
         planner_code   amd_planner_logons.PLANNER_CODE%TYPE;
      BEGIN
         SELECT planner_code
           INTO getRepairablePlannerCode.PLANNER_CODE
           FROM amd_default_planners_v
          WHERE default_type = 'REPAIRABLE';

         RETURN planner_code;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            RETURN 'UNR';
      END getRepairablePlannerCode;

      FUNCTION getConsumableLogonId
         RETURN amd_planner_logons.LOGON_ID%TYPE
      IS
         logon_id   amd_planner_logons.LOGON_ID%TYPE;
      BEGIN
         SELECT bems_id
           INTO getConsumableLogonId.logon_id
           FROM amd_default_users_v
          WHERE default_type = 'CONSUMABLE';

         RETURN logon_id;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            RETURN '1671850';
      END getConsumableLogonId;

      FUNCTION getRepairableLogonId
         RETURN amd_planner_logons.LOGON_ID%TYPE
      IS
         logon_id   amd_planner_logons.LOGON_ID%TYPE;
      BEGIN
         SELECT bems_id
           INTO getRepairableLogonId.logon_id
           FROM amd_default_users_v
          WHERE default_type = 'REPAIRABLE';

         RETURN logon_id;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            RETURN '0324366';
      END getRepairableLogonId;

      FUNCTION getNsnLogonId
         RETURN amd_planner_logons.LOGON_ID%TYPE
      IS
         logon_id      amd_planner_logons.logon_id%TYPE;
         wk_logon_id   amd_planner_logons.logon_id%TYPE;
         result        NUMBER;
      BEGIN
         wk_logon_id := TRIM (GetParamValue ('nsn_logon_id'));

         IF wk_logon_id IS NULL
         THEN
            wk_logon_id := '0334080'; -- this user may not exist in amd_users, but this is the current default
         END IF;

        <<validateLogonId>>
         BEGIN
            SELECT 1
              INTO result
              FROM DUAL
             WHERE EXISTS
                      (SELECT NULL
                         FROM amd_planner_logons
                        WHERE     logon_id = wk_logon_id
                              AND planner_code = NSN_PLANNER_CODE
                              AND action_code <> DELETE_ACTION);
         EXCEPTION
            WHEN STANDARD.NO_DATA_FOUND
            THEN
               DBMS_OUTPUT.put_line (
                     'amd_defaults 30: Default NSN Logon_id, '
                  || wk_logon_id
                  || ' does not exist in amd_planner_logons for planner '
                  || NSN_PLANNER_CODE);

               IF STRICT
               THEN
                  raise_application_error (
                     -20002,
                        'amd_defaults: Default NSN Logon_id, '
                     || wk_logon_id
                     || ' does not exist in amd_planner_logons for planner '
                     || NSN_PLANNER_CODE);
               END IF;
         END validateLogonId;

         RETURN wk_logon_id;
      END getNsnLogonId;

      FUNCTION getNslLogonId
         RETURN amd_planner_logons.LOGON_ID%TYPE
      IS
         logon_id      amd_planner_logons.logon_id%TYPE;
         wk_logon_id   amd_planner_logons.logon_id%TYPE;
         result        NUMBER;
      BEGIN
         wk_logon_id := TRIM (GetParamValue ('nsl_logon_id'));

         IF wk_logon_id IS NULL
         THEN
            wk_logon_id := '0235143';
         END IF;

        <<validateLogonId>>
         BEGIN
            SELECT 1
              INTO result
              FROM DUAL
             WHERE EXISTS
                      (SELECT NULL
                         FROM amd_planner_logons
                        WHERE     logon_id = wk_logon_id
                              AND planner_code = NSL_PLANNER_CODE
                              AND action_code <> DELETE_ACTION);
         EXCEPTION
            WHEN STANDARD.NO_DATA_FOUND
            THEN
               DBMS_OUTPUT.put_line (
                     'amd_defaults 40: Default NSL Logon_id, '
                  || wk_logon_id
                  || ' does not exist in amd_planner_logons for planner '
                  || NSL_PLANNER_CODE);

               IF STRICT
               THEN
                  raise_application_error (
                     -20003,
                        'amd_defaults: Default NSL Logon_id, '
                     || wk_logon_id
                     || ' does not exist in amd_planner_logons for planner '
                     || NSL_PLANNER_CODE);
               END IF;
         END validateLogonId;

         RETURN wk_logon_id;
      END getNslLogonId;



      FUNCTION getCleanDataDay
         RETURN VARCHAR2
      IS
         dayOfTheWeek   VARCHAR2 (10);
      BEGIN
         dayOfTheWeek := UPPER (TRIM (getParamValue ('clean_data_day')));

         IF dayOfTheWeek IS NULL
         THEN
            RETURN 'SATURDAY';
         ELSE
            RETURN dayOfTheWeek;
         END IF;
      END getCleanDataDay;

      FUNCTION getPsmsCommitThreshold
         RETURN VARCHAR2
      IS
         threshold   NUMBER;
      BEGIN
         threshold :=
            TO_NUMBER (TRIM (getParamValue ('psms_commit_threshold')));

         IF threshold IS NULL
         THEN
            RETURN 1000;
         ELSE
            RETURN threshold;
         END IF;
      END getPsmsCommitThreshold;

      FUNCTION getMainCommitThreshold
         RETURN VARCHAR2
      IS
         threshold   NUMBER;
      BEGIN
         threshold :=
            TO_NUMBER (TRIM (getParamValue ('main_commit_threshold')));

         IF threshold IS NULL
         THEN
            RETURN 1000;
         ELSE
            RETURN threshold;
         END IF;
      END getMainCommitThreshold;

      FUNCTION getTempNsnsCommitThreshold
         RETURN VARCHAR2
      IS
         threshold   NUMBER;
      BEGIN
         threshold :=
            TO_NUMBER (TRIM (getParamValue ('temp_nsns_commit_threshold')));

         IF threshold IS NULL
         THEN
            RETURN 1000;
         ELSE
            RETURN threshold;
         END IF;
      END getTempNsnsCommitThreshold;

      FUNCTION getGoldCommitThreshold
         RETURN VARCHAR2
      IS
         threshold   NUMBER;
      BEGIN
         threshold :=
            TO_NUMBER (TRIM (getParamValue ('gold_commit_threshold')));

         IF threshold IS NULL
         THEN
            RETURN 1000;
         ELSE
            RETURN threshold;
         END IF;
      END getGoldCommitThreshold;

      FUNCTION getPartStrucCommitThreshold
         RETURN VARCHAR2
      IS
         threshold   NUMBER;
      BEGIN
         threshold :=
            TO_NUMBER (TRIM (getParamValue ('partstruc_commit_threshold')));

         IF threshold IS NULL
         THEN
            RETURN 1000;
         ELSE
            RETURN threshold;
         END IF;
      END getPartStrucCommitThreshold;

      FUNCTION getDateLvlLoadedModifier
         RETURN VARCHAR2
      IS
         dateLvlLoadedModifier   NUMBER;
      BEGIN
         dateLvlLoadedModifier :=
            TO_NUMBER (TRIM (getParamValue ('date_lvl_loaded_modifier')));

         IF dateLvlLoadedModifier IS NULL
         THEN
            RETURN 210;
         ELSE
            RETURN dateLvlLoadedModifier;
         END IF;
      END getDateLvlLoadedModifier;

      FUNCTION getTslConsumablCalendarDays
         RETURN NUMBER
      IS
         tslConsumablCalendarDays   NUMBER;
      BEGIN
         tslConsumablCalendarDays :=
            TO_NUMBER (TRIM (getParamValue ('tsl_consumabl_calendar_days')));

         IF tslConsumablCalendarDays IS NULL
         THEN
            RETURN 210;
         ELSE
            RETURN tslConsumablCalendarDays;
         END IF;
      END getTslConsumablCalendarDays;

      FUNCTION getTheROQ
         RETURN NUMBER
      IS
         roq   NUMBER;
      BEGIN
         roq := TO_NUMBER (TRIM (getParamValue ('roq')));

         IF roq IS NULL
         THEN
            RETURN amd_defaults.ROQ;
         ELSE
            RETURN roq;
         END IF;
      END getTheROQ;

      FUNCTION getTheROP
         RETURN NUMBER
      IS
         rop   NUMBER;
      BEGIN
         rop := TO_NUMBER (TRIM (getParamValue ('rop')));

         IF rop IS NULL
         THEN
            RETURN amd_defaults.ROP;
         ELSE
            RETURN rop;
         END IF;
      END getTheROP;

      FUNCTION getTheIcpInd
         RETURN VARCHAR2
      IS
         icp_ind   amd_spare_parts.icp_ind%TYPE;
      BEGIN
         icp_ind := getParamValue ('icp_ind');

         IF icp_ind IS NULL
         THEN
            RETURN amd_defaults.ICP_IND;
         ELSE
            RETURN icp_ind;
         END IF;
      END getTheIcpInd;

      FUNCTION getTheSourceCode
         RETURN VARCHAR2
      IS
         source_code   cat1.source_code%TYPE;
      BEGIN
         source_code := getParamValue ('source_code');

         IF source_code IS NULL
         THEN
            RETURN amd_defaults.SOURCE_CODE;
         ELSE
            RETURN source_code;
         END IF;
      END getTheSourceCode;

      FUNCTION getTheSourceOfSupply
         RETURN VARCHAR2
      IS
         source_of_supply   VARCHAR2 (5);
      BEGIN
         source_of_supply := getParamValue ('source_of_supply');

         IF source_of_supply IS NULL
         THEN
            RETURN amd_defaults.SOURCE_OF_SUPPLY;
         ELSE
            RETURN source_of_supply;
         END IF;
      END getTheSourceOfSupply;


      FUNCTION getTheNonStockageList
         RETURN VARCHAR2
      IS
         non_stockage_list   amd_spare_parts.nsn%TYPE;
      BEGIN
         non_stockage_list := getParamValue ('non_stockage_list');

         IF non_stockage_list IS NULL
         THEN
            RETURN amd_defaults.NON_STOCKAGE_LIST;
         ELSE
            RETURN non_stockage_list;
         END IF;
      END getTheNonStockageList;

      -- get the Foriegn Military Sale segment code for Austrailia
      FUNCTION getFmsSegCodeForAUS
         RETURN whse.sc%TYPE
      IS
         sc   whse.sc%TYPE;
      BEGIN
         sc := TRIM (getParamValue ('fms_aus'));

         IF sc IS NULL
         THEN
            RETURN amd_defaults.AMD_AUS_SC;
         ELSE
            RETURN sc;
         END IF;
      END getFmsSegCodeForAUS;

      FUNCTION getFmsSegCodeForBASC
         RETURN whse.sc%TYPE
      IS
         sc   whse.sc%TYPE;
      BEGIN
         sc := TRIM (getParamValue ('fms_basc'));

         IF sc IS NULL
         THEN
            RETURN amd_defaults.AMD_BASC_SC;
         ELSE
            RETURN sc;
         END IF;
      END getFmsSegCodeForBASC;


      -- get the Foriegn Military Sale segment code for Canada
      FUNCTION getFmsSegCodeForCAN
         RETURN whse.sc%TYPE
      IS
         sc   whse.sc%TYPE;
      BEGIN
         sc := TRIM (getParamValue ('fms_can'));

         IF sc IS NULL
         THEN
            RETURN amd_defaults.AMD_CAN_SC;
         ELSE
            RETURN sc;
         END IF;
      END getFmsSegCodeForCAN;

      FUNCTION getFmsSegCodeForUK
         RETURN whse.sc%TYPE
      IS
         sc   whse.sc%TYPE;
      BEGIN
         sc := TRIM (getParamValue ('fms_uk'));

         IF sc IS NULL
         THEN
            RETURN amd_defaults.AMD_UK_SC;
         ELSE
            RETURN sc;
         END IF;
      END getFmsSegCodeForUK;

      FUNCTION getTheStartLocId
         RETURN NUMBER
      IS
         startLocId   whse.sc%TYPE;
      BEGIN
         startLocId := TO_NUMBER (TRIM (getParamValue ('start_loc_id')));

         IF startLocId IS NULL
         THEN
            RETURN amd_defaults.START_LOC_ID;
         ELSE
            RETURN startLocId;
         END IF;
      END getTheStartLocId;

      FUNCTION getTheProgramId
         RETURN VARCHAR2
      IS
         programId   VARCHAR2 (30);
      BEGIN
         programId := TRIM (getParamValue ('program_id'));

         IF programId IS NULL
         THEN
            RETURN amd_defaults.PROGRAM_ID;
         ELSE
            RETURN programId;
         END IF;
      END getTheProgramId;
   BEGIN
      amd_defaults.CONDEMN_AVG := GetCondemnAvg ();
      amd_defaults.consumable_reduction_factor :=
         GetConsumableReductionFactor ();
      amd_defaults.DISPOSAL_COST := GetDisposalCost ();
      amd_defaults.DISTRIB_UOM := GetDistribUom ();
      amd_defaults.engine_part_reduction_factor :=
         GetEnginePartReductionFactor ();
      amd_defaults.non_engine_part_reductn_factor :=
         GetNonEnginePartReductnFactor ();
      amd_defaults.NRTS_AVG := GetNrtsAvg ();
      amd_defaults.OFF_BASE_TURN_AROUND := GetOffBaseTurnAround ();
      amd_defaults.ORDER_QUANTITY := GetOrderQuantity ();
      amd_defaults.ORDER_UOM := GetOrderUom ();
      amd_defaults.QPEI_WEIGHTED := GetQpeiWeighted ();
      amd_defaults.RTS_AVG := GetRtsAvg ();
      amd_defaults.SCRAP_VALUE := GetScrapValue ();
      amd_defaults.SHELF_LIFE := GetShelfLife ();
      amd_defaults.order_lead_time_consumable := GetOrderLeadTimeConsumable ();
      amd_defaults.order_lead_time_repairable := GetOrderLeadTimeRepairable ();
      amd_defaults.TIME_TO_REPAIR_ON_BASE_AVG := GetTimeToRepairOnBaseAvg ();
      amd_defaults.UNIT_VOLUME := GetUnitVolume ();
      amd_defaults.USE_BSSM_TO_GET_NSLs := GetUseBssmToGetNsls ();
      amd_defaults.TIME_TO_REPAIR_ONBASE := GetTimeToRepairOnbase ();
      amd_defaults.TIME_TO_REPAIR_OFFBASE := GetTimeToRepairOffbase ();
      amd_defaults.COST_TO_REPAIR_ONBASE := GetCostToRepairOnbase ();
      amd_defaults.UNIT_COST_FACTOR_OFFBASE := GetUnitCostFactorOffbase ();
      amd_defaults.NSL_PLANNER_CODE := getNslPlannerCode ();
      amd_defaults.NSN_PLANNER_CODE := getNsnPlannerCode ();
      amd_defaults.NSN_LOGON_ID := getNsnLogonId (); -- assumes NSN_PLANNER_CODe has a valid value
      amd_defaults.NSL_LOGON_ID := getNslLogonId (); -- assumes NSL_PLANNER_CODE has a valid value
      amd_defaults.STRICT := getStrict ();
      amd_defaults.CLEAN_DATA_DAY := getCleanDataDay ();
      amd_defaults.PSMS_COMMIT_THRESHOLD := getPsmsCommitThreshold ();
      amd_defaults.MAIN_COMMIT_THRESHOLD := getMainCommitThreshold ();
      amd_defaults.TEMP_NSNS_COMMIT_THRESHOLD := getTempNsnsCommitThreshold ();
      amd_defaults.GOLD_COMMIT_THRESHOLD := getGoldCommitThreshold ();
      amd_defaults.PARTSTRUC_COMMIT_THRESHOLD :=
         getPartStrucCommitThreshold ();
      amd_defaults.DATE_LVL_LOADED_MODIFIER := getDateLvlLoadedModifier ();
      amd_defaults.TSL_CONSUMABL_CALENDAR_DAYS :=
         getTslConsumablCalendarDays ();
      amd_defaults.ROQ := getTheROQ ();
      amd_defaults.ROP := getTheROP ();
      amd_defaults.ICP_IND := getTheIcpInd ();
      amd_defaults.START_LOC_ID := getTheStartLocId ();
      amd_defaults.PROGRAM_ID := getTheProgramId ();
      amd_defaults.NON_STOCKAGE_LIST := getTheNonStockageList ();
      amd_defaults.SOURCE_OF_SUPPLY := getTheSourceOfSupply ();
      amd_defaults.AMD_AUS_SC := getFmsSegCodeForAUS ();
      amd_defaults.AMD_BASC_SC := getFmsSegCodeForBASC ();
      amd_defaults.AMD_CAN_SC := getFmsSegCodeForCAN ();
      amd_defaults.AMD_UK_SC := getFmsSegCodeForUK ();
      fmsSegCodes :=
         fmsSegCodeTab (AMD_AUS_SC,
                        AMD_BASC_SC,
                        AMD_CAN_SC,
                        AMD_UK_SC);
      amd_defaults.CONSUMABLE_LOGON_ID := getConsumableLogonId;
      amd_defaults.REPAIRABLE_LOGON_ID := getRepairableLogonId;
      amd_defaults.REPAIRABLE_PLANNER_CODE := getRepairablePlannerCode;
      amd_defaults.CONSUMABLE_PLANNER_CODE := getConsumablePlannerCode;
   END;
END amd_defaults;
/


DROP PACKAGE BODY AMD_OWNER.AMD_DEFAULT_EFFECTIVITY_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_default_effectivity_pkg as
    /*
       $Author:   c970183  $
     $Revision:   1.1  $
         $Date:   15 May 2002 10:12:24  $
     $Workfile:   amd_default_effectivity_pkg.pkb  $
	      $Log:   \\www-amssc-01\pds\archives\SDS-AMD\Database\Packages\amd_default_effectivity_pkg.pkb-arc  $
/*
/*      Rev 1.1   15 May 2002 10:12:24   c970183
/*   eliminated select of nextval and added select of currval for the sequence.

	  SCCSID:	amd_default_effectivity_pkg.sql	1.2	Modified: 05/15/02  10:20:46
		  */

    function newGroup return number is

	    nsiGroupSid  number;

    begin


	    insert into amd_nsi_groups(nsi_group_sid, fleet_size_name, split_effect)
		    values(nsiGroupSid, 'All Aircraft', 'N') ;

	    select amd_nsi_group_sid_seq.currval
		    into nsiGroupSid
		    from dual;

	    return nsiGroupSid ;
	    /*
	    update amd_national_stock_items set
		    nsi_group_sid = nsigroupsid
		    effect_by = 'S'
		    where nsi_sid = pNsiSid;
	    */

    end;

    procedure setNsiEffects(pNsiSid number) is
	    cursor cur_sel_tail_no is
		    select tail_no
		    from amd_aircrafts
		    where tail_no != 'DUMMY' ;
    begin
	    for rec in cur_sel_tail_no LOOP
		    insert into amd_nsi_effects(nsi_sid, tail_no, effect_type,
					    user_defined, derived)
		    values (pNsiSid, rec.tail_no, 'B','S','N') ;
	    end loop;
    end ;

end amd_default_effectivity_pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_DEMAND;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Demand
AS
   /*
         $Author:    Douglas S. Elder
       $Revision:   1.59
           $Date:   21 Nov 2018
       $Workfile:   amd_demand.sql
            Rev 1.59    DSE 11/20/2018 Per TFS # 72313 allow request_id's with EY1213 to be used
            Rev 1.58    DSE 02/09/2018 fixed proc_code value to be GFP vs GPV
            Rev 1.57    DSE 01/31/2018 for procedures loadSanAntonioDemands and its cursor sanAntonioDemands
                                       add a check of proc_code and accept it if it is NULL or GPF
                                       and added EY1746 to the IN list for AND NOT (    SUBSTR (R.request_id, 1, 6) IN
                                  ('FB2065', 'EY1213', 'EY1746') of loadDepotDemands ( formerly loadBascUkDemands)
                                       per TFS ticket 52919

            Rev 1.56    DSE 12/19/2017 removed locattion EY1746 from the date filter implemented by
                        rev 1.54.1 per TFS 48244

            Rev 1.55    DSE 11/22/2017 added dbms_output for all raise commands

            Rev 1.54.3  DSE 8/25/2017 added loadWarnerRobinsDemands


            Rev 1.54.2  DSE 8/8/2017 Changed query for loadSanAntonioDemands: date comparison
            >= '2015-01' and created_date not truncated to the first of the month

            Rev 1.54.1  DSE 8/7/2017 excluded demands for ukbasc that are
                       1. substr(request_id,1,6) in ('FB2065', 'EY1213','EY1746')
                       2. and created_datetime >= 2015-01

            Rev 1.54    DSE 8/2/2017 added procedure loadSanAntonioDemands

            Rev 1.53.11 DSE 10/19/16 added DBMS output when loading amd_demands

            Rev 1.53.10 DSE 09/23/15 use START_LOC_ID constant

            Rev 1.53.9 DSE 09/21/15 use amd_defaults.getProgramId

            Rev 1.53.8 DSE 06/09/15 use trhi.loc_id

            Rev 1.53.7 DSE 06/05/15 added nsi_sid to merge command for load_amd_demands_table

            Rev 1.53.6 DSE 2/23/15 added amd_defaults.getStartLocId

           Rev 1.53.5 DSE 6/17/15 for any lcf table filtered out substr(doc_no,1,4) = 'S005'

           Rev 1.53.4 DSE 6/16/15 for amd_l67_source filtered out substr(doc_no,1,4) = 'S005'

           Rev 1.53.3 DSE 8/19/14 Laurie said the nsn's with dashes in them for amd_l67_source can be ignored - the function was also slowing down access and
           the process was taking 19 hours to complete!

           Rev 1.53.2 DSE 6/13/14 added amd_utils.formatNsn function when comparing nsn against amd_rbl_pairs.old_nsn

           Rev 1.53.1 DSE 6/12/14 changed L67cur to manage TIN and TRN's , DOC and DUO's and related ISG pairs

           Rev 1.53 DSE 2/21/14 changed loadAmdBssmSourceTmpAmdDemands' to use  writeMsg for start/end stats
           added writeMsg to:
               InsertL67TmpLcfIcp
               loadAmdBssmSourceTmpAmdDemands
               LoadFmsDemands
               LoadBascUkDemands
               load_amd_demands_table
           added merge to load_amd_demands_table


           Rev 1.52 DSE 2/11/14 changed loadAmdBssmSourceTmpAmdDemands's docsur's group by to include nsn and modified
           CalcQuantity and CalcBadQuantity to include nsn as an argument so qty's will be by doc and nsn per Laurie Compton's request
           Also, changed spec and made CalcQuantity and CalcBadQuantiy public so they can be easily tested

          Rev 1.51 (DouglasElder) added an "when others" exception hanlder for LoadBascUkDemands

          Rev 1.50 (402417) and asn2.loc_sid is not null  ... added to cursor for loadFmsDemand

         Rev 1.49 renamed procedure loadAmdDemands to loadAmdBssmSourceTmpAmdDemands

         Rev 1.48 renamed procedure amd_demand_a2a to load_amd_demand_table

         Rev 1.47 Streamlined demandCur for loadBascUkDemands and added table amd_depot_partnering_locations with the addition of Macon to
         the list of locations previously used

         Rev 1.46 fix the query against amd_sc_inclusions to use an existential qualifier

         Rev 1.45   Additional criteria to the REASON in function CalcQuantity per CQ# LBPSS00002694 (L67 Demand DOC TTPC Action Taken Code Modification) requested by LC.

         Rev 1.44   Added Procedure LoadFmsDemand per ClearQuest# LBPSS00002393 by Laurie Compton.

         Rev 1.43   Thuy switched reason and dmd_cd for CalcQuantity and CalcBadQuantity
                    Thuy modified CalcQuantity and CalcBadQuantity

         Rev 1.42   11 Sep 2009 12:40:20   zf297a
      Implemented interfaces getVersion, setDebug, and getDebugYorN
      and added pragma for ErrorMsg

         Rev 1.41   24 Feb 2009 14:13:40   zf297a
      Removed a2a code.

         Rev 1.40   28 Oct 2008 08:46:46   zf297a
      When creating ExtForecast A2A transactions, make the duplicate column 1 when it is null.

         Rev 1.39   10 Apr 2008 11:07:02   zf297a
      Thuy Pham added EB as request_id to be part of LoadBascUKDemand.

         Rev 1.38   23 Oct 2007 18:29:34   zf297a
      For genDuplicateForConsumables fix the cursor demandsNotSame to make sure that it only retrieves the current period and beyond.

         Rev 1.37   03 Oct 2007 13:25:08   zf297a
      Implemented interface getCalendarDate and interface getFiscalPeriod.

         Rev 1.36   12 Sep 2007 13:58:38   zf297a
      Removed commits from for loop.

         Rev 1.35   21 Aug 2007 11:52:00   zf297a
      Passed part_no instead of rec.nsn to amd_utils.isPartActive for nested procedure insertA2A which is subordinate to procedure loadAllA2A.

         Rev 1.34   20 Aug 2007 09:32:02   zf297a
      Added constant EXTERNAL and implemented procedure loadAllA2A.

         Rev 1.33   17 Aug 2007 13:42:36   zf297a
      Changed the program code to count the total number of periods that should have the same quantity for each part/location - so the A2A record with the PERIOD counts that record itself as being included in the DUPLICATE count.  Where we had DUPLICATE value of '1' before goes to '2', and value of '63' goes to '64'.

         Rev 1.32   08 Aug 2007 11:23:42   zf297a
      Fixed getCurrentPeriod for when the period > cur_year to compute the current period as 10/01/period - 1 when the cur_month < 10, and cur_month/01/period - 1  when the cur_month >= 10.

         Rev 1.31   08 Aug 2007 09:59:42   zf297a
      Adjusted the duplicate count to be 1 less so that the count includes the record that contains the duplicate: ie a duplicate of 1 means the current record plus 1 = 2 records of the 66 total allowed and a duplicate of 63 means the current record plus 63 = 64 of the 66 total allowed.

         Rev 1.30   08 Aug 2007 00:26:06   zf297a
      Fixed getCurrentPeriod to return 10/1/period when period > current year.
      Fixed genDuplicateForConsumables to sum periods together that have the same demand_forecast.  Fixed final update to update only those periods belonging to the current_period with 66.

         Rev 1.29   07 Aug 2007 13:31:04   zf297a
      Fixed update of tmp_amd_dmnd_frcst_consumables - the where clause should have period = (select min(period)....) not perdiod <> (select min(period)...)

         Rev 1.28   01 Aug 2007 16:58:56   zf297a
      Make sure the update of tmp_amd_dmnd_frcst_consumables updates only the current_period with the duplicate of  DUP_THRESHOLD

         Rev 1.27   01 Aug 2007 16:38:38   zf297a
      removed function getDuplicate.  Enhanced procedure doDmndFrcstConsumablesDiff by adding duplicate to the interface.
      Added function getCurrentPeriod, which will be using in creating the tmp_a2a_ext_forecast table.
      Create a routine to read tmp_amd_dmnd_frcst_consumables and create the duplicate column needed for the ExtForecast A2A transactions.

         Rev 1.26   23 Jul 2007 15:47:22   zf297a
      Implemented interface for getDuplicate, which is a function used to get the duplicate # for the A2A External Forecast Transaction.

      Used amd_loc_part_forecasts_pkg.getCurrentPeriod, which gets it data from the amd_param_changes table, for the period and the new function getDuplicate(cur_period) to get the duplicate # for the A2A External  Forecast Transaction.

         Rev 1.25   Jul 20 2007 07:03:38   c402417
      Added Canada Demand(EY1414).

         Rev 1.24   Jul 19 2007 19:19:26   c402417
      Modified procedure insertA2A
      to get correct Period and Duplicate.

         Rev 1.23   23 May 2007 00:12:14   zf297a
      Implemented interface doDmndFrcstConsumablesDiff

         Rev 1.22   Apr 05 2007 11:13:10   c402417
      Remove all the  TRIM from WHERE clauses for AMD v1.8.06.6

         Rev 1.21   Mar 05 2007 12:09:46   c402417
      Added AU demand.

         Rev 1.20   Jun 09 2006 12:51:26   zf297a
      implemented version

         Rev 1.19   Mar 07 2006 13:17:32   c402417
      Changed field Site to get spo_location from amd_spare_networks instead of loc_id.

         Rev 1.18   Dec 07 2005 13:12:20   zf297a
      When joining with amd_sent_to_a2a, make sure the part was not deleted from the SPO - i.e. action_code != 'D'.

      Check that the super prime part no is actually vaild and that it has been sent to the SPO.

         Rev 1.17   Dec 05 2005 16:43:30   c402417
      Added version 1.10.1.2 to the current version.

         Rev 1.14   Dec 01 2005 09:30:38   zf297a
      added pvcs keywords
   */



   debug                    BOOLEAN := FALSE;
   doWarnings               BOOLEAN := FALSE;
   PROGRAM_ID      CONSTANT VARCHAR2 (30) := amd_defaults.getProgramId;
   PROGRAM_ID_LL   CONSTANT NUMBER := LENGTH (PROGRAM_ID);
   START_LOC_ID    CONSTANT NUMBER := amd_defaults.getStartLocId;

   EXTERNAL_CNST   CONSTANT VARCHAR2 (8) := 'External';

   PROCEDURE InsertTmpLcf1;

   PROCEDURE InsertTmpLcfIcp;

   PROCEDURE InsertL67TmpLcfIcp;

   PROCEDURE errorMsg (sqlFunction         IN VARCHAR2,
                       tableName           IN VARCHAR2,
                       pError_Location     IN NUMBER,
                       key1                IN VARCHAR2 := '',
                       key2                IN VARCHAR2 := '',
                       key3                IN VARCHAR2 := '',
                       key4                IN VARCHAR2 := '',
                       key5                IN VARCHAR2 := '',
                       keywordValuePairs   IN VARCHAR2 := '')
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      Amd_Utils.InsertErrorMsg (
         pLoad_no        => Amd_Utils.GetLoadNo (pSourceName   => sqlFunction,
                                                 pTableName    => tableName),
         pData_line_no   => pError_Location,
         pData_line      => 'amd_demand',
         pKey_1          => key1,
         pKey_2          => key2,
         pKey_3          => key3,
         pKey_4          => key4,
         pKey_5          =>    key5
                            || ' '
                            || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MM:SS')
                            || ' '
                            || keywordValuePairs,
         pComments       =>    SqlFunction
                            || '/'
                            || TableName
                            || ' sqlcode('
                            || SQLCODE
                            || ') sqlerrm('
                            || SQLERRM
                            || ')');
      COMMIT;
      RETURN;
   END ErrorMsg;


   PROCEDURE writeMsg (
      pTableName        IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
      pError_location   IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
      pKey1             IN VARCHAR2 := '',
      pKey2             IN VARCHAR2 := '',
      pKey3             IN VARCHAR2 := '',
      pKey4             IN VARCHAR2 := '',
      pData             IN VARCHAR2 := '',
      pComments         IN VARCHAR2 := '')
   IS
   BEGIN
      Amd_Utils.writeMsg (pSourceName       => 'amd_demand',
                          pTableName        => pTableName,
                          pError_location   => pError_location,
                          pKey1             => pKey1,
                          pKey2             => pKey2,
                          pKey3             => pKey3,
                          pKey4             => pKey4,
                          pData             => pData,
                          pComments         => pComments);
   END writeMsg;

   FUNCTION CalcQuantity (pDocNo VARCHAR2, pNsn VARCHAR2, pDic VARCHAR2)
      RETURN NUMBER
   IS
      qty     NUMBER := 0;
      qtyd1   NUMBER := 0;
      qtyd2   NUMBER := 0;
   BEGIN
      IF pDic = 'TIN'
      THEN
         BEGIN
            SELECT NVL (SUM (action_qty), 0)
              INTO qty
              FROM TMP_LCF_ICP
             WHERE     doc_no = pDocNo
                   AND nsn = pNsn
                   --                    AND dic = 'TIN'
                   AND ttpc = '1B'
                   AND dmd_cd IN ('B',
                                  'C',
                                  'J',
                                  'V',
                                  'X',
                                  'A',
                                  'D',
                                  'F',
                                  'G',
                                  'K',
                                  'L',
                                  'Z',
                                  '1',
                                  '2',
                                  '3',
                                  '4',
                                  '5',
                                  '6',
                                  '7',
                                  '8',
                                  '9');
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               qty := 0;
         END;
      ELSIF pDic = 'TRN'
      THEN
         BEGIN
            SELECT NVL (SUM (action_qty), 0)
              INTO qty
              FROM TMP_LCF_ICP
             WHERE     doc_no = pDocNo
                   AND nsn = pNsn
                   AND dic = 'TRN'
                   AND ttpc = '4S'
                   AND reason IN ('A',
                                  'F',
                                  'G',
                                  'K',
                                  'L',
                                  'Z');
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               qty := 0;
         END;
      ELSIF pDic = 'ISU'
      THEN
         BEGIN
            SELECT NVL (SUM (action_qty), 0)
              INTO qty
              FROM TMP_LCF_ICP
             WHERE     doc_no = pDocNo
                   AND nsn = pNsn
                   AND dic = 'ISU'
                   AND ttpc IN ('1A', '3P', '3Q');
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               qty := 0;
         END;
      ELSIF pDic = 'MSI'
      THEN
         BEGIN
            SELECT NVL (SUM (action_qty), 0)
              INTO qty
              FROM TMP_LCF_ICP
             WHERE     doc_no = pDocNo
                   AND nsn = pNsn
                   AND dic = 'MSI'
                   AND ttpc IN ('1C',
                                '1G',
                                '1O',
                                '1Q',
                                '2I',
                                '2K',
                                '3P');
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               qty := 0;
         END;
      ELSIF pDic = 'DUO'
      THEN
         BEGIN
            SELECT NVL (SUM (action_qty), 0)
              INTO qty
              FROM TMP_LCF_ICP
             WHERE     doc_no = pDocNo
                   AND nsn = pNsn
                   AND dic = 'DUO'
                   AND ttpc IN ('2D', '4W');
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               qty := 0;
         END;
      ELSIF pDic = 'DOC'
      THEN
         BEGIN
            SELECT NVL (SUM (action_qty), 0)
              INTO qtyd1
              FROM TMP_LCF_ICP
             WHERE     doc_no = pDocNo
                   AND nsn = pNsn
                   AND dic = 'DOC'
                   AND ttpc IN ('2A', '2C')
                   AND (   reason IN ('B',
                                      'C',
                                      'J',
                                      'V',
                                      'X',
                                      'A',
                                      'F',
                                      'G',
                                      'K',
                                      'L',
                                      'Z')
                        OR reason IS NULL); /* added on 7/20/2010 by TP requested by LC */
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               qtyd1 := 0;
         END;

         qty := qtyd1;
      END IF;

      RETURN (qty);
   END CalcQuantity;


   FUNCTION CalcBadQuantity (pDocNo VARCHAR2, pNsn VARCHAR2, pDic VARCHAR2)
      RETURN NUMBER
   IS
      qty   NUMBER := 0;
   BEGIN
      IF pDic = 'TIN'
      THEN
         BEGIN
            SELECT NVL (SUM (action_qty), 0)
              INTO qty
              FROM TMP_LCF_ICP
             WHERE     doc_no = pDocNo
                   AND nsn = pNsn
                   AND dic = 'TIN'
                   AND ttpc = '1B'
                   AND dmd_cd NOT IN ('B',
                                      'C',
                                      'J',
                                      'V',
                                      'X',
                                      'A',
                                      'D',
                                      'F',
                                      'G',
                                      'K',
                                      'L',
                                      'Z',
                                      '1',
                                      '2',
                                      '3',
                                      '4',
                                      '5',
                                      '6',
                                      '7',
                                      '8',
                                      '9');
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               qty := 0;
         END;
      ELSIF pDic = 'TRN'
      THEN
         BEGIN
            SELECT NVL (SUM (action_qty), 0)
              INTO qty
              FROM TMP_LCF_ICP
             WHERE     doc_no = pDocNo
                   AND nsn = pNsn
                   AND dic = 'TRN'
                   AND ttpc = '4S'
                   AND reason NOT IN ('A',
                                      'F',
                                      'G',
                                      'K',
                                      'L',
                                      'Z');
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               qty := 0;
         END;
      END IF;

      RETURN (qty);
   END CalcBadQuantity;



   PROCEDURE InsertTmpLcf1
   IS
   BEGIN
      INSERT INTO TMP_LCF_1 (stock_no,
                             erc,
                             dic,
                             ttpc,
                             dmd_cd,
                             reason,
                             doc_no,
                             trans_date,
                             trans_ser,
                             action_qty,
                             sran,
                             nomenclature,
                             marked_for,
                             date_of_last_demand,
                             unit_of_issue,
                             supplemental_address)
           SELECT stock_no,
                  erc,
                  dic,
                  ttpc,
                  dmd_cd,
                  reason,
                  doc_no,
                  TO_DATE (trans_date, 'yyyyddd'),
                  trans_ser,
                  action_qty,
                  sran,
                  nomenclature,
                  marked_for,
                  TO_DATE (date_of_last_demand, 'yyyyddd'),
                  unit_of_issue,
                  supplemental_address
             FROM TMP_LCF_RAW
            WHERE     SUBSTR (doc_no, 1, 1) IN ('X',
                                                'J',
                                                'R',
                                                'B',
                                                'S')
                  AND SUBSTR (doc_no, 1, 4) <> 'S005'
         GROUP BY stock_no,
                  erc,
                  dic,
                  ttpc,
                  dmd_cd,
                  reason,
                  doc_no,
                  TO_DATE (trans_date, 'yyyyddd'),
                  trans_ser,
                  action_qty,
                  sran,
                  nomenclature,
                  marked_for,
                  TO_DATE (date_of_last_demand, 'yyyyddd'),
                  unit_of_issue,
                  supplemental_address;


      UPDATE TMP_LCF_1
         SET nsn = SUBSTR (stock_no, 1, 13),
             mmc = SUBSTR (stock_no, 14, 2),
             sran = 'FB' || sran;

      COMMIT;
   END InsertTmpLcf1;


   PROCEDURE InsertTmpLcfIcp
   IS
   BEGIN
      INSERT INTO TMP_LCF_ICP (nsn,
                               mmc,
                               stock_no,
                               erc,
                               dic,
                               ttpc,
                               dmd_cd,
                               reason,
                               doc_no,
                               trans_date,
                               trans_ser,
                               action_qty,
                               sran,
                               nomenclature,
                               marked_for,
                               date_of_last_demand,
                               supplemental_address)
         SELECT nsn,
                mmc,
                stock_no,
                erc,
                dic,
                ttpc,
                dmd_cd,
                reason,
                doc_no,
                trans_date,
                trans_ser,
                action_qty,
                DECODE (asn.loc_type, 'TMP', asn.mob, sran) sran,
                nomenclature,
                marked_for,
                date_of_last_demand,
                supplemental_address
           FROM TMP_LCF_1 tl1, AMD_SPARE_NETWORKS asn
          WHERE tl1.sran = asn.loc_id AND SUBSTR (tl1.doc_no, 1, 4) <> 'S005';

      COMMIT;
   END InsertTmpLcfIcp;



   PROCEDURE InsertL67TmpLcfIcp
   IS
      CURSOR l67Cur
      IS
         SELECT DISTINCT als.nsn,
                         mmc,
                         erc,
                         tric,
                         ttpc,
                         dmd_cd,
                         reason,
                         als.doc_no,
                         trans_date,
                         trans_ser,
                         action_qty,
                         DECODE (asn.loc_type, 'TMP', asn.mob, sran) sran,
                         nomenclature,
                         marked_for,
                         dold,
                         supp_address
           FROM AMD_L67_SOURCE als, AMD_SPARE_NETWORKS asn, amd_rbl_pairs p
          WHERE     SUBSTR (als.doc_no, 1, 1) IN ('X',
                                                  'S',
                                                  'B',
                                                  'J',
                                                  'R')
                AND SUBSTR (als.doc_no, 1, 4) <> 'S005'
                AND als.sran = asn.loc_id
                AND amd_utils.formatNsn (als.nsn) = p.old_nsn
                AND (   tric IN ('TIN', 'TRN')
                     OR (    tric = 'DOC'
                         AND EXISTS
                                (SELECT NULL
                                   FROM amd_l67_source
                                  WHERE     doc_no = als.doc_no
                                        AND nsn = als.nsn
                                        AND tric = 'DUO'))
                     OR (    tric = 'DUO'
                         AND EXISTS
                                (SELECT NULL
                                   FROM amd_l67_source
                                  WHERE     doc_no = als.doc_no
                                        AND nsn = als.nsn
                                        AND tric = 'DOC'))
                     OR (    tric NOT IN ('TRN', 'TIN')
                         AND NOT EXISTS
                                (SELECT NULL
                                   FROM amd_l67_source
                                  WHERE     tric IN ('TIN', 'TRN')
                                        AND doc_no = als.doc_no
                                        AND nsn IN
                                               (SELECT old_nsn
                                                  FROM amd_rbl_pairs
                                                 WHERE new_nsn = p.new_nsn))))
         UNION
         SELECT DISTINCT als.nsn,
                         mmc,
                         erc,
                         tric,
                         ttpc,
                         dmd_cd,
                         reason,
                         als.doc_no,
                         trans_date,
                         trans_ser,
                         action_qty,
                         DECODE (asn.loc_type, 'TMP', asn.mob, sran) sran,
                         nomenclature,
                         marked_for,
                         dold,
                         supp_address
           FROM AMD_L67_SOURCE als, AMD_SPARE_NETWORKS asn
          WHERE     SUBSTR (als.doc_no, 1, 1) IN ('X',
                                                  'S',
                                                  'B',
                                                  'J',
                                                  'R')
                AND SUBSTR (als.doc_no, 1, 4) <> 'S005'
                AND als.sran = asn.loc_id
                AND amd_utils.formatNsn (als.nsn) NOT IN
                       (SELECT old_nsn
                          FROM amd_rbl_pairs);

      nsn        VARCHAR2 (20);
      mmacCode   NUMBER;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_lcf_icp',
         pError_location   => 10,
         pKey1             => 'InsertL67TmpLcfIcp',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      FOR rec IN l67Cur
      LOOP
         BEGIN
            mmacCode := rec.mmc;
            nsn := rec.nsn || rec.mmc;
         EXCEPTION
            WHEN OTHERS
            THEN
               nsn := rec.nsn;
         END;

         INSERT INTO TMP_LCF_ICP (nsn,
                                  mmc,
                                  stock_no,
                                  erc,
                                  dic,
                                  ttpc,
                                  dmd_cd,
                                  reason,
                                  doc_no,
                                  trans_date,
                                  trans_ser,
                                  action_qty,
                                  sran,
                                  nomenclature,
                                  marked_for,
                                  date_of_last_demand,
                                  supplemental_address)
              VALUES (nsn,
                      rec.mmc,
                      nsn,
                      rec.erc,
                      rec.tric,
                      rec.ttpc,
                      rec.dmd_cd,
                      rec.reason,
                      rec.doc_no,
                      rec.trans_date,
                      rec.trans_ser,
                      rec.action_qty,
                      rec.sran,
                      rec.nomenclature,
                      rec.marked_for,
                      rec.dold,
                      rec.supp_address);
      END LOOP;

      COMMIT;
      writeMsg (
         pTableName        => 'tmp_lcf_icp',
         pError_location   => 20,
         pKey1             => 'InsertL67TmpLcfIcp',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
   END;



   --
   -- loadAmdBssmSourceTmpAmdDemands -
   --
   -- procedure to load amd_af_reqs from lcf data.
   --
   -- currently, we manually load lcf data into tmp_lcf_raw, tmp_lcf_1,
   -- tmp_lcf_icp tables manually.  we do not know at this time how we would
   -- receive the lcf data in the future.
   --
   -- assume we have data loaded into tmp_lcf_icp, the follows are processes
   -- to be perform to load data into amd_af_reqs table.
   --
   -- 1) loop for each doc_no.
   -- 2) for each doc_no:
   --     2.1) select sum of qualified tin into goodtin
   --     2.2) select sum of non-qualified tin into badtin
   --     2.3) select sum of qualified trn into goodtrn
   --     2.4) select sum of non-qualified trn into badtrn
   --     2.5) calculate tin quantity:
   --                         tinqty = goodtin + goodtrn
   --     2.6) calculate badtin quantity:
   --             badtinqty = badtin + badtrn
   -- 2.7) select sum of qualified isu
   -- 2.8) select sum of qualified msi
   -- 2.9) select sum of qualified duo
   -- 2.10)select sum of qualified doc
   -- 2.11)calculate duo quantity:
   --             duoqty = duo - doc.
   --           note: if duoqty is negative, set duoqty = 0.
   -- 2.12)calculate non tin quantity:
   --             ntinqty = isu + msi + duoqty - badtinqty
   --     2.13)calculate other quantity:
   --             otherqty = ntinqty - tinqty
   -- 2.14)calculate requisition quantity:
   --                 if otherqty > 0 then
   --                             qty        = tinqty + otherqty
   --                    else
   --                      qty        = tinqty
   --                    end if
   --    2.15) if the qty = 0, do not insert the requisition.
   --
   -- 3) select nsn of the doc_no and select prime part from amd_spare_parts
   -- 4) use trans_date as requistion_date
   -- 5) insert into amd_demands table.
   --
   PROCEDURE loadAmdBssmSourceTmpAmdDemands
   IS
      vNsn                VARCHAR2 (20);
      tinqty              NUMBER := 0;
      ntinqty             NUMBER := 0;
      otherqty            NUMBER := 0;
      qty                 NUMBER := 0;
      goodtin             NUMBER := 0;
      badtin              NUMBER := 0;
      goodtrn             NUMBER := 0;
      badtrn              NUMBER := 0;
      badtinqty           NUMBER := 0;
      isu                 NUMBER := 0;
      msi                 NUMBER := 0;
      duo                 NUMBER := 0;
      doc                 NUMBER := 0;
      duoqty              NUMBER := 0;
      reqDate             DATE;
      lcf1cnt             NUMBER;
      nsiSid              NUMBER;
      dup_cnt             NUMBER := 0;
      load_cnt            NUMBER := 0;
      rows_read           NUMBER := 0;
      nsiSidNotFoundCnt   NUMBER := 0;
      CRLF       CONSTANT CHAR (2) := CHR (13) || CHR (10);

      CURSOR docCur
      IS
           SELECT tli.doc_no,
                  asn.loc_sid,
                  amd_utils.formatNsn (TLI.NSN) nsn,
                  MIN (tli.trans_date)        trans_date
             FROM TMP_LCF_ICP tli, AMD_SPARE_NETWORKS asn
            WHERE tli.sran = asn.loc_id AND SUBSTR (tli.doc_no, 1, 4) <> 'S005'
         -- and  not exists (select null from amd_rbl_pairs where tli.nsn = old_nsn and old_nsn = new_nsn)
         GROUP BY tli.doc_no, asn.loc_sid, amd_utils.formatNsn (tli.nsn);
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_demands',
         pError_location   => 30,
         pKey1             => 'loadAmdBssmSourceTmpAmdDemands',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));


      --
      -- if there are no records in tmp_lcf_1 then
      -- insert them from tmp_lcf_raw
      --
      SELECT COUNT (*) INTO lcf1cnt FROM TMP_LCF_1;

      IF (lcf1cnt = 0)
      THEN
         InsertTmpLcf1;
      END IF;

      InsertTmpLcfIcp; --* limits locations to the ones specified in amd_spare_networks
      InsertL67TmpLcfIcp;

      FOR rec IN docCur
      LOOP
         rows_read := rows_read + 1;
         goodtin := CalcQuantity (rec.doc_no, rec.nsn, 'TIN');
         badtin := CalcBadQuantity (rec.doc_no, rec.nsn, 'TIN');
         goodtrn := CalcQuantity (rec.doc_no, rec.nsn, 'TRN');
         badtrn := CalcBadQuantity (rec.doc_no, rec.nsn, 'TRN');
         tinqty := goodtin + goodtrn;
         badtinqty := badtin + badtrn;

         isu := CalcQuantity (rec.doc_no, rec.nsn, 'ISU');
         msi := CalcQuantity (rec.doc_no, rec.nsn, 'MSI');
         duo := CalcQuantity (rec.doc_no, rec.nsn, 'DUO');
         doc := CalcQuantity (rec.doc_no, rec.nsn, 'DOC');

         duoqty := duo - doc;

         IF duoqty < 0
         THEN
            duoqty := 0;
         END IF;

         ntinqty := isu + msi + duoqty - badtinqty;
         otherqty := ntinqty - tinqty;

         IF otherqty > 0
         THEN
            qty := tinqty + otherqty;
         ELSE
            qty := tinqty;
         END IF;

         IF qty != 0
         THEN
            IF rec.doc_no = 'X317SA73191200'
            THEN
               DBMS_OUTPUT.put_line (
                     'doc_no: '
                  || rec.doc_no
                  || CRLF
                  || repeat (' ', 2)
                  || 'rec.nsn: '
                  || rec.nsn
                  || CRLF
                  || repeat (' ', 2)
                  || 'rows_read: '
                  || rows_read
                  || CRLF
                  || repeat (' ', 2)
                  || 'goodtin: '
                  || goodtin
                  || CRLF
                  || repeat (' ', 2)
                  || 'badtin: '
                  || badtin
                  || CRLF
                  || repeat (' ', 2)
                  || 'goodtrn: '
                  || goodtrn
                  || CRLF
                  || repeat (' ', 2)
                  || 'badtrn:  '
                  || badtrn
                  || CRLF
                  || repeat (' ', 2)
                  || 'tinqty: '
                  || tinqty
                  || CRLF
                  || repeat (' ', 2)
                  || 'badtinqty: '
                  || badtinqty
                  || CRLF
                  || repeat (' ', 2)
                  || 'isu: '
                  || isu
                  || CRLF
                  || repeat (' ', 2)
                  || 'msi: '
                  || msi
                  || CRLF
                  || repeat (' ', 2)
                  || 'duo: '
                  || duo
                  || CRLF
                  || repeat (' ', 2)
                  || 'doc: '
                  || doc
                  || CRLF
                  || repeat (' ', 2)
                  || 'duoqty: '
                  || duoqty
                  || CRLF
                  || repeat (' ', 2)
                  || 'ntinqty: '
                  || ntinqty
                  || CRLF
                  || repeat (' ', 2)
                  || 'otherqty: '
                  || otherqty
                  || CRLF
                  || repeat (' ', 2)
                  || 'qty: '
                  || qty
                  || CRLF);
            END IF;


            --
            --  Get the NSN to use for BSSM
            --
            IF tinqty > 0
            THEN
               SELECT MAX (nsn)
                 INTO vNsn
                 FROM TMP_LCF_ICP
                WHERE doc_no = rec.doc_no AND dic IN ('TIN', 'TRN');
            ELSE
               SELECT MAX (nsn)
                 INTO vNsn
                 FROM TMP_LCF_ICP
                WHERE doc_no = rec.doc_no AND dic NOT IN ('TIN', 'TRN');
            END IF;


            IF (vNsn IS NOT NULL)
            THEN
               reqDate := rec.trans_date;

              <<getNsiSid>>
               BEGIN
                  nsiSid := Amd_Utils.GetNsiSid (pNsn => rec.nsn);

                  IF rec.doc_no = 'X317SA73191200'
                  THEN
                     DBMS_OUTPUT.put_line (
                           'doc_no: '
                        || rec.doc_no
                        || ' Nsn: '
                        || vNsn
                        || ' rec.nsn: '
                        || rec.nsn
                        || ' (nsisid '
                        || nsiSid
                        || ') qty: '
                        || qty);
                  END IF;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     nsiSidNotFoundCnt := nsiSidNotFoundCnt + 1;

                     IF debug
                     THEN
                        writeMsg (
                           pTableName        => 'tmp_amd_denads',
                           pError_location   => 40,
                           pKey1             => 'loadAmdBssmSourceTmpAmdDemands',
                           pKey2             =>    'Nsn '
                                                || vNsn
                                                || ' no nsi_sid found',
                           pKey3             => 'doc_no: ' || rec.doc_no);
                     END IF;

                     CONTINUE;
                  WHEN OTHERS
                  THEN
                     IF SQLCODE = -20000
                     THEN
                        DBMS_OUTPUT.DISABLE ();
                        CONTINUE;
                     ELSE
                        DBMS_OUTPUT.put_line (
                              'getNsiSid: sqlcode='
                           || SQLCODE
                           || ' sqlerrm='
                           || SQLERRM);
                        RAISE;
                     END IF;
               END getNsiSid;

               --
               -- send data to bssm table for extract to bssm
               --
               INSERT INTO amd_bssm_source (requisition_no,
                                            requisition_date,
                                            quantity,
                                            loc_sid,
                                            nsn,
                                            action_code)
                    VALUES (rec.doc_no,
                            reqDate,
                            qty,
                            rec.loc_sid,
                            rec.nsn,
                            AMD_DEFAULTS.INSERT_ACTION);

               BEGIN
                  INSERT INTO tmp_amd_demands (doc_no,
                                               doc_date,
                                               nsi_sid,
                                               loc_sid,
                                               quantity,
                                               action_code,
                                               last_update_dt)
                       VALUES (rec.doc_no,
                               reqDate,
                               nsiSid,
                               rec.loc_sid,
                               qty,
                               Amd_Defaults.INSERT_ACTION,
                               SYSDATE);

                  load_cnt := load_cnt + 1;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     NULL;     -- nsiSid not found generates this, just ignore
                  WHEN DUP_VAL_ON_INDEX
                  THEN
                     dup_cnt := dup_cnt + 1;
                     errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                               tableName         => 'tmp_amd_demands',
                               pError_Location   => 50,
                               key1              => rec.doc_no,
                               key2              => rec.loc_sid,
                               key3              => qty,
                               key4              => dup_cnt,
                               key5              => rows_read);
               END;
            END IF;
         END IF;
      END LOOP;

      writeMsg (
         pTableName        => 'tmp_amd_denads',
         pError_location   => 60,
         pKey1             => 'loadAmdBssmSourceTmpAmdDemands',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             =>    rows_read
                              || ' row(s) read '
                              || load_cnt
                              || ' row(s) loaded '
                              || dup_cnt
                              || ' duplicate(s)',
         pkey4             => 'nsi_sid not found count ' || nsiSidNotFoundCnt);

      DBMS_OUTPUT.put_line (
            'loadAmdBssmSourceTmpAmdDemands: '
         || rows_read
         || ' row(s) read '
         || load_cnt
         || ' row(s) loaded '
         || dup_cnt
         || ' duplicate(s)'
         || ' nsi_sid not found count '
         || nsiSidNotFoundCnt);

      IF nsiSidNotFoundCnt > 0 AND doWarnings
      THEN
         amd_warnings_pkg.insertWarningMsg (
            pData_line_no   => 77,
            pData_line      => 'loadAmdBssmSourceTmpAmdDemands',
            pWarning        =>    'nsi_sid not found cnt: '
                               || nsiSidNotFoundCnt
                               || ' select * from amd_load_details where data_line = ''amd_demand'' and key_2 like ''Nsn''');
      END IF;
   END loadAmdBssmSourceTmpAmdDemands;


   PROCEDURE LoadFmsDemands
   IS
      load_cnt    NUMBER := 0;
      dup_cnt     NUMBER := 0;
      rows_read   NUMBER := 0;

      CURSOR demandCur
      IS
         SELECT DISTINCT asp.nsn            nsn,
                         t.tran_id          tran_id,
                         t.created_datetime created_datetime,
                         (NVL (t.qty, 0))   quantity,
                         asn2.loc_sid       loc_sid,
                         t.loc_id           sc,
                         t.part             part
           FROM TRHI               t,
                amd_spare_parts    asp,
                amd_spare_networks asn1,
                amd_spare_networks asn2
          WHERE     asp.part_no = t.part
                AND asp.action_code != 'D'
                AND (NVL (t.qty, 0)) != 0
                AND (   asn1.loc_id = t.loc_id
                     OR (EXISTS
                            (SELECT NULL
                               FROM amd_sc_inclusions
                              WHERE SUBSTR (t.sc, START_LOC_ID, 7) =
                                       SUBSTR (include_sc, START_LOC_ID, 7))))
                AND asn1.mob = asn2.loc_id(+)
                AND asn1.loc_type = 'FMS'
                AND asn2.loc_sid IS NOT NULL;

      nsiSid      NUMBER;
      nsnAmd      VARCHAR2 (20);
   BEGIN
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 70,
         pKey1             => 'LoadFmsDemands',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));


      FOR rec IN demandCur
      LOOP
         rows_read := rows_read + 1;
         nsnAmd := Amd_Utils.FormatNsn (rec.nsn, 'AMD');

         INSERT INTO AMD_BSSM_SOURCE (requisition_no,
                                      requisition_date,
                                      quantity,
                                      loc_sid,
                                      nsn)
              VALUES (rec.tran_id,
                      rec.created_datetime,
                      rec.quantity,
                      rec.loc_sid,
                      nsnAmd);

         BEGIN
            nsiSid := Amd_Utils.GetNsiSid (pPart_no => rec.part);

            INSERT INTO TMP_AMD_DEMANDS (doc_no,
                                         doc_date,
                                         nsi_sid,
                                         loc_sid,
                                         quantity,
                                         action_code,
                                         last_update_dt)
                 VALUES (rec.tran_id,
                         rec.created_datetime,
                         nsiSid,
                         rec.loc_sid,
                         rec.quantity,
                         Amd_Defaults.INSERT_ACTION,
                         SYSDATE);

            load_cnt := load_cnt + 1;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;           -- nsiSid not found generates this, just ignore
            WHEN DUP_VAL_ON_INDEX
            THEN
               dup_cnt := dup_cnt + 1;
               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'tmp_amd_demands',
                         pError_Location   => 80,
                         key1              => rec.tran_id,
                         key2              => rec.loc_sid,
                         key3              => rec.quantity,
                         key4              => dup_cnt,
                         key5              => rows_read);
         END;
      END LOOP;

      DBMS_OUTPUT.put_line (
            'LoadFmsDemands: '
         || rows_read
         || ' row(s) read '
         || load_cnt
         || ' row(s) loaded '
         || dup_cnt
         || ' duplicate(s)');
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 90,
         pKey1             => 'LoadFmsDemands',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             =>    rows_read
                              || ' row(s) read '
                              || load_cnt
                              || ' row(s) loaded '
                              || dup_cnt
                              || ' duplicate(s)');
   END LoadFmsDemands;

   PROCEDURE loadSanAntonioDemands
   IS
      dup_cnt     NUMBER := 0;
      load_cnt    NUMBER := 0;
      rows_read   NUMBER := 0;

      --
      CURSOR sanAntonioDemands
      IS
         SELECT p.nsn,
                R.REQUEST_ID,
                r.created_datetime,
                (  NVL (r.QTY_RESERVED, 0)
                 + NVL (r.QTY_ISSUED, 0)
                 + NVL (r.QTY_DUE, 0))
                   quantity,
                amd_utils.getLocSid ('EY1746') loc_sid,
                r.prime,
                n.nsi_sid
           FROM Amd_spare_parts          p,
                req1sa                   r,
                amd_national_stock_items n,
                cat1
          WHERE     p.part_no = r.select_from_part
                AND r.prime = cat1.part
                AND r.select_from_sc = 'SATCAA0001C17G'
                AND R.STATUS IN ('U',
                                 'H',
                                 'O',
                                 'R',
                                 'S')
                AND NVL (proc_code, 'GFP') = 'GFP'
                AND TO_CHAR (r.created_datetime, 'YYYY-MM') >= '2015-01'
                AND p.nsn = n.nsn
                AND n.action_code != 'D';

      nsiSid      NUMBER;
      nsnAmd      VARCHAR2 (20);
   BEGIN
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 100,
         pKey1             => 'loadSanAntonioDemands',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      FOR rec IN sanAntonioDemands
      LOOP
         rows_read := rows_read + 1;

         INSERT INTO AMD_BSSM_SOURCE (requisition_no,
                                      requisition_date,
                                      quantity,
                                      loc_sid,
                                      nsn)
              VALUES (rec.request_id,
                      rec.created_datetime,
                      rec.quantity,
                      rec.loc_sid,
                      rec.nsn);

         BEGIN
            INSERT INTO TMP_AMD_DEMANDS (doc_no,
                                         doc_date,
                                         nsi_sid,
                                         loc_sid,
                                         quantity,
                                         action_code,
                                         last_update_dt)
                 VALUES (rec.request_id,
                         rec.created_datetime,
                         rec.nsi_sid,
                         rec.loc_sid,
                         rec.quantity,
                         Amd_Defaults.INSERT_ACTION,
                         SYSDATE);

            load_cnt := load_cnt + 1;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;           -- nsiSid not found generates this, just ignore
            WHEN DUP_VAL_ON_INDEX
            THEN
               dup_cnt := dup_cnt + 1;
               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'tmp_amd_demands',
                         pError_Location   => 110,
                         key1              => rec.request_id,
                         key2              => rec.loc_sid,
                         key3              => rec.quantity,
                         key4              => dup_cnt,
                         key5              => rows_read);
            WHEN OTHERS
            THEN
               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'tmp_amd_demands',
                         pError_Location   => 120,
                         key1              => rec.request_id,
                         key2              => rec.loc_sid,
                         key3              => rec.quantity,
                         key4              => rec.prime,
                         key5              => rows_read);
         END;
      END LOOP;

      DBMS_OUTPUT.put_line (
            'loadSanAntonioDemands: '
         || rows_read
         || ' row(s) read '
         || load_cnt
         || ' row(s) loaded '
         || dup_cnt
         || ' duplicate(s)');
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 130,
         pKey1             => 'loadSanAntonioDemands',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             =>    rows_read
                              || ' row(s) read '
                              || load_cnt
                              || ' row(s) loaded '
                              || dup_cnt
                              || ' duplicate(s)');
   END loadSanAntonioDemands;

   PROCEDURE unloadWarnerRobinsDemands
   IS
      unload_cnt           NUMBER := 0;
      rows_read            NUMBER := 0;
      invalid_number_cnt   NUMBER := 0;
      bssm_deleted         NUMBER := 0;
      wr_updated           NUMBER := 0;


      --
      CURSOR warnerRobinsDemands
      IS
           SELECT items.nsn,
                  request_id,
                  created_datetime,
                  qty                          quantity,
                  amd_utils.getLocSid ('EY1746') loc_sid,
                  items.prime_part_no          prime,
                  items.nsi_sid
             FROM (  SELECT wr.nsn             nsn,
                            doc_no             request_id,
                            MIN (transaction_date) created_datetime,
                            SUM (demand_quantity) qty
                       FROM amd_warner_robins_files wr, amd_nsns
                      WHERE     wr.nsn = amd_nsns.nsn
                            AND (   date_loaded_to_demands IS NOT NULL
                                 OR bad_nsn IS NOT NULL
                                 OR action_code IS NOT NULL)
                   GROUP BY wr.nsn, doc_no) wr_summed,
                  amd_nsns,
                  amd_national_stock_items items
            WHERE     wr_summed.nsn = amd_nsns.nsn
                  AND amd_nsns.nsi_sid = items.nsi_sid
         ORDER BY nsn, request_id;
   BEGIN
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 332,
         pKey1             => 'unloadWarnerRobinsDemands',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      FOR rec IN warnerRobinsDemands
      LOOP
         rows_read := rows_read + 1;

         IF rows_read MOD 500 = 0
         THEN
            COMMIT;
         END IF;

        <<deleteAmdBssmSource>>
         BEGIN
            DELETE AMD_BSSM_SOURCE
             WHERE     requisition_no = rec.request_id
                   AND requisition_date = rec.created_datetime
                   AND quantity = rec.quantity
                   AND loc_sid = rec.loc_sid
                   AND nsn = rec.nsn;

            bssm_deleted := bssm_deleted + 1;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;
         END deleteAmdBssmSource;

         BEGIN
            DELETE TMP_AMD_DEMANDS
             WHERE     doc_no = rec.request_id
                   AND doc_date = rec.created_datetime
                   AND nsi_sid = rec.nsi_sid
                   AND loc_sid = rec.loc_sid
                   AND quantity = rec.quantity;

            unload_cnt := unload_cnt + 1;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;           -- nsiSid not found generates this, just ignore
            WHEN OTHERS
            THEN
               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'tmp_amd_demands',
                         pError_Location   => 336,
                         key1              => rec.request_id,
                         key2              => rec.loc_sid,
                         key3              => rec.quantity,
                         key4              => rec.prime,
                         key5              => rows_read);
         END;
      END LOOP;

     <<updateDateLoadedToDemands>>
      BEGIN
         UPDATE amd_warner_robins_files
            SET date_loaded_to_demands = NULL,
                bad_nsn = NULL,
                action_code = NULL
          WHERE    date_loaded_to_demands IS NOT NULL
                OR bad_nsn IS NOT NULL
                OR action_code IS NOT NULL;

         wr_updated := wr_updated + SQL%ROWCOUNT;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
         WHEN INVALID_NUMBER
         THEN
            invalid_number_cnt := invalid_number_cnt + 1;
            errorMsg (sqlFunction       => amd_defaults.UPDATE_ACTION,
                      tableName         => 'amd_warner_robins_files',
                      pError_Location   => 337,
                      key1              => unload_cnt);
      END updateDateLoadedToDemands;

      DBMS_OUTPUT.put_line (
            'unloadWarnerRobinsDemands: '
         || rows_read
         || ' row(s) read '
         || unload_cnt
         || ' row(s) unloaded '
         || bssm_deleted
         || ' bssm_deleted '
         || wr_updated
         || ' wr_updated ');
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 338,
         pKey1             => 'unloadWarnerRobinsDemands',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             =>    rows_read
                              || ' row(s) read '
                              || unload_cnt
                              || ' row(s) unloaded ');
   END unloadWarnerRobinsDemands;

   PROCEDURE loadWarnerRobinsDemands
   IS
      dup_cnt              NUMBER := 0;
      other_bssm           NUMBER := 0;
      load_cnt             NUMBER := 0;
      rows_read            NUMBER := 0;
      invalid_number_cnt   NUMBER := 0;
      other_demands        NUMBER := 0;
      wr_recs_updated      NUMBER := 0;
      fixed_nsn            NUMBER := 0;
      bad_nsn_cnt          NUMBER := 0;
      no_rows_to_process   NUMBER := 0;
      deleted_nsn_cnt      NUMBER := 0;
      fixed_action_code    NUMBER := 0;

      --
      CURSOR warnerRobinsDemands
      IS
         SELECT doc_no,
                loc_sid,
                nsi_sid,
                nsn,
                created_datetime,
                quantity,
                prime_part_no prime
           FROM amd_warner_robins_summed_v;
   BEGIN
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 132,
         pKey1             => 'loadWarnerRobinsDemands',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      -- check if any nsn's that were bad were fixed
      UPDATE amd_warner_robins_files wr
         SET bad_nsn = NULL
       WHERE     bad_nsn = 'Y'
             AND nsn IN (SELECT nsn
                           FROM amd_nsns
                          WHERE wr.nsn = nsn);

      fixed_nsn := fixed_nsn + SQL%ROWCOUNT;

      UPDATE amd_warner_robins_files wr
         SET action_code = NULL
       WHERE     action_code = 'D'
             AND nsn IN
                    (SELECT nsns.nsn
                       FROM amd_nsns nsns, amd_national_stock_items items
                      WHERE     wr.nsn = nsns.nsn
                            AND nsns.nsi_sid = items.nsi_sid
                            AND items.action_code <> 'D');

      fixed_action_code := fixed_action_code + SQL%ROWCOUNT;

      COMMIT;

      FOR rec IN warnerRobinsDemands
      LOOP
         rows_read := rows_read + 1;

         IF rows_read MOD 500 = 0
         THEN
            COMMIT;
         END IF;

        <<insertAmdBssmSource>>
         BEGIN
            INSERT INTO AMD_BSSM_SOURCE (requisition_no,
                                         requisition_date,
                                         quantity,
                                         loc_sid,
                                         nsn)
                 VALUES (rec.doc_no,
                         rec.created_datetime,
                         rec.quantity,
                         rec.loc_sid,
                         rec.nsn);
         EXCEPTION
            WHEN OTHERS
            THEN
               other_bssm := other_bssm + 1;
               DBMS_OUTPUT.put_line (
                  'amd_bssm_source: ' || SQLCODE || ' -ERROR- ' || SQLERRM);

               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'amd_bssm_source',
                         pError_Location   => 133,
                         key1              => rec.doc_no,
                         key2              => rec.loc_sid,
                         key3              => rec.quantity,
                         key4              => other_bssm,
                         key5              => rows_read);
         END insertAmdBssmSource;

        <<insertTmpAmdDemands>>
         BEGIN
            INSERT INTO TMP_AMD_DEMANDS (doc_no,
                                         doc_date,
                                         nsi_sid,
                                         loc_sid,
                                         quantity,
                                         action_code,
                                         last_update_dt)
                 VALUES (rec.doc_no,
                         rec.created_datetime,
                         rec.nsi_sid,
                         rec.loc_sid,
                         rec.quantity,
                         Amd_Defaults.INSERT_ACTION,
                         SYSDATE);

            load_cnt := load_cnt + 1;

           <<updateAmdWarnerRobinsFiles>>
            BEGIN
               UPDATE amd_warner_robins_files
                  SET date_loaded_to_demands = SYSDATE, bad_nsn = NULL
                WHERE     nsn IN (SELECT nsn
                                    FROM amd_nsns
                                   WHERE nsi_sid = rec.nsi_sid)
                      AND doc_no = rec.doc_no
                      AND date_loaded_to_demands IS NULL;

               wr_recs_updated := wr_recs_updated + SQL%ROWCOUNT;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  no_rows_to_process := no_rows_to_process + 1;
               WHEN OTHERS
               THEN
                  errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                            tableName         => 'tmp_amd_demands',
                            pError_Location   => 135,
                            key1              => rec.doc_no,
                            key2              => rec.loc_sid,
                            key3              => rec.quantity,
                            key4              => rec.prime,
                            key5              => rows_read);
            END updateAmdWarnerRobinsFiles;
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX
            THEN
               dup_cnt := dup_cnt + 1;

               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'tmp_amd_demands',
                         pError_Location   => 134,
                         key1              => rec.doc_no,
                         key2              => rec.nsn,
                         key3              => dup_cnt,
                         key4              => rows_read);
            WHEN OTHERS
            THEN
               other_demands := other_demands + 1;

               DBMS_OUTPUT.put_line (
                     'Error tmp_amd_demands: requestion_no '
                  || rec.doc_no
                  || ' nsn '
                  || rec.nsn
                  || ' sqlcode('
                  || SQLCODE
                  || ') sqlerrm('
                  || SQLERRM
                  || ')');
               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'tmp_amd_demands',
                         pError_Location   => 136,
                         key1              => rec.doc_no,
                         key2              => rec.nsn,
                         key3              => rec.quantity,
                         key4              => rec.prime,
                         key5              => rows_read);
         END;
      END LOOP;

     <<badNsn>>
      DECLARE
      BEGIN
         UPDATE amd_warner_robins_files wr
            SET bad_nsn = 'Y'
          WHERE     nsn NOT IN (SELECT nsn
                                  FROM amd_nsns
                                 WHERE wr.nsn = nsn)
                AND bad_nsn IS NULL;

         bad_nsn_cnt := bad_nsn_cnt + SQL%ROWCOUNT;
      END badNsn;

     <<deletedNsn>>
      DECLARE
      BEGIN
         UPDATE amd_warner_robins_files wr
            SET action_code = 'D'
          WHERE     nsn IN
                       (SELECT nsns.nsn
                          FROM amd_nsns nsns, amd_national_stock_items items
                         WHERE     wr.nsn = nsns.nsn
                               AND nsns.nsi_sid = items.nsi_sid
                               AND items.action_code = 'D')
                AND action_code IS NULL;

         deleted_nsn_cnt := deleted_nsn_cnt + SQL%ROWCOUNT;
      END deletedNsn;


      DBMS_OUTPUT.put_line (
            'loadWarnerRobinsDemands: '
         || rows_read
         || ' row(s) read '
         || load_cnt
         || ' row(s) loaded ');

      IF wr_recs_updated > 0
      THEN
         DBMS_OUTPUT.put_line ('rows processed: ' || wr_recs_updated);
      END IF;

      IF dup_cnt > 0
      THEN
         DBMS_OUTPUT.put_line (
            'tmp_amd_demands: ' || dup_cnt || ' duplicate(s)');
      END IF;

      IF bad_nsn_cnt > 0
      THEN
         DBMS_OUTPUT.put_line (
            'amd_warnerrobins_files: has ' || bad_nsn_cnt || ' bad nsns');
      END IF;

      IF deleted_nsn_cnt > 0
      THEN
         DBMS_OUTPUT.put_line (
               'amd_warnerrobine_files: has '
            || deleted_nsn_cnt
            || ' nsns that are flagged as DELETED');
      END IF;

      IF fixed_nsn > 0
      THEN
         DBMS_OUTPUT.put_line (
            'amd_warnerrobins_files: fixed ' || fixed_nsn || ' nsns fixed.');
      END IF;

      IF fixed_action_code > 0
      THEN
         DBMS_OUTPUT.put_line (
               'amd_warnerrobins_files: fixed '
            || fixed_action_code
            || ' flagged as deleted');
      END IF;

      IF no_rows_to_process > 0
      THEN
         DBMS_OUTPUT.put_line (
               'There were '
            || no_rows_to_process
            || ' records that were not processed');
      END IF;

      IF invalid_number_cnt > 0
      THEN
         DBMS_OUTPUT.put_line (
               'amd_warner_robins_files: update error '
            || invalid_number_cnt
            || ' invalid_number_cnt');
      END IF;

      IF other_bssm > 0
      THEN
         DBMS_OUTPUT.put_line (
            'amd_bssm_source: ' || other_bssm || ' category: other errors');
      END IF;

      IF other_demands > 0
      THEN
         DBMS_OUTPUT.put_line (
            'tmp_amd_demands: ' || other_demands || ' category: other errors');
      END IF;


      IF wr_recs_updated > 0
      THEN
         DBMS_OUTPUT.put_line (
               'amd_warner_robins_files: rows_updated with date_loaded_to_demands '
            || wr_recs_updated);
      END IF;

      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 138,
         pKey1             => 'loadWarnerRobinsDemands',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             =>    rows_read
                              || ' row(s) read '
                              || load_cnt
                              || ' row(s) loaded '
                              || wr_recs_updated
                              || ' recs_updated');
   END loadWarnerRobinsDemands;



   PROCEDURE LoadDepotDemands
   IS
      dup_cnt     NUMBER := 0;
      load_cnt    NUMBER := 0;
      rows_read   NUMBER := 0;

      CURSOR demandCur
      IS
           SELECT c.nsn,
                  r.request_id,
                  r.created_datetime,
                  (  NVL (r.qty_issued, 0)
                   + NVL (r.qty_due, 0)
                   + NVL (r.qty_reserved, 0))
                     quantity,
                  asn.loc_sid,
                  r.prime
             FROM REQ1                         r,
                  CAT1                         c,
                  amd_spare_networks           asn,
                  amd_depot_partnering_locations depot
            WHERE     r.prime = c.part
                  AND NVL (r.nsn, 'null') <> 'null'
                  AND SUBSTR (r.request_id, 1, 6) = depot.loc_id
                  AND NOT (    SUBSTR (R.request_id, 1, 6) IN
                                  ('FB2065',  'EY1746')
                           AND TRUNC (r.created_datetime, 'YEAR') >=
                                  TO_DATE ('01/01/2015', 'MM/DD/YYYY'))
                  AND SUBSTR (r.select_from_sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                  AND (  NVL (r.qty_issued, 0)
                       + NVL (r.qty_due, 0)
                       + NVL (r.qty_reserved, 0)) != 0
                  AND SUBSTR (request_id, 11, 1) != 'S'
                  AND r.status NOT IN ('X', 'C')
                  AND asn.loc_id = 'EY1746'
         ORDER BY 1;



      nsiSid      NUMBER;
      nsnAmd      VARCHAR2 (20);
   BEGIN
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 100,
         pKey1             => 'LoadDepotDemands',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      FOR rec IN demandCur
      LOOP
         rows_read := rows_read + 1;
         nsnAmd := Amd_Utils.FormatNsn (rec.nsn, 'AMD');

         INSERT INTO AMD_BSSM_SOURCE (requisition_no,
                                      requisition_date,
                                      quantity,
                                      loc_sid,
                                      nsn)
              VALUES (rec.request_id,
                      rec.created_datetime,
                      rec.quantity,
                      rec.loc_sid,
                      nsnAmd);

         BEGIN
            nsiSid := Amd_Utils.GetNsiSid (pPart_no => rec.prime);

            INSERT INTO TMP_AMD_DEMANDS (doc_no,
                                         doc_date,
                                         nsi_sid,
                                         loc_sid,
                                         quantity,
                                         action_code,
                                         last_update_dt)
                 VALUES (rec.request_id,
                         rec.created_datetime,
                         nsiSid,
                         rec.loc_sid,
                         rec.quantity,
                         Amd_Defaults.INSERT_ACTION,
                         SYSDATE);

            load_cnt := load_cnt + 1;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               NULL;           -- nsiSid not found generates this, just ignore
            WHEN DUP_VAL_ON_INDEX
            THEN
               dup_cnt := dup_cnt + 1;
               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'tmp_amd_demands',
                         pError_Location   => 110,
                         key1              => rec.request_id,
                         key2              => rec.loc_sid,
                         key3              => rec.quantity,
                         key4              => dup_cnt,
                         key5              => rows_read);
            WHEN OTHERS
            THEN
               errorMsg (sqlFunction       => amd_defaults.INSERT_ACTION,
                         tableName         => 'tmp_amd_demands',
                         pError_Location   => 120,
                         key1              => rec.request_id,
                         key2              => rec.loc_sid,
                         key3              => rec.quantity,
                         key4              => rec.prime,
                         key5              => rows_read);
         END;
      END LOOP;

      DBMS_OUTPUT.put_line (
            'LoadDepotDemands: '
         || rows_read
         || ' row(s) read '
         || load_cnt
         || ' row(s) loaded '
         || dup_cnt
         || ' duplicate(s)');
      writeMsg (
         pTableName        => 'amd_bssm_source',
         pError_location   => 130,
         pKey1             => 'LoadDepotDemands',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             =>    rows_read
                              || ' row(s) read '
                              || load_cnt
                              || ' row(s) loaded '
                              || dup_cnt
                              || ' duplicate(s)');
   END LoadDepotDemands;

   PROCEDURE load_amd_demands_table
   IS
      CURSOR get_new_demands_cur
      IS
         SELECT doc_no,
                doc_date,
                doc_date_defaulted,
                nsi_sid,
                loc_sid,
                quantity,
                action_code,
                last_update_dt
           FROM TMP_AMD_DEMANDS a
          WHERE NOT EXISTS
                   (SELECT 'x'
                      FROM AMD_DEMANDS b
                     WHERE a.doc_no = b.doc_no AND a.loc_sid = b.loc_sid);
   BEGIN
      writeMsg (
         pTableName        => 'amd_demands',
         pError_location   => 140,
         pKey1             => 'load_amd_demands_table',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      DBMS_OUTPUT.put_line (
            'load_amd_demands_table: started at '
         || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      BEGIN
         MERGE INTO amd_demands tgt
              USING tmp_amd_demands src
                 ON (    SRC.DOC_NO = tgt.doc_no
                     AND SRC.LOC_SID = tgt.loc_sid
                     AND SRC.NSI_SID = tgt.nsi_sid)
         WHEN MATCHED
         THEN
            UPDATE SET tgt.doc_date = src.doc_date,
                       tgt.doc_date_defaulted = src.doc_date_defaulted,
                       tgt.quantity = src.quantity,
                       tgt.action_code = AMD_DEFAULTS.UPDATE_ACTION,
                       tgt.last_update_dt = SYSDATE
         WHEN NOT MATCHED
         THEN
            INSERT     (tgt.doc_no,
                        tgt.doc_date,
                        tgt.doc_date_defaulted,
                        tgt.nsi_sid,
                        tgt.loc_sid,
                        tgt.quantity,
                        tgt.action_code,
                        tgt.last_update_dt)
                VALUES (src.doc_no,
                        src.doc_date,
                        src.doc_date_defaulted,
                        src.nsi_sid,
                        src.loc_sid,
                        src.quantity,
                        AMD_DEFAULTS.INSERT_ACTION,
                        SYSDATE);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            DBMS_OUTPUT.put_line (
                  'load_amd_demands_table: 1 sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE_APPLICATION_ERROR (
               -20001,
               'no data found load_amd_demands_table proc for loc_id, amd_spare_networks');
         WHEN OTHERS
         THEN
            DBMS_OUTPUT.put_line (
                  'load_amd_demands_table: 1 sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE_APPLICATION_ERROR (
               -20001,
                  'OTHERS: load_amd_demands_table proc SQLERRM '
               || SQLERRM
               || ' SQLCODE '
               || SQLCODE);
      END;

      writeMsg (
         pTableName        => 'amd_demands',
         pError_location   => 150,
         pKey1             => 'load_amd_demands_table',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => SQL%ROWCOUNT || ' rows merged.');

      DBMS_OUTPUT.put_line (
            'load_amd_demands_table: ended at '
         || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM')
         || ' '
         || SQL%ROWCOUNT
         || ' rows merged');
   END load_amd_demands_table;

   PROCEDURE prime_part_change (
      old_part_no    AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE,
      new_part_no    AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE)
   AS
      CURSOR get_nsi_sid_cur (
         cv_prime_part_no    AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE)
      IS
         SELECT nsi_sid
           FROM AMD_NATIONAL_STOCK_ITEMS
          WHERE prime_part_no = cv_prime_part_no;

      CURSOR get_demands_cur (
         cv_nsi_sid    AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE)
      IS
         SELECT a.doc_no,
                a.doc_date,
                a.doc_date_defaulted,
                a.nsi_sid,
                b.spo_location, -- changed loc_id to spo_location . Thuy 2/16/06
                a.quantity,
                a.action_code,
                a.last_update_dt
           FROM AMD_DEMANDS a, AMD_SPARE_NETWORKS b
          WHERE a.nsi_sid = cv_nsi_sid AND a.loc_sid = b.loc_sid;
   BEGIN
      --  This iteration is for all the 'D' using the old_part_no being passed
      --  Then read them with the new_part_no being passed

      FOR get_nsi_sid_rec IN get_nsi_sid_cur (old_part_no)
      LOOP
         FOR get_demands_rec IN get_demands_cur (get_nsi_sid_rec.nsi_sid)
         LOOP
            NULL;
         END LOOP;
      END LOOP;
   END;

   FUNCTION getFiscalPeriod (aDate IN DATE)
      RETURN NUMBER
   IS
      the_year    NUMBER := TO_NUMBER (TO_CHAR (aDate, 'YYYY'));
      the_month   NUMBER := TO_NUMBER (TO_CHAR (aDate, 'MM'));
   BEGIN
      IF the_month <= 9
      THEN
         RETURN TO_NUMBER (the_year);
      ELSE
         RETURN TO_NUMBER (the_year) + 1;
      END IF;
   END getFiscalPeriod;

   FUNCTION getCalendarDate (period IN NUMBER)
      RETURN DATE
   IS
      cur_year        NUMBER := TO_NUMBER (TO_CHAR (SYSDATE, 'YYYY'));
      cur_month       NUMBER := TO_NUMBER (TO_CHAR (SYSDATE, 'MM'));
      calendar_date   DATE := NULL;   -- return null if the period has expired
   BEGIN
      IF period = cur_year
      THEN
         IF cur_month <= 9
         THEN
            calendar_date :=
               TO_DATE (TO_CHAR (cur_month) || '/01/' || TO_CHAR (cur_year),
                        'MM/DD/YYYY');
         ELSE
            NULL; -- do nothing since october starts a new fiscal year.  So, period has expired if cur_month >= 10
         END IF;
      ELSIF period > cur_year
      THEN
         IF cur_month < 10
         THEN
            calendar_date :=
               TO_DATE ('10/01/' || TO_CHAR (period - 1), 'MM/DD/YYYY');
         ELSE
            calendar_date :=
               TO_DATE (
                  TO_CHAR (cur_month) || '/01/' || TO_CHAR (period - 1),
                  'MM/DD/YYYY');
         END IF;
      END IF;

      RETURN calendar_date;
   END getCalendarDate;

   FUNCTION doDmndFrcstConsumablesDiff (nsn               IN VARCHAR2,
                                        sran              IN VARCHAR2,
                                        period            IN NUMBER,
                                        demand_forecast   IN NUMBER,
                                        duplicate         IN NUMBER,
                                        action_code       IN VARCHAR2)
      RETURN NUMBER
   IS
      PROCEDURE updateRow
      IS
      BEGIN
         UPDATE amd_dmnd_frcst_consumables
            SET demand_forecast = doDmndFrcstConsumablesDiff.demand_forecast,
                duplicate = doDmndFrcstConsumablesDiff.duplicate,
                action_code = doDmndFrcstConsumablesDiff.action_code,
                last_update_dt = SYSDATE
          WHERE     nsn = doDmndFrcstConsumablesDiff.nsn
                AND sran = doDmndFrcstConsumablesDiff.sran
                AND period = doDmndFrcstConsumablesDiff.period;
      END updateRow;

      PROCEDURE insertRow
      IS
      BEGIN
         INSERT INTO amd_dmnd_frcst_consumables (nsn,
                                                 sran,
                                                 period,
                                                 demand_forecast,
                                                 duplicate,
                                                 action_code)
              VALUES (nsn,
                      sran,
                      period,
                      demand_forecast,
                      duplicate,
                      action_code);
      EXCEPTION
         WHEN STANDARD.DUP_VAL_ON_INDEX
         THEN
            updateRow;
      END insertRow;
   BEGIN
      IF action_code = amd_defaults.INSERT_ACTION
      THEN
         insertRow;
      ELSIF action_code = amd_defaults.UPDATE_ACTION
      THEN
         updateRow;
      ELSIF action_code = amd_defaults.DELETE_ACTION
      THEN
         updateRow;
      ELSE
         errorMsg (sqlFunction       => action_code,
                   tableName         => 'doDmndFrcstConsumables',
                   pError_Location   => 160,
                   key1              => nsn,
                   key2              => sran,
                   key3              => period);
         DBMS_OUTPUT.put_line (
               'doDmndFrcstConsumables: 1 action_code='
            || action_code
            || ' nsn='
            || nsn
            || ' period='
            || period
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE badActionCode;
      END IF;

      RETURN 0;
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction       => action_code,
                   tableName         => 'doDmndFrcstConsumables',
                   pError_Location   => 170,
                   key1              => nsn,
                   key2              => sran,
                   key3              => period);
         DBMS_OUTPUT.put_line (
               'doDmndFrcstConsumables: 2 action_code='
            || action_code
            || ' nsn='
            || nsn
            || ' period='
            || period
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END doDmndFrcstConsumablesDiff;

   PROCEDURE genDuplicateForConsumables
   IS
      TYPE demandTab IS TABLE OF tmp_amd_dmnd_frcst_consumables%ROWTYPE
         INDEX BY VARCHAR2 (23);

      demands                  demandTab;

      CURSOR demandsNotSame (
         the_current_period    NUMBER)
      IS
           SELECT CASE
                     WHEN TO_DATE ('10/01/' || TO_CHAR (period - 1),
                                   'MM/DD/YYYY') >= TRUNC (SYSDATE, 'Month')
                     THEN
                        MONTHS_BETWEEN (
                           TO_DATE ('09/01/' || period, 'MM/DD/YYYY'),
                           TO_DATE ('10/01/' || TO_CHAR (period - 1),
                                    'MM/DD/YYYY'))
                     WHEN SYSDATE <= TO_DATE ('09/01/' || period, 'MM/DD/YYYY')
                     THEN
                        MONTHS_BETWEEN (
                           TO_DATE ('09/01/' || period, 'MM/DD/YYYY'),
                           TRUNC (SYSDATE, 'Month'))
                     ELSE
                        0
                  END
                     calc_duplicate,
                  tmp.*
             FROM tmp_amd_dmnd_frcst_consumables tmp,
                  (  SELECT nsn, sran, COUNT (*)
                       FROM (  SELECT nsn,
                                      sran,
                                      demand_forecast,
                                      COUNT (period)
                                 FROM tmp_amd_dmnd_frcst_consumables
                                WHERE period >= the_current_period
                             GROUP BY nsn, sran, demand_forecast)
                   GROUP BY nsn, sran
                     HAVING COUNT (*) > 1) x
            WHERE     tmp.nsn = x.nsn
                  AND tmp.sran = x.sran
                  AND tmp.period >= the_current_period
         --and tmp.nsn = '1560013299845'
         --and tmp.sran = 'FB4400'
         ORDER BY tmp.nsn, tmp.sran, tmp.period;

      totDuplicates            NUMBER := 0;
      nsn                      tmp_amd_dmnd_frcst_consumables.nsn%TYPE;
      sran                     tmp_amd_dmnd_frcst_consumables.SRAN%TYPE;
      demand_forecast          tmp_amd_dmnd_frcst_consumables.demand_forecast%TYPE;
      period                   tmp_amd_dmnd_frcst_consumables.period%TYPE;
      dupValue                 NUMBER := 0;
      DUP_THRESHOLD   CONSTANT NUMBER := 66;
      cur_period               NUMBER := getFiscalPeriod (SYSDATE);

      PROCEDURE doUpdate (nsn      IN VARCHAR2,
                          sran     IN VARCHAR2,
                          period   IN NUMBER)
      IS
      BEGIN
         UPDATE tmp_amd_dmnd_frcst_consumables
            SET duplicate = dupValue
          WHERE     nsn = doUpdate.nsn
                AND sran = doUpdate.sran
                AND period = doUpdate.period;

         IF totDuplicates + dupValue > DUP_THRESHOLD
         THEN
            totDuplicates := DUP_THRESHOLD;
         ELSE
            totDuplicates := totDuplicates + dupValue;
         END IF;
      END doUpdate;
   BEGIN
      FOR rec IN demandsNotSame (cur_period)
      LOOP
         IF nsn IS NULL
         THEN
            nsn := rec.nsn;
            sran := rec.sran;
            demand_forecast := rec.demand_forecast;
            period := rec.period;
         END IF;

         IF nsn || sran <> rec.nsn || rec.sran
         THEN
            IF dupValue > 0
            THEN
               doUpdate (nsn, sran, period);
            END IF;

            totDuplicates := 0;
            dupValue := 0;
            nsn := rec.nsn;
            sran := rec.sran;
            period := rec.period;
            demand_forecast := rec.demand_forecast;
         END IF;

         IF demand_forecast <> rec.demand_forecast
         THEN
            IF dupValue > 0
            THEN
               doUpdate (nsn, sran, period);
            END IF;

            dupValue := 0;
            period := rec.period;
            demand_forecast := rec.demand_forecast;
         END IF;

         IF totDuplicates + dupValue + rec.calc_duplicate + 1 > DUP_THRESHOLD
         THEN
            dupValue := DUP_THRESHOLD - totDuplicates;
         ELSE
            dupValue := dupValue + rec.calc_duplicate + 1;
         END IF;
      END LOOP;

      IF dupValue > 0
      THEN
         doUpdate (nsn, sran, period);
      END IF;

      UPDATE tmp_amd_dmnd_frcst_consumables a
         SET duplicate = DUP_THRESHOLD
       WHERE duplicate IS NULL AND period = cur_period;

      COMMIT;
   END genDuplicateForConsumables;

   FUNCTION getDoWarningsYorN
      RETURN VARCHAR2
   IS
   BEGIN
      IF doWarnings
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getDoWarningsYorN;

   PROCEDURE setDoWarnings (switch VARCHAR2)
   IS
   BEGIN
      doWarnings :=
         UPPER (switch) IN ('Y',
                            'T',
                            'YES',
                            'TRUE');
   END setDoWarnings;

   FUNCTION getDebugYorN
      RETURN VARCHAR2
   IS
   BEGIN
      IF debug
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getDebugYorN;

   PROCEDURE setDebug (switch IN VARCHAR2)
   IS
   BEGIN
      debug :=
         UPPER (switch) IN ('Y',
                            'T',
                            'YES',
                            'TRUE');

      IF debug
      THEN
         DBMS_OUTPUT.ENABLE (100000);
      ELSE
         DBMS_OUTPUT.DISABLE;
      END IF;
   END setDebug;


   PROCEDURE version
   IS
   BEGIN
      writeMsg (pTableName        => 'amd_demand',
                pError_location   => 180,
                pKey1             => 'amd_demand',
                pKey2             => '$Revision:   1.59');
   END version;

   FUNCTION getVersion
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN '$Revision:   1.59';
   END getVersion;
END Amd_Demand;
/


DROP PACKAGE BODY AMD_OWNER.AMD_EFFECTIVITY_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_effectivity_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
	    $Date:   Nov 30 2005 12:24:06  $
    $Workfile:   amd_effectivity_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_effectivity_pkg.pkb-arc  $
/*
/*      Rev 1.1   Nov 30 2005 12:24:06   zf297a
/*   added PVCS keywords
*/

	NUM_TIME_PERIODS   constant number:=60;
	FOREVER            constant date  :=add_months(sysdate,NUM_TIME_PERIODS);



	procedure genFlyingAltus(
							pNsiSid number);
	procedure genFlyingByShip(
							pNsiSid number);
	procedure genFlyingByFleet(
							pNsiSid number);
	procedure updateFsls(
							pRec amd_nsi_loc_distribs%rowtype);
	procedure processLatestConfig(
							pNsiSid number);
	procedure processNonLatestConfig(
							pNsiSid number);
	procedure insertNsiLocDistribs(
							pRec amd_nsi_loc_distribs%rowtype);
	procedure genFlyingDerived(
							pNsiSid number);
	function getAssignedQuantity(
							pTimePeriod date,
							pLocSid number) return number;
	procedure genCapable(
							pNsiSid number);
	function getCountByShip(
							pNsiSid number) return number;
	function getCountByFleet(
							pNsiSid number) return number;
	procedure displayMsg(
							pMsg varchar2);
	function isOrphan(
							pNsiSid number) return boolean;
	procedure updateOrphanStatus(
							pNsiSid number);



	procedure displayMsg(
							pMsg varchar2) is
	begin
		dbms_output.put_line(pMsg);
	end;


	procedure updateChildS(
							pChildRec amd_nsi_effects%rowtype) is
	begin
		update amd_nsi_effects set
			derived      = pChildRec.derived
		where
			nsi_sid     = pChildRec.nsi_sid
			and tail_no = pChildRec.tail_no;

	end;

	procedure updateChildF(
							pChildRec amd_cur_nsi_loc_distribs%rowtype) is
	begin
		update amd_cur_nsi_loc_distribs set
			quantity       = pChildRec.quantity,
			derived        = pChildRec.derived,
			last_update_id = substr(user,1,8),
			last_update_dt = sysdate
		where
			nsi_sid     = pChildRec.nsi_sid
			and loc_sid = pChildRec.loc_sid;

	end;


	--
	-- Generates A_C_N_L_D records as a default if they don't exist.
	--
	procedure genLocRecs(
							pChildSid number) is
		cursor locCur is
			select
				loc_sid
			from
				amd_spare_networks
			where
				loc_type = 'MOB';

		locRec    amd_cur_nsi_loc_distribs%rowtype;
	begin

		for rec in locCur loop
			locRec.nsi_sid      := pChildSid;
			locRec.loc_sid      := rec.loc_sid;
			locRec.quantity     := 0;
			locRec.user_defined := 'N';
			locRec.derived      := 'N';

			begin
				insert into amd_cur_nsi_loc_distribs
				(
					nsi_sid,
					loc_sid,
					user_defined,
					derived,
					quantity,
					last_update_id,
					last_update_dt
				)
				values
				(
					locRec.nsi_sid,
					locRec.loc_sid,
					locRec.user_defined,
					locRec.derived,
					locRec.quantity,
					substr(user,1,8),
					sysdate
				);
			exception
				when dup_val_on_index then NULL;
			end;
		end loop;

	end;

	procedure rebuildChild(
							pChildSid number,
							pType varchar2 default 'S') is
		cursor sParentCur(pSid number) is
			select distinct
				ane.tail_no
			from
				amd_product_structure aps,
				amd_nsi_effects ane,
				amd_national_stock_items ansi,
				amd_nsi_groups ang,
				amd_ltd_fleet_size_member alfsm
			where
				aps.comp_nsi_sid     = pSid
				and aps.assy_nsi_sid = ane.nsi_sid
				and ane.effect_type  = 'B'
				and ane.user_defined in ('Y','S')
				and aps.assy_nsi_sid    = ansi.nsi_sid
				and ansi.nsi_group_sid  = ang.nsi_group_sid
				and ang.fleet_size_name = alfsm.fleet_size_name
				and alfsm.tail_no       = ane.tail_no;

		cursor fParentCur(pSid number) is
			select
				acnld.loc_sid,
				sum(acnld.quantity) quantity
			from
				amd_product_structure aps,
				amd_cur_nsi_loc_distribs acnld
			where
				aps.comp_nsi_sid     = pSid
				and aps.assy_nsi_sid = acnld.nsi_sid
			group by
				acnld.loc_sid;

		sChildRec    amd_nsi_effects%rowtype;
		fChildRec    amd_cur_nsi_loc_distribs%rowtype;
		userDefinedCnt   number;

	begin
		update amd_national_stock_items set
			effect_by             = upper(pType),
			effect_last_update_id = substr(user,1,8),
			effect_last_update_dt = sysdate
		where nsi_sid = pChildsid;

		-- Process ansi.effect_by = 'S'|'F' different ways
		--
		if (upper(pType) = 'S') then
			update amd_nsi_effects set
				derived = 'N'
			where
				nsi_sid = pChildSid
				and derived = 'Y';

			for rec in sParentCur(pChildSid) loop
				sChildRec.nsi_sid      := pChildSid;
				sChildRec.tail_no      := rec.tail_no;
				sChildRec.derived      := 'Y';

				updateChildS(sChildRec);
			end loop;
		elsif (upper(pType) = 'F') then
			genLocRecs(pChildSid);

			update amd_cur_nsi_loc_distribs set
				quantity = 0,
				derived = 'N'
			where
				nsi_sid = pChildSid
				and derived = 'Y';

			for rec in fParentCur(pChildSid) loop
				fChildRec.nsi_sid  := pChildSid;
				fChildRec.loc_sid  := rec.loc_sid;
				fChildRec.quantity := rec.quantity;
				fChildRec.derived  := 'Y';

				updateChildF(fChildRec);
			end loop;

		end if;

		if (isOrphan(pChildSid)) then
			updateOrphanStatus(pChildSid);
		end if;
	end;

	procedure rebuildChildren(
							pParentSid number) is
		cursor childCur(pSid number) is
			select
				comp_nsi_sid
			from
				amd_product_structure
			where
				assy_nsi_sid = pSid;

		effectBy    varchar2(1);
	begin

		select effect_by
		into effectBy
		from amd_national_stock_items
		where nsi_sid = pParentSid;

		for rec in childCur(pParentSid) loop
			rebuildChild(rec.comp_nsi_sid,effectBy);
		end loop;

	end;


	procedure genDistribution(
							pNsn varchar2,
							pType varchar2) is
		nsiSid     number;
	begin
		displayMsg('genDistribution('||pNsn||','||pType||')');

		select nsi_sid
		into nsiSid
		from amd_nsns
		where nsn = pNsn;

		genDistribution(nsiSid,pType);
	end;


	procedure genDistribution(
							pNsiSid number,
							pType varchar2) is
		effectBy     varchar2(1);
	begin
		displayMsg('genDistribution('||pNsiSid||','||pType||')');

		select effect_by
		into effectBy
		from amd_national_stock_items
		where nsi_sid = pNsiSid;

		-- pType -
		-- 'F'=calculate asFlying values
		-- 'C'=calculate asCapable values
		-- 'A'=calculate asFlying values for Altus only
		--
		if (pType = 'F') then
			delete from amd_nsi_loc_distribs
			where
				nsi_sid = pNsiSid
				and time_period_start >= trunc(sysdate,'mm');

			if (effectBy = 'S') then
				genFlyingByShip(pNsiSid);
			elsif (effectBy = 'F') then
				genFlyingByFleet(pNsiSid);
			end if;

		elsif (pType = 'C') then
			genCapable(pNsiSid);
		elsif (pType = 'A') then
			genFlyingAltus(pNsiSid);
		elsif (pType = 'DERIVED' and effectBy = 'F') then
			genFlyingDerived(pNsiSid);
		end if;
	end;


	procedure genFlyingByShip(
							pNsiSid number) is
	begin
		displayMsg('genFlyingByShip('||pNsiSid||')');

		insert into amd_nsi_loc_distribs
		(
			nsi_sid,
			loc_sid,
			time_period_start,
			time_period_end,
			as_flying_count
		)
			select
				header.nsi_sid,
				header.loc_sid,
				header.tpStart tpStart,
				last_day(header.tpStart+.99999) tpEnd,
				nvl(flying.acCount,0)
			from
				(select
					 pNsiSid nsi_sid,
					loc_sid,
					tp.tpStart
				from
					amd_spare_networks,
					(select
						add_months(trunc(sysdate,'mm'),rownum-1) tpStart
					from amd_spare_parts
					where rownum <=60) tp
				where
					loc_type = 'MOB') Header,
				(select
					asFlying.loc_sid,
					tpQ.TPStart,
					count(*) acCount
				from
					(select
						add_months(trunc(sysdate,'mm'),rownum-1) TPStart,
						add_months(trunc(sysdate,'mm')+14,rownum-1) TPMid,
						last_day(add_months(trunc(sysdate,'mm'),rownum-1)) TPEnd
					from amd_spare_parts
					where rownum <= NUM_TIME_PERIODS) tpQ,
					(select
						aaa.tail_no,
						aaa.loc_sid,
						decode(aaa.assignment_start,aaa2.deliveryDt,
							trunc(aaa.assignment_start,'mm'),
							aaa.assignment_start) startDate,
						nvl(aaa.assignment_end,
							add_months(trunc(sysdate,'mm'),NUM_TIME_PERIODS)) endDate
					from
						amd_nsi_effects ane,
						amd_ac_assigns aaa,
						(select
							tail_no,
							min(assignment_start) deliveryDt
						from amd_ac_assigns
						group by tail_no) aaa2,
						amd_national_stock_items ansi,
						amd_nsi_groups ang,
						amd_ltd_fleet_size_member alfsm
					where
						ane.nsi_sid = pNsiSid
						and ((ane.user_defined in ('Y','S') and ane.effect_type = 'B')
							or ane.derived = 'Y')
						and ane.tail_no = aaa.tail_no
						and aaa.tail_no = aaa2.tail_no(+)
						and aaa.assignment_start = aaa2.deliveryDt(+)
						and ane.nsi_sid          = ansi.nsi_sid
						and ansi.nsi_group_sid   = ang.nsi_group_sid
						and ang.fleet_size_name  = alfsm.fleet_size_name
						and alfsm.tail_no        = ane.tail_no) AsFlying
				where
					TPq.TPMid between asFlying.startDate and asFlying.endDate
					and asFlying.endDate > (asFlying.startDate+14)
				group by
					asFlying.loc_sid,
					tpQ.tpStart) flying
			where
				header.loc_sid     = flying.loc_sid(+)
				and header.tpStart = flying.tpStart(+);

	exception
		when others then
			displayMsg('EXCEPTION: genFlyingByShip('||sqlerrm||')');
			raise;
	end genFlyingByShip;


	procedure genCapable(
							pNsiSid number) is
		cursor dataCur is
			select
				time_period_start,
				time_period_end,
				anld.loc_sid,
				asn.location_name,
				as_flying_count
			from amd_nsi_loc_distribs anld,
				amd_spare_networks asn
			where nsi_sid = pNsiSid
				and time_period_start >= trunc(sysdate,'mm')
				and anld.loc_sid = asn.loc_sid
				and asn.loc_type = 'MOB';

		relatedCnt             number;
		relatedLimitedCnt      number;
		adjCapableCnt          number;
		fleetSize              number;
		locRec                 amd_nsi_loc_distribs%rowtype;
	begin
		displayMsg('genCapable('||pNsiSid||')');

		--
		-- The asCapable count of an nsn is equal to the sum of the following:
		--   it's own asFlying count
		--   asFlying count of all related nsns with a 1-way or 2-way relationship
		--   asCapable count of all related nsns with a limited relationship
		--
		for rec in dataCur loop

			-- Get count of related nsns asFlying count.
			--
			select
				nvl(sum(anldL.as_flying_count),0)
			into relatedCnt
			from
				amd_related_nsi_pairs arnp,
				amd_nsi_loc_distribs anldL
			where
				arnp.replaced_by_nsi_sid    = pNsiSid
				and arnp.replaced_nsi_sid   = anldL.nsi_sid
				and arnp.interchange_type in ('1-way','2-way')
				and anldL.time_period_start = rec.time_period_start
				and anldL.loc_sid           = rec.loc_sid;

			-- Get count of limited nsns asCapable count.
			--
			if (rec.location_name = 'ALTUS') then
				select
					count(distinct aneR.tail_no)
				into relatedLimitedCnt
	         from
	            amd_related_nsi_pairs arnp,
	            amd_nsi_effects aneL,
					amd_national_stock_items ansiL,
					amd_nsi_groups angL,
					amd_ltd_fleet_size_member alfsmL,
					amd_nsi_effects aneR,
					amd_national_stock_items ansiR,
					amd_nsi_groups angR,
					amd_ltd_fleet_size_member alfsmR
	         where
	            arnp.replaced_by_nsi_sid  = pNsiSid
	            and arnp.replaced_by_nsi_sid = aneL.nsi_sid
					and arnp.replaced_by_nsi_sid = ansiL.nsi_sid
					and ansiL.nsi_group_sid   = angL.nsi_group_sid
					and angL.fleet_size_name  = alfsmL.fleet_size_name
					and alfsmL.tail_no        = aneL.tail_no
	            and arnp.interchange_type = 'limited'
	            and aneL.effect_type      = 'C'
	            and aneL.user_defined     = 'Y'
					and arnp.replaced_nsi_sid = aneR.nsi_sid
					and arnp.replaced_nsi_sid = ansiR.nsi_sid
					and ansiR.nsi_group_sid   = angR.nsi_group_sid
					and angR.fleet_size_name  = alfsmR.fleet_size_name
					and alfsmR.tail_no        = aneR.tail_no
					and aneR.effect_type      = 'B'
					and aneR.user_defined     = 'Y'
					and aneR.tail_no          = aneL.tail_no;
			else
				-- Get count of limited nsns asCapable count.
				--
				select
					count(*)
				into relatedLimitedCnt
				from amd_ac_assigns aaa1
				where
					tail_no in
						(select
							aneR.tail_no
			         from
			            amd_related_nsi_pairs arnp,
			            amd_nsi_effects aneL,
							amd_national_stock_items ansiL,
							amd_nsi_groups angL,
							amd_ltd_fleet_size_member alfsmL,
							amd_nsi_effects aneR,
							amd_national_stock_items ansiR,
							amd_nsi_groups angR,
							amd_ltd_fleet_size_member alfsmR
			         where
			            arnp.replaced_by_nsi_sid  = pNsiSid
			            and arnp.replaced_by_nsi_sid = aneL.nsi_sid
							and arnp.replaced_by_nsi_sid = ansiL.nsi_sid
							and ansiL.nsi_group_sid   = angL.nsi_group_sid
							and angL.fleet_size_name  = alfsmL.fleet_size_name
							and alfsmL.tail_no        = aneL.tail_no
			            and arnp.interchange_type = 'limited'
			            and aneL.effect_type      = 'C'
			            and aneL.user_defined     = 'Y'
							and arnp.replaced_nsi_sid = aneR.nsi_sid
							and arnp.replaced_nsi_sid = ansiR.nsi_sid
							and ansiR.nsi_group_sid   = angR.nsi_group_sid
							and angR.fleet_size_name  = alfsmR.fleet_size_name
							and alfsmR.tail_no        = aneR.tail_no
							and aneR.effect_type      = 'B'
							and aneR.user_defined     = 'Y'
							and aneR.tail_no          = aneL.tail_no)
					and rec.time_period_start
						between trunc(assignment_start,'mm') and nvl(assignment_end,FOREVER)
					and loc_sid = rec.loc_sid;
			end if;

			-- This is a boundary check only.
			--
			select count(*)
			into fleetSize
			from
				amd_national_stock_items ansi,
				amd_nsi_groups ang,
				amd_ltd_fleet_size_member alfsm
			where
				ansi.nsi_sid = pNsiSid
				and ansi.nsi_group_sid = ang.nsi_group_sid
				and ang.fleet_size_name = alfsm.fleet_size_name;

			-- Add the related asFlying and limited asCapable counts
			-- to its own asFlying count obtained in the loop cursor.
			--
			adjCapableCnt := rec.as_flying_count + relatedCnt + relatedLimitedCnt;

			if (adjCapableCnt > fleetSize) then
				adjCapableCnt := adjCapableCnt - relatedLimitedCnt;
			end if;

			update amd_nsi_loc_distribs set
				as_capable_count = adjCapableCnt
			where
				nsi_sid               = pNsiSid
				and loc_sid           = rec.loc_sid
				and time_period_start = rec.time_period_start;

			if (rec.location_name = 'ALTUS') then
				-- update fsls
				locRec.nsi_sid           := pNsiSid;
				locRec.time_period_start := rec.time_period_start;
				locRec.time_period_end   := rec.time_period_end;
				locRec.as_capable_count  := adjCapableCnt;

				updateFsls(locRec);
			end if;
		end loop;

	end genCapable;


	procedure genFlyingAltus(pNsiSid number) is
		cursor timeCur(pSid number) is
			select distinct
				time_period_start,
				time_period_end
			from amd_nsi_loc_distribs
			where nsi_sid = pSid
				and time_period_start >= trunc(sysdate,'mm');

		adjFlyingCnt    number;
		locRec          amd_nsi_loc_distribs%rowtype;
	begin
		displayMsg('genFlyingAltus('||pNsiSid||')');

		for rec in timeCur(pNsiSid) loop
			select
				sum(as_flying_count)
			into adjFlyingCnt
			from amd_nsi_loc_distribs
			where nsi_sid = pNsiSid
				and time_period_start = rec.time_period_start;

			update amd_nsi_loc_distribs set
				as_flying_count  = adjFlyingCnt
			where nsi_sid = pNsiSid
				and time_period_start = rec.time_period_start
				and loc_sid =
					(select loc_sid
					from amd_spare_networks
					where location_name = 'ALTUS');

			locRec.nsi_sid           := pNsiSid;
			locRec.time_period_start := rec.time_period_start;
			locRec.time_period_end   := rec.time_period_end;
			locRec.as_flying_count   := adjFlyingCnt;

			updateFsls(locRec);
		end loop;

	end genFlyingAltus;


	procedure updateFsls(
							pRec amd_nsi_loc_distribs%rowtype) is
		cursor locCur is
			select distinct
				loc_sid
			from amd_spare_networks asn
			where loc_type = 'FSL'
			order by loc_sid;

	begin
		displayMsg('updateFsls()');

		for locRec in locCur loop
			begin
				insert into amd_nsi_loc_distribs
				(
					nsi_sid,
					loc_sid,
					time_period_start,
					time_period_end,
					as_flying_count,
					as_flying_percent,
					as_capable_count,
					as_capable_percent
				)
				values
				(
					pRec.nsi_sid,
					locRec.loc_sid,
					pRec.time_period_start,
					pRec.time_period_end,
					pRec.as_flying_count,
					pRec.as_flying_percent,
					pRec.as_capable_count,
					pRec.as_capable_percent
				);
			exception
				when dup_val_on_index then
					update amd_nsi_loc_distribs set
						as_capable_count = pRec.as_capable_count
					where
						nsi_sid               = pRec.nsi_sid
						and loc_sid           = locRec.loc_sid
						and time_period_start = pRec.time_period_start
						and time_period_end   = pRec.time_period_end;
			end;
		end loop;

	end updateFsls;


	procedure genFlyingByFleet(
							pNsiSid number) is
		latestConfig   varchar2(1);
	begin
		displayMsg('genFlyingByFleet('||pNsiSid||')');

		select latest_config
		into latestConfig
		from amd_national_stock_items
		where nsi_sid = pNsiSid;

		if (latestConfig = 'Y') then
			processLatestConfig(pNsiSid);
		else
			processNonLatestConfig(pNsiSid);
			null;
		end if;
	end;


	procedure processLatestConfig(
							pNsiSid number) is
		cursor timeLocCur(pSid number) is
			select
				atp.time_period_start,
				atp.time_period_end,
				acnld.loc_sid,
				acnld.quantity
			from
				amd_cur_nsi_loc_distribs acnld,
				amd_time_periods atp
			where
				acnld.nsi_sid = pSid
				and atp.time_period_start >= trunc(sysdate,'mm')
			order by
				atp.time_period_start,
				acnld.loc_sid;

		locRec     amd_nsi_loc_distribs%rowtype;
		flyingCnt  number;
		newDels    number:=0;
	begin
		displayMsg('processLatestConfig('||pNsiSid||')');
		for rec in timeLocCur(pNsiSid) loop
			newDels := getAssignedQuantity(
						rec.time_period_start,
						rec.loc_sid);
			locRec.nsi_sid            := pNsiSid;
			locRec.loc_sid            := rec.loc_sid;
			locRec.time_period_start  := rec.time_period_start;
			locRec.time_period_end    := rec.time_period_end;
			locRec.as_flying_count    := rec.quantity + newDels;

			insertNsiLocDistribs(locRec);
		end loop;
	end;

	procedure processNonLatestConfig(
							pNsiSid number) is
		cursor locCur(pSid number) is
			select
				acnld.loc_sid,
				atp.time_period_start,
				atp.time_period_end,
				acnld.quantity
			from
				amd_cur_nsi_loc_distribs acnld,
				amd_time_periods atp
			where
				nsi_sid = pSid
				and atp.time_period_start >= trunc(sysdate,'mm');

		locRec     amd_nsi_loc_distribs%rowtype;
		flyingCnt  number;
	begin
		displayMsg('processNonLatestConfig('||pNsiSid||')');

		for rec in locCur(pNsiSid) loop
			locRec.nsi_sid           := pNsiSid;
			locRec.loc_sid           := rec.loc_sid;
			locRec.time_period_start := rec.time_period_start;
			locRec.time_period_end   := rec.time_period_end;
			locRec.as_flying_count   := rec.quantity;
			insertNsiLocDistribs(locRec);
		end loop;

	end processNonLatestConfig;


	procedure insertNsiLocDistribs(
							pRec amd_nsi_loc_distribs%rowtype) is
	begin
			insert into amd_nsi_loc_distribs
			(
				nsi_sid,
				loc_sid,
				time_period_start,
				time_period_end,
				as_flying_count,
				as_flying_percent,
				as_capable_count,
				as_capable_percent
			)
			values
			(
				pRec.nsi_sid,
				pRec.loc_sid,
				pRec.time_period_start,
				pRec.time_period_end,
				pRec.as_flying_count,
				pRec.as_flying_percent,
				pRec.as_capable_count,
				pRec.as_capable_percent
			);
	end;


	function getAssignedQuantity(
							pTimePeriod date,
							pLocSid number) return number is
		newDels    number;
	begin
		select count(*)
		into newDels
		from amd_ac_assigns aaa1
		where
			loc_sid = pLocSid
			and assignment_start >= SYSDATE
			and trunc(pTimePeriod,'mm') between trunc(assignment_start,'mm')
				and nvl(assignment_end,FOREVER)
			and not exists
				(select 'x'
				from amd_ac_assigns aaa2
				where aaa2.tail_no = aaa1.tail_no
					and aaa2.assignment_start < aaa1.assignment_start);

		return newDels;
	end;


	procedure genDistribution(
							pType varchar2) is
		cursor nsnCur is
			(select
				nsi_sid
			from
				amd_national_stock_items
			where nsi_group_sid in
				(select nsi_group_sid
				from amd_nsi_groups
				where split_effect = 'Y'))
			union
			(select
				nsi_sid
			from amd_national_stock_items
			where nsi_group_sid in
				(select nsi_group_sid
				from amd_national_stock_items
				group by nsi_group_sid
				having count(*) >1))
			union
			(select
				nsi_sid
			from amd_national_stock_items
			where nsi_group_sid in
				(select nsi_group_sid
				from amd_nsi_groups
				where fleet_size_name != 'All Aircraft'))
			minus
			(select
				nsi_sid
			from amd_national_stock_items
			where asset_mgmt_status is null);

	begin
		displayMsg('genDistribution('||pType||')');

		buildTimePeriods(NUM_TIME_PERIODS);

		for rec in nsnCur loop
			genDistribution(rec.nsi_sid,pType);
		end loop;

	end;

	procedure buildTimePeriods(
							pCount number) is
		cntr    number;
	begin
		select max(tactical_bucket_id)+1
		into cntr
		from amd_time_periods;

		for i in 0..pCount loop
			begin
				cntr := cntr + 1;
				insert into amd_time_periods
				(
					time_period_start,
					time_period_end,
					tactical_bucket_name,
					tactical_bucket_id,
					action_code,
					last_update_dt
				)
				values
				(
					add_months(trunc(sysdate,'mm'),i),
					last_day(add_months(trunc(sysdate,'mm'),i))+.99999,
					'FORECAST_BUCKET',
					cntr,
					'A',
					sysdate
				);
			exception
				when dup_val_on_index then NULL;
			end;
		end loop;
	end;


	procedure updateAssetMgmtStatus(
							pGroupSid number) is
		cursor nsiSidCur(pSid number) is
			select
				nsi_sid,
				effect_by
			from amd_national_stock_items
			where nsi_group_sid = pSid;

		fleetSize  number;
		acCnt      number:=0;
	begin

		select count(*)
		into fleetSize
		from amd_ltd_fleet_size_member
		where
			fleet_size_name =
				(select fleet_size_name
				from amd_nsi_groups
				where nsi_group_sid = pGroupSid);

		for rec in nsiSidCur(pGroupSid) loop
			if (rec.effect_by = 'S') then
				acCnt := acCnt + getCountByShip(rec.nsi_sid);
			elsif (rec.effect_by = 'F') then
				acCnt := acCnt + getCountByFleet(rec.nsi_sid);
			end if;
		end loop;

		if (acCnt = fleetSize) then
			update amd_national_stock_items set
				asset_mgmt_status = 'COMPLETE'
			where nsi_group_sid = pGroupSid;
		else
			update amd_national_stock_items set
				asset_mgmt_status = NULL
			where nsi_group_sid = pGroupSid;
		end if;
	end;


	function getCountByShip(
							pNsiSid number) return number is
		acCnt     number;
	begin
		displayMsg('getCountByShip('||pNsiSid||')');

		select nvl(count(*),0)
		into acCnt
		from
			amd_nsi_effects ane,
			amd_national_stock_items ansi,
			amd_nsi_groups ang,
			amd_ltd_fleet_size_member alfsm
		where
			ane.nsi_sid = pNsiSid
			and ane.effect_type = 'B'
			and ane.user_defined in ('Y','S')
			and ansi.nsi_sid = ane.nsi_sid
			and ang.nsi_group_sid = ansi.nsi_group_sid
			and alfsm.fleet_size_name = ang.fleet_size_name
			and ane.tail_no = alfsm.tail_no;

		return acCnt;
	end;


	function getCountByFleet(
							pNsiSid number) return number is
		acCnt     number;
	begin
		displayMsg('getCountByFleet('||pNsiSid||')');

		select nvl(sum(quantity),0)
		into acCnt
		from amd_cur_nsi_loc_distribs
		where nsi_sid = pNsiSid
			and user_defined in ('Y','S');

		return acCnt;
	end;


	procedure genFlyingDerived(
							pNsiSid number) is
		cursor timeCur is
			select
				acnld.loc_sid,
				acnld.time_period_start,
				sum(acnld.as_flying_count) derivedQty
			from
				amd_product_structure aps,
				amd_nsi_loc_distribs acnld
			where
				aps.comp_nsi_sid     = pNsiSid
				and aps.assy_nsi_sid = acnld.nsi_sid
				and acnld.time_period_start >= trunc(sysdate,'mm')
			group by
				acnld.loc_sid,
				acnld.time_period_start;

	begin
		displayMsg('getFlyingDerived('||pNsiSid||')');

		for rec in timeCur loop
			update amd_nsi_loc_distribs set
				as_flying_count = as_flying_count + rec.derivedQty
			where
				nsi_sid = pNsiSid
				and loc_sid = rec.loc_sid
				and time_period_start = rec.time_period_start;
		end loop;

	end;


	function isOrphan(
							pNsiSid number) return boolean is
		parentCnt  number;
	begin
		select count(*)
		into parentCnt
		from amd_product_structure
		where comp_nsi_sid = pNsiSid;

		return (parentCnt = 0);
	end;


	procedure updateOrphanStatus(
							pNsiSid number) is
	begin

		update amd_national_stock_items set
			effect_by = 'S',
			asset_mgmt_status = NULL
		where nsi_sid = pNsiSid;

		update amd_nsi_effects set
			user_defined = 'S',
			derived      = 'N'
		where nsi_sid = pNsiSid;
	end;


	procedure batchProcess is
	begin
		amd_ascapableflying_pkg.updateDistribForNewAc;
		amd_effectivity_pkg.genDistribution('F');
		amd_ascapableflying_pkg.adjustForRetrofit;
		amd_effectivity_pkg.genDistribution('A');
		amd_effectivity_pkg.genDistribution('C');
		amd_ascapableflying_pkg.updatePercentages;
		amd_effectivity_pkg.genDistribution('DERIVED');
	end;

end;
/


DROP PACKAGE BODY AMD_OWNER.AMD_EFFECTIVITY_TCTO_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_effectivity_tcto_pkg
is
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
	    $Date:   Nov 30 2005 12:24:06  $
    $Workfile:   amd_effectivity_tcto_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_effectivity_tcto_pkg.pkb-arc  $
/*
/*      Rev 1.1   Nov 30 2005 12:24:06   zf297a
/*   added PVCS keywords
*/
  DECREMENT_BY_1 CONSTANT integer := -1;
  INCREMENT_BY_1 CONSTANT integer := 1;
  e_updateAsFlyAsCapable EXCEPTION;

  function getAcAssignLocSid(pTailNo amd_ac_assigns.tail_no%type, pDate date) return amd_spare_networks.loc_sid%type
  is
  	   locSid amd_spare_networks.loc_sid%type;
       -- sample data had tail with 2 assignment_end dates of null, get latest one
       cursor ac_cur is
            select loc_sid
     	    from amd_ac_assigns
	        where tail_no = pTailNo and
	   		    assignment_start <= pDate and (assignment_end is null or assignment_end >= pDate)
            order by assignment_start desc;
       acRec ac_cur%rowtype;
  begin
       open ac_cur;
       fetch ac_cur into acRec;
       close ac_cur;
       if (acRec.loc_sid is null) then
            raise no_data_found;
       else
            return acRec.loc_sid;
       end if;
  end getAcAssignLocSid;

  procedure updateWhenEffectByS(rec amd_nsi_effects%rowtype)
  is
  begin
  	   update amd_nsi_effects set
	   		  user_defined = decode(rec.user_defined, null, user_defined, rec.user_defined),
			  effect_type  = decode(rec.effect_type, null, effect_type, rec.effect_type),
			  derived  = decode(rec.derived, null, derived, rec.derived)
	   where
	   		  nsi_sid = rec.nsi_sid and
			  tail_no = rec.tail_no;
  end updateWhenEffectByS;

  procedure updateWhenEffectByF(rec amd_cur_nsi_loc_distribs%rowtype)
  is
  begin
  	   update amd_cur_nsi_loc_distribs set
	   		  quantity = nvl(quantity,0) + rec.quantity
	   where
	   		  nsi_sid = rec.nsi_sid and
			  loc_sid = rec.loc_sid;
  end updateWhenEffectByF;

  procedure updateAsFlyAsCapable(pFieldName varchar2, pFieldValue varchar2, pTailNo amd_aircrafts.tail_no%type, pDate date)
  is
  	   cursor curBlkToTcto(pFieldValue varchar2) is
	   		  select
			  		 tcto_number
			  from
			  		 amd_retrofit_schedules
			  where
			  		 block_name = pFieldValue and
					 tail_no = pTailNo;
  begin
  	   if (lower(pFieldName) = 'block_name') then
	   	  	 for rec in curBlkToTcto(pFieldValue) loop
			 	 updateAsFlyAsCapable(rec.tcto_number, pTailNo, pDate);
			 end loop;
	   elsif (lower(pFieldName) = 'tcto_number') then
	   		 updateAsFlyAsCapable(pFieldValue, pTailNo, pDate);
	   end if;
	   commit;
  exception
  	   when others then
	   		rollback;
			raise;
  end updateAsFlyAsCapable;

  procedure updateAnsiAudit(pNsiSid amd_national_stock_items.nsi_sid%type)
  is
  begin
  	   update
	   		  amd_national_stock_items
	   set
	   	  	  effect_last_update_id = substr(user, 1, 8),
			  effect_last_update_dt = sysdate
	   where
	   	   	  nsi_sid = pNsiSid;

  end;

  procedure updateAsFlyAsCapable(pTcto amd_retrofit_schedules.tcto_number%type, pTailNo amd_retrofit_schedules.tail_no%type, pDate date)
  is
  		cursor effCur (pTcto amd_retrofit_schedules.tcto_number%type) is
			   select
			   	   arnp.replaced_nsi_sid as fromSid,
				   arnp.replaced_by_nsi_sid as toSid,
				   ansi.effect_by as fromEffectBy,
				   ansiTo.effect_by as toEffectBy
			   from

			   	   amd_related_nsi_pairs arnp,
	   			   amd_national_stock_items ansi,
				   amd_national_stock_items ansiTo
	   		   where
			   	   arnp.tcto_number = pTcto and
				   arnp.replaced_nsi_sid = ansi.nsi_sid and
				   arnp.replaced_by_nsi_sid = ansiTo.nsi_sid;
		effInfo effCur%rowtype;
		aneRec amd_nsi_effects%rowtype;
		acnldRec amd_cur_nsi_loc_distribs%rowtype;
		locSid amd_spare_networks.loc_sid%type;
		foundRec boolean := false;
  begin
   			-- will throw error if no location found

  	   	for rec in effCur(pTcto) loop
   			foundRec := true;
            begin
           	    locSid := getAcAssignLocSid(pTailNo, pDate);
            exception
                when no_data_found then
                   locSid := null;
            end;
          			-- to Sid --
  	    	aneRec := null;
    	   	acnldRec := null;
   		   	if (rec.toEffectBy = 'F') then
                if (locSid is not null) then
  	    	       acnldRec.nsi_sid := rec.toSid;
       	    	   acnldRec.loc_sid := locSid;
       		   	   acnldRec.quantity := INCREMENT_BY_1;
        	       updateWhenEffectByF(acnldRec);
                end if;
       		else -- effect by 'S'
                if (amd_ascapableflying_pkg.isPartOnTail(rec.toSid, pTailNo)) then
        	       aneRec.nsi_sid := rec.toSid;
    		       aneRec.tail_no := pTailNo;
        		   aneRec.effect_type := 'B';
            	   aneRec.user_defined := 'Y';
	               updateWhenEffectByS(aneRec);
                end if;
   		   	end if;
            if (aneRec.nsi_sid is not null or acnldRec.nsi_sid is not null) then
              	amd_effectivity_pkg.rebuildChildren(rec.toSid);                                            updateAnsiAudit(rec.toSid);
            end if;
			   	-- from sid --
            if (amd_ascapableflying_pkg.isPartOnTail(rec.fromSid, pTailNo)) then
    			aneRec := null;
    			acnldRec := null;
	    		if (rec.fromEffectBy = 'F') then
		    	   acnldRec.nsi_sid := rec.fromSid;
    			   acnldRec.loc_sid := locSid;
	    		   acnldRec.quantity := DECREMENT_BY_1;
		    	   updateWhenEffectByF(acnldRec);
    			else
	    			aneRec.nsi_sid := rec.fromSid;
		    	    aneRec.tail_no := pTailNo;
			    	aneRec.user_defined := 'N';
		    		updateWhenEffectByS(aneRec);
                /* procedure to update as capable will be run subsequent to this procedure */
		    	end if;
		        updateAnsiAudit(rec.fromSid);
		    	amd_effectivity_pkg.rebuildChildren(rec.fromSid);
             end if;
		end loop;
		if (not foundRec) then
		   raise no_data_found;
		end if;
  end updateAsFlyAsCapable;
  function getNsiLocDistribs(pNsiSid integer) return ref_cursor
  is
	refCursor ref_cursor;
  begin
	open refCursor for
		select
			nsn,
			prime_part_no,
			location_name,
			loc_id,
			to_char(time_period_start, 'MM/DD/YY') as time_period_start,
			to_char(time_period_end, 'MM/DD/YY') as time_period_end,
			as_flying_count,
			as_flying_percent,
			as_capable_count,
			as_capable_percent
		from
			amd_nsi_loc_distribs anld,
			amd_national_stock_items ansi,
			amd_spare_networks asn
		where
			anld.nsi_sid=ansi.nsi_sid and
			anld.loc_sid=asn.loc_sid and anld.nsi_sid = pNsiSid
		order by loc_id, anld.time_period_start;
	return refCursor;
  end;
end amd_effectivity_tcto_pkg;
/


DROP PACKAGE BODY AMD_OWNER.AMD_FROM_BSSM_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_FROM_BSSM_PKG AS
    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.12  $
         $Date:   Jun 09 2006 11:20:30  $
     $Workfile:   amd_from_bssm_pkg.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_from_bssm_pkg.pkb-arc  $	  *

      Rev 1.12   Jun 09 2006 11:20:30   zf297a
   Implemented version + used writeMsg for all loadAmd... public procedures

      Rev 1.11   Jun 09 2006 10:29:00   zf297a
   got rid of cannot convert message going to amd_load_details

      Rev 1.10   Dec 06 2005 09:42:40   zf297a
   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS

      Rev 1.9   Aug 04 2005 14:35:44   zf297a
   Changed all queries using lock_sid to use a character string so it will search via the index.

      Rev 1.8   Jun 20 2005 15:11:50   c970183
   fixed update of criticality (it is a number in amd_national_stock_items)

      Rev 1.7   May 17 2005 10:08:20   c970183
   Updated InsertErrorMessage to new interface

      Rev 1.6   May 06 2005 07:31:18   c970183
   changed dla_warehouse_stcok to current_backorder fro amd_national_stock_items.  added PVCS keywords
		  */
	   ERRSOURCE constant varchar2(20) := 'AmdFromBssmPkg';
	   NOT_ACCEPTABLE_BSSM_PLTP_REC exception;


	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_from_bssm_pkg',
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;

		procedure errorMsg(
						sqlFunction in varchar2,
						tableName in varchar2,
						errorLocation in number,
						key1 in varchar2 := '',
				 		key2 in varchar2 := '',
						key3 in varchar2 := '',
						key4 in varchar2 := '',
						key5 in varchar2 := '',
						keywordvaluepairs in varchar2 := '') is
		begin
			rollback;
			amd_utils.inserterrormsg (
					pload_no => amd_utils.getloadno(
							psourcename => sqlfunction,
							ptablename  => tablename),
					pdata_line_no => errorlocation,
					pdata_line    => 'amd_from_bssm_pkg',
					pkey_1 => key1,
					pkey_2 => key2,
					pkey_3 => key3,
					pkey_4 => key4,
					pkey_5 => key5 || ' ' || to_char(sysdate,'MM/DD/YYYY HH:MM:SS') ||
							   ' ' || keywordvaluepairs,
					pcomments => sqlfunction || '/' || tablename || ' sqlcode('||sqlcode||') sqlerrm('||sqlerrm||')');
			commit;
			return ;
		end errorMsg;

	   function ConvertCriticality(pCriticality bssm_parts.criticality%type) return varchar2 is
	   		-- criticality is bssm is a number, criticality in amd is 1 char
			criticality varchar2(1) := null;
	   begin
	   		-- from Tony Maingot of i2 - if criticality null, then consider as 'M'.
			-- however, will do this on outbound thru tmapi and leave as null in db.
			if (pCriticality is null) then
			    criticality	:= null;
	   		elsif (pCriticality <= .33 and pCriticality >= 0) then
			   	criticality := 'M';
			elsif (pCriticality <= .67) then
				criticality := 'D';
			elsif (pCriticality <= 1.0) then
				criticality := 'C';
			else
				null ; -- if out of range return null
			end if;
			return criticality;
	   end ConvertCriticality;

	   function ConvertItemType(pItemType bssm_parts.item_type%type) return amd_national_stock_items.item_type%type is
	   		itemType varchar2(1) := null;
	   /* -- email from laurie when asked for mapping of bssm to amd
	   	 Sent:	Thursday, October 25, 2001 2:38 PM
	   	 In AMD today, T and P are Repairable, N is Consumable.  */

	   begin
	   				-- if not listed below, return as is
			if (pItemType is null) then
			   itemType := null;
	   		elsif ( pItemType in ('P', 'T') ) then
			   itemType := 'R';
			elsif (pItemType = 'N') then
			   itemType := 'C';
			else
			   itemType := pItemType; -- cannot convert return what was passed
			end if;
			return itemType;
	   end ConvertItemType;

       function GetCurrentBssmNsn(pNsn bssm_parts.nsn%type) return bssm_parts.nsn%type is
	   		cursor bssmNsn_cur(pNsiSid amd_nsns.nsi_sid%type) is
				   select bp.nsn
				   	   from bssm_parts bp, amd_nsns an
				   	   where bp.nsn = an.nsn and
					   		 bp.lock_sid = '0' and
					   		 an.nsi_sid = pNsiSid
					   order by bp.nsn;
			rNsn_rec bssmNsn_cur%rowtype;
			nsiSid amd_nsns.nsi_sid%type;
	   begin
		   		-- nsn is likely to come from amd, this function will be updated when amd_nsns.creation_date
				-- usable, bssm_nsn_revisions data available, or not important as bob eberlein noted
				-- bssm_parts will contain current only.
				-- below just in case and to handle current data situation which has all versions
				-- of the "nsn", i.e. multiple bssm_parts lock_sid 0 records relate to one nsi_sid in amd.
			nsiSid := amd_utils.GetNsiSid(pNsn => pNsn);
			if (not bssmNsn_cur%ISOPEN) then
			   open bssmNsn_cur(nsiSid);
			end if;
			fetch bssmNsn_cur into rNsn_rec;
			if (bssmNsn_cur%NOTFOUND) then
			   close bssmNsn_cur;
			   raise no_data_found;
			end if;
			close bssmNsn_cur;
			return rNsn_rec.nsn;
	   end GetCurrentBssmNsn;

	   function GetLocSid(pLocId amd_spare_networks.loc_id%type) return amd_spare_networks.loc_sid%type is
	   	    locId amd_spare_networks.loc_id%type := null;
	   begin
			if (pLocId = BSSM_WAREHOUSE_SRAN) then
		       locId := AMD_WAREHOUSE_LOCID;
			else
			   locId := pLocId;
			end if;
			return amd_utils.GetLocSid(locId);
	   end GetLocSid;

	   procedure LoadAmdBaseFromBssmRaw is
	   			 -- to get all of them
	   		cursor bssmBase_cur is
				   select
				   		bp.*
				   from
				   		bssm_base_parts bp,
						amd_nsns an
				   where
				   		 bp.nsn = an.nsn   and
						 bp.lock_sid = '0';
						 /*
						 (bp.repair_indicator is not null or
						  bp.replacement_indicator is not null or
						  );*/
				cnt number := 0 ;
	   begin
			writeMsg(pTableName => 'amd_part_locs', pError_location => 10,
					pKey1 => 'LoadAmdBaseFromBssmRaw',
					pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	   		for bssmBaseRec in bssmBase_cur
			loop
				begin
					 UpdateAmdPartLocs(bssmBaseRec);
					 cnt := cnt + 1 ;
				exception
				 	 when others then
					 	  errorMsg(sqlFunction => 'update', tablename => 'amd_part_locs',
						  	errorLocation => 10,
						  	key1 => bssmBaseRec.nsn, key2 => bssmBaseRec.sran) ;
						  raise ;
				end;
			end loop;
			writeMsg(pTableName => 'amd_part_locs', pError_location => 20,
					pKey1 => 'LoadAmdBaseFromBssmRaw',
					pKey2 => 'cnt=' || to_char(cnt),
					pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
			commit ;
	   end LoadAmdBaseFromBssmRaw;

	   procedure LoadAmdBaseFromBssmRaw(pNsn bssm_base_parts.nsn%type, pSran bssm_base_parts.sran%type) is
	   			 bssmBaseRec bssm_base_parts%rowtype;

				 -- current bssm can have not current parts in bssm_parts,
				 vNsn bssm_base_parts.nsn%type;
	   begin
					 -- nsn can come from any direction, from bssm or from amd
					 -- still assuming bob eberlein in that his is only holding latest.
				 vNsn := GetCurrentBssmNsn(pNsn);
				 select *
				 	into bssmBaseRec
				 	from bssm_base_parts
					where nsn = vNsn and
						  sran = pSran and
						  lock_sid = '0';
				 UpdateAmdPartLocs(bssmBaseRec);
	   exception
	   			when no_data_found then
					 null;
				when others then
					 errorMsg(sqlFunction => 'select', tablename => 'bssmBaseRec',
					 	ErrorLocation => 20,
					 	key1 => vNsn, key2 => pSran) ;
					 raise ;
       end LoadAmdBaseFromBssmRaw;

	   procedure LoadAmdPartFromBssmRaw is
 	   		-- bssm_parts will only have latest part, now can
			-- go thru amd_nsns table.
			-- bob eberlein said only current part will be in bssm_parts
			-- so should not be a problem.  for foolproof, would go to
			-- bssm_nsn_revisions, but currently there is no data.
			/*
	   		 cursor bssmParts_cur is
				   select
				   		  bp.*
 				   from
				   		 bssm_parts bp,
				   		 amd_national_stock_items ansi,
						 amd_nsns an
				   where
				   		 bp.lock_sid = 0 	 and
						 bp.nsn = an.nsn	 and
						 bp.nsn = GetCurrentBssmNsn(an.nsn) and
						 an.nsi_sid = ansi.nsi_sid; */
			cursor bssmParts_cur is
				   select
				   		  bp.*
 				   from
				   		 bssm_parts bp,
				   		 amd_national_stock_items ansi,
						 amd_nsns an
				   where
				   		 bp.lock_sid = '0' 	 and
						 bp.nsn = an.nsn	 and
						 an.nsi_sid = ansi.nsi_sid;
			cnt number := 0 ;
	   begin
			writeMsg(pTableName => 'amd_national_stock_items', pError_location => 30,
					pKey1 => 'LoadAmdPartFromBssmRaw',
					pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	   		for bssmPartRec in bssmParts_cur
			loop
				begin
					 UpdateAmdNsi(bssmPartRec);
					 cnt := cnt + 1 ;
				exception
					 when others then
					 	  errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items',
						    errorLocation => 30,
						  	key1 => bssmPartRec.nsn) ;
						  raise ;
				end;
			end loop;
			writeMsg(pTableName => 'amd_national_stock_items', pError_location => 40,
					pKey1 => 'LoadAmdPartFromBssmRaw',
					pKey2 => 'cnt=' || to_char(cnt),
					pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
			commit;
	   end LoadAmdPartFromBssmRaw;


   	   procedure LoadAmdPartFromBssmRaw(pNsn bssm_parts.nsn%type) is
	   			 bssmPartRec bssm_parts%rowtype;

				 -- current bssm can have not current parts in bssm_parts,
				 vNsn bssm_parts.nsn%type;
	   begin
					 -- nsn can come from any direction, from bssm or from amd
					 -- still assuming bob eberlein in that his is only holding latest.
				 vNsn := GetCurrentBssmNsn(pNsn);
				 select *
				 	into bssmPartRec
				 	from bssm_parts
					where nsn = vNsn
					and lock_sid = '0';
				 UpdateAmdNsi(bssmPartRec);
	   exception
	   			when no_data_found then
					 null;
       end LoadAmdPartFromBssmRaw;


	   procedure LoadAmdPartLocTimePeriods is
	   		cursor partLoc_cur is
				   select apl.nsi_sid, apl.loc_sid, bpltp.*
				   from
				   		bssm_part_loc_time_periods bpltp,
						amd_nsns an,
						amd_part_locs apl,
						amd_spare_networks asn
				   where
				   		 bpltp.nsn = an.nsn 	   and
						 an.nsi_sid = apl.nsi_sid  and
						 apl.loc_sid = asn.loc_sid and
						 asn.loc_id = decode(bpltp.sran, BSSM_WAREHOUSE_SRAN, AMD_WAREHOUSE_LOCID, bpltp.sran);
			cnt number := 0 ;
	   begin
			writeMsg(pTableName => 'amd_part_loc_time_periods', pError_location => 50,
					pKey1 => 'LoadAmdPartLocTimePeriods',
					pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	   		for partLocRec in partLoc_cur
			loop
				begin
					 -- bssm_part_loc_time_periods allows nullable fields
					 -- amd_part_loc_time_periods has no fields nullable

					 if (partLocRec.time_period_end   is null or
					 	 partLocRec.reorder_point 	  is null or
						 partLocRec.reorder_quantity  is null) then
					 	 	raise NOT_ACCEPTABLE_BSSM_PLTP_REC;
					 end if;
					 if (partLocRec.last_update_date is null) then
					 	 partLocRec.last_update_date := SYSDATE;
					 end if;
					 insert into amd_part_loc_time_periods
						 		(nsi_sid,
								 loc_sid,
								 time_period_start,
								 time_period_end,
								 reorder_point,
								 reorder_quantity,
								 se_target,
								 action_code,
								 last_update_dt)
							 values(
							 	 partLocRec.nsi_sid,
								 partLocRec.loc_sid,
						 		 partLocRec.time_period_start,
								 partLocRec.time_period_end,
								 partLocRec.reorder_point,
						 		 partLocRec.reorder_quantity,
								 partLocRec.se_target,
						 		 amd_defaults.INSERT_ACTION,
						 		 partLocRec.last_update_date);
					cnt := cnt + 1 ;
				exception
					when NOT_ACCEPTABLE_BSSM_PLTP_REC then
						 -- missing info which is not nullable for amd counterpart
						 null;
					when others then
					 	  errorMsg(sqlFunction => 'insert', tablename => 'amd_part_loc_time_periods',
						    errorLocation => 40,
						    key1 => partLocRec.nsn, key2 => partLocRec.nsi_sid, key3 => partLocRec.loc_sid) ;
						  raise ;
				end;
			end loop;
			writeMsg(pTableName => 'amd_part_loc_time_periods', pError_location => 60,
					pKey1 => 'LoadAmdPartLocTimePeriods',
					pKey2 => 'cnt=' || to_char(cnt),
					pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
			commit;
	   end LoadAmdPartLocTimePeriods;


	   procedure UpdateAmdNsi (pBssmPartsRec bssm_parts%rowtype) is
	   		nsiSid amd_national_stock_items.nsi_sid%type;
			procedure validateData is
					  item amd_national_stock_items%rowtype ;
					  line_no number := 0 ;
			begin
				 line_no := line_no + 1; item.add_increment       := pBssmPartsRec.add_increment ;
				 line_no := line_no + 1; item.amc_base_stock      := pBssmPartsRec.amc_base_stock ;
				 line_no := line_no + 1; item.amc_days_experience := pBssmPartsRec.amc_days_experience ;
				 line_no := line_no + 1; item.amc_demand		  := pBssmPartsRec.amc_demand ;
				 line_no := line_no + 1; item.capability_requirement := pBssmPartsRec.capability_requirement ;
				 line_no := line_no + 1; item.condemn_avg 	  		 := pBssmPartsRec.condemn ;
				 line_no := line_no + 1; item.criticality 	  		 := pBssmPartsRec.criticality  ;
				 line_no := line_no + 1; item.demand_variance 	  	 := pBssmPartsRec.demand_variance ;
				 line_no := line_no + 1; item.dla_demand 	  		 := pBssmPartsRec.dla_demand ;
				 line_no := line_no + 1; item.current_backorder 	 := pBssmPartsRec.current_backorder ;
				 line_no := line_no + 1; item.min_purchase_quantity  := pBssmPartsRec.min_purchase_quantity ;
				 line_no := line_no + 1; item.nrts_avg 	 			 := pBssmPartsRec.nrts ;
				 line_no := line_no + 1; item.rts_avg 	  			 := pBssmPartsRec.rts ;
				 line_no := line_no + 1; item.ru_ind 	  			 := pBssmPartsRec.ru_ind ;
				 line_no := line_no + 1; item.time_to_repair_on_base_avg := pBssmPartsRec.on_base_turnaround ;
				 line_no := line_no + 1; item.user_comment 	  		 := pBssmPartsRec.user_comment ;
			exception when others then
					  errorMsg(sqlFunction => 'validate', tablename => 'amd_national_stock_items',
					    errorLocation => 50,
					  	key1 => to_char(line_no) ) ;
					  raise ;
			end validateData ;

	   begin
	   			-- will throw exception if not found
		    validateData ;
	   		nsiSid := amd_utils.GetNsiSid(pNsn => pBssmPartsRec.nsn);
	   		update amd_national_stock_items
					 set
					 		add_increment  = pBssmPartsRec.add_increment,
					 		amc_base_stock = pBssmPartsRec.amc_base_stock,
							amc_days_experience = pBssmPartsRec.amc_days_experience,
							amc_demand = pBssmPartsRec.amc_demand,
							capability_requirement = pBssmPartsRec.capability_requirement,
							condemn_avg = pBssmPartsRec.condemn,
							criticality = pBssmPartsRec.criticality,
							demand_variance = pBssmPartsRec.demand_variance,
							dla_demand = pBssmPartsRec.dla_demand,
							current_backorder = pBssmPartsRec.current_backorder,
							-- fedc_cost = pBssmPartsRec.fedc_cost,
							-- 			 now mic pulled from amd_l67_tmp directly
					 		-- mic_code_lowest = pBssmPartsRec.mic_code,
							min_purchase_quantity = pBssmPartsRec.min_purchase_quantity,
							nrts_avg = pBssmPartsRec.nrts,
							rts_avg = pBssmPartsRec.rts,
							ru_ind = pBssmPartsRec.ru_ind,
							time_to_repair_on_base_avg = pBssmPartsRec.on_base_turnaround,
							user_comment = pBssmPartsRec.user_comment,
							last_update_dt = SYSDATE
			 where  nsi_sid = nsiSid;
	   exception
	   		 when no_data_found then
			 	  -- cannot find nsiSid
			 	  null;
			 when others then
				errorMsg(sqlFunction => 'update', tablename => 'amd_national_stock_items',
				    errorLocation => 60,
					key1 => nsiSid) ;
			    raise ;

	   end UpdateAmdNsi;


	   procedure UpdateAmdPartLocs(pBssmBaseRec bssm_base_parts%rowtype) is
	   	   		nsiSid amd_national_stock_items.nsi_sid%type;
				locSid amd_spare_networks.loc_sid%type;
	   begin
	   			-- nsi_sid will throw exception if not found
	   		nsiSid := amd_utils.GetNsiSid(pNsn => pBssmBaseRec.nsn);
			locSid := GetLocSid(pBssmBaseRec.sran);
			if (locSid is not null) then
			    update amd_part_locs
					   set repair_level_code = pBssmBaseRec.repair_indicator,
					   	   removal_ind 		 = pbssmbaserec.replacement_indicator,
						  -- 		 will come from ramp
						  -- rsp_on_hand  	 = pBssmBaseRec.rsp_on_hand,
  						  -- rsp_objective 	 = pBssmBaseRec.rsp_objective,
						   order_cost 		 = pBssmBaseRec.order_cost,
						   holding_cost 	 = pBssmBaseRec.holding_cost,
						   backorder_fixed_cost = pBssmBaseRec.backorder_fixed_cost,
						   backorder_variable_cost = pBssmBaseRec.backorder_variable_cost,
						   last_update_dt = SYSDATE
				where
					   nsi_sid = nsiSid		 and
				   	   loc_sid = locSid;
			end if;
	   exception
	   		when no_data_found then
 			 	  -- cannot find nsiSid
				 null;
			when others then
				errorMsg(sqlFunction => 'update', tablename => 'amd_part_locs',
					errorLocation => 70,
					key1 => nsiSid, key2 => locSid) ;
				raise ;

	   end UpdateAmdPartLocs;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_from_bssm_pkg',
		 		pError_location => 80, pKey1 => 'amd_from_bssm_pkg', pKey2 => '$Revision:   1.12  $') ;
	end version ;

END AMD_FROM_BSSM_PKG;
/


DROP PACKAGE BODY AMD_OWNER.AMD_INVENTORY;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Inventory
AS
   /* ------------------------------------------------------------------- */
   /*  this program extracts data from gold and generate records for the  */
   /*  amd_spare_invs table for the boeing icp parts which have been      */
   /*  loaded in the amd_spare_parts.                                     */
   /*                                                                     */
   /*  this program also generates data for amd_repair_levels and         */
   /*  amd_main_task_distribs table.                                      */
   /* ------------------------------------------------------------------- */
   /*
       PVCS Keywords

      $Author:   Douglas S Elder
    $Revision:   1.121
        $Date:   21 Nov 2017
    $Workfile:   amd_inventory.pkb  $

         Rev 1.121 21 Nov 2017 added dbms_output for all raise commands

         Rev 1.120 24 Aug 2017 per Laurie Compton's email for 8/23/2017 regarding
                              TFS 38300 removed rsp_level > 0 for loadRsp's cursor
                              rspInv

         Rev 1.119 24 Jan 2017 added dbms_output for inserts

         Rev 1.118 17 Jun 2016 reformatted code

         Rev 1.117 Per CQ LBPSS00003520 removed amd_order_prefixes

         Rev 1.116.1  29 Sep 2015 DSE removed redundant check for tmp1.from_loc_id

         Rev 1.116  28 Sep 2015 DSE for loadInRepair, loadInTransits, and loadOnHand make
         aure loc_type is NOT KIT

         Rev 1.115.1  23 Sep 2015 DSE added START_LOC_ID

         Rev 1.115  21 Sep 2015 DSE added amd_defaults.getProgramId, PROGRAM_ID and PROGRAM_ID_LL

         Rev 1.114  03 Sep 2015 DSE for loadRsp - make sure the rspInv cursor only
         gets rows with rsp_level > 0 and rsp_inv > 0

         Rev 1.113.1 18 Jun 2015 DSE use from_loc_id

         Rev 1.113 10 Jun 2015 DSE use new ramp.sran and ord1.loc_id

         Rev 1.112 17 Feb 2015 DSE use new rsp_inv_v and eliminated erroneous update /
         exception hander.  NOTE: the NO_DATA_FOUND exception will not occur
         for the UPDATE when the where clause criteria is not met, instead
         it will just not do the update.

         Rev 1.111 DSE fixed rspCnt by using sql%rowcount immediately after
         the bulk insert

         Rev 1.110 DSE added amd_defaults.getIcpInd

         Rev 1.109 DSE added whse rsp_level's to the loading to tmp_amd_rsp

         Rev 1.108 removed C from segmentt code queries used to load tmp_amd_on_hand_invs and tmp_amd_in_repair per Laurie's IM instructions

         Rev 1.107 add segregation code SATCAA0001C17G  per ClearQuest request LBPSS00003377 and make it EY1746 when loading itemsa data

        Rev 1.106 fixed itemType3aCur for loadOnOrder to check for sc ending in G or the existance of sc = amd_sc_inclusions.include_sc
        and  existance of substtr sc = sbustr amd_sc_inclusions ... exists is used so that it may be entirely empty and moved to prod

       Rev 1.105 make sure records are distinct when loading tmp_amd_in_repair from cursor itemType5Cur
       and renumbered perror's.  Removed all the truncates of a2a tables.

       Rev 1.104   9 Aug 2010    12:00    c402417
   Implemented  per Change Request # LBPSS00002722  and LBPSS00002723  requested by Laurie Compton.

      Rev 1.103    Apr 2010    09:09    c402417
   Added  'UAB' for loc_type to on_hand_invs and in_repair per Laurie's request.

     Rev 1.101   13 Jul 2009 19:06:28   zf297a
  Removed invocations of a2a procedures

     Rev 1.100   05 Jun 2009 09:50:54   zf297a
  Added WF to list of values for substr(order_no,1,2) for table ord1

     Rev 1.99   16 Feb 2009 17:39:56   zf297a
  Implement function interface isInvalidDateYorN

     Rev 1.98   14 Feb 2009 16:13:42   zf297a
  Removed code invoking  A2A's routines for package amd_location_part_override_pkg since they have been removed.

     Rev 1.97   16 Jan 2009 23:17:50   zf297a
  Added warnings for when the repair_need_date is bad and set it to null.  Added warning for when the repair_date is bad and rejected the record.

     Rev 1.96   08 Feb 2008 09:39:10   zf297a
  Thuy Pham changed cursor itemType3bCur to retrieve Open Orders from ord1 ... ie status = 'O'

     Rev 1.95   06 Feb 2008 21:25:32   zf297a
  Added implementation for interfaces for function getVersion and procedure setDebug.  Added an exception handler to getCurrentLine to help in debugging it.

     Rev 1.94   06 Feb 2008 20:28:54   zf297a
  Implemented the new getCurrentLine using the loc_sid as part of the primary key and fixed everyplace it is invoked.

     Rev 1.93   Dec 19 2007 13:14:02   c402417
  Added loc_sid part of the key for OnOrderRow, OnOrderDelete and OnOrderUpdate.

     Rev 1.92   20 Nov 2007 17:22:24   zf297a
  Use bulk insert for most inserts.

     Rev 1.91   07 Nov 2007 21:32:22   zf297a
  Use bulk collect for most cursors.

     Rev 1.90   06 Nov 2007 10:30:22   zf297a
  Make sure that the ROQ data gets sent for corresponding ROQ amd_rsp_sum quantities, since the ROQ value is not stored in amd_rsp_sum.  Send the default ROQ value.

     Rev 1.89   29 Oct 2007 12:04:02   zf297a
  Implemented doRspSumDiff interface - moved override_type from the last argument to become the 3rd argument.

     Rev 1.88   19 Oct 2007 12:13:16   zf297a
  Added argument override_type to function doRspSumDiff.  Added override_type to all where clauses for the UPDATE's.  Whenever an ROP override_type is sent to SPO update the qty by substracting one or making it the default ROP value whenever it is null or zero.

     Rev 1.87   02 May 2007 15:37:36   zf297a
  Added serviceable_flag as part of the key for amd_in_transits_sum

     Rev 1.86   06 Apr 2007 20:48:26   zf297a
  Fixed getCurrentLine interface and implemented new select

     Rev 1.85   06 Apr 2007 16:58:28   zf297a
  Added sched_receipt_date to updates of amd_on_order

     Rev 1.84   06 Apr 2007 09:58:10   zf297a
  Fixed getNextLIne.  When using the MAX aggregate function there will not be a no_data_found exception, instead a null value will be returned by MAX.  Check the "maxLine" for a null.  If maxLIne is null, set it to zero so it will get set to maxLine + 1 for the first line number.

     Rev 1.83   06 Apr 2007 09:25:52   zf297a
  Removed line from interface insertOnOrderRow, updateOnOrderRow, and deleteRow.
  Added functions getNextLine, which will return the next line number for a given gold_order_number, and getCurrentLIne, which will return the current line for the given gold_order_number.

  Changed the insertOnOrderRow to use the new getNextLine function and for updateOnOnOrderRow and deleteRow to use the new getCurrentLine function.

     Rev 1.82   05 Apr 2007 11:10:48   zf297a
  Removed all Rtrim's and added writeMsg for all procedures invoked by loadGoldInventory.

     Rev 1.81   30 Mar 2007 13:14:40   zf297a
  For procedure updateRow qualifed the part_no on the right hand side of the equal operator to be updateRow.part_no, otherwise Oracle will compare the column part_no to itself!

     Rev 1.80   08 Mar 2007 23:35:12   zf297a
  replaced all execute immediate truncate table... with the procedure mta_truncate_table.  Eliminated the truncation of tmp_a2a_order_info - since it no longer exists and causes a ORA-00980 synonym translation is no longer valid

     Rev 1.79   06 Mar 2007 09:19:26   zf297a
  removed a2a_pkg.insertTmpA2AOrderInfoLine

     Rev 1.77   Feb 14 2007 12:45:34   c402417
  Modified cursors itemMCur and itemACur to eliminate duplicate goes into table tmp_amd_in_repair.

     Rev 1.76   Jan 17 2007 16:13:50   c402417
  Removed total_inaccessible from RspQty when populate data into table tmp_amd_rsp.
  Also modified the cursor rampCurFB to get more accurate data into tmp_amd_rsp and it's the only cursor for tmp_amd_rsp.

     Rev 1.75   Nov 29 2006 23:30:26   zf297a
  Removed unecessary site_location variables

     Rev 1.74   Nov 28 2006 13:29:02   zf297a
  fixed doRspSumDiff - For delete transactons send a zero qty for tmp_a2a_loc_part_override a2a transactions.

     Rev 1.73   Nov 07 2006 09:29:02   c402417
  Removed the query to get data from rvs1 to tmp_amd_in_transits per Laurie.

     Rev 1.72   Nov 03 2006 12:13:12   c402417
  Added Exception for duplicate on insert into tmp_amd_in_transits

     Rev 1.71   Jun 09 2006 11:39:30   zf297a
  implemented interface version

     Rev 1.70   Jun 05 2006 08:59:06   zf297a
  Fixed errorMsg - changed literal from amd_load to amd_inventory

     Rev 1.69   May 16 2006 12:08:00   zf297a
  Fixed doRspSumDiff to invoke A2a_Pkg.insertInvInfo with the qty_on_hand or zero if it is null

     Rev 1.68   Apr 28 2006 12:51:28   c402417
  Added tmp_a2a_loc_part_override to truncate .

     Rev 1.67   Apr 28 2006 12:42:32   c402417
  Added AMD Inventory Mofication for SPO - including new process for amd_rsp, removed Order Type of M from amd_on_order, removed HPMSK_BALANCE+ SPRAM_BALANCE+WRM_BALANCE from amd_on_hand_inv.

     Rev 1.66   Jan 20 2006 12:01:38   c402417
  Need to exclude part_no w/out spo_location for spo_total_inventory.

     Rev 1.65   Dec 15 2005 12:20:44   zf297a
  Added truncate of table tmp_a2a_repair_inv_info to loadInRepair

     Rev 1.64   Dec 06 2005 14:25:44   zf297a
  Fixed the doUpdate of the insertOnOrderRow routine when it checks for a Deleted order qualify the select with the order_date and also fixed the update by adding the order_date in its where clause.

     Rev 1.63   Dec 06 2005 14:04:36   zf297a
  Fixed deleteRow - passed an qty_ordered of 0 and sysdate for the A2A transaction.

     Rev 1.62   Dec 06 2005 12:29:20   zf297a
  Implemented new version of deleteRow for amd_on_order diff.  The code has been streamlined since all the necessary data is being passed in from the java diff application.

     Rev 1.61   Dec 06 2005 10:20:20   zf297a
  Fixed update of amd_on_order: qualified the where clause with  gold_order_number and order_date.  Order_date was missing and caused a unique constraint error.

     Rev 1.60   Nov 03 2005 09:33:18   c402417
  Changed sequence of procedure so the SpoTotalInventory get update after all inventory tables get loaded.

     Rev 1.59   Oct 27 2005 15:47:54   c402417
  Added repair_need_date to A2a_pkg.insertRepairInfo.

     Rev 1.58   Oct 20 2005 16:35:58   c402417
  Added Cursor RampCurUAB. This cursor feeds data from table ramp with SC = UAB to amd_on_hand_invs.

     Rev 1.57   Oct 19 2005 11:37:42   zf297a
  removed invocation of insertTmpA2AOrderInfoLine and update the arg list for insertTmpA2AOrderInfo, which now inserts both the tmp_a2a_order_info and the tmp_a2a_order_info_line.

  Thuy, added code for rampCurUAB.

     Rev 1.56   Oct 13 2005 11:12:14   c402417
  Added Repair Inventory Sum diff function . This to sum parts which have doc_no like 'R' and 'II' and send them to table amd_repair_invs_sum and these data consider DEFECTIVE as on_hand_type in SPO - Inventory.

     Rev 1.55   Oct 04 2005 13:05:12   c402417
  Add goldsa for amd_on_hand_invs.(This added for SPO 5.0)

     Rev 1.54   Oct 04 2005 11:51:26   c402417
  minor fixed in in_repair update statement .

     Rev 1.53   Sep 26 2005 09:31:20   zf297a
  Fixed deleteRow for doOnHandInvsSumDiff: it was trying to update amd_on_hand_invs instead of amd_on_hand_invs_sum

     Rev 1.52   Sep 13 2005 12:44:24   zf297a
  Implemented the isVoucher boolean function and modified the getOnOrderParams procedure to check if from/to dates not null and have a length > 0 before returning them.

     Rev 1.51   Sep 12 2005 11:36:40   zf297a
  implemented interfaces for one get and one set procedure for all the on order date parameters for a given voucher.

     Rev 1.50   Sep 09 2005 10:56:34   zf297a
  For amd_on_hand_inv_sums changed the site_location column to be the spo_location column.  The spo_location comes from amd_spare_networks.spo_location.

     Rev 1.49   Sep 07 2005 21:01:24   zf297a
  raised sched_receipt_date_exception in setScheduledReceiptDate when the from_date argument is > than the to_date argument.

     Rev 1.48   Sep 07 2005 15:17:32   zf297a
  Added orderdates subtype.   Implemented gets and sets for create_order_date, scheduled_receipt_date_from, scheduled_receipt_date_to, and number_of_calander days.

     Rev 1.47   Sep 02 2005 15:50:24   zf297a
  Started implementing interfaces for getOrderCreateDate, setOrderCreateDate, getScdeduledReceiptDateFrom, getScdeduledReceiptDateTo, setScheduledReceiptDate, and setScheduledReceiptDateCalDays using empty functions and procedures.

     Rev 1.46   Aug 30 2005 10:40:38   zf297a
  Moved cursors outside of loadGoldInventory.  Implemented loadOnHandInvs and loadInRepair as separate procedures.  Updated loadGoldInventory to use these new procedures.

     Rev 1.45   12 Aug 2005 09:42:18   c402417
  Added FC to order_no on ORD1 for amd_on_onder

     Rev 1.44   Aug 04 2005 08:12:52   zf297a
  Made insertRow and updateRow unique for the jdbc interface by renaming them to insertOnOrderRow and updateOnOrderRow.

     Rev 1.43   03 Aug 2005 17:43:14   b1013683
  Added Accountable_YN in  amd_in_repair.
  Added sched_receipt_date and changed in order_date in amd_on_order.
  Made modification in getting spo_total_inventory in table ansi.

     Rev 1.41   Jul 15 2005 10:59:08   zf297a
  Fixed updateRow for amd_inv_on_hand and insertRow for amd_in_transits

     Rev 1.39   Jul 11 2005 11:49:12   zf297a
  used procedure a2a_pkg.insertTmpA2AInTransits

     Rev 1.38   Jul 11 2005 10:39:22   zf297a
  used a2a_pkg to insertTmpA2AOrderInfo and insertTmpA2AOrderInfoLine

     Rev 1.37   Jul 11 2005 09:49:02   zf297a
  updated pError_Location numbers (10, 20, 30,.........400)

     Rev 1.36   Jul 11 2005 09:30:36   zf297a
  made the loading of tmp_amd_in_transits a separate procedure

     Rev 1.35   Jul 11 2005 09:17:42   zf297a
  made the loading of tmp_amd_on_order a separate procedure

     Rev 1.34   Jul 06 2005 09:28:14   zf297a
  Enhanced amd_in_repair and added spo inventory total

     Rev 1.33   Jun 17 2005 06:52:50   c970183
  removed insertInvInfo, updateInvInfo, and deleteInvInfo from routine dealing with amd_in_repair

     Rev 1.32   May 17 2005 10:06:08   c970183
  Updated InsertErrorMessage to new interface

     Rev 1.31   May 04 2005 10:26:04   c970183
  added logical insert (update) for AMD_IN_TRANSITS which had previously been logically deleted.

     Rev 1.30   May 04 2005 10:14:30   c970183
  added logical insert (update) for AMD_ON_HAND_INVS which has been previously logically deleted.

     Rev 1.29   May 04 2005 10:05:50   c970183
  added a logical insert (update) for amd_in_repair for a row that has been previously logically deleted.

     Rev 1.28   May 04 2005 09:50:14   c970183
  truncated all tmp_a2a tables when loadGoldInventory is executed

     Rev 1.27   May 04 2005 09:16:00   c970183
  Added logical insert of amd_on_order when it has been previously marked as deleted.

     Rev 1.26   Apr 27 2005 09:21:42   c970183
  aded counters of rows inserted for loadGoldInventory.  Added info messages using dbms_output and amd_load_details.

     Rev 1.25   20 Sep 2004 10:17:42   c970183
  Fixed site_location for insertRow of in_transits - it must be varchar(20)

     Rev 1.24   20 Aug 2004 16:51:46   c402417
  Added tmp_amd_in_repairs

     Rev 1.23   09 Aug 2004 14:48:22   c970183
  fixed deleteRow for tmp_a2a_on_hand_invs: the qty_on_hand is required, so set it to zero.

     Rev 1.22   09 Aug 2004 14:40:02   c970183
  fixed deleteRow (insert of tmp_a2a_on_hand_invs) the site_location field was NOT being inserted.

     Rev 1.21   09 Aug 2004 14:23:46   c970183
  added insertion of tmp_a2a_order_info for inserts and updates

     Rev 1.16   05 Aug 2004 07:47:26   c970183
  changed parameter from using p prefix to the same namje as used by the colum.  Added function or procedure qualification for all parameters used in SQL where clauses and UPDATE set clauses

     Rev 1.13   03 Aug 2004 10:15:02   c402417
  Added the amd_in_repair diff function.

     Rev 1.12   02 Aug 2004 14:14:34   c970183
  accomodate insert/update of detail rows for amd_on_hand_invs

     Rev 1.11   Aug 02 2004 08:47:10   c970183
  changed case of plocSid to pLocSid

     Rev 1.9   Jul 30 2004 12:02:18   c970183
  added comments to document changes made

    */



   -- DSE 7/23/04 added InsertRow, DeleteRow, and UpdateRow stubs
   -- TL  7/26/04 added ErrorMsg and code for amd_on_order InsertRow, DeleteRow, and UpdateRow
   -- DSE 7/27/04 added tmp prefix to all amd tables created by LoadGoldInventory
   -- DSE 7/29/04 Added InsertRow, UpdateRow, and DeleteRow for the amd_on_order table
   -- TL  7/30/04 Enhanced the ErrorMsg Function and implemented the InsertRow, UpdateRow,
   --                   and DeleteRow functions for the amd_on_hand_invs table
   -- TP     8/2/04  Added InsertRow, UpdateRow, and DeleteRow for the amd_in_repair table.
   -- TP    8/18/04 Added InsertRow, UpdateRow, and DeleteRow for the amd_in_transits table.
   --

   debug                                  BOOLEAN := FALSE;
   dateThreshold                          DATE := TO_DATE ('01/01/1980', 'MM/DD/YYYY'); -- there should not be any repair dates earlier than this

   ON_ORDER_DATE                 CONSTANT AMD_PARAMS.PARAM_KEY%TYPE := 'on_order_date_';
   PROGRAM_ID                    CONSTANT VARCHAR2 (30) := amd_defaults.getProgramId;
   PROGRAM_ID_LL                 CONSTANT NUMBER := LENGTH (PROGRAM_ID);
   START_LOC_ID                  CONSTANT NUMBER := amd_defaults.getStartLocId;

   SUBTYPE orderdates IS NUMBER;

   ORDER_CREATE_DATE             CONSTANT orderdates := 1;
   SCHEDULED_RECEIPT_DATE_FROM   CONSTANT orderdates := 2;
   SCHEDULED_RECEIPT_DATE_TO     CONSTANT orderdates := 3;
   NUMBER_OF_CALANDER_DAYS       CONSTANT orderdates := 4;

   TYPE partRec IS RECORD
   (
      part_no   amd_spare_parts.part_no%TYPE,
      nsn       amd_national_stock_items.nsn%TYPE
   );

   TYPE partTab IS TABLE OF partRec;

   partRecs                               partTab;



   CURSOR partCur
   IS
      SELECT DISTINCT asp.part_no, asp.nsn
        FROM AMD_SPARE_PARTS asp,
             AMD_NATIONAL_STOCK_ITEMS ansi,
             AMD_NSI_PARTS anp
       WHERE     icp_ind = amd_defaults.getIcpInd
             AND asp.part_no = anp.part_no
             AND anp.prime_ind = 'Y'
             AND NVL (
                    "UNASSIGNMENT_DATE",
                    TO_DATE (' 0001-01-01 00:00:00',
                             'syyyy-mm-dd hh24:mi:ss')) =
                    TO_DATE (' 0001-01-01 00:00:00',
                             'syyyy-mm-dd hh24:mi:ss')
             AND asp.nsn = ansi.nsn
             AND asp.action_code != 'D';

   -- Type 1,2 Retail

   TYPE rampRec IS RECORD
   (
      loc_sid                  amd_spare_networks.loc_sid%TYPE,
      serviceable_balance      ramp.SERVICEABLE_BALANCE%TYPE,
      spram_balance            ramp.SPRAM_BALANCE%TYPE,
      wrm_balance              ramp.WRM_BALANCE%TYPE,
      hpmsk_balance            ramp.HPMSK_BALANCE%TYPE,
      total_inaccessible_qty   ramp.TOTAL_INACCESSIBLE_QTY%TYPE,
      difm_balance             ramp.DIFM_BALANCE%TYPE,
      unserviceable_balance    ramp.UNSERVICEABLE_BALANCE%TYPE,
      spram_level              ramp.SPRAM_LEVEL%TYPE,
      wrm_level                ramp.WRM_LEVEL%TYPE,
      hpmsk_level_qty          ramp.HPMSK_LEVEL_QTY%TYPE,
      suspended_in_stock       ramp.SUSPENDED_IN_STOCK%TYPE,
      inv_date                 ramp.DATE_PROCESSED%TYPE,
      repair_need_date         ramp.DATE_PROCESSED%TYPE
   );


   TYPE rampTab IS TABLE OF rampRec;

   rampRecs                               rampTab;

   TYPE rampInvQtyRec IS RECORD
   (
      loc_sid                  amd_spare_networks.loc_sid%TYPE,
      serviceable_balance      ramp.SERVICEABLE_BALANCE%TYPE,
      spram_balance            ramp.SPRAM_BALANCE%TYPE,
      wrm_balance              ramp.WRM_BALANCE%TYPE,
      hpmsk_balance            ramp.HPMSK_BALANCE%TYPE,
      total_inaccessible_qty   ramp.TOTAL_INACCESSIBLE_QTY%TYPE,
      difm_balance             ramp.DIFM_BALANCE%TYPE,
      unserviceable_balance    ramp.UNSERVICEABLE_BALANCE%TYPE,
      spram_level              ramp.SPRAM_LEVEL%TYPE,
      wrm_level                ramp.WRM_LEVEL%TYPE,
      hpmsk_level_qty          ramp.HPMSK_LEVEL_QTY%TYPE,
      suspended_in_stock       ramp.SUSPENDED_IN_STOCK%TYPE,
      inv_date                 ramp.DATE_PROCESSED%TYPE,
      repair_need_date         ramp.DATE_PROCESSED%TYPE,
      inventory_quantity       NUMBER,
      action_code              TMP_AMD_ON_HAND_INVS.ACTION_CODE%TYPE,
      last_update_dt           DATE
   );

   TYPE rampInvQtyTab IS TABLE OF rampInvQtyRec;

   rampInvQtyRecs                         rampInvQtyTab;



   CURSOR rampCurUAB (
      pNsn    VARCHAR2)
   IS
      SELECT DECODE (n.loc_type, 'TMP', asn2.loc_sid, n.loc_sid) loc_sid,
             NVL (r.serviceable_balance, 0) serviceable_balance,
             NVL (r.spram_balance, 0) spram_balance,
             NVL (r.hpmsk_balance, 0) hpmsk_balance,
             NVL (r.wrm_balance, 0) wrm_balance,
             NVL (r.total_inaccessible_qty, 0) total_inaccessible_qty,
             NVL (r.difm_balance, 0) difm_balance,
             NVL (r.spram_level, 0) spram_level,
             NVL (r.wrm_level, 0) wrm_level,
             NVL (r.hpmsk_level_qty, 0) hpmsk_level_qty,
             TRUNC (NVL (r.date_processed, SYSDATE)) inv_date,
             TRUNC ( (r.date_processed) + NVL (avg_repair_cycle_time, 0))
                repair_need_date
        FROM (SELECT *
                FROM RAMP
               WHERE current_stock_number = pNsn) r,
             AMD_SPARE_NETWORKS n,
             AMD_SPARE_NETWORKS asn2
       WHERE     n.loc_id = r.sran(+)
             AND SUBSTR (r.sran, 1, 2) = 'FB'             --AND asp.nsn = pNsn
             AND n.loc_type = 'UAB'
             AND n.mob = asn2.loc_id(+);

   TYPE rampFBrec IS RECORD
   (
      loc_sid                  amd_spare_networks.loc_sid%TYPE,
      serviceable_balance      ramp.SERVICEABLE_BALANCE%TYPE,
      spram_balance            ramp.SPRAM_BALANCE%TYPE,
      wrm_balance              ramp.WRM_BALANCE%TYPE,
      hpmsk_balance            ramp.HPMSK_BALANCE%TYPE,
      total_inaccessible_qty   ramp.TOTAL_INACCESSIBLE_QTY%TYPE,
      difm_balance             ramp.DIFM_BALANCE%TYPE,
      spram_level              ramp.SPRAM_LEVEL%TYPE,
      wrm_level                ramp.WRM_LEVEL%TYPE,
      hpmsk_level_qty          ramp.HPMSK_LEVEL_QTY%TYPE,
      inv_date                 ramp.DATE_PROCESSED%TYPE,
      repair_need_date         ramp.DATE_PROCESSED%TYPE
   );

   TYPE rampFBtab IS TABLE OF rampFBrec;

   rampFBrecs                             rampFBtab;



   TYPE tmpAmdOnHandInvsTab IS TABLE OF tmp_amd_on_hand_invs%ROWTYPE;

   tmpAmdOnHandInvsRecs                   tmpAmdOnHandInvsTab;



   PROCEDURE writeMsg (
      pTableName        IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
      pError_location   IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
      pKey1             IN VARCHAR2 := '',
      pKey2             IN VARCHAR2 := '',
      pKey3             IN VARCHAR2 := '',
      pKey4             IN VARCHAR2 := '',
      pData             IN VARCHAR2 := '',
      pComments         IN VARCHAR2 := '')
   IS
   BEGIN
      Amd_Utils.writeMsg (pSourceName       => 'amd_inventory',
                          pTableName        => pTableName,
                          pError_location   => pError_location,
                          pKey1             => pKey1,
                          pKey2             => pKey2,
                          pKey3             => pKey3,
                          pKey4             => pKey4,
                          pData             => pData,
                          pComments         => pComments);
   END writeMsg;


   PROCEDURE warningMsg (pWarning_Location   IN NUMBER,
                         key1                IN VARCHAR2 := '',
                         key2                IN VARCHAR2 := '',
                         key3                IN VARCHAR2 := '',
                         key4                IN VARCHAR2 := '',
                         key5                IN VARCHAR2 := '',
                         msg                 IN VARCHAR2 := '')
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      Amd_warnings_pkg.insertWarningMsg (pData_line_no   => pWarning_Location,
                                         pData_line      => 'amd_inventory',
                                         pKey_1          => key1,
                                         pKey_2          => key2,
                                         pKey_3          => key3,
                                         pKey_4          => key4,
                                         pKey_5          => key5,
                                         pWarning        => msg);
      COMMIT;
      RETURN;
   END warningMsg;

   PROCEDURE errorMsg (sqlFunction         IN VARCHAR2,
                       tableName           IN VARCHAR2,
                       pError_Location     IN NUMBER,
                       key1                IN VARCHAR2 := '',
                       key2                IN VARCHAR2 := '',
                       key3                IN VARCHAR2 := '',
                       key4                IN VARCHAR2 := '',
                       key5                IN VARCHAR2 := '',
                       keywordValuePairs   IN VARCHAR2 := '')
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      Amd_Utils.InsertErrorMsg (
         pLoad_no        => Amd_Utils.GetLoadNo (pSourceName   => sqlFunction,
                                                 pTableName    => tableName),
         pData_line_no   => pError_Location,
         pData_line      => 'amd_inventory',
         pKey_1          => key1,
         pKey_2          => key2,
         pKey_3          => key3,
         pKey_4          => key4,
         pKey_5          => key5 || ' ' || keywordValuePairs,
         pComments       =>    SqlFunction
                            || '/'
                            || TableName
                            || ' sqlcode('
                            || SQLCODE
                            || ') sqlerrm('
                            || SQLERRM
                            || ')');
      COMMIT;
      RETURN;
   END ErrorMsg;

   FUNCTION ErrorMsg (pSqlFunction         IN VARCHAR2,
                      pTableName           IN VARCHAR2,
                      pError_Location      IN NUMBER,
                      pReturn_code         IN NUMBER,
                      pKey_1               IN VARCHAR2,
                      pKey_2               IN VARCHAR2 := '',
                      pKey_3               IN VARCHAR2 := '',
                      pKey_4               IN VARCHAR2 := '',
                      pKeywordValuePairs   IN VARCHAR2 := '')
      RETURN NUMBER
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      Amd_Utils.InsertErrorMsg (
         pLoad_no        => Amd_Utils.GetLoadNo (pSourceName   => pSqlFunction,
                                                 pTableName    => pTableName),
         pData_line_no   => pError_Location,
         pData_line      => 'amd_inventory',
         pKey_1          => pKey_1,
         pKey_2          => pKey_2,
         pKey_3          => pKey_3,
         pKey_4          => pKey_4,
         pKey_5          =>    'rc='
                            || TO_CHAR (pReturn_code)
                            || ' '
                            || pKeywordValuePairs,
         pComments       =>    pSqlFunction
                            || '/'
                            || pTableName
                            || ' sqlcode('
                            || SQLCODE
                            || ') sqlerrm('
                            || SQLERRM
                            || ')');
      COMMIT;
      RETURN pReturn_code;
   END ErrorMsg;


   PROCEDURE LoadGoldInventory
   IS
      nsnDashed   VARCHAR2 (16);
      orderSid    NUMBER;

      pn          VARCHAR2 (50);
      loc_sid     NUMBER;
      inv_date    DATE;
      invQty      NUMBER;

      result      NUMBER;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_...',
         pError_location   => 10,
         pKey1             => 'loadGoldInventory',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      loadOnHandInvs;

      loadInRepair;

      loadOnOrder;

      loadInTransits;

      loadRsp;


      writeMsg (
         pTableName        => 'tmp_amd_...',
         pError_location   => 20,
         pKey1             => 'loadGoldInventory',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'loadGoldInventory',
                   tableName         => 'inventory tables',
                   pError_Location   => 20);
         DBMS_OUTPUT.put_line (
               'loadGoldInventory: sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END LoadGoldInventory;


   PROCEDURE loadOnOrder
   IS
      TYPE tmpAmdOnOrderTab IS TABLE OF tmp_amd_on_order%ROWTYPE;

      tmpAmdOnOrderRecs   tmpAmdOnOrderTab;



      CURSOR itemType3aCur
      IS
           SELECT asp.part_no part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid)
                     loc_sid,
                  invQ.inv_date inv_date,
                  SUM (invQ.inv_qty) inv_qty,
                  invQ.order_no order_no,
                  TRUNC (invQ.receipt_date) receipt_date,
                  amd_defaults.getINSERT_ACTION action_code,
                  SYSDATE last_update_dt
             FROM (SELECT DISTINCT
                          o.part part_no,
                          o.loc_id,
                          TRUNC (o.created_datetime) inv_date,
                          NVL (o.qty_due, 0) inv_qty,
                          o.order_no order_no,
                          DECODE (ecd, NULL, need_date, ecd) receipt_date
                     FROM ORD1 o, amd_spare_networks asn
                    WHERE     o.status = 'O'
                          AND SUBSTR (o.sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                          AND (   o.sc LIKE '%G'
                               OR (EXISTS
                                      (SELECT NULL
                                         FROM amd_sc_inclusions
                                        WHERE o.sc = include_sc)))
                          AND o.order_type = 'M'
                          AND o.created_datetime IS NOT NULL
                          AND (   asn.loc_id = o.loc_id
                               OR (EXISTS
                                      (SELECT NULL
                                         FROM amd_sc_inclusions
                                        WHERE SUBSTR (o.sc, START_LOC_ID, 7) =
                                                 SUBSTR (include_sc,
                                                         START_LOC_ID,
                                                         7))))
                   UNION ALL
                   SELECT DISTINCT
                          part part_no,
                          o.loc_id,
                          TRUNC (o.created_datetime) inv_date,
                          NVL (o.qty_due, 0) inv_qty,
                          o.order_no order_no,
                          DECODE (o.ecd, NULL, o.need_date, o.ecd) receipt_date
                     FROM ORD1 o, amd_spare_networks asn
                    WHERE     o.status = 'O'
                          AND SUBSTR (o.sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                          AND (   o.sc LIKE '%G'
                               OR (EXISTS
                                      (SELECT NULL
                                         FROM amd_sc_inclusions
                                        WHERE o.sc = include_sc)))
                          AND o.order_type = 'C'
                          --AND SUBSTR(o.order_no,1,2) IN (select prefix from amd_order_prefixes)
                          AND o.created_datetime IS NOT NULL
                          AND (   asn.loc_id = o.loc_id
                               OR (EXISTS
                                      (SELECT NULL
                                         FROM amd_sc_inclusions
                                        WHERE SUBSTR (o.sc, START_LOC_ID, 7) =
                                                 SUBSTR (include_sc,
                                                         START_LOC_ID,
                                                         7))))
                   UNION ALL
                   SELECT DISTINCT
                          part part_no,
                          o.loc_id,
                          TRUNC (o.created_datetime) inv_date,
                          NVL (o.qty_due, 0) inv_qty,
                          o.order_no order_no,
                          DECODE (o.ecd, NULL, o.need_date, o.ecd) receipt_date
                     FROM ORD1 o, amd_spare_networks asn
                    WHERE     o.status = 'O'
                          AND SUBSTR (o.sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                          AND (   o.sc LIKE '%G'
                               OR (EXISTS
                                      (SELECT NULL
                                         FROM amd_sc_inclusions
                                        WHERE o.sc = include_sc)))
                          AND o.order_type = 'C'
                          AND SUBSTR (order_no, 1, 3) =
                                 SUBSTR (asn.loc_id, 4, 3)
                          AND SUBSTR (asn.loc_id, 1, 2) IN ('FB', 'EY')
                          AND o.created_datetime IS NOT NULL
                          AND (   asn.loc_id = o.loc_id
                               OR (EXISTS
                                      (SELECT NULL
                                         FROM amd_sc_inclusions
                                        WHERE SUBSTR (o.sc, START_LOC_ID, 7) =
                                                 SUBSTR (include_sc,
                                                         START_LOC_ID,
                                                         7))))) invQ,
                  AMD_SPARE_NETWORKS asn,
                  AMD_SPARE_PARTS asp,
                  AMD_SPARE_NETWORKS asnLink
            WHERE     asp.part_no = invQ.part_no
                  AND asn.loc_id = invQ.loc_id
                  AND asn.loc_type <> 'KIT'
                  AND asp.action_code != 'D'
                  AND asn.mob = asnLink.loc_id(+)
                  AND invQ.inv_date IS NOT NULL
         GROUP BY asp.part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid),
                  invQ.inv_date,
                  invQ.order_no,
                  TRUNC (invQ.receipt_date)
           HAVING SUM (invQ.inv_qty) > 0;



      CURSOR itemType3bCur
      IS
           SELECT i.part part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid)
                     loc_sid,
                  TRUNC (i.created_datetime) inv_date,
                  SUM (i.qty) inv_qty,
                  i.item_id order_no,
                  DECODE (TRUNC (o.ecd), NULL, SYSDATE, TRUNC (o.ecd))
                     receipt_date,
                  amd_defaults.INSERT_ACTION action_code,
                  SYSDATE last_update_dt
             FROM ITEM i,
                  ORD1 o,
                  AMD_SPARE_NETWORKS asn,
                  AMD_SPARE_PARTS asp,
                  AMD_SPARE_NETWORKS asnLink
            WHERE     i.receipt_order_no = o.order_no
                  AND o.status = 'O'
                  AND SUBSTR (o.sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                  AND SUBSTR (o.sc, LENGTH (o.sc), 1) = 'G'
                  AND i.condition = 'B170-ATL'
                  AND asp.part_no = i.part
                  AND asn.loc_id = i.loc_id
                  AND ASN.LOC_TYPE <> 'KIT'
                  AND asp.action_code != 'D'
                  AND asn.mob = asnLink.loc_id(+)
                  AND i.created_datetime IS NOT NULL
         GROUP BY i.part,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid),
                  TRUNC (i.created_datetime),
                  i.item_id,
                  DECODE (TRUNC (o.ecd), NULL, SYSDATE, TRUNC (o.ecd))
           HAVING SUM (i.qty) > 0;

      TYPE itemType3cRec IS RECORD
      (
         part_no        tmp1.FROM_PART%TYPE,
         loc_sid        amd_spare_networks.loc_sid%TYPE,
         inv_date       DATE,
         inv_qty        NUMBER,
         order_no       tmp1.TEMP_OUT_ID%TYPE,
         receipt_date   DATE
      );

      TYPE itemType3cTab IS TABLE OF itemType3cRec;

      itemType3cRecs      itemType3cTab;

      CURSOR itemType3cCur
      IS
           SELECT from_part part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid)
                     loc_sid,
                  TRUNC (from_datetime) inv_date,
                  SUM (qty_due) inv_qty,
                  temp_out_id order_no,
                  DECODE (est_return_date, NULL, NULL, est_return_date)
                     receipt_date,
                  amd_defaults.INSERT_ACTION action_code,
                  SYSDATE last_update_dt
             FROM TMP1,
                  AMD_SPARE_NETWORKS asn,
                  AMD_SPARE_PARTS asp,
                  AMD_SPARE_NETWORKS asnLink
            WHERE     NVL (returned_voucher, '-1') = '-1'
                  AND status = 'O'
                  AND tcn = 'LNI'
                  AND SUBSTR (from_sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                  AND asn.loc_id = from_loc_id
                  AND asp.part_no = from_part
                  AND asn.loc_type <> 'KIT'
                  AND asp.action_code != 'D'
                  AND asn.mob = asnLink.loc_id(+)
                  AND from_datetime IS NOT NULL
         GROUP BY from_part,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid),
                  TRUNC (from_datetime),
                  temp_out_id,
                  est_return_date
           HAVING SUM (qty_due) > 0;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_on_order',
         pError_location   => 30,
         pKey1             => 'loadOnOrder',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
      Mta_Truncate_Table ('TMP_AMD_ON_ORDER', 'reuse storage');

      OPEN itemType3aCur;

      FETCH itemType3aCur BULK COLLECT INTO tmpAmdOnOrderRecs;

      CLOSE itemType3aCur;

      IF tmpAmdOnOrderRecs.FIRST IS NOT NULL
      THEN
         -- type3aWholeSale
         FORALL indx IN tmpAmdOnOrderRecs.FIRST .. tmpAmdOnOrderRecs.LAST
            -- Type_3a
            INSERT INTO TMP_AMD_ON_ORDER
                 VALUES tmpAmdOnOrderRecs (indx);

         DBMS_OUTPUT.put_line (
               'loadOnOrder: rows inserted to tmp_amd_on_order from itemType3aCur '
            || SQL%ROWCOUNT);
         writeMsg (
            pTableName        => 'tmp_amd_on_order',
            pError_location   => 40,
            pKey1             => 'itemType3a',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# of recs = ' || TO_CHAR (SQL%ROWCOUNT));
         COMMIT;
      END IF;

      OPEN itemType3bCur;

      FETCH itemType3bCur BULK COLLECT INTO tmpAmdOnOrderRecs;

      CLOSE itemtype3bCur;

      IF tmpAmdOnOrderRecs.FIRST IS NOT NULL
      THEN
         --type3bWholesale
         FORALL indx IN tmpAmdOnOrderRecs.FIRST .. tmpAmdOnOrderRecs.LAST
            -- Type_3b
            INSERT INTO TMP_AMD_ON_ORDER
                 VALUES tmpAmdOnOrderRecs (indx);

         DBMS_OUTPUT.put_line (
               'loadOnOrder: rows inserted to tmp_amd_on_order from itemType3bCur '
            || SQL%ROWCOUNT);
         writeMsg (
            pTableName        => 'tmp_amd_on_order',
            pError_location   => 50,
            pKey1             => 'itemType3b',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# recs = ' || TO_CHAR (SQL%ROWCOUNT));
         COMMIT;
      END IF;

      OPEN itemType3cCur;

      FETCH itemType3cCur BULK COLLECT INTO tmpAmdOnOrderRecs;

      CLOSE itemType3cCur;

      IF tmpAmdOnOrderRecs.FIRST IS NOT NULL
      THEN
         -- type3cWholeSale
         FORALL indx IN tmpAmdOnOrderRecs.FIRST .. tmpAmdOnOrderRecs.LAST
            --Type_3c
            INSERT INTO TMP_AMD_ON_ORDER
                 VALUES tmpAmdOnOrderRecs (indx);

         DBMS_OUTPUT.put_line (
               'loadOnOrder: rows inserted to tmp_amd_on_order from itemType3cCur '
            || SQL%ROWCOUNT);

         writeMsg (
            pTableName        => 'tmp_amd_on_order',
            pError_location   => 60,
            pKey1             => 'itemType3c',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# recs = ' || TO_CHAR (SQL%ROWCOUNT));
         COMMIT;
      END IF;

      writeMsg (
         pTableName        => 'tmp_amd_on_order',
         pError_location   => 70,
         pKey1             => 'loadOnOrder',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
   END loadOnOrder;



   PROCEDURE loadInTransits
   IS
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_in_transits',
         pError_location   => 80,
         pKey1             => 'loadInTransits',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
      Mta_Truncate_Table ('TMP_AMD_IN_TRANSITS', 'reuse storage');

     -- Populate data into table amd_in_transits
     <<insertInTransits1>>
      BEGIN
         INSERT INTO TMP_AMD_IN_TRANSITS (to_loc_sid,
                                          quantity,
                                          action_code,
                                          last_update_dt,
                                          document_id,
                                          part_no,
                                          from_location,
                                          in_transit_date,
                                          serviceable_flag)
            SELECT loc_sid,
                   (NVL (m.ship_qty, 0) - NVL (m.receipt_qty, 0)) quantity,
                   'A',
                   SYSDATE,
                   m.document_id,
                   m.part,
                   m.in_tran_from,
                   TO_DATE (m.create_date),
                   DECODE (m.mils_condition,
                           'A', 'Y',
                           'B', 'Y',
                           'C', 'Y',
                           'D', 'Y',
                           'N')
                      mils_condition
              FROM MLIT m, AMD_SPARE_NETWORKS a
             WHERE     (NVL (m.ship_qty, 0) - NVL (m.receipt_qty, 0)) > 0
                   AND SUBSTR (m.in_tran_to, 1, 2) <> 'FE'
                   AND a.loc_type <> 'KIT'
                   AND (   DECODE (m.in_tran_to,
                                   'FD2090', 'CTLATL',
                                   'FB' || SUBSTR (in_tran_to, 3)) = a.loc_id
                        OR DECODE (m.in_tran_to,
                                   'EY3571', 'CODALT',
                                   'FB' || SUBSTR (in_tran_to, 3)) = a.loc_id
                        OR DECODE (m.in_tran_to,
                                   'EY7739', 'CODCHS',
                                   'FB' || SUBSTR (in_tran_to, 3)) = a.loc_id
                        OR DECODE (m.in_tran_to,
                                   'EY8388', 'CODMCD',
                                   'FB' || SUBSTR (in_tran_to, 3)) = a.loc_id);

         DBMS_OUTPUT.put_line (
               'loadInTransits: rows inserted to tmp_amd_on_order from MLIT '
            || SQL%ROWCOUNT);

         COMMIT;
      END insertInTransits1;

     <<insertInTransits2>>
      BEGIN
         INSERT INTO TMP_AMD_IN_TRANSITS (to_loc_sid,
                                          quantity,
                                          action_code,
                                          last_update_dt,
                                          document_id,
                                          part_no,
                                          from_location,
                                          in_transit_date,
                                          serviceable_flag)
            SELECT a.loc_sid,
                   i.qty,
                   'A',
                   SYSDATE,
                   i.item_id,
                   i.part,
                   i.loc_id,
                   i.created_datetime,
                   i.status_servicable
              FROM ITEM i, AMD_SPARE_NETWORKS a
             WHERE     i.status_3 = 'I'
                   AND i.condition != 'B170-ATL'
                   AND i.status_servicable = 'Y'
                   AND i.status_new_order = 'N'
                   AND i.status_accountable = 'Y'
                   AND i.status_active = 'Y'
                   AND i.status_mai = 'N'
                   AND SUBSTR (i.sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                   AND NOT EXISTS
                          (SELECT 1
                             FROM ITEM i2
                            WHERE     i2.status_avail = 'N'
                                  AND NVL (i2.receipt_order_no, '-1') = '-1'
                                  AND i2.item_id = i.item_id)
                   AND i.loc_id = a.loc_id
                   AND a.loc_type <> 'KIT'
                   AND i.qty IS NOT NULL;

         DBMS_OUTPUT.put_line (
               'loadInTransits: rows inserted to tmp_amd_on_order from ITEM '
            || SQL%ROWCOUNT);

         COMMIT;
      END insertInTransits2;


      writeMsg (
         pTableName        => 'tmp_amd_in_transits',
         pError_location   => 90,
         pKey1             => 'loadInTransits',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
   END loadInTransits;


   PROCEDURE loadRsp
   IS
      nsnDashed       VARCHAR2 (16) := NULL;
      RspQty          NUMBER := 0;
      RspLevel        NUMBER := 0;
      cntRsp          NUMBER := 0;
      cntType1        NUMBER := 0;
      cntType2        NUMBER := 0;
      result          NUMBER := 0;

      TYPE tmpAmdRspTab IS TABLE OF tmp_amd_rsp%ROWTYPE;

      tmpAmdRspRecs   tmpAmdRspTab;

      CURSOR rspInv
      IS
         SELECT part_no,
                loc_sid,
                rsp_inv,
                rsp_level,
                amd_defaults.getINSERT_ACTION action_code,
                SYSDATE last_update_dt
           FROM rsp_inv_v
          WHERE rsp_inv > 0;


      rspCnt          NUMBER := 0;
      ins_cnt         NUMBER := 0;
      upd_cnt         NUMBER := 0;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_rsp',
         pError_location   => 100,
         pKey1             => 'loadRsp',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
      Mta_Truncate_Table ('TMP_AMD_RSP', 'reuse storage');
      COMMIT;


      -- Populate data into table tmp_amd_rsp

      OPEN rspInv;

      FETCH rspInv BULK COLLECT INTO tmpAmdRspRecs;

      CLOSE rspInv;

      IF tmpAmdRspRecs.FIRST IS NOT NULL
      THEN
         --rspUABRampLoop
         FORALL yDex IN tmpAmdRspRecs.FIRST .. tmpAmdRspRecs.LAST
            INSERT INTO TMP_AMD_RSP
                 VALUES tmpAmdRspRecs (yDex);

         rspCnt := rspCnt + SQL%ROWCOUNT;
         COMMIT;
      END IF;

      DBMS_OUTPUT.put_line ('loadRsp: rows inserted ' || rspCnt);


      DBMS_OUTPUT.put_line (
            'loadRsp ended at '
         || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM')
         || ' # recs = '
         || TO_CHAR (rspCnt));

      writeMsg (
         pTableName        => 'tmp_amd_rsp',
         pError_location   => 110,
         pKey1             => 'loadRsp',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => '# recs = ' || TO_CHAR (rspCnt));
   END loadRsp;


   FUNCTION getSiteLocation (loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE)
      RETURN AMD_SPARE_NETWORKS.loc_id%TYPE
   IS
      loc_id   AMD_SPARE_NETWORKS.loc_id%TYPE;
      result   NUMBER;
   BEGIN
      SELECT loc_id
        INTO loc_id
        FROM AMD_SPARE_NETWORKS
       WHERE loc_sid = getSiteLocation.loc_sid;

      RETURN loc_id;
   EXCEPTION
      WHEN OTHERS
      THEN
         result :=
            ErrorMsg (pSqlFunction      => 'select',
                      pTableName        => 'amd_spare_networks',
                      pError_Location   => 80,
                      pReturn_code      => FAILURE,
                      pKey_1            => 'loc_sid');
         DBMS_OUTPUT.put_line (
               'getSiteLocation: loc_sid='
            || loc_sid
            || ' sqlcode='
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END getSiteLocation;


   FUNCTION doRepairInvsSumDiff (part_no         IN VARCHAR2,
                                 site_location   IN VARCHAR2,
                                 qty_on_hand     IN NUMBER,
                                 action_code     IN VARCHAR2)
      RETURN NUMBER
   IS
      badActionCode   EXCEPTION;

      FUNCTION InsertRow
         RETURN NUMBER
      IS
      BEGIN
        <<insertAmdRepairInvsSums>>
         DECLARE
            PROCEDURE doUpdate
            IS
            BEGIN
              <<getActionCode>>
               DECLARE
                  action_code   AMD_IN_REPAIR.action_code%TYPE;
                  badInsert     EXCEPTION;
               BEGIN
                  SELECT action_code
                    INTO action_code
                    FROM AMD_REPAIR_INVS_SUM
                   WHERE     part_no = doRepairInvsSumDiff.part_no
                         AND site_location =
                                doRepairInvsSumDiff.site_location;

                  IF action_code != Amd_Defaults.DELETE_ACTION
                  THEN
                     DBMS_OUTPUT.put_line (
                           'doRepairInvsSumDiff: insertAmdRepairInvsSums getActionCode: action_code='
                        || action_code
                        || ' part_no='
                        || doRepairInvsSumDiff.part_no
                        || ' site_location='
                        || doRepairInvsSumDiff.site_location
                        || ' qty_on_hand='
                        || qty_on_hand
                        || ' action_code='
                        || action_code);
                     RAISE badInsert;
                  END IF;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     errorMsg (
                        SqlFunction       => 'select',
                        TableName         => 'amd_repair_invs_sum',
                        pError_location   => 120,
                        key1              => doRepairInvsSumDiff.part_no,
                        key2              => doRepairInvsSumDiff.site_location);
               END getActionCode;

               UPDATE AMD_REPAIR_INVS_SUM
                  SET qty_on_hand = doRepairInvsSumDiff.qty_on_hand,
                      action_code = Amd_Defaults.INSERT_ACTION,
                      last_update_dt = SYSDATE
                WHERE     part_no = doRepairInvsSumDiff.part_no
                      AND site_location = doRepairInvsSumDiff.site_location;
            END doUpdate;
         BEGIN
            INSERT INTO AMD_REPAIR_INVS_SUM (part_no,
                                             site_location,
                                             qty_on_hand,
                                             action_code,
                                             last_update_dt)
                 VALUES (part_no,
                         site_location,
                         qty_on_hand,
                         Amd_Defaults.INSERT_ACTION,
                         SYSDATE);
         EXCEPTION
            WHEN STANDARD.DUP_VAL_ON_INDEX
            THEN
               doUpdate;
            WHEN OTHERS
            THEN
               ErrorMsg (sqlFunction       => 'insert',
                         tableName         => 'amd_on_order',
                         pError_location   => 130,
                         key1              => part_no,
                         key2              => site_location);
               DBMS_OUTPUT.put_line (
                     'doRepairInvsSumDiff: insertAmdRepairInvs: part_no='
                  || part_no
                  || ' site_location='
                  || site_location
                  || ' qty_on_hand='
                  || qty_on_hand
                  || ' action_code='
                  || action_code
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END insertAmdRepairInvs;


         RETURN SUCCESS;
      END InsertRow;

      FUNCTION UpdateRow
         RETURN NUMBER
      IS
         -- get the detail for the summarized inv_qty
         result   NUMBER;
      BEGIN
        <<updateAmdRepairInvs>>
         BEGIN
            UPDATE AMD_REPAIR_INVS_SUM
               SET qty_on_hand = doRepairInvsSumDiff.qty_on_hand,
                   action_code = Amd_Defaults.UPDATE_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = doRepairInvsSumDiff.part_no
                   AND site_location = doRepairInvsSumDiff.site_location;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (SqlFunction       => 'update',
                         TableName         => 'amd_repair_invs_sum',
                         pError_location   => 140,
                         key1              => part_no,
                         key2              => site_location);
               DBMS_OUTPUT.put_line (
                     'doRepairInvsSumDiff: updateAmdRepairInvs: 1 part_no='
                  || part_no
                  || ' site_location='
                  || site_location
                  || ' qty_on_hand='
                  || qty_on_hand
                  || ' action_code='
                  || action_code
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END updateAmdRepairInvs;


         RETURN SUCCESS;
      END UpdateRow;

      FUNCTION DeleteRow
         RETURN NUMBER
      IS
      BEGIN
        <<updateAmdRepairInvs>> -- logically delete all records for the part_no and loc_sid
         BEGIN
            UPDATE AMD_REPAIR_INVS_SUM
               SET action_code = Amd_Defaults.DELETE_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = doRepairInvsSumDiff.part_no
                   AND site_location = doRepairInvsSumDiff.site_location;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (SqlFunction       => 'update',
                         TableName         => 'amd_repair_invs_sum',
                         pError_location   => 150,
                         key1              => part_no,
                         key2              => site_location);
               DBMS_OUTPUT.put_line (
                     'updateAmdRepairInvs: 2 part_no='
                  || part_no
                  || ' site_location='
                  || site_location
                  || ' qty_on_hand='
                  || qty_on_hand
                  || ' action_code='
                  || action_code
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END updateAmdRepairInvs;


         RETURN SUCCESS;
      END DeleteRow;
   BEGIN
      IF action_code = Amd_Defaults.INSERT_ACTION
      THEN
         RETURN insertRow;
      ELSIF action_code = Amd_Defaults.UPDATE_ACTION
      THEN
         RETURN updateRow;
      ELSIF action_code = Amd_Defaults.DELETE_ACTION
      THEN
         RETURN deleteRow;
      ELSE
         errorMsg (action_code,
                   'amd_repair_invs_sum',
                   68,
                   part_no,
                   site_location);
         DBMS_OUTPUT.put_line (
               'doRepairInvsSumDiff: action_code='
            || action_code
            || ' part_no='
            || part_no
            || ' site_location='
            || site_location
            || ' qty_on_hand='
            || qty_on_hand
            || ' action_code='
            || action_code
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);

         RAISE badActionCode;
         RETURN FAILURE;
      END IF;
   END doRepairInvsSumDiff;


   FUNCTION getDateThreshold
      RETURN DATE
   IS
   BEGIN
      RETURN dateThreshold;
   END getDateThreshold;

   PROCEDURE setDateThreshold (date_in       IN VARCHAR2,
                               date_format   IN VARCHAR2 := 'MM/DD/YYYY')
   IS
   BEGIN
      dateThreshold := TO_DATE (date_in, date_format);
   END setDateThreshold;


   FUNCTION isInvalidDate (date_in IN DATE)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN TRUNC (date_in) < TRUNC (dateThreshold);
   END isInvalidDate;

   FUNCTION isInvalidDateYorN (date_in IN DATE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF isInvalidDate (date_in)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isInvalidDateYorN;

   PROCEDURE dateWarningMsg (date_in            IN DATE,
                             part_no            IN VARCHAR2,
                             loc_sid            IN NUMBER,
                             order_no           IN VARCHAR2,
                             date_name          IN VARCHAR2,
                             warning_location   IN NUMBER,
                             rec_status         IN VARCHAR2 := '')
   IS
   BEGIN
      warningMsg (
         pWarning_Location   => warning_location,
         key1                => part_no,
         key2                => loc_sid,
         key3                => order_no,
         msg                 =>    TO_CHAR (date_in, 'MM/DD/YYYY')
                                || ' occurs before '
                                || TO_CHAR (dateThreshold, 'MM/DD/YYYY')
                                || ' for '
                                || date_name
                                || ' '
                                || rec_status);
   END dateWarningMsg;


   /* amd_in_repair diff functions */
   FUNCTION InsertRow (PART_NO            IN VARCHAR2,
                       LOC_SID            IN NUMBER,
                       REPAIR_DATE        IN DATE,
                       REPAIR_QTY         IN NUMBER,
                       ORDER_NO           IN VARCHAR2,
                       REPAIR_NEED_DATE   IN DATE)
      RETURN NUMBER
   IS
      wk_repair_need_date   DATE := repair_need_date;
   BEGIN
      IF isInvalidDate (repair_need_date)
      THEN
         dateWarningMsg (repair_need_date,
                         part_no,
                         loc_sid,
                         order_no,
                         'amd_in_repair.repair_need_date',
                         10,
                         rec_status   => 'Date set to null');
         wk_repair_need_date := NULL;
      END IF;

      IF isInvalidDate (repair_date)
      THEN
         dateWarningMsg (repair_date,
                         part_no,
                         loc_sid,
                         order_no,
                         'amd_in_repair.repair_date',
                         20,
                         rec_status   => 'Record rejected');
         RETURN SUCCESS; -- warning allows the app to continue and will be reported later
      END IF;

     <<insertAmdInRepair>>
      DECLARE
         PROCEDURE doUpdate
         IS
         BEGIN
           <<getActionCode>>
            DECLARE
               action_code   AMD_IN_REPAIR.action_code%TYPE;
               badInsert     EXCEPTION;
            BEGIN
               SELECT action_code
                 INTO action_code
                 FROM AMD_IN_REPAIR
                WHERE     part_no = insertRow.part_no
                      AND loc_sid = insertRow.loc_sid
                      AND order_no = insertRow.order_no;

               IF action_code != Amd_Defaults.DELETE_ACTION
               THEN
                  DBMS_OUTPUT.put_line (
                        'insertRow: insertAmdInRepair: getActionCode part_no='
                     || part_no
                     || ' loc_sid='
                     || loc_sid
                     || ' repair_date='
                     || TO_CHAR (repair_date, 'MM/DD/YYYY')
                     || ' order_no='
                     || order_no
                     || ' order_need_date='
                     || TO_CHAR (repair_need_date, 'MM/DD/YYYY')
                     || ' action_code='
                     || action_code);
                  RAISE badInsert;
               END IF;
            EXCEPTION
               WHEN OTHERS
               THEN
                  errorMsg (sqlFunction       => 'select',
                            tableName         => 'amd_in_repair',
                            pError_location   => 160,
                            key1              => part_no,
                            key2              => loc_sid,
                            key3              => order_no);
            END getActionCode;

            UPDATE AMD_IN_REPAIR
               SET part_no = insertRow.part_no,
                   loc_sid = insertRow.loc_sid,
                   repair_date = insertRow.repair_date,
                   repair_qty = insertRow.repair_qty,
                   order_no = insertRow.order_no,
                   repair_need_date = insertRow.wk_repair_need_date,
                   action_code = Amd_Defaults.INSERT_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = insertRow.part_no
                   AND loc_sid = insertRow.loc_sid
                   AND order_no = insertRow.order_no;
         END doUpdate;
      BEGIN
         INSERT INTO AMD_IN_REPAIR (part_no,
                                    loc_sid,
                                    repair_date,
                                    repair_qty,
                                    order_no,
                                    repair_need_date,
                                    action_code,
                                    last_update_dt)
              VALUES (part_no,
                      loc_sid,
                      repair_date,
                      repair_qty,
                      order_no,
                      wk_repair_need_date,
                      Amd_Defaults.INSERT_ACTION,
                      SYSDATE);
      EXCEPTION
         WHEN STANDARD.DUP_VAL_ON_INDEX
         THEN
            doUpdate;
         WHEN OTHERS
         THEN
            ErrorMsg (SqlFunction       => 'insert',
                      TableName         => 'amd_in_repair',
                      pError_location   => 170,
                      key1              => part_no,
                      key2              => loc_sid,
                      key3              => order_no);
            DBMS_OUTPUT.put_line (
                  'insertAmdInRepair: part_no='
               || part_no
               || ' loc_sid='
               || loc_sid
               || ' order_no='
               || order_no
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END insertAmdInRepair;


      RETURN SUCCESS;
   END InsertRow;

   FUNCTION UpdateRow (PART_NO            IN VARCHAR2,
                       LOC_SID            IN NUMBER,
                       REPAIR_DATE        IN DATE,
                       REPAIR_QTY         IN NUMBER,
                       ORDER_NO           IN VARCHAR2,
                       REPAIR_NEED_DATE   IN DATE)
      RETURN NUMBER
   IS
      wk_repair_need_date   DATE := repair_need_date;
   BEGIN
      IF isInvalidDate (repair_need_date)
      THEN
         dateWarningMsg (repair_need_date,
                         part_no,
                         loc_sid,
                         order_no,
                         'amd_in_repair.repair_need_date',
                         10,
                         rec_status   => 'Date set to null');
         wk_repair_need_date := NULL;
      END IF;

      IF isInvalidDate (repair_date)
      THEN
         dateWarningMsg (repair_date,
                         part_no,
                         loc_sid,
                         order_no,
                         'amd_in_repair.repair_date',
                         20,
                         rec_status   => 'Record rejected');
         RETURN SUCCESS; -- warning allows the app to continue and will be reported later
      END IF;

     <<updateAmdInRepair>>
      BEGIN
         UPDATE AMD_IN_REPAIR
            SET repair_date = UpdateRow.repair_date,
                repair_qty = UpdateRow.repair_qty,
                repair_need_date = UpdateRow.wk_repair_need_date,
                action_code = Amd_Defaults.UPDATE_ACTION,
                last_update_dt = SYSDATE
          WHERE     part_no = UpdateRow.part_no
                AND loc_sid = UpdateRow.loc_sid
                AND order_no = UpdateRow.order_no;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (SqlFunction       => 'update',
                      TableName         => 'amd_in_repair',
                      pError_location   => 180,
                      key1              => part_no,
                      key2              => loc_sid,
                      key3              => order_no);
            DBMS_OUTPUT.put_line (
                  'updateRow: part_no='
               || part_no
               || ' loc_sid='
               || loc_sid
               || ' repair_date='
               || TO_CHAR (repair_date, 'MM/DD/YYYY')
               || ' repair_qty='
               || repair_qty
               || ' order_no='
               || ' repair_need_date='
               || TO_CHAR (repair_need_date, 'MM/DD/YYYY')
               || order_no
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END updateAmdInRepair;

      RETURN SUCCESS;
   END UpdateRow;

   FUNCTION inRepairDeleteRow (PART_NO    IN VARCHAR2,
                               LOC_SID    IN NUMBER,
                               ORDER_NO   IN VARCHAR2)
      RETURN NUMBER
   IS
      repair_qty         AMD_IN_REPAIR.repair_qty%TYPE;
      repair_date        AMD_IN_REPAIR.repair_date%TYPE;
      repair_need_date   AMD_IN_REPAIR.repair_need_date%TYPE;
   BEGIN
     <<updateAmdInRepair>>
      BEGIN
         UPDATE AMD_IN_REPAIR
            SET action_code = Amd_Defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE     PART_NO = inRepairDeleteRow.part_no
                AND LOC_SID = inRepairDeleteRow.LOC_SID
                AND ORDER_NO = inRepairDeleteRow.ORDER_NO;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (SqlFunction       => 'update',
                      TableName         => 'amd_in_repair',
                      pError_location   => 190,
                      key1              => part_no,
                      key2              => loc_sid,
                      key3              => order_no);
            DBMS_OUTPUT.put_line (
                  'updateAmdInRepair: part_no='
               || part_no
               || ' loc_sid='
               || loc_sid
               || ' order_no='
               || order_no
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END updateAmdInRepair;

     <<selectAmdInRepair>>
      BEGIN
         SELECT repair_qty, repair_date, repair_need_date
           INTO repair_qty, repair_date, repair_need_date
           FROM AMD_IN_REPAIR
          WHERE     part_no = inRepairDeleteRow.part_no
                AND loc_sid = inRepairDeleteRow.loc_sid
                AND order_no = inRepairDeleteRow.order_no;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (SqlFunction       => 'select',
                      TableName         => 'amd_in_repair',
                      pError_location   => 200,
                      key1              => part_no,
                      key2              => loc_sid,
                      key3              => order_no);
            DBMS_OUTPUT.put_line (
                  'selectAmdInRepair: part_no='
               || part_no
               || ' loc_sid='
               || loc_sid
               || ' order_no='
               || order_no
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END selectAmdInRepair;

      RETURN SUCCESS;
   END inRepairDeleteRow;


   /* amd_on_order diff functions */

   FUNCTION getNextLine (
      gold_order_number   IN amd_on_order.gold_order_number%TYPE)
      RETURN NUMBER
   IS
      maxLine   NUMBER;
   BEGIN
      SELECT MAX (line)
        INTO maxLine
        FROM amd_on_order
       WHERE gold_order_number = getNextLine.gold_order_number;

      IF maxLine IS NULL
      THEN
         maxLine := 0;
      END IF;

      RETURN maxLine + 1;
   END getNextLine;

   FUNCTION getCurrentLine (
      gold_order_number   IN amd_on_order.gold_order_number%TYPE,
      order_date          IN amd_on_order.order_date%TYPE,
      loc_sid             IN amd_on_order.loc_sid%TYPE)
      RETURN NUMBER
   IS
      curLine   NUMBER := NULL;
   BEGIN
      SELECT line
        INTO curLine
        FROM amd_on_order
       WHERE     gold_order_number = getCurrentLine.gold_order_number
             AND order_date = getCurrentLine.order_date
             AND loc_sid = getCurrentLine.loc_sid;

      RETURN curLine;
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction       => 'select',
                   tableName         => 'amd_on_order',
                   pError_location   => 210,
                   key1              => gold_order_number,
                   key2              => TO_CHAR (order_date, 'MM/DD/YYYY'),
                   key3              => loc_sid);
         DBMS_OUTPUT.put_line (
               'getCurrentLine: gold_order_number='
            || gold_order_number
            || ' order_date='
            || TO_CHAR (order_date, 'MM/DD/YYYY')
            || ' loc_sid='
            || loc_sid
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END getCurrentLine;

   FUNCTION insertOnOrderRow (PART_NO              IN VARCHAR2,
                              LOC_SID              IN NUMBER,
                              ORDER_DATE           IN DATE,
                              ORDER_QTY            IN NUMBER,
                              GOLD_ORDER_NUMBER    IN VARCHAR2,
                              SCHED_RECEIPT_DATE   IN DATE)
      RETURN NUMBER
   IS
      -- site_location TMP_A2A_ORDER_INFO_LINE.SITE_LOCATION%TYPE := getSiteLocation(loc_sid) ;
      nextLine   amd_on_order.line%TYPE := getNextLine (gold_order_number);


      PROCEDURE doUpdate
      IS
      BEGIN
        <<getActionCode>>
         DECLARE
            action_code   AMD_ON_ORDER.action_code%TYPE;
            badInsert     EXCEPTION;
         BEGIN
            SELECT action_code
              INTO action_code
              FROM AMD_ON_ORDER
             WHERE     gold_order_number = insertOnOrderRow.gold_order_number
                   AND order_date = insertOnOrderRow.order_date
                   AND loc_sid = insertOnOrderRow.loc_sid;

            IF action_code != Amd_Defaults.DELETE_ACTION
            THEN
               DBMS_OUTPUT.put_line (
                     'insertOnOrderRow: 1 part_no='
                  || part_no
                  || ' loc_sid='
                  || loc_sid
                  || ' order_date='
                  || TO_CHAR (order_date, 'MM/DD/YYYY')
                  || ' order_qty='
                  || order_qty
                  || ' GOLD_ORDER_NUMBER='
                  || GOLD_ORDER_NUMBER
                  || ' SCHED_RECEIPT_DATE='
                  || TO_CHAR (SCHED_RECEIPT_DATE, 'MM/DD/YYYY'));
               RAISE badInsert;
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               errorMsg (
                  sqlFunction       => 'select',
                  tableName         => 'amd_on_order',
                  pError_location   => 220,
                  key1              => gold_order_number,
                  key2              => TO_CHAR (order_date, 'MM/DD/YYYY'));
               DBMS_OUTPUT.put_line (
                     'insertOnOrderRow: 1 part_no='
                  || part_no
                  || ' loc_sid='
                  || loc_sid
                  || ' order_date='
                  || TO_CHAR (order_date, 'MM/DD/YYYY')
                  || ' order_qty='
                  || order_qty
                  || ' GOLD_ORDER_NUMBER='
                  || GOLD_ORDER_NUMBER
                  || ' SCHED_RECEIPT_DATE='
                  || TO_CHAR (SCHED_RECEIPT_DATE, 'MM/DD/YYYY')
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END getActionCode;



         UPDATE AMD_ON_ORDER
            SET part_no = insertOnOrderRow.part_no,
                order_qty = insertOnOrderRow.order_qty,
                sched_receipt_date = insertOnOrderRow.sched_receipt_date,
                action_code = Amd_Defaults.INSERT_ACTION,
                last_update_dt = SYSDATE
          WHERE     gold_order_number = insertOnOrderRow.gold_order_number
                AND order_date = insertOnOrderRow.order_date
                AND loc_sid = insertOnOrderRow.loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_on_order',
                      pError_location   => 230,
                      key1              => gold_order_number,
                      key2              => TO_CHAR (order_date, 'MM/DD/YYYY'));
      END doUpdate;
   BEGIN
     <<insertAmdOnOrder>>
      BEGIN
         INSERT INTO AMD_ON_ORDER (part_no,
                                   loc_sid,
                                   order_date,
                                   order_qty,
                                   gold_order_number,
                                   action_code,
                                   last_update_dt,
                                   sched_receipt_date,
                                   line)
              VALUES (part_no,
                      loc_sid,
                      order_date,
                      order_qty,
                      gold_order_number,
                      Amd_Defaults.INSERT_ACTION,
                      SYSDATE,
                      sched_receipt_date,
                      nextline);
      EXCEPTION
         WHEN STANDARD.DUP_VAL_ON_INDEX
         THEN
            doUpdate;
         WHEN OTHERS
         THEN
            ErrorMsg (
               SqlFunction       => 'insert',
               TableName         => 'amd_on_order',
               pError_location   => 240,
               key1              => gold_order_number,
               key2              => TO_CHAR (order_date,
                                             'MM/DD/YYYY HH:MM:SS'));
            DBMS_OUTPUT.put_line (
                  'insertAmdOnOrder: gold_order_number='
               || gold_order_number
               || ' order_date='
               || TO_CHAR (order_date, 'MM/DD/YYYY')
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END insertAmdOnOrder;



      RETURN SUCCESS;
   END insertOnOrderRow;

   FUNCTION updateOnOrderRow (PART_NO              IN VARCHAR2,
                              LOC_SID              IN NUMBER,
                              ORDER_DATE           IN DATE,
                              ORDER_QTY            IN NUMBER,
                              GOLD_ORDER_NUMBER    IN VARCHAR2,
                              SCHED_RECEIPT_DATE   IN DATE)
      RETURN NUMBER
   IS
   -- site_location TMP_A2A_ORDER_INFO_LINE.site_location%TYPE := getSiteLocation(loc_sid) ;

   BEGIN
     <<updateAmdOnOrder>>
      BEGIN
         UPDATE AMD_ON_ORDER
            SET part_no = UpdateOnOrderRow.part_no,
                order_qty = UpdateOnOrderRow.order_qty,
                action_code = Amd_Defaults.UPDATE_ACTION,
                sched_receipt_date = updateOnOrderRow.sched_receipt_date,
                last_update_dt = SYSDATE
          WHERE     gold_order_number = UpdateOnOrderRow.gold_order_number
                AND order_date = UpdateOnOrderRow.order_date
                AND loc_sid = UpdateOnOrderRow.loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (
                      pSqlFunction      => 'update',
                      pTableName        => 'amd_on_order',
                      pError_location   => 250,
                      pReturn_code      => FAILURE,
                      pKey_1            => UpdateOnOrderRow.gold_order_number,
                      pKey_2            => TO_CHAR (
                                             UpdateOnOrderRow.order_date,
                                             'MM/DD/YYYY HH:MM:SS'));
      END updateAmdOnOrder;


      RETURN SUCCESS;
   END updateOnOrderRow;

   FUNCTION deleterow (part_no             IN VARCHAR2,
                       loc_sid             IN NUMBER,
                       gold_order_number   IN VARCHAR2,
                       order_date          IN DATE)
      RETURN NUMBER
   IS
   BEGIN
     <<updateAmdOnOrder>>
      BEGIN
         UPDATE AMD_ON_ORDER
            SET action_code = Amd_Defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE     GOLD_ORDER_NUMBER = DeleteRow.gold_order_number
                AND order_date = DeleteRow.order_date
                AND loc_sid = DeleteRow.loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (
                      pSqlFunction      => 'update',
                      pTableName        => 'amd_on_order',
                      pError_location   => 260,
                      pReturn_code      => FAILURE,
                      pKey_1            => gold_order_number,
                      pKey_2            => TO_CHAR (order_date,
                                                    'MM/DD/YYYY HH:MM:SS'));
      END updateAmdOnOrder;



      RETURN SUCCESS;
   END DeleteRow;

   FUNCTION doOnHandInvsSumDiff (part_no        IN VARCHAR2,
                                 spo_location   IN VARCHAR2,
                                 qty_on_hand    IN NUMBER,
                                 action_code    IN VARCHAR2)
      RETURN NUMBER
   IS
      badActionCode   EXCEPTION;

      FUNCTION InsertRow
         RETURN NUMBER
      IS
      BEGIN
        <<insertAmdOnHandInvsSums>>
         DECLARE
            PROCEDURE doUpdate
            IS
            BEGIN
              <<getActionCode>>
               DECLARE
                  action_code   AMD_ON_HAND_INVS.action_code%TYPE;
                  badInsert     EXCEPTION;
               BEGIN
                  SELECT action_code
                    INTO action_code
                    FROM AMD_ON_HAND_INVS_SUM
                   WHERE     part_no = doOnHandInvsSumDiff.part_no
                         AND spo_location = doOnHandInvsSumDiff.spo_location;

                  IF action_code != Amd_Defaults.DELETE_ACTION
                  THEN
                     DBMS_OUTPUT.put_line (
                           'doOnHandInvsSumDiff: 1 part_no='
                        || part_no
                        || ' spo_location='
                        || spo_location
                        || ' qty_on_hand='
                        || qty_on_hand
                        || ' action_code='
                        || action_code);
                     RAISE badInsert;
                  END IF;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     errorMsg (
                        SqlFunction       => 'select',
                        TableName         => 'amd_on_hand_invs_sum',
                        pError_location   => 270,
                        key1              => doOnHandInvsSumDiff.part_no,
                        key2              => doOnHandInvsSumDiff.spo_location);
               END getActionCode;

               UPDATE AMD_ON_HAND_INVS_SUM
                  SET qty_on_hand = doOnHandInvsSumDiff.qty_on_hand,
                      action_code = Amd_Defaults.INSERT_ACTION,
                      last_update_dt = SYSDATE
                WHERE     part_no = doOnHandInvsSumDiff.part_no
                      AND spo_location = doOnHandInvsSumDiff.spo_location;
            END doUpdate;
         BEGIN
            INSERT INTO AMD_ON_HAND_INVS_SUM (part_no,
                                              spo_location,
                                              qty_on_hand,
                                              action_code,
                                              last_update_dt)
                 VALUES (part_no,
                         spo_location,
                         qty_on_hand,
                         Amd_Defaults.INSERT_ACTION,
                         SYSDATE);
         EXCEPTION
            WHEN STANDARD.DUP_VAL_ON_INDEX
            THEN
               doUpdate;
            WHEN OTHERS
            THEN
               RETURN ErrorMsg (pSqlFunction      => 'insert',
                                pTableName        => 'amd_on_hand_invs_sum',
                                pError_location   => 280,
                                pReturn_code      => FAILURE,
                                pKey_1            => part_no,
                                pKey_2            => spo_location);
         END insertAmdOnHandInvs;


         RETURN SUCCESS;
      END InsertRow;

      FUNCTION UpdateRow
         RETURN NUMBER
      IS
         -- get the detail for the summarized inv_qty
         result   NUMBER;
      BEGIN
        <<updateAmdOnHandInvs>>
         BEGIN
            UPDATE AMD_ON_HAND_INVS_SUM
               SET qty_on_hand = doOnHandInvsSumDiff.qty_on_hand,
                   action_code = Amd_Defaults.UPDATE_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = doOnHandInvsSumDiff.part_no
                   AND spo_location = doOnHandInvsSumDiff.spo_location;
         EXCEPTION
            WHEN OTHERS
            THEN
               RETURN ErrorMsg (pSqlFunction      => 'update',
                                pTableName        => 'amd_on_hand_invs_sum',
                                pError_location   => 290,
                                pReturn_code      => FAILURE,
                                pKey_1            => part_no,
                                pKey_2            => spo_location);
         END updateAmdOnHandInvs;


         RETURN SUCCESS;
      END UpdateRow;

      FUNCTION DeleteRow
         RETURN NUMBER
      IS
      BEGIN
        <<updateAmdOnHandInvs>> -- logically delete all records for the part_no and loc_sid
         BEGIN
            UPDATE AMD_ON_HAND_INVS_SUM
               SET action_code = Amd_Defaults.DELETE_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = doOnHandInvsSumDiff.part_no
                   AND spo_location = doOnHandInvsSumDiff.spo_location;
         EXCEPTION
            WHEN OTHERS
            THEN
               RETURN ErrorMsg (pSqlFunction      => 'update',
                                pTableName        => 'amd_on_hand_invs_sum',
                                pError_location   => 300,
                                pReturn_code      => FAILURE,
                                pKey_1            => part_no,
                                pKey_2            => spo_location);
         END updateAmdOnHandInvs;


         RETURN SUCCESS;
      END DeleteRow;
   BEGIN
      IF action_code = Amd_Defaults.INSERT_ACTION
      THEN
         RETURN insertRow;
      ELSIF action_code = Amd_Defaults.UPDATE_ACTION
      THEN
         RETURN updateRow;
      ELSIF action_code = Amd_Defaults.DELETE_ACTION
      THEN
         RETURN deleteRow;
      ELSE
         errorMsg (action_code,
                   'amd_on_hand_invs_sum',
                   330,
                   part_no,
                   spo_location);
         DBMS_OUTPUT.put_line (
               'doOnHandInvsSumDiff: 2 part_no='
            || part_no
            || ' spo_location='
            || spo_location
            || ' qty_on_hand='
            || qty_on_hand
            || ' action_code='
            || action_code);
         RAISE badActionCode;
         RETURN FAILURE;
      END IF;
   END doOnHandInvsSumDiff;

   /* amd_on_hand_invs diff functions */
   FUNCTION InsertRow (part_no   IN VARCHAR2,
                       loc_sid   IN NUMBER,
                       inv_qty   IN NUMBER)
      RETURN NUMBER
   IS
   BEGIN
     <<insertAmdOnHandInvs>>
      DECLARE
         PROCEDURE doUpdate
         IS
         BEGIN
           <<getActionCode>>
            DECLARE
               action_code   AMD_ON_HAND_INVS.action_code%TYPE;
               badInsert     EXCEPTION;
            BEGIN
               SELECT action_code
                 INTO action_code
                 FROM AMD_ON_HAND_INVS
                WHERE     part_no = insertRow.part_no
                      AND loc_sid = insertRow.loc_sid;

               IF action_code != Amd_Defaults.DELETE_ACTION
               THEN
                  DBMS_OUTPUT.put_line (
                        'InsertRow: part_no='
                     || insertRow.part_no
                     || ' loc_sid='
                     || insertRow.loc_sid
                     || ' inv_qty='
                     || inv_qty
                     || ' action_code='
                     || action_code);
                  RAISE badInsert;
               END IF;
            EXCEPTION
               WHEN OTHERS
               THEN
                  errorMsg (SqlFunction       => 'select',
                            TableName         => 'amd_on_hand_invs',
                            pError_location   => 310,
                            key1              => insertRow.part_no,
                            key2              => insertRow.loc_sid);
            END getActionCode;

            UPDATE AMD_ON_HAND_INVS
               SET inv_qty = insertRow.inv_qty,
                   action_code = Amd_Defaults.INSERT_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = insertRow.part_no
                   AND loc_sid = insertRow.loc_sid;
         END doUpdate;
      BEGIN
         INSERT INTO AMD_ON_HAND_INVS (part_no,
                                       loc_sid,
                                       inv_qty,
                                       action_code,
                                       last_update_dt)
              VALUES (part_no,
                      InsertRow.loc_sid,
                      inv_qty,
                      Amd_Defaults.INSERT_ACTION,
                      SYSDATE);
      EXCEPTION
         WHEN STANDARD.DUP_VAL_ON_INDEX
         THEN
            doUpdate;
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (pSqlFunction      => 'insert',
                             pTableName        => 'amd_on_hand_invs',
                             pError_location   => 320,
                             pReturn_code      => FAILURE,
                             pKey_1            => part_no,
                             pKey_2            => TO_CHAR (InsertRow.loc_sid));
      END insertAmdOnHandInvs;


      RETURN SUCCESS;
   END InsertRow;

   FUNCTION UpdateRow (part_no   IN VARCHAR2,
                       loc_sid   IN NUMBER,
                       inv_qty   IN NUMBER)
      RETURN NUMBER
   IS
      -- get the detail for the summarized inv_qty
      result   NUMBER;
   BEGIN
     <<updateAmdOnHandInvs>>
      BEGIN
         UPDATE AMD_ON_HAND_INVS
            SET inv_qty = UpdateRow.inv_qty,
                action_code = Amd_Defaults.UPDATE_ACTION,
                last_update_dt = SYSDATE
          WHERE part_no = UpdateRow.part_no AND loc_sid = UpdateRow.loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (pSqlFunction      => 'update',
                             pTableName        => 'amd_on_hand_invs',
                             pError_location   => 330,
                             pReturn_code      => FAILURE,
                             pKey_1            => part_no,
                             pKey_2            => TO_CHAR (loc_sid));
      END updateAmdOnHandInvs;


      RETURN SUCCESS;
   END UpdateRow;

   FUNCTION DeleteRow (part_no IN VARCHAR2, loc_sid IN NUMBER)
      RETURN NUMBER
   IS
   BEGIN
     <<updateAmdOnHandInvs>> -- logically delete all records for the part_no and loc_sid
      BEGIN
         UPDATE AMD_ON_HAND_INVS
            SET action_code = Amd_Defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE part_no = DeleteRow.part_no AND loc_sid = DeleteRow.loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (pSqlFunction      => 'update',
                             pTableName        => 'amd_on_hand_invs',
                             pError_location   => 340,
                             pReturn_code      => FAILURE,
                             pKey_1            => part_no,
                             pKey_2            => TO_CHAR (loc_sid));
      END updateAmdOnHandInvs;


      RETURN SUCCESS;
   END DeleteRow;

   /*amd_rsp diff functions */

   FUNCTION RspInsertRow (part_no     IN VARCHAR2,
                          loc_sid     IN NUMBER,
                          rsp_inv     IN NUMBER,
                          rsp_level   IN NUMBER)
      RETURN NUMBER
   IS
      PROCEDURE doUpdate
      IS
      BEGIN
        <<getActionCode>>
         DECLARE
            action_code   AMD_RSP.action_code%TYPE;
            badInsert     EXCEPTION;
         BEGIN
            SELECT action_code
              INTO action_code
              FROM AMD_RSP
             WHERE     part_no = RspInsertRow.part_no
                   AND loc_sid = RspInsertRow.loc_sid;

            IF action_code != Amd_Defaults.DELETE_ACTION
            THEN
               DBMS_OUTPUT.put_line (
                     'RspInsertRow: part_no='
                  || part_no
                  || ' loc_sid='
                  || loc_sid
                  || ' rsp_inv='
                  || rsp_inv
                  || 'rsp_level='
                  || rsp_level);
               RAISE badInsert;
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               errorMsg (SqlFunction       => 'select',
                         TableName         => 'amd_rsp',
                         pError_location   => 350,
                         key1              => RspInsertRow.part_no,
                         key2              => RspInsertRow.loc_sid);
               DBMS_OUTPUT.put_line (
                     'RspInsertRow: 1  part_no='
                  || part_no
                  || ' loc_sid='
                  || ' rsp_inv='
                  || rsp_inv
                  || ' rsp_level='
                  || rsp_level
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);

               RAISE;
         END getActionCode;

         UPDATE AMD_RSP
            SET rsp_inv = RspInsertRow.rsp_inv,
                rsp_level = RspInsertRow.rsp_level,
                action_code = Amd_Defaults.INSERT_ACTION,
                last_update_dt = SYSDATE
          WHERE     part_no = RspInsertRow.part_no
                AND loc_sid = RspInsertRow.loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_rsp',
                      pError_location   => 360,
                      key1              => RspInsertRow.part_no,
                      key2              => RspInsertRow.loc_sid);
      END doUpdate;
   BEGIN
     <<insertAmdRsp>>
      BEGIN
         INSERT INTO AMD_RSP (part_no,
                              loc_sid,
                              rsp_inv,
                              rsp_level,
                              action_code,
                              last_update_dt)
              VALUES (part_no,
                      RspInsertRow.loc_sid,
                      rsp_inv,
                      rsp_level,
                      Amd_Defaults.INSERT_ACTION,
                      SYSDATE);
      EXCEPTION
         WHEN STANDARD.DUP_VAL_ON_INDEX
         THEN
            doUpdate;
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (
                      pSqlFunction      => 'insert',
                      pTableName        => 'amd_rsp',
                      pError_location   => 370,
                      pReturn_code      => FAILURE,
                      pKey_1            => part_no,
                      pkey_2            => TO_CHAR (RspInsertRow.loc_sid));
      END insertAmdRsp;

      RETURN SUCCESS;
   END RspInsertRow;


   FUNCTION RspUpdateRow (part_no     IN VARCHAR2,
                          loc_sid     IN NUMBER,
                          rsp_inv     IN NUMBER,
                          rsp_level   IN NUMBER)
      RETURN NUMBER
   IS
      result   NUMBER;
   BEGIN
     <<updateAmdRsp>>
      BEGIN
         UPDATE AMD_RSP
            SET rsp_inv = RspUpdateRow.rsp_inv,
                rsp_level = RspUpdateRow.rsp_level,
                action_code = Amd_Defaults.UPDATE_ACTION,
                last_update_dt = SYSDATE
          WHERE     part_no = RspUpdateRow.part_no
                AND loc_sid = RspUpdateRow.loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (
                      pSqlFunction      => 'update',
                      pTableName        => 'amd_rsp',
                      pError_location   => 380,
                      pReturn_code      => FAILURE,
                      pKey_1            => RspUpdateRow.part_no,
                      pKey_2            => TO_CHAR (RspUpdateRow.loc_sid));
      END updateAmdRsp;

      RETURN SUCCESS;
   END RspUpdateRow;

   FUNCTION RspDeleteRow (part_no IN VARCHAR2, loc_sid IN NUMBER)
      RETURN NUMBER
   IS
   BEGIN
     <<updateAmdRsp>> -- logically delete all records for the part_no and loc_sid
      BEGIN
         UPDATE AMD_RSP
            SET action_code = Amd_Defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE     part_no = RspDeleteRow.part_no
                AND loc_sid = RspDeleteRow.loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (pSqlFunction      => 'update',
                             pTableName        => 'amd_rsp',
                             pError_location   => 390,
                             pReturn_code      => FAILURE,
                             pKey_1            => part_no,
                             pKey_2            => TO_CHAR (loc_sid));
      END updateAmdRsp;

      RETURN SUCCESS;
   END RspDeleteRow;



   /* amd_rsp_sum diff functions */

   FUNCTION doRspSumDiff (part_no         IN VARCHAR2,
                          rsp_location    IN VARCHAR2,
                          override_type   IN VARCHAR2, /* added 10/29/2007 by dse */
                          qty_on_hand     IN NUMBER,
                          rsp_level       IN NUMBER,
                          action_code     IN VARCHAR2)
      RETURN NUMBER
   IS
      badActionCode   EXCEPTION;


      PROCEDURE InsertRow
      IS
         PROCEDURE doUpdate
         IS
            action_code   AMD_RSP_SUM.action_code%TYPE;
            badInsert     EXCEPTION;
         BEGIN
           <<getActionCode>>
            BEGIN
               SELECT action_code
                 INTO action_code
                 FROM AMD_RSP_SUM
                WHERE     part_no = doRspSumDiff.part_no
                      AND rsp_location = doRspSumDiff.rsp_location
                      AND override_type = doRspSumDiff.override_type;

               IF action_code != Amd_Defaults.DELETE_ACTION
               THEN
                  DBMS_OUTPUT.put_line (
                        'doRspSumDiff: 1 part_no='
                     || part_no
                     || ' rsp_location='
                     || rsp_location
                     || ' override_type='
                     || override_type
                     || ' qty_on_hand='
                     || qty_on_hand
                     || ' rsp_level='
                     || rsp_level
                     || ' action_code='
                     || action_code);
                  RAISE badInsert;
               END IF;
            EXCEPTION
               WHEN OTHERS
               THEN
                  errorMsg (SqlFunction       => 'select',
                            TableName         => 'amd_rsp_sum',
                            pError_location   => 400,
                            key1              => doRspSumDiff.part_no,
                            key2              => doRspSumDiff.rsp_location,
                            key3              => doRspSumDiff.override_type);
                  DBMS_OUTPUT.put_line (
                        'doRspSumDiff: 2 part_no='
                     || part_no
                     || ' rsp_location='
                     || rsp_location
                     || ' override_type='
                     || override_type
                     || ' qty_on_hand='
                     || qty_on_hand
                     || ' rsp_level='
                     || rsp_level
                     || ' action_code='
                     || action_code
                     || ' sqlcode='
                     || SQLCODE
                     || ' sqlerrm='
                     || SQLERRM);
                  RAISE;
            END getActionCode;

            UPDATE AMD_RSP_SUM
               SET qty_on_hand = doRspSumDiff.qty_on_hand,
                   rsp_level = doRspSumDiff.rsp_level,
                   action_code = Amd_Defaults.INSERT_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = doRspSumDiff.part_no
                   AND rsp_location = doRspSumDiff.rsp_location
                   AND override_type = doRspSumDiff.override_type;
         END doUpdate;
      BEGIN
        <<insertAmdRspSum>>
         BEGIN
            INSERT INTO AMD_RSP_SUM (part_no,
                                     rsp_location,
                                     override_type,
                                     qty_on_hand,
                                     rsp_level,
                                     action_code,
                                     last_update_dt)
                 VALUES (part_no,
                         rsp_location,
                         override_type,
                         qty_on_hand,
                         rsp_level,
                         Amd_Defaults.INSERT_ACTION,
                         SYSDATE);
         EXCEPTION
            WHEN STANDARD.DUP_VAL_ON_INDEX
            THEN
               doUpdate;
            WHEN OTHERS
            THEN
               ErrorMsg (sqlFunction       => 'insert',
                         tableName         => 'amd_rsp_sum',
                         pError_location   => 410,
                         key1              => part_no,
                         key2              => rsp_location,
                         key3              => override_type);
               DBMS_OUTPUT.put_line (
                     'doRspSumDiff: 2 part_no='
                  || part_no
                  || ' rsp_location='
                  || rsp_location
                  || ' override_type='
                  || override_type
                  || ' qty_on_hand='
                  || qty_on_hand
                  || ' rsp_level='
                  || rsp_level
                  || ' action_code='
                  || action_code
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END insertAmdRspSum;
      END InsertRow;

      PROCEDURE UpdateRow
      IS
         -- get the detail for the summarized inv_qty
         result   NUMBER;
      BEGIN
        <<updateAmdRspSum>>
         BEGIN
            UPDATE AMD_RSP_SUM
               SET qty_on_hand = doRspSumDiff.qty_on_hand,
                   rsp_level = doRspSumDiff.rsp_level,
                   action_code = Amd_Defaults.UPDATE_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = doRspSumDiff.part_no
                   AND rsp_location = doRspSumDiff.rsp_location
                   AND override_type = doRspSumDiff.override_type;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (SqlFunction       => 'update',
                         TableName         => 'amd_rsp_sum',
                         pError_location   => 420,
                         key1              => part_no,
                         key2              => rsp_location,
                         key3              => override_type);
               DBMS_OUTPUT.put_line (
                     'doRspSumDiff: 3 part_no='
                  || part_no
                  || ' rsp_location='
                  || rsp_location
                  || ' override_type='
                  || override_type
                  || ' qty_on_hand='
                  || qty_on_hand
                  || ' rsp_level='
                  || rsp_level
                  || ' action_code='
                  || action_code
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END updateAmdRspSum;
      END UpdateRow;

      PROCEDURE DeleteRow
      IS
      BEGIN
        <<updateAmdRspSum>> -- logically delete all records for the part_no and loc_sid
         BEGIN
            UPDATE AMD_RSP_SUM
               SET action_code = Amd_Defaults.DELETE_ACTION,
                   last_update_dt = SYSDATE
             WHERE     part_no = doRspSumDiff.part_no
                   AND rsp_location = doRspSumDiff.rsp_location
                   AND override_type = doRspSumDiff.override_type;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (SqlFunction       => 'update',
                         TableName         => 'amd_rsp_sum',
                         pError_location   => 430,
                         key1              => part_no,
                         key2              => rsp_location,
                         key3              => override_type);
               DBMS_OUTPUT.put_line (
                     'doRspSumDiff: 4 part_no='
                  || part_no
                  || ' rsp_location='
                  || rsp_location
                  || ' override_type='
                  || override_type
                  || ' qty_on_hand='
                  || qty_on_hand
                  || ' rsp_level='
                  || rsp_level
                  || ' action_code='
                  || action_code
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END updateAmdRspSum;
      END DeleteRow;
   BEGIN
      IF action_code = Amd_Defaults.INSERT_ACTION
      THEN
         insertRow;
      ELSIF action_code = Amd_Defaults.UPDATE_ACTION
      THEN
         updateRow;
      ELSIF action_code = Amd_Defaults.DELETE_ACTION
      THEN
         deleteRow;
      ELSE
         errorMsg (action_code,
                   'rsp_sum',
                   331,
                   part_no,
                   rsp_location);
         DBMS_OUTPUT.put_line (
               'doRspSumDiff: 5 part_no='
            || part_no
            || ' rsp_location='
            || rsp_location
            || ' override_type='
            || override_type
            || ' qty_on_hand='
            || qty_on_hand
            || ' rsp_level='
            || rsp_level
            || ' action_code='
            || action_code
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE badActionCode;
      END IF;



      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (SqlFunction       => 'doRspSumDiff(' || action_code || ')',
                   TableName         => 'amd_rsp_sum / tmp_a2a_loc_part_override',
                   pError_Location   => 400);
         RETURN FAILURE;
   END doRspSumDiff;



   /* amd_in_transits diff functions */
   FUNCTION InsertRow (to_loc_sid         IN NUMBER,
                       quantity           IN NUMBER,
                       document_id        IN VARCHAR2,
                       part_no            IN VARCHAR2,
                       from_location      IN VARCHAR2,
                       in_transit_date    IN DATE,
                       serviceable_flag   IN VARCHAR2)
      RETURN NUMBER
   IS
      result   NUMBER;

      --site_location TMP_IN_TRANSITS_DIFF.site_location%TYPE := getSiteLocation(to_loc_sid) ;

      PROCEDURE doUpdate
      IS
      BEGIN
        <<GetActionCode>>
         DECLARE
            action_code   AMD_IN_TRANSITS.action_code%TYPE;
            badInsert     EXCEPTION;
         BEGIN
            SELECT action_code
              INTO action_code
              FROM AMD_IN_TRANSITS
             WHERE document_id = insertRow.document_id;

            IF action_code != Amd_Defaults.DELETE_ACTION
            THEN
               DBMS_OUTPUT.put_line (
                     'insertRow: to_loc_sid='
                  || to_loc_sid
                  || ' quantity='
                  || quantity
                  || ' document_id='
                  || document_id
                  || ' part_no='
                  || part_no
                  || ' from_location='
                  || from_location
                  || ' in_transit_date='
                  || TO_CHAR (in_transit_date, 'MM/DD/YYYY')
                  || ' serviceable_flag='
                  || serviceable_flag);
               RAISE badInsert;
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (sqlFunction       => 'select',
                         tableName         => 'amd_in_transits',
                         pError_location   => 440,
                         key1              => insertRow.document_id);
         END getActionCode;

         UPDATE AMD_IN_TRANSITS
            SET to_loc_sid = insertRow.to_loc_sid,
                quantity = insertRow.quantity,
                action_code = Amd_Defaults.INSERT_ACTION,
                last_update_dt = SYSDATE,
                part_no = insertRow.part_no,
                from_location = insertRow.from_location,
                in_transit_date = insertRow.in_transit_date,
                serviceable_flag = insertRow.serviceable_flag
          WHERE document_id = insertRow.document_id;
      END doUpdate;
   BEGIN
     <<insertAmdInTransits>>
      BEGIN
         INSERT INTO AMD_IN_TRANSITS (to_loc_sid,
                                      quantity,
                                      action_code,
                                      last_update_dt,
                                      document_id,
                                      part_no,
                                      from_location,
                                      in_transit_date,
                                      serviceable_flag)
              VALUES (to_loc_sid,
                      quantity,
                      Amd_Defaults.INSERT_ACTION,
                      SYSDATE,
                      document_id,
                      part_no,
                      from_location,
                      in_transit_date,
                      serviceable_flag);
      EXCEPTION
         WHEN STANDARD.DUP_VAL_ON_INDEX
         THEN
            doUpdate;
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (pSqlFunction      => 'insert',
                             pTableName        => 'amd_in_transits',
                             pError_location   => 450,
                             pReturn_code      => FAILURE,
                             pKey_1            => document_id,
                             pKey_2            => part_no,
                             pKey_3            => to_loc_sid,
                             pKey_4            => in_transit_date);
      END insertAmdInTransits;

      RETURN SUCCESS;
   END InsertRow;

   FUNCTION UpdateRow (TO_LOC_SID         IN NUMBER,
                       QUANTITY           IN NUMBER,
                       DOCUMENT_ID        IN VARCHAR2,
                       PART_NO            IN VARCHAR2,
                       FROM_LOCATION      IN VARCHAR2,
                       IN_TRANSIT_DATE    IN DATE,
                       SERVICEABLE_FLAG   IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
     <<updateAmdInTransits>>
      BEGIN
         UPDATE AMD_IN_TRANSITS
            SET quantity = UpdateRow.quantity,
                action_code = Amd_Defaults.UPDATE_ACTION,
                last_update_dt = SYSDATE,
                from_location = UpdateRow.from_location,
                in_transit_date = UpdateRow.in_transit_date
          WHERE     document_id = UpdateRow.document_id
                AND part_no = UpdateRow.part_no
                AND to_loc_sid = UpdateRow.to_loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (pSqlFunction      => 'update',
                             pTableName        => 'amd_in_transits',
                             pError_location   => 460,
                             pReturn_code      => FAILURE,
                             pKey_1            => document_id,
                             pKey_2            => part_no,
                             pKey_3            => TO_CHAR (to_loc_sid));
      END updateAmdInTransit;


      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN ErrorMsg (pSqlFunction      => 'updateRow',
                          pTableName        => 'amd_in_transits',
                          pError_location   => 470,
                          pReturn_code      => FAILURE,
                          pKey_1            => part_no);
   END UpdateRow;

   FUNCTION DeleteRow (DOCUMENT_ID   IN VARCHAR2,
                       PART_NO       IN VARCHAR2,
                       TO_LOC_SID    IN NUMBER)
      RETURN NUMBER
   IS
      quantity          AMD_IN_TRANSITS.quantity%TYPE;
      from_location     AMD_IN_TRANSITS.from_location%TYPE;
      in_transit_date   AMD_IN_TRANSITS.in_transit_date%TYPE;
   BEGIN
     <<updateAmdInTransit>>
      BEGIN
         UPDATE AMD_IN_TRANSITS
            SET quantity = DeleteRow.quantity,
                from_location = DeleteRow.from_location,
                in_transit_date = DeleteRow.in_transit_date,
                action_code = Amd_Defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE     DOCUMENT_ID = DeleteRow.DOCUMENT_ID
                AND PART_NO = Deleterow.PART_NO
                AND TO_LOC_SID = DeleteRow.TO_LOC_SID;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (pSqlFunction      => 'update',
                             pTableName        => 'amd_in_transits',
                             pError_location   => 480,
                             pReturn_code      => FAILURE,
                             pKey_1            => document_id,
                             pKey_2            => part_no,
                             pKey_3            => TO_CHAR (to_loc_sid));
      END updateAmdInTransit;

     <<selectAmdInTransit>>
      BEGIN
         SELECT quantity, from_location, in_transit_date
           INTO quantity, from_location, in_transit_date
           FROM AMD_IN_TRANSITS
          WHERE     document_id = DeleteRow.document_id
                AND part_no = DeleteRow.part_no
                AND to_loc_sid = DeleteRow.to_loc_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            RETURN ErrorMsg (pSqlFunction      => 'select',
                             pTableName        => 'amd_in_transits',
                             pError_location   => 490,
                             pReturn_code      => FAILURE,
                             pKey_1            => document_id,
                             pKey_2            => part_no,
                             pKey_3            => TO_CHAR (to_loc_sid));
      END selectAmdInTransit;

      RETURN SUCCESS;
   END DeleteRow;

   FUNCTION InsertRow (part_no            IN VARCHAR2,
                       site_location      IN VARCHAR2,
                       quantity           IN NUMBER,
                       serviceable_flag   IN VARCHAR2)
      RETURN NUMBER
   IS
      result   NUMBER;

      FUNCTION doUpdate
         RETURN NUMBER
      IS
         action_code   AMD_IN_TRANSITS_SUM.action_code%TYPE;
         badInsert     EXCEPTION;
      BEGIN
         UPDATE AMD_IN_TRANSITS_SUM
            SET quantity = InsertRow.quantity,
                action_code = Amd_Defaults.INSERT_ACTION,
                last_update_dt = SYSDATE
          WHERE     part_no = InsertRow.part_no
                AND site_location = InsertRow.site_location
                AND serviceable_flag = InsertRow.serviceable_flag;

         RETURN SUCCESS;
      EXCEPTION
         WHEN OTHERS
         THEN
            result :=
               ErrorMsg (pSqlFunction      => 'update',
                         pTableName        => 'amd_in_transits_sum',
                         pError_location   => 500,
                         pReturn_code      => FAILURE,
                         pKey_1            => part_no,
                         pKey_2            => site_location,
                         pKey_3            => serviceable_flag);
            DBMS_OUTPUT.put_line (
                  'insertRow: 1 part_no='
               || part_no
               || ' site_location='
               || site_location
               || ' quantity='
               || quantity
               || ' serviceable_flag='
               || serviceable_flag
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END doUpdate;
   BEGIN
      IF (quantity > 0)
      THEN
         BEGIN
            INSERT INTO AMD_IN_TRANSITS_SUM (part_no,
                                             site_location,
                                             quantity,
                                             serviceable_flag,
                                             action_code,
                                             last_update_dt)
                 VALUES (InsertRow.part_no,
                         InsertRow.site_location,
                         InsertRow.quantity,
                         InsertRow.serviceable_flag,
                         Amd_Defaults.INSERT_ACTION,
                         SYSDATE);
         EXCEPTION
            WHEN STANDARD.DUP_VAL_ON_INDEX
            THEN
               result := doUpdate;
            WHEN OTHERS
            THEN
               result :=
                  ErrorMsg (pSqlFunction      => 'insert',
                            pTableName        => 'amd_in_transits_sum',
                            pError_location   => 510,
                            pReturn_code      => FAILURE,
                            pKey_1            => part_no,
                            pKey_2            => site_location,
                            pKey_3            => serviceable_flag,
                            pKey_4            => quantity);
               DBMS_OUTPUT.put_line (
                     'insertRow: 1 part_no='
                  || part_no
                  || ' site_location='
                  || site_location
                  || ' quantity='
                  || quantity
                  || ' serviceable_flag='
                  || serviceable_flag
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END insertAmdIntransitSum;
      -- END IF ;

      END IF;

      RETURN SUCCESS;
   END InsertRow;

   FUNCTION UpdateRow (part_no            IN VARCHAR2,
                       site_location      IN VARCHAR2,
                       quantity           IN NUMBER,
                       serviceable_flag   IN VARCHAR2)
      RETURN NUMBER
   IS
      result   NUMBER;
   BEGIN
     <<updateAmdInTransitsSum>>
      BEGIN
         UPDATE AMD_IN_TRANSITS_SUM
            SET quantity = UpdateRow.quantity,
                action_code = Amd_Defaults.UPDATE_ACTION,
                last_update_dt = SYSDATE
          WHERE     part_no = UpdateRow.part_no
                AND site_location = UpdateRow.site_location
                AND serviceable_flag = updateRow.serviceable_flag;
      END updateAmdInTransitsSum;

      RETURN SUCCESS;
   END UpdateRow;

   FUNCTION DeleteRow (part_no            IN VARCHAR2,
                       site_location      IN VARCHAR2,
                       serviceable_flag   IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
     <<updateAmdInTransits>>
      BEGIN
         UPDATE AMD_IN_TRANSITS_SUM
            SET action_code = Amd_Defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE     part_no = DeleteRow.part_no
                AND site_location = DeleteRow.site_location
                AND serviceable_flag = DeleteRow.serviceable_flag;
      END updateAmdInTransits;

      RETURN SUCCESS;
   END DeleteRow;

   PROCEDURE loadOnHandInvs
   IS
      nsnDashed           VARCHAR2 (16) := NULL;
      invQty              NUMBER := 0;
      cntOnHandInvs       NUMBER := 0;
      cntType1            NUMBER := 0;
      cntType2            NUMBER := 0;
      result              NUMBER := 0;
      cntType1WholeSale   NUMBER := 0;


      CURSOR onHandCur (
         pNsn       VARCHAR2,
         pPartNo    VARCHAR2)
      IS
         SELECT pPartNo part_no,
                DECODE (n.loc_type, 'TMP', asn2.loc_sid, n.loc_sid) loc_sid,
                TRUNC (NVL (r.date_processed, SYSDATE)) inv_date,
                NVL (r.serviceable_balance, 0) + NVL (r.difm_balance, 0)
                   inv_qty,
                amd_defaults.getINSERT_ACTION action_code,
                SYSDATE last_update_dt
           FROM (SELECT *
                   FROM RAMP
                  WHERE current_stock_number = pNsn) r,
                --AMD_SPARE_PARTS asp,
                AMD_SPARE_NETWORKS n,
                AMD_SPARE_NETWORKS asn2
          WHERE     n.loc_id = r.sran(+)
                --AND asp.nsn = pNsn
                AND n.loc_type IN ('MOB', 'FSL', 'UAB')
                AND n.loc_type NOT IN ('KIT')
                AND n.mob = asn2.loc_id(+)
                AND (NVL (r.serviceable_balance, 0) + NVL (r.difm_balance, 0)) >
                       0;

      -- Type 1 Wholesale from ITEM and TMP1
      CURSOR itemType1Cur
      IS
           SELECT asp.part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid)
                     loc_sid,
                  invQ.inv_date inv_date,
                  SUM (invQ.inv_qty) inv_qty,
                  amd_defaults.getINSERT_ACTION action_code,
                  SYSDATE last_update_dt
             FROM (  SELECT part part_no,
                            SUBSTR (i.sc, 8, 6) loc_id,
                            TRUNC (
                               DECODE (i.created_datetime,
                                       NULL, i.last_changed_datetime,
                                       i.created_datetime))
                               inv_date,
                            '1' inv_type,
                            SUM (NVL (i.qty, 0)) inv_qty
                       FROM ITEM i
                      WHERE     i.status_3 != 'I'
                            AND SUBSTR (i.sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                            AND SUBSTR (i.sc, LENGTH (i.sc), 1) IN ('G')
                            AND i.status_servicable = 'Y'
                            AND i.status_new_order = 'N'
                            AND i.status_accountable = 'Y'
                            AND i.status_active = 'Y'
                            AND i.status_mai = 'N'
                            AND i.condition != 'B170-ATL'
                            AND NOT EXISTS
                                   (SELECT 1
                                      FROM ITEM ii
                                     WHERE     ii.status_avail = 'N'
                                           AND NVL (ii.receipt_order_no, '-1') =
                                                  '-1'
                                           AND ii.item_id = i.item_id)
                   GROUP BY part,
                            SUBSTR (i.sc, 8, 6),
                            TRUNC (
                               DECODE (i.created_datetime,
                                       NULL, i.last_changed_datetime,
                                       i.created_datetime))
                   UNION
                   (  SELECT part part_no,
                             DECODE (i.sc,
                                     PROGRAM_ID || 'PCAG', 'EY1746',
                                     'SATCAA0001' || PROGRAM_ID || 'G', 'EY1746')
                                loc_id,
                             TRUNC (
                                DECODE (i.created_datetime,
                                        NULL, i.last_changed_datetime,
                                        i.created_datetime))
                                inv_date,
                             '1' inv_type,
                             SUM (NVL (i.qty, 0)) inv_qty
                        FROM ITEMSA i
                       WHERE     i.status_3 != 'I'
                             AND i.status_servicable = 'Y'
                             AND i.status_new_order = 'N'
                             AND i.status_accountable = 'Y'
                             AND i.status_active = 'Y'
                             AND i.status_mai = 'N'
                             AND i.condition != 'B170-ATL'
                             AND NOT EXISTS
                                    (SELECT 1
                                       FROM ITEMSA ii
                                      WHERE     ii.status_avail = 'N'
                                            AND NVL (ii.receipt_order_no, '-1') =
                                                   '-1'
                                            AND ii.item_id = i.item_id)
                    GROUP BY part,
                             DECODE (
                                i.sc,
                                PROGRAM_ID || 'PCAG', 'EY1746',
                                'SATCAA0001' || PROGRAM_ID || 'G', 'EY1746'),
                             TRUNC (
                                DECODE (i.created_datetime,
                                        NULL, i.last_changed_datetime,
                                        i.created_datetime)))) invQ,
                  AMD_SPARE_NETWORKS asn,
                  AMD_SPARE_PARTS asp,
                  AMD_SPARE_NETWORKS asnLink
            WHERE     asp.part_no = invQ.part_no
                  AND asn.loc_id = invQ.loc_id
                  AND asn.loc_type != 'KIT'
                  AND asp.action_code != 'D'
                  AND asn.mob = asnLink.loc_id(+)
         GROUP BY asp.part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid),
                  invQ.inv_date
           HAVING SUM (invQ.inv_qty) > 0;

      onHandCnt           NUMBER := 0;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_on_hand_invs',
         pError_location   => 520,
         pKey1             => 'loadOnHandInvs',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
      DBMS_OUTPUT.put_line (
            'loadOnHandInvs started at '
         || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MM:SS'));
      Mta_Truncate_Table ('TMP_AMD_ON_HAND_INVS', 'reuse storage');

      OPEN partCur;

      FETCH partCur BULK COLLECT INTO partRecs;

      CLOSE partCur;

      IF partRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN partRecs.FIRST .. partRecs.LAST
         LOOP
            nsnDashed := Amd_Utils.FormatNsn (partRecs (indx).nsn, 'GOLD');

            --
            -- For each part, extract inventory data from ramp and item tables.
            --
            OPEN onHandCur (nsnDashed, partRecs (indx).part_no);

            FETCH onHandCur BULK COLLECT INTO tmpAmdOnHandInvsRecs;

            CLOSE onHandCur;

            IF tmpAmdOnHandInvsRecs.FIRST IS NOT NULL
            THEN
               FORALL yDex
                   IN tmpAmdOnHandInvsRecs.FIRST .. tmpAmdOnHandInvsRecs.LAST
                  INSERT INTO tmp_amd_on_hand_invs
                       VALUES tmpAmdOnHandInvsRecs (yDex);
            END IF;

            onHandCnt := onHandCnt + SQL%ROWCOUNT;
         END LOOP f77PartLoop;

         writeMsg (
            pTableName        => 'tmp_amd_on_hand_invs',
            pError_location   => 530,
            pKey1             => 'loadOnHandInvs.f77PartLoop',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# of rows=' || TO_CHAR (onHandCnt));
         COMMIT;
         DBMS_OUTPUT.put_line (
            'loadOnHandInvs: rows inserted to tmp_on_hand_invs ' || onHandCnt);
      END IF;


      OPEN itemType1Cur;

      FETCH itemType1Cur BULK COLLECT INTO tmpAmdOnHandInvsRecs;

      CLOSE itemType1Cur;


      IF tmpAmdOnHandInvsRecs.FIRST IS NOT NULL
      THEN
         FORALL indx
             IN tmpAmdOnHandInvsRecs.FIRST .. tmpAmdOnHandInvsRecs.LAST
            -- Type 1
            INSERT INTO tmp_amd_on_hand_invs
                 VALUES tmpAmdOnHandInvsRecs (indx);

         writeMsg (
            pTableName        => 'tmp_amd_on_hand_invs',
            pError_location   => 540,
            pKey1             => 'type1WholeSale',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# of rows=' || TO_CHAR (SQL%ROWCOUNT));
         COMMIT;
      END IF;


      writeMsg (
         pTableName        => 'tmp_amd_on_hand_invs',
         pError_location   => 550,
         pKey1             => 'loadOnHandInvs',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pkey3             => TO_CHAR (cntOnHandInvs),
         pkey4             => TO_CHAR (cntType1),
         pData             => TO_CHAR (cntType1WholeSale));
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'select',
                   tableName         => 'tmp_amd_on_hand_invs',
                   pError_Location   => 520);
         DBMS_OUTPUT.put_line (
               'loadOnHandInvs: cntOnHandInvs='
            || cntOnHandInvs
            || ' cntType1='
            || cntType1
            || ' cntType1WholeSale='
            || cntType1WholeSale);
         RAISE;
   END loadOnHandInvs;

   PROCEDURE loadInRepair
   IS
      nsnDashed              VARCHAR2 (16) := NULL;
      invQty                 NUMBER := 0;
      cntType2               NUMBER := 0;
      cntInRepair            NUMBER := 0;
      result                 NUMBER := 0;
      cntType4WholeSale      NUMBER := 0;
      cntTypeBASCWholeSale   NUMBER := 0;
      cntType5WholeSale      NUMBER := 0;

      TYPE tmpAmdInRepairTab IS TABLE OF tmp_amd_in_repair%ROWTYPE;

      tmpAmdInRepairRecs     tmpAmdInRepairTab;


      CURSOR inRepairCur (
         pNsn       VARCHAR2,
         pPartNo    VARCHAR2)
      IS
         SELECT pPartNo,
                DECODE (n.loc_type, 'TMP', asn2.loc_sid, n.loc_sid) loc_sid,
                TRUNC (NVL (r.date_processed, SYSDATE)) inv_date,
                  NVL (r.unserviceable_balance, 0)
                + NVL (r.suspended_in_stock, 0)
                   inv_qty,
                'Retail' order_no,
                TRUNC ( (r.date_processed) + NVL (avg_repair_cycle_time, 0))
                   repair_need_date,
                amd_defaults.INSERT_ACTION action_code,
                SYSDATE last_update_dt
           FROM (SELECT *
                   FROM RAMP
                  WHERE current_stock_number = pNsn) r,
                --AMD_SPARE_PARTS asp,
                AMD_SPARE_NETWORKS n,
                AMD_SPARE_NETWORKS asn2
          WHERE     n.loc_id = r.sran(+)
                --AND asp.nsn = pNsn
                AND n.loc_type IN ('MOB', 'FSL', 'UAB')
                AND n.mob = asn2.loc_id(+)
                AND (  NVL (r.unserviceable_balance, 0)
                     + NVL (r.suspended_in_stock, 0)) > 0;

      -- Type 4 Wholesale
      CURSOR itemMCur
      IS
           SELECT asp.part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid)
                     loc_sid,
                  TRUNC (i.created_datetime) inv_date,
                  SUM (NVL (i.qty, 0)) inv_qty,
                  i.item_id item_id,
                  TRUNC (i.created_datetime + ansi.time_to_repair_off_base)
                     repair_need_date,
                  amd_defaults.getINSERT_ACTION action_code,
                  SYSDATE last_update_dt
             FROM ITEM i,
                  AMD_NATIONAL_STOCK_ITEMS ansi,
                  AMD_SPARE_NETWORKS asn,
                  AMD_SPARE_PARTS asp,
                  AMD_SPARE_NETWORKS asnLink
            WHERE     asp.part_no = i.part
                  AND i.prime = ansi.prime_part_no
                  AND ansi.nsn = asp.nsn
                  AND i.status_3 != 'I'
                  AND SUBSTR (i.sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                  AND SUBSTR (i.sc, LENGTH (i.sc), 1) IN ('G')
                  AND i.status_servicable = 'N'
                  AND i.status_new_order = 'N'
                  AND i.status_accountable = 'Y'
                  AND i.status_active = 'Y'
                  AND i.status_mai = 'N'
                  AND asn.loc_id = i.loc_id
                  AND asp.action_code != 'D'
                  AND asn.mob = asnLink.loc_id(+)
                  AND asn.loc_type <> 'KIT'
                  AND i.created_datetime IS NOT NULL
         GROUP BY asp.part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid),
                  i.item_id,
                  DECODE (i.created_datetime,
                          NULL, TRUNC (i.last_changed_datetime),
                          TRUNC (i.created_datetime)),
                  TRUNC (i.created_datetime),
                  TRUNC (i.created_datetime + ansi.time_to_repair_off_base)
           HAVING SUM (NVL (i.qty, 0)) > 0;

      inRepairCnt            NUMBER := 0;

      CURSOR itemACur
      IS
           SELECT asp.part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid)
                     loc_sid,
                  TRUNC (i.created_datetime) repair_date,
                  SUM (NVL (i.qty, 0)) inv_qty,
                  i.item_id item_id,
                  TRUNC (
                     i.created_datetime + NVL (ansi.time_to_repair_off_base, 0))
                     repair_need_date,
                  amd_defaults.getINSERT_ACTION action_code,
                  SYSDATE last_update_dt
             FROM ITEMSA i,
                  AMD_NATIONAL_STOCK_ITEMS ansi,
                  AMD_SPARE_NETWORKS asn,
                  AMD_SPARE_PARTS asp,
                  AMD_SPARE_NETWORKS asnLink
            WHERE     asp.part_no = i.part
                  AND i.prime = ansi.prime_part_no
                  AND ansi.nsn = asp.nsn
                  AND i.status_3 != 'I'
                  AND i.status_servicable = 'N'
                  AND i.status_new_order = 'N'
                  AND i.status_accountable = 'Y'
                  AND i.status_active = 'Y'
                  AND i.status_mai = 'N'
                  AND i.created_datetime IS NOT NULL
                  AND asn.loc_id = 'EY1746'
                  AND asn.loc_type <> 'KIT'
                  AND asp.action_code != 'D'
                  AND asn.mob = asnLink.loc_id(+)
         GROUP BY asp.part_no,
                  DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid),
                  i.item_id,
                  DECODE (i.created_datetime,
                          NULL, TRUNC (i.last_changed_datetime),
                          TRUNC (i.created_datetime)),
                  TRUNC (i.created_datetime),
                  TRUNC (
                       i.created_datetime
                     + NVL (ansi.time_to_repair_off_base, 0))
           HAVING SUM (NVL (i.qty, 0)) > 0;

      CURSOR itemType5Cur
      IS
         SELECT DISTINCT
                asp.part_no,
                DECODE (asn.loc_type, 'TMP', asnLink.loc_sid, asn.loc_sid)
                   loc_sid,
                o.created_datetime inv_date,
                NVL (o.qty_due, 0) inv_qty,
                o.order_no order_no,
                DECODE (ov.vendor_est_ret_date,
                        NULL, o.ecd,
                        ov.vendor_est_ret_date)
                   repair_need_date,
                amd_defaults.getINSERT_ACTION action_code,
                SYSDATE last_update_dt
           FROM ORD1 o,
                ORDV ov,
                amd_sc_inclusions,
                AMD_SPARE_NETWORKS asn,
                AMD_SPARE_PARTS asp,
                AMD_SPARE_NETWORKS asnLink
          WHERE     o.order_no = ov.order_no
                AND asp.part_no = o.part
                AND o.status IN ('O', 'U')
                AND o.order_type = 'J'
                AND o.accountable_yn = 'Y'
                AND SUBSTR (o.sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                AND (   SUBSTR (o.sc, LENGTH (o.sc), 1) = 'G'
                     OR o.loc_id = SUBSTR (include_sc, START_LOC_ID, 6))
                AND asn.loc_id = o.loc_id
                AND asn.loc_type <> 'KIT'
                AND asp.action_code != 'D'
                AND asn.mob = asnLink.loc_id(+)
                AND o.created_datetime IS NOT NULL
                AND NVL (o.qty_due, 0) > 0;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_in_repair',
         pError_location   => 560,
         pKey1             => 'loadInRepair',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
      Mta_Truncate_Table ('TMP_AMD_IN_REPAIR', 'reuse storage');

      OPEN partCur;

      FETCH partCur BULK COLLECT INTO partRecs;

      CLOSE partCur;

      IF partRecs.FIRST IS NOT NULL
      THEN
        <<f77PartLoop>>
         FOR indx IN partRecs.FIRST .. partRecs.LAST
         LOOP
            nsnDashed := Amd_Utils.FormatNsn (partRecs (indx).nsn, 'GOLD');

            --
            -- For each part, extract inventory data from ramp and item tables.
            --
            OPEN inRepairCur (nsnDashed, partRecs (indx).part_no);

            FETCH inRepairCur BULK COLLECT INTO tmpAmdInRepairRecs;

            CLOSE inRepairCur;

            IF tmpAmdInRepairRecs.FIRST IS NOT NULL
            THEN
               FORALL yDex
                   IN tmpAmdInRepairRecs.FIRST .. tmpAmdInRepairRecs.LAST
                  -- type 2
                  INSERT INTO TMP_AMD_IN_REPAIR
                       VALUES tmpAmdInRepairRecs (yDex);
            END IF;

            inRepairCnt := inRepairCnt + SQL%ROWCOUNT;
         END LOOP f77PartLoop;

         writeMsg (
            pTableName        => 'tmp_amd_on_hand_invs',
            pError_location   => 570,
            pKey1             => 'loadInRepair.f77PartLoop',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# recs = ' || TO_CHAR (inRepairCnt));
         DBMS_OUTPUT.PUT_LINE (
               'loadInRepair: inserted rows to tmp_amd_in_repair from inRepairCur '
            || inRepairCnt);
         COMMIT;
      END IF;

      OPEN itemMCur;

      FETCH itemMcur BULK COLLECT INTO tmpAmdInRepairRecs;

      CLOSE itemMcur;

      IF tmpAmdInRepairRecs.FIRST IS NOT NULL
      THEN
         FORALL indx IN tmpAmdInRepairRecs.FIRST .. tmpAmdInRepairRecs.LAST
            -- Type 4
            INSERT INTO TMP_AMD_IN_REPAIR
                 VALUES tmpAmdInRepairRecs (indx);

         DBMS_OUTPUT.PUT_LINE (
               'loadInRepair: insert rows int tmp_amd_in_repair from itemMcur '
            || SQL%ROWCOUNT);
         writeMsg (
            pTableName        => 'tmp_amd_on_hand_invs',
            pError_location   => 580,
            pKey1             => 'loadInRepair.type4WholeSale',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# of recs = ' || TO_CHAR (SQL%ROWCOUNT));
         COMMIT;
      END IF;

      OPEN itemAcur;

      FETCH itemAcur BULK COLLECT INTO tmpAmdInRepairRecs;

      CLOSE itemAcur;

      IF tmpAmdInRepairRecs.FIRST IS NOT NULL
      THEN
         --typeBASCWholeSale
         FORALL indx IN tmpAmdInRepairRecs.FIRST .. tmpAmdInRepairRecs.LAST
            INSERT INTO TMP_AMD_IN_REPAIR
                 VALUES tmpAmdInRepairRecs (indx);

         DBMS_OUTPUT.PUT_LINE (
               'loadInRepair: insert rows int tmp_amd_in_repair from itemAcur '
            || SQL%ROWCOUNT);
         writeMsg (
            pTableName        => 'tmp_amd_on_hand_invs',
            pError_location   => 590,
            pKey1             => 'loadInRepair.typeBASCWholeSale',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# of recs = ' || TO_CHAR (SQL%ROWCOUNT));
         COMMIT;
      END IF;

      OPEN itemType5Cur;

      FETCH itemType5Cur BULK COLLECT INTO tmpAmdInRepairRecs;

      CLOSE itemType5Cur;

      IF tmpAmdInRepairRecs.FIRST IS NOT NULL
      THEN
         -- itemType5WholeSale
         FORALL indx IN tmpAmdInRepairRecs.FIRST .. tmpAmdInRepairRecs.LAST
            INSERT INTO TMP_AMD_IN_REPAIR
                 VALUES tmpAmdInRepairRecs (indx);

         DBMS_OUTPUT.PUT_LINE (
               'loadInRepair: insert rows int tmp_amd_in_repair from itemType5Cur '
            || SQL%ROWCOUNT);

         writeMsg (
            pTableName        => 'tmp_amd_on_hand_invs',
            pError_location   => 600,
            pKey1             => 'loadInRepair.itemType5WholeSale',
            pKey2             =>    'loaded at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'),
            pKey3             => '# of recs = ' || TO_CHAR (SQL%ROWCOUNT));
         COMMIT;
      END IF;

      writeMsg (
         pTableName        => 'tmp_amd_in_repair',
         pError_location   => 610,
         pKey1             => 'loadInRepair',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'select',
                   tableName         => 'tmp_amd_in_repair',
                   pError_Location   => 580);
         DBMS_OUTPUT.put_line (
            'loadInRepair: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM);
         RAISE;
   END loadInRepair;


   PROCEDURE updateSpoTotalInventory
   IS
      CURSOR partCur
      IS
         SELECT DISTINCT prime_part_no
           FROM AMD_NATIONAL_STOCK_ITEMS ansi, AMD_SPARE_PARTS asp
          WHERE ansi.nsn = asp.nsn AND ansi.action_code != 'D';

      TYPE spoInvRec IS RECORD
      (
         nsn        amd_national_stock_items.nsn%TYPE,
         quantity   NUMBER
      );

      TYPE spoInvTab IS TABLE OF spoInvRec;

      spoInvRecs   spoInvTab;

      CURSOR totalSpoInvCur
      IS
           SELECT ansi.nsn, SUM (qty) quantity
             FROM (SELECT a.part_no, quantity qty, nsn
                     FROM AMD_IN_TRANSITS a,
                          AMD_SPARE_NETWORKS asn,
                          AMD_SPARE_PARTS asp
                    WHERE     asn.loc_sid = a.to_loc_sid
                          AND a.part_no = asp.part_no
                          AND asp.action_code IN ('A', 'C')
                          AND a.action_code != 'D'
                          AND asn.action_code != 'D'
                          AND asn.spo_location IS NOT NULL
                   UNION ALL
                   SELECT a.part_no, order_qty qty, asp.nsn
                     FROM AMD_ON_ORDER a,
                          AMD_SPARE_NETWORKS asn,
                          AMD_SPARE_PARTS asp
                    WHERE     asn.loc_sid = a.loc_sid
                          AND a.part_no = asp.part_no
                          AND asp.action_code IN ('A', 'C')
                          AND a.action_code != 'D'
                          AND asn.action_code != 'D'
                          AND asn.spo_location IS NOT NULL
                   UNION ALL
                   SELECT a.part_no, inv_qty qty, asp.nsn
                     FROM AMD_ON_HAND_INVS a,
                          AMD_SPARE_NETWORKS asn,
                          AMD_SPARE_PARTS asp
                    WHERE     asn.loc_sid = a.loc_sid
                          AND a.part_no = asp.part_no
                          AND asp.action_code IN ('A', 'C')
                          AND a.action_code != 'D'
                          AND asn.action_code != 'D'
                          AND asn.spo_location IS NOT NULL
                   UNION ALL
                   SELECT a.part_no, repair_qty qty, asp.nsn
                     FROM AMD_IN_REPAIR a,
                          AMD_SPARE_NETWORKS asn,
                          AMD_SPARE_PARTS asp
                    WHERE     asn.loc_sid = a.loc_sid
                          AND a.part_no = asp.part_no
                          AND asp.action_code IN ('A', 'C')
                          AND a.action_code != 'D'
                          AND asn.action_code != 'D'
                          AND asn.spo_location IS NOT NULL
                   UNION ALL
                   SELECT a.part_no, rsp_inv qty, asp.nsn
                     FROM AMD_RSP a,
                          AMD_SPARE_NETWORKS asn,
                          AMD_SPARE_PARTS asp
                    WHERE     asn.loc_sid = a.loc_sid
                          AND a.part_no = asp.part_no
                          AND asp.action_code IN ('A', 'C')
                          AND a.action_code != 'D'
                          AND asn.action_code != 'D'
                          AND asn.spo_location IS NOT NULL) qtyQ,
                  AMD_NATIONAL_STOCK_ITEMS ansi
            WHERE ansi.nsn = qtyQ.nsn
         GROUP BY ansi.nsn;
   BEGIN
      DBMS_OUTPUT.put_line (
            'updateSpoTotalInventory started at '
         || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MM:SS'));

      BEGIN
         UPDATE AMD_NATIONAL_STOCK_ITEMS
            SET spo_total_inventory = NULL
          WHERE spo_total_inventory IS NOT NULL;
      END;

     <<primePartLoop>>
      -- FOR rec IN partCur LOOP
      OPEN totalSpoInvCur;

      FETCH totalSpoInvCur BULK COLLECT INTO spoInvRecs;

      CLOSE totalSpoInvCur;

      IF spoInvRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN spoInvRecs.FIRST .. spoInvRecs.LAST
         LOOP
            -- dbms_output.put_line('part_no=' || rampRecs(yDex).prime_part_no ); --' qty = ' || rampRecs(yDex).quantity) ;
            BEGIN
               UPDATE AMD_NATIONAL_STOCK_ITEMS
                  SET spo_total_inventory = spoInvRecs (indx).quantity
                WHERE nsn = spoInvRecs (indx).nsn AND action_code != 'D';
            END;
         END LOOP totalSpoInvLoop;
      END IF;

      --END LOOP partCur ;
      DBMS_OUTPUT.put_line (
            'updateSpoTotalInventory ended at '
         || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MM:SS'));
   END updateSpoTotalInventory;

   -- added 9/2/2005
   FUNCTION getParamDate (rawData      IN AMD_PARAM_CHANGES.PARAM_VALUE%TYPE,
                          typeOfDate   IN orderdates)
      RETURN DATE
   IS
      paramDate   DATE;
      params      Amd_Utils.arrayOfWords := Amd_Utils.arrayOfWords ();
      cnt         NUMBER;
   BEGIN
      params := Amd_Utils.splitString (rawData);
      cnt := params.COUNT ();

      IF params.COUNT () > 0
      THEN
         paramDate := TO_DATE (params (typeOfDate), 'MM/DD/YYYY');
      END IF;

      RETURN paramDate;
   END getParamDate;

   PROCEDURE setParamDate (voucher      IN VARCHAR2,
                           theDate      IN DATE,
                           typeOfDate   IN orderdates)
   IS
      params   Amd_Utils.arrayOfwords;
   BEGIN
      params :=
         Amd_Utils.splitString (
            Amd_Defaults.getParamValue (ON_ORDER_DATE || voucher));

      IF params.COUNT () > 0
      THEN
         params (typeOfDate) := theDate;
      END IF;

      Amd_Defaults.setParamValue (LOWER (ON_ORDER_DATE || voucher),
                                  Amd_Utils.joinString (params));
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         Amd_Defaults.setParamValue (LOWER ('on_order_date' || voucher),
                                     NULL);
   END setParamDate;

   FUNCTION getOrderCreateDate (voucher IN VARCHAR2)
      RETURN DATE
   IS
   BEGIN
      RETURN getParamDate (
                Amd_Defaults.GetParamValue (LOWER (ON_ORDER_DATE || voucher)),
                ORDER_CREATE_DATE);
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN NULL;
   END getOrderCreateDate;


   PROCEDURE setOrderCreateDate (voucher           IN VARCHAR2,
                                 orderCreateDate   IN DATE)
   IS
      theDate   VARCHAR2 (10) := TO_CHAR (orderCreateDate, 'MM/DD/YYYY');
      pos       NUMBER;
      rawData   AMD_PARAM_CHANGES.PARAM_VALUE%TYPE;
      params    Amd_Utils.arrayOfWords;
   BEGIN
      setParamDate (voucher, orderCreateDate, ORDER_CREATE_DATE);
   END setOrderCreateDate;

   FUNCTION getScdeduledReceiptDateFrom (voucher IN VARCHAR2)
      RETURN DATE
   IS
   BEGIN
      RETURN getParamDate (
                Amd_Defaults.GetParamValue (LOWER (ON_ORDER_DATE || voucher)),
                SCHEDULED_RECEIPT_DATE_FROM);
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN NULL;
   END getScdeduledReceiptDateFrom;

   FUNCTION getScdeduledReceiptDateTo (voucher IN VARCHAR2)
      RETURN DATE
   IS
   BEGIN
      RETURN getParamDate (
                Amd_Defaults.GetParamValue (LOWER (ON_ORDER_DATE || voucher)),
                SCHEDULED_RECEIPT_DATE_TO);
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN NULL;
   END getScdeduledReceiptDateTo;

   PROCEDURE setScheduledReceiptDate (voucher    IN VARCHAR2,
                                      fromDate   IN DATE,
                                      toDate        DATE)
   IS
      params   Amd_Utils.arrayOfwords;
   BEGIN
      IF fromDate IS NOT NULL AND toDate IS NOT NULL
      THEN
         IF fromDate > toDate
         THEN
            DBMS_OUTPUT.put_line (
                  'setScheduledReceiptDate: voucher='
               || voucher
               || ' fromDate='
               || TO_CHAR (fromDate, 'MM/DD/YYYY')
               || ' toDate='
               || TO_CHAR (toDate, 'MM/DD/YYYY'));
            RAISE sched_receipt_date_exception;
         END IF;
      END IF;

      params :=
         Amd_Utils.splitString (
            Amd_Defaults.getParamValue (ON_ORDER_DATE || voucher));

      IF params.COUNT () = 0
      THEN
         params.EXTEND (SCHEDULED_RECEIPT_DATE_TO);
      ELSIF params.COUNT () = 1
      THEN
         params.EXTEND (2);
      END IF;

      params (SCHEDULED_RECEIPT_DATE_FROM) := fromDate;
      params (SCHEDULED_RECEIPT_DATE_TO) := toDate;
      Amd_Defaults.setParamValue (LOWER (ON_ORDER_DATE || voucher),
                                  Amd_Utils.joinString (params));
   END setScheduledReceiptDate;

   PROCEDURE setScheduledReceiptDateCalDays (voucher   IN VARCHAR2,
                                             days      IN NUMBER)
   IS
      params   Amd_Utils.arrayOfwords;
   BEGIN
      params :=
         Amd_Utils.splitString (
            Amd_Defaults.getParamValue (ON_ORDER_DATE || voucher));

      IF params.COUNT () > 0
      THEN
         params (NUMBER_OF_CALANDER_DAYS) := days;
      END IF;

      Amd_Defaults.setParamValue (LOWER (ON_ORDER_DATE || voucher),
                                  Amd_Utils.joinString (params, ','));
   END setScheduledReceiptDateCalDays;

   FUNCTION getScheduledReceiptDateCalDays (voucher IN VARCHAR2)
      RETURN NUMBER
   IS
      calDays   NUMBER := NULL;
      params    Amd_Utils.arrayOfWords;
   BEGIN
      params :=
         Amd_Utils.splitString (
            Amd_Defaults.GetParamValue (ON_ORDER_DATE || voucher));

      IF params.COUNT () > 0
      THEN
         calDays := TO_NUMBER (params (NUMBER_OF_CALANDER_DAYS));
      END IF;

      RETURN calDays;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN NULL;
   END getScheduledReceiptDateCalDays;

   PROCEDURE getOnOrderParams (voucher                IN     VARCHAR2,
                               orderCreateDate           OUT DATE,
                               schedReceiptDateFrom      OUT DATE,
                               schedReceiptDateTo        OUT DATE,
                               schedReceiptCalDays       OUT NUMBER)
   IS
      params   Amd_Utils.arrayOfWords;
   BEGIN
      params :=
         Amd_Utils.splitString (
            Amd_Defaults.GetParamValue (LOWER (ON_ORDER_DATE || voucher)));

      IF params.COUNT () >= NUMBER_OF_CALANDER_DAYS
      THEN
         IF params (NUMBER_OF_CALANDER_DAYS) IS NOT NULL
         THEN
            schedReceiptCalDays :=
               TO_NUMBER (params (NUMBER_OF_CALANDER_DAYS));
         ELSE
            schedReceiptCalDays := NULL;
         END IF;
      ELSE
         schedReceiptCalDays := NULL;
      END IF;

      IF params.COUNT () >= SCHEDULED_RECEIPT_DATE_TO
      THEN
         IF     params (SCHEDULED_RECEIPT_DATE_FROM) IS NOT NULL
            AND LENGTH (params (SCHEDULED_RECEIPT_DATE_FROM)) >= 8
         THEN
            schedReceiptDateFrom :=
               TO_DATE (params (SCHEDULED_RECEIPT_DATE_FROM), 'MM/DD/YYYY');
         ELSE
            schedReceiptDateFrom := NULL;
         END IF;

         IF     params (SCHEDULED_RECEIPT_DATE_TO) IS NOT NULL
            AND LENGTH (params (SCHEDULED_RECEIPT_DATE_TO)) >= 8
         THEN
            schedReceiptDateTo :=
               TO_DATE (params (SCHEDULED_RECEIPT_DATE_TO), 'MM/DD/YYYY');
         ELSE
            schedReceiptDateTo := NULL;
         END IF;
      ELSE
         schedReceiptDateFrom := NULL;
         schedReceiptDateTo := NULL;
      END IF;

      IF params.COUNT () >= ORDER_CREATE_DATE
      THEN
         IF     params (ORDER_CREATE_DATE) IS NOT NULL
            AND LENGTH (params (ORDER_CREATE_DATE)) >= 8
         THEN
            orderCreateDate :=
               TO_DATE (params (ORDER_CREATE_DATE), 'MM/DD/YYYY');
         ELSE
            orderCreateDate := NULL;
         END IF;
      ELSE
         orderCreateDate := NULL;
      END IF;
   END getOnOrderParams;

   PROCEDURE setOnOrderParams (voucher                IN VARCHAR2,
                               orderCreateDate        IN DATE,
                               schedReceiptDateFrom   IN DATE,
                               schedReceiptDateTo     IN DATE,
                               schedReceiptCalDays    IN NUMBER)
   IS
      params   Amd_Utils.arrayOfWords := Amd_Utils.arrayOfWords ();
   BEGIN
      params.EXTEND (4);
      params (ORDER_CREATE_DATE) := TO_CHAR (orderCreateDate, 'MM/DD/YYYY');

      IF schedReceiptDateFrom IS NOT NULL AND schedReceiptDateTo IS NOT NULL
      THEN
         IF schedReceiptDateFrom > schedReceiptDateTo
         THEN
            DBMS_OUTPUT.put_line (
                  'setOnOrderParams: voucher='
               || voucher
               || ' orderCreeateDate='
               || TO_CHAR (orderCreateDate, 'MM/DD/YYYY')
               || ' schedReceiptDateFrom='
               || TO_CHAR (schedReceiptDateFrom, 'MM/DD/YYYY')
               || ' schedReceiptCalDays='
               || schedReceiptCalDays);
            RAISE sched_receipt_date_exception;
         END IF;

         params (SCHEDULED_RECEIPT_DATE_FROM) :=
            TO_CHAR (schedReceiptDateFrom, 'MM/DD/YYYY');
         params (SCHEDULED_RECEIPT_DATE_TO) :=
            TO_CHAR (schedReceiptDateTo, 'MM/DD/YYYY');
         params (NUMBER_OF_CALANDER_DAYS) := NULL;
      ELSE
         IF schedReceiptCalDays IS NOT NULL
         THEN
            params (SCHEDULED_RECEIPT_DATE_FROM) := NULL;
            params (SCHEDULED_RECEIPT_DATE_TO) := NULL;
            params (NUMBER_OF_CALANDER_DAYS) := schedReceiptCalDays;
         ELSE
            params (SCHEDULED_RECEIPT_DATE_FROM) := NULL;
            params (SCHEDULED_RECEIPT_DATE_TO) := NULL;
            params (NUMBER_OF_CALANDER_DAYS) := NULL;
         END IF;
      END IF;

      IF NOT Amd_Defaults.isParamKey (LOWER (ON_ORDER_DATE || voucher))
      THEN
         Amd_Defaults.addParamKey (
            LOWER (ON_ORDER_DATE || voucher),
               'The order create date and scheduled receipt date for the '
            || LOWER (voucher)
            || ' voucher');
      END IF;

      Amd_Defaults.setParamValue (LOWER (ON_ORDER_DATE || voucher),
                                  Amd_Utils.joinString (params));
   END setOnOrderParams;

   FUNCTION isVoucher (voucher IN VARCHAR2)
      RETURN BOOLEAN
   IS
      theVoucher   VARCHAR2 (2);
   BEGIN
      SELECT DISTINCT SUBSTR (gold_order_number, 1, 2)
        INTO theVoucher
        FROM AMD_ON_ORDER
       WHERE LOWER (SUBSTR (gold_order_number, 1, 2)) =
                LOWER (isVoucher.voucher);

      RETURN TRUE;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN FALSE;
   END isVoucher;

   PROCEDURE clearOnOrderParams
   IS
      CURSOR onOrderParams
      IS
         SELECT *
           FROM AMD_PARAM_CHANGES outer
          WHERE     param_key LIKE ON_ORDER_DATE || '%'
                AND effective_date = (SELECT MAX (effective_date)
                                        FROM AMD_PARAM_CHANGES
                                       WHERE param_key = outer.param_key);
   BEGIN
      FOR rec IN onOrderParams
      LOOP
         INSERT INTO AMD_PARAM_CHANGES (param_key,
                                        param_value,
                                        effective_date,
                                        user_id)
              VALUES (rec.param_key,
                      ',,,',
                      SYSDATE,
                      USER);
      END LOOP;
   END clearOnOrderParams;

   FUNCTION numberOfOnOrderParams
      RETURN NUMBER
   IS
      cnt   NUMBER;
   BEGIN
      SELECT COUNT (*)
        INTO cnt
        FROM AMD_PARAM_CHANGES outer
       WHERE     param_key LIKE ON_ORDER_DATE || '%'
             AND effective_date = (SELECT MAX (effective_date)
                                     FROM AMD_PARAM_CHANGES
                                    WHERE param_key = outer.param_key);

      RETURN cnt;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN 0;
   END numberOfOnOrderParams;

   FUNCTION getVouchers
      RETURN ref_cursor
   IS
      vouchers_cursor   ref_cursor;
   BEGIN
      OPEN vouchers_cursor FOR
           SELECT DISTINCT SUBSTR (gold_order_number, 1, 2) voucher
             FROM AMD_ON_ORDER
         ORDER BY voucher;

      RETURN vouchers_cursor;
   END getVouchers;


   PROCEDURE version
   IS
   BEGIN
      writeMsg (pTableName        => 'amd_inventory',
                pError_location   => 620,
                pKey1             => 'amd_inventory',
                pKey2             => '$Revision:   1.121 $');
   END version;

   FUNCTION getVersion
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN '$Revision:   1.121  $';
   END getVersion;

   PROCEDURE setDebug (switch IN VARCHAR2)
   IS
   BEGIN
      debug :=
         UPPER (switch) IN ('Y',
                            'T',
                            'YES',
                            'TRUE');

      IF debug
      THEN
         DBMS_OUTPUT.ENABLE (100000);
      ELSE
         DBMS_OUTPUT.DISABLE;
      END IF;
   END setDebug;
END Amd_Inventory;
/


DROP PACKAGE BODY AMD_OWNER.AMD_LOAD;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_LOAD
AS
   /*
           PVCS Keywords

          $Author:   Douglas S. Elder
        $Revision:   1.97
            $Date:   05 Feb 2018
        $Workfile:   amd_load.pkb  $

          Rev 1.97   05 FEb 2018 renamed loadBascUKDemands to loadDepotDemands per TFS 52919


          Rev 1.96   5 Dec 2017 use mtbdr when the associated part has been created within the last 5 years (tfs 47117)

          Rev 1.95  21 Nov 2017 added dbms_output.put_line for every raise command
          Rev 1.94  15 Nov 2017 added qualified where clauses by using lock_sid, part_no, and nsn
                                for bssm_parts since that is the primary key!
                                Added nsn qualifier for queries of bssm_parts when having part_no and nsn
                                removed calculation of elapsed time for loadGold since SQL*Plus will
                                give elapsed time with SET TIMING ON
          Rev 1.93  14 Nov 2013 added dbms_output with counts and reformatted code
                                added exception handler for <<cleaned>> begin end to just
                                report problem and continue
                                added cursor to getCleanedDataByPart because was fetching more than one row

          Rev 1.92  19 Oct 2015 fix loadRblPairs to ignore duplicate rows, but to report them. Also,
          add order by old_nsn, subgroup_code, part_pref_code so that
           old_nsn AA (subgroup_code) A (part_pref_code) gets inserted over the same old_nsn AA B

          Rev 1.91  17 Aug 2015 when performing logical deletes or bulk inserts ignore trigger compilation
                   errors

          Rev 1.90  17 Feb 2015 removed amd_owner and bssm_owner qualifier

          Rev 1.89  added amd_defaults.getSourceCode, getNonStockageList

          Rev 1.88  Use slic_ha_v and slic_hg_v views instead of table and db links

         Rev 1.87 added exception handler to loadMain and added distict to query for order_qty from tmp_main zf297a

         Rev 1.86 renamed amd_demand.amd_demand_a2a to amd_demand.load_amd_demands_table
         and renamed amd_demand.loadAmdDemands to amd_demand.loadAmdBssmSourceTmpAmdDemands

          Rev 1.85 removed truncate of tmp_a2a tables

           Rev 1.84  21 Feb 2012 rewrote loadPsms to use simplified slic views
           that do not trim any columns used by the where clause predicate so that
           the query is fast.  Used the Oracle analytical functions to get the best smr_code
           from slic.  loadPsms has been reduced to a bulk select and a bulk update.  Used
           Toad's reformat tool to make loadGold code neater.

          Rev 1.84  16 Feb 2012 tried to optimize getSmr zf297a

         Rev 1.83  13 Feb 2012 used common routine and new amd_repair_cost_detail to calc avg cost  to repair off base zf297a

         Rev 1.82   09 Feb 2012 changed names of all pslms views to a slic prefix with a _v suffix

         Rev 1.81    07 Dec 2011  made the ccn_prefix query more flexible by using the length of the ccn_prefix in the substr of the existential subquery

         Rev 1.80    03 Aug 2011 Added useBizDays switch, added code to invoke the amd_utils.bizdays2calendardays when useBizDays is true
                         otherwise do not invoke it.  added code to get/set the useBizDays switch via SQL or via the amd_param_changes table using the useBizDays data switch

         Rev 1.79    18 Mar 2010 Made changes to function getOffBaseTurnAround to comply with ClearQuest LBPSS00002451

         Rev 1.78    26 Feb 2010 Eliminated the PsmsInstance Function and updated the Procedure GetPsmsData to comply with the conversion of the SLICWave.

                     Made changes in getting smr_code and shelf_life from PSMS to SLICWave and PSMV is going away.

                     Removed constant the_a2a_pkg which is more a2a code not being used.
                     Thuy is making changes to loadPsms and Douglas removed amd_partPrime_pkg.diffPartToPrime

         Rev 1.77   05 Oct 2009 eliminated more A2A code

         Rev 1.76   15 Jul 2009 10:28:18   zf297a
      Removed a2a code

         Rev 1.75   06 Jul 2009 11:19:32   zf297a
      Used amd_isgp_rbl_pairs as the source for amd_rbl_pairs

         Rev 1.74   24 Feb 2009 15:08:58   zf297a
      eliminated part factors load of virtual loc's.

         Rev 1.73   14 Feb 2009 16:18:26   zf297a
      Removed invocation of any A2A procedure for package amd_location_part_override_pkg since all A2A code has been removed from that package.

         Rev 1.72   26 Nov 2008 07:50:08   zf297a
      Use new debugMsg procedure with a pError_location parameter to help locate the debugMsg in the code.  Also, added the autonomous transaction pragma.
      Inserted lots of debug code for loadGold.


         Rev 1.71   30 Sep 2008 10:59:52   zf297a
      Fixed getBemsId ... was not returning a bemsid when it should have for a C + bems_id.

         Rev 1.70   07 Jul 2008 10:01:28   zf297a
      Make the debugThreshold 1/10 of the size of amd_spare_partss when a null value is passed to the setDebugThreshold procedure.

         Rev 1.69   07 Jul 2008 09:17:18   zf297a
      Implemented interfaces getDebugThreshold and setDebugThreshold.  Added debug code to time routines.

         Rev 1.68   03 Jul 2008 23:40:30   zf297a
      Added bulk insert to loadGold and bulk update to loadMain and loadPsms.  Added timing dbms_output to loadGold.

         Rev 1.67   30 Jun 2008 15:25:44   zf297a
      Implemented setDebug, and getDebug.  Changed default for bulkInsertThreshold to 600.

         Rev 1.66   23 May 2008 13:10:44   zf297a
      Implemented  function getVersion.

         Rev 1.65   23 May 2008 13:06:34   zf297a
      Make sure that all planner_code exist in amd_planners where amd_planners.action_code <> 'D'

         Rev 1.64   07 Nov 2007 12:42:24   zf297a
      Added bulk collect to most cursors.

         Rev 1.63   12 Sep 2007 15:53:10   zf297a
      Removed commits from for loops.

         Rev 1.62   25 Aug 2007 21:49:32   zf297a
      Added hint to sql statement in boolean function onNsl to make sure Oracle uses the correct index in its execution plan.

         Rev 1.61   Aug 09 2007 10:49:52   c402417
      Added procedure LoadWecm to support Version 6.p with Consumables.

         Rev 1.60   Jul 04 2007 10:14:18   c402417
      Fixed the main where clause in LoadRblPairs select statement.

         Rev 1.59   24 Apr 2007 10:21:10   zf297a
      Modified algorithm of getCalculatedData:
      1. try getting cleaned data by nsn
      2. try getting cleaned data by part_no/nsn
      3. try getting original data by nsn
      4. try getting original data by part_no

         Rev 1.58   23 Apr 2007 16:42:04   zf297a
      Fixed getCalculatedData: 1st tried getting the cleaned data via nsn and verifying that either the nsn is currently active or that the part_no for the lock_sid 0 is currently active.
      If no data is not found try getting the lock sid 0 data and verifying that either the nsn is active or the part_no is active.
      If no data is found, try getting the  original data via part_no and verifying that either the nsn is active or the part is active.

         Rev 1.57   12 Apr 2007 09:29:24   zf297a
      Added commit threshold checks for all load routines.  Converted execute immediate to mta_truncate_table per DBA's recommendation.

         Rev 1.56   10 Apr 2007 16:20:02   zf297a
      Added Trim's to updateUsersRow for the Users diff

         Rev 1.55   10 Apr 2007 09:04:52   zf297a
      Made partNo varchar2 for getOffBaseTurnAround and getOffBaseRepairCost

         Rev 1.53   05 Apr 2007 00:37:20   zf297a
      Get rid of recursion error - getByPatNo

         Rev 1.52   04 Apr 2007 15:35:06   zf297a
      Fixed getCalculatedData to try getting mtbdr_computed in the following order:
      by nsn for cleaned data
      by nsn for original data
      by part for cleaned data
      by part for original data.

         Rev 1.51   03 Apr 2007 17:18:24   zf297a
      Fix getOriginalBssmData to try first by using the nsn and then using the part_no.

         Rev 1.50   02 Apr 2007 12:57:10   zf297a
      Replaced getOriginalBssmData with the new inferface that does not use the mtbdr_computed argument.

      Simplified the procedure getOriginalBssmData by only using one "select" and its exception handlers.

      Replaced procedure getCalulatedData with function getCalculatedData which takes two arguments: nsn and part_no and returns mtbdr_computed.

      Use the new getOriginalBssmData and getCalculatedData in procedure getBssmData.

      Implemented function getOrderLeadTime - it takes a trimmed part_no and retrives the order lead time from cat1 if it can find it otherwise it returns a null.

      Eliminated ave_cap_lead_time from the catCur cursor since that data is being retrieved by the function getOrderLeadTime

      Implemented functions getORIGINAL_DATA, getCLEANED_DATA, and getCURRENT_NSN to return their assocaited constants.

         Rev 1.49   Mar 05 2007 11:45:16   c402417
      Amd_spare_parts.order_lead-time is now getting data from Cat1 instead of tmp_main per Laurie.

         Rev 1.48   14 Feb 2007 13:52:26   zf297a
      Added amc_demand to getOrigianlBssmData and added amc_demand_cleaned to getCleanedBssmData. Implemented getCalculatedData to get mtbdr_computed.
      Added amc_demand and amc_demand_cleaned to getBssmData.  Added invocation of getCalculatedData to getBssmData.  Added amc_demand and amc_demand_cleaned to insert of tmp_amd_spare_parts.

         Rev 1.47   Jan 17 2007 16:22:14   c402417
      Added Procedure LoadRblPairs - This step is to populate the data to table AMD_RBL_PAIRS from the Gold database instead of using data from the FedLog.

         Rev 1.46   Nov 21 2006 10:16:08   zf297a
      Fixed insert of tmp_a2a_site_resp_asset_mgr

         Rev 1.45   Oct 31 2006 14:45:18   zf297a
      Implemented validatePartStructure

         Rev 1.44   Oct 13 2006 10:23:54   zf297a
      For the primeCat cursor changed the RTRIM's to TRIM (a part with a leading space got loaded into amd_spare_parts).  For catCur changed the RTRIM to TRIM.

         Rev 1.43   Oct 10 2006 11:11:12   zf297a
      For function getBemsId, errorMsg and writeMsg cannot be used when the function is being used in a query.   Therefore, the error handling routines have been adjusted to check for this error and use the raise_application_error as a last resort for report what may be wrong with the function.  Enhanced the algorithm to try getting the bems_id via the clock number (emp_id) and if that fails try using the employeeNo as the bems_id and verify it against the amd_people_all_v table.

         Rev 1.42   Oct 10 2006 09:56:38   zf297a
      Added more error checks for getBemsId.

         Rev 1.41   Oct 03 2006 11:51:54   zf297a
      Make sure planner_code_cleaned and smr_code_cleaned are in upper case

         Rev 1.40   Sep 18 2006 10:16:24   zf297a
      Removed infoMsg.  Added writeMsg at the start and the end of loadGold, loadPsms, and loadMain.  Changed all execute immediates to use mta_truncate_table.  Changed errorMsg to have default values for all args and changed error_location to pError_Location.   Added dbms_output.put_line to version.  Fixed 2nd select of bssm data to use only the part and verify that it has an nsn_type of C for current.

         Rev 1.39   Sep 15 2006 14:49:44   zf297a
      Added data_source to insertSiteRespAssetMgr

         Rev 1.38   Jul 11 2006 11:23:34   zf297a
      Removed quotes from package name

         Rev 1.37   Jun 09 2006 11:44:56   zf297a
      implemented version

         Rev 1.36   Jun 04 2006 13:27:26   zf297a
      Fixed createSiteRespAssetMgrA2Atran to use a cursor.

         Rev 1.35   Mar 20 2006 08:57:00   zf297a
      Added  "Future use" comments

         Rev 1.34   Mar 19 2006 01:50:50   zf297a
      Used didStepComplete to conditionally execute a batch step only once for a given job.

         Rev 1.33   Mar 17 2006 09:06:00   zf297a
      Eliminated rudundant step ending code.

         Rev 1.32   Mar 16 2006 15:24:18   zf297a
      Add steps to PrepAmdDatabase

         Rev 1.31   Mar 16 2006 15:08:20   zf297a
      Added step info to preProcess and LoadGoldPsmsMain

         Rev 1.30   Mar 16 2006 10:37:40   zf297a
      Fixed retrieval of bssm data: try to retrieve the data using nsn and if the data is not found, use the part_no.  Write separate procedures for the routinese that gather rmads data and bssm data to enable easy unit testing.

         Rev 1.29   Mar 08 2006 12:01:04   zf297a
      Added mtbdr_computed

         Rev 1.28   Mar 05 2006 21:19:50   zf297a
      Implemented  loadGoldPsmsMain, preProcess, postProcess, postDiffProcess, prepAmdDatabase, disableAmdConstraints, truncateAmdTables, and enableAmdConstraints to simplify the amd_loader.ksh script.

         Rev 1.27   Dec 15 2005 12:12:52   zf297a
      Added truncate table for tmp_a2a_bom_detail and tmp_a2a_part_effectivity to loadGold

         Rev 1.26   Dec 07 2005 13:18:18   zf297a
      Fixed insertUsersRow by returning SUCCESS after a doUpdate is invoked without an error.

         Rev 1.25   Dec 07 2005 12:22:48   zf297a
      fixed insertUsersRow by adding a doUpdate routine for a user that has been

         Rev 1.24   Dec 06 2005 09:46:24   zf297a
      Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS

         Rev 1.23   Nov 23 2005 07:39:02   zf297a
      Fixed routine getBssmData, the getOriginalData begin block, added an additional qualification for the subselect getting data from amd_nsns so that only one row of data is returned by this query: added "and nsn_type = 'C', which checks for the "current" nsn being used - there can only be one of these per nsi_sid.

         Rev 1.22   Aug 26 2005 14:50:26   zf297a
      updated getOffBaseTurnAroundTime to use an action taken of 'F' (modification/repair) and changed interface for amd_clean_data to use both nsn and part_no

         Rev 1.23   Aug 23 2005 12:16:08   zf297a
      Used new interface, which uses nsn and part_no, for the best spares cleaned data

         Rev 1.22   Aug 19 2005 12:45:24   zf297a
      Converted time_to_repair_off_base_cleand and order_lead_time_cleaned from months to calendar days.  Converted order_lead_time from business days to calendar days.

         Rev 1.21   Aug 16 2005 14:12:30   zf297a
      removed loadCurrentBackorder

         Rev 1.20   Aug 09 2005 09:52:26   zf297a
      Added the ability to dynamically use debugMsg via the amd_param_changes table having a param debugAmdLoad with a value of 1.

         Rev 1.19   Aug 05 2005 12:28:12   zf297a
      Fixed insertRow for amd_planners to handle changing of a logically deleted planner to an added planner.  Added return SUCCESS to insertUsersRow, updateUsersRow, and deleteUsersRow.

         Rev 1.18   Aug 04 2005 14:43:54   zf297a
      Implemented insertUsersRow, updateUsersRow, and deleteUsersRow for the amd_users diff java application.

         Rev 1.17   Jul 28 2005 08:42:08   zf297a
      Qualified cursors currentUsers, newUsers, and deleteUsers with action_codes not equal to amd_defaults.DELETE_ACTION.

         Rev 1.16   Jul 27 2005 14:56:38   zf297a
      Refined newUsers and deleteUsers cursors for loadUsers

         Rev 1.15   Jul 27 2005 11:48:32   zf297a
      Fixed getBemsId by transforming the employeeNo into a work field before it is used in a query.  Fixed loadUsers by refering to the besm_id via the rec variable for the insert statement and the invocation of the spo routines.

         Rev 1.14   Jul 26 2005 12:32:22   zf297a
      Enhanced the loadUsers procedure to use the getBemsId function.

         Rev 1.13   Jul 20 2005 07:47:00   zf297a
      using only bems_id for amd_users

         Rev 1.12   Jul 19 2005 14:22:48   zf297a
      added procedure loadUsers - populates the amd_users table and sends inserts, updates, and deletes via the a2a_pgk.spoUser procedure.

         Rev 1.11   Jun 10 2005 11:23:32   c970183
      using new version of insertSiteRespAssetMgr with the additional param of action_code

         Rev 1.10   Jun 09 2005 14:58:58   c970183
      Added insert, update, and delete routines for the amd_planners diff and the amd_planner_logons diff.

         Rev 1.9   May 17 2005 14:24:12   c970183
      Modified getCleaned block to use the amd_clean_data package functions.

         Rev 1.8   May 17 2005 10:18:24   c970183
      Update InsertErrorMessage to new interface

         Rev 1.7   May 16 2005 12:02:12   c970183
      Moved time_to_repair_off_base and cost_to_repair_off_base from amd_part_locs to be part of tmp_amd_spare_parts.

         Rev 1.5   Apr 27 2005 09:19:28   c970183
      added infoMsg, which is almost the same as ErrorMsg, but it does not do a Rollback or a commit.
             **/



   --
   -- Local Declarations
   --
   TYPE t_part_no_tab IS TABLE OF tmp_amd_spare_parts.part_no%TYPE;

   THIS_PACKAGE            CONSTANT VARCHAR2 (8) := 'amd_load';
   THE_AMD_INVENTORY_PKG   CONSTANT VARCHAR2 (13) := 'amd_inventory';

   mDebug                           BOOLEAN := FALSE;
   useBizDays                       BOOLEAN := FALSE;
   bulkInsertThreshold              NUMBER := 600;
   debugThreshold                   NUMBER := 5000;
   startDebugRec                    NUMBER := 0;
   psms_cnt                         NUMBER := 0;
   psmsThreshold                    NUMBER := 10000;


   --
   -- procedure/Function bodies
   --
   PROCEDURE performLogicalDelete (pPartNo VARCHAR2);

   PROCEDURE debugMsg (msg               IN AMD_LOAD_DETAILS.DATA_LINE%TYPE,
                       pError_Location   IN NUMBER)
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      IF mDebug
      THEN
         Amd_Utils.debugMsg (pMsg        => msg,
                             pPackage    => THIS_PACKAGE,
                             pLocation   => pError_location);
         COMMIT;                                -- make sure the trace is kept
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         IF SQLCODE = -14551 OR SQLCODE = -14552
         THEN
            NULL;    -- cannot do a commit inside a query, so ignore the error
         ELSE
            DBMS_OUTPUT.put_line (
               'debugMsg: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM);
            RAISE;
         END IF;
   END debugMsg;


   PROCEDURE errorMsg (sqlFunction         IN VARCHAR2 := 'errorMsg',
                       tableName           IN VARCHAR2 := 'noname',
                       pError_location     IN NUMBER := -100,
                       key1                IN VARCHAR2 := '',
                       key2                IN VARCHAR2 := '',
                       key3                IN VARCHAR2 := '',
                       key4                IN VARCHAR2 := '',
                       key5                IN VARCHAR2 := '',
                       keywordValuePairs   IN VARCHAR2 := '')
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      Amd_Utils.InsertErrorMsg (
         pLoad_no        => Amd_Utils.GetLoadNo (pSourceName   => sqlFunction,
                                                 pTableName    => tableName),
         pData_line_no   => pError_location,
         pData_line      => THIS_PACKAGE,
         pKey_1          => key1,
         pKey_2          => key2,
         pKey_3          => key3,
         pKey_4          => key4,
         pKey_5          => key5 || ' ' || keywordValuePairs,
         pComments       =>    'sqlcode('
                            || SQLCODE
                            || ') sqlerrm('
                            || SQLERRM
                            || ')');
      COMMIT;
      RETURN;
   END ErrorMsg;


   PROCEDURE writeMsg (
      pTableName        IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
      pError_location   IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
      pKey1             IN VARCHAR2 := '',
      pKey2             IN VARCHAR2 := '',
      pKey3             IN VARCHAR2 := '',
      pKey4             IN VARCHAR2 := '',
      pData             IN VARCHAR2 := '',
      pComments         IN VARCHAR2 := '')
   IS
   BEGIN
      Amd_Utils.writeMsg (pSourceName       => 'amd_load',
                          pTableName        => pTableName,
                          pError_location   => pError_location,
                          pKey1             => pKey1,
                          pKey2             => pKey2,
                          pKey3             => pKey3,
                          pKey4             => pKey4,
                          pData             => pData,
                          pComments         => pComments);
   END writeMsg;


   FUNCTION getBemsId (employeeNo IN AMD_USE1.EMPLOYEE_NO%TYPE)
      RETURN AMD_USERS.BEMS_ID%TYPE
   IS
      bems_id         amd_people_all_v.BEMS_ID%TYPE;

      wk_employeeNo   AMD_USE1.employee_no%TYPE
                         := UPPER (TRIM (REPLACE (employeeNo, ';', '')));

      FUNCTION isNumber (txt IN VARCHAR2)
         RETURN BOOLEAN
      IS
         theNumber   NUMBER;
      BEGIN
        <<testForNumber>>
         BEGIN
            theNumber := TO_NUMBER (txt);
         EXCEPTION
            WHEN VALUE_ERROR
            THEN
               theNumber := NULL;
         END testForNumber;

         RETURN (theNumber IS NOT NULL);
      END isNumber;

      PROCEDURE getViaBemsId
      IS
      BEGIN
         IF isNumber (wk_employeeNo) AND LENGTH (wk_employeeNo) = 6
         THEN
            getBemsId.bems_id := '0' || wk_employeeNo;
         ELSE
            IF SUBSTR (wk_employeeNo, 1, 1) = 'C'
            THEN
               wk_employeeNo := SUBSTR (wk_employeeNo, 2);

               IF isNumber (wk_employeeNo) AND LENGTH (wk_employeeNo) = 6
               THEN
                  wk_employeeNo := '0' || wk_employeeNo;
               END IF;
            END IF;

            getBemsId.bems_id := SUBSTR (wk_employeeNo, 1, 7);
         END IF;

         BEGIN
            SELECT bems_id
              INTO getBemsId.bems_id
              FROM amd_people_all_v
             WHERE bems_id = getBemsId.bems_id;
         EXCEPTION
            WHEN STANDARD.NO_DATA_FOUND
            THEN
               getBemsId.bems_id := NULL;
            WHEN OTHERS
            THEN
               ErrorMsg (
                  sqlFunction       => 'select',
                  tableName         => 'amd_people_all_v',
                  pError_location   => 10,
                  key1              => 'wk_employeeNo=' || wk_employeeNo);
               DBMS_OUTPUT.put_line (
                     'getViaBemsId: wkr_employeeNo='
                  || wk_employeeNo
                  || ' select amd_people_all_v 1 sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (sqlFunction       => 'select',
                      tableName         => 'amd_people_all_v',
                      pError_location   => 20,
                      key1              => 'wk_employeeNo=' || wk_employeeNo);
            DBMS_OUTPUT.put_line (
                  'getViaBemsId: wkr_employeeNo='
               || wk_employeeNo
               || ' select amd_people_all_v 2 sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END getViaBemsId;
   BEGIN
      IF SUBSTR (wk_employeeNo, LENGTH (wk_employeeNo), 1) NOT IN ('1',
                                                                   '2',
                                                                   '3',
                                                                   '4',
                                                                   '5',
                                                                   '6',
                                                                   '7',
                                                                   '8',
                                                                   '9',
                                                                   '0')
      THEN
         wk_employeeNo :=
            SUBSTR (wk_employeeNo, 1, LENGTH (wk_employeeNo) - 1); -- strip non-numeric suffix
      END IF;

      IF SUBSTR (wk_employeeNo, 1, 1) = 'C'
      THEN
         -- try getting bemsid via the emp_id
         BEGIN
            SELECT bems_id
              INTO getBemsId.bems_id
              FROM amd_people_all_v
             WHERE UPPER (emp_id) = wk_employeeNo;
         EXCEPTION
            WHEN STANDARD.NO_DATA_FOUND
            THEN
               getViaBemsId;
            WHEN OTHERS
            THEN
               ErrorMsg (
                  sqlFunction       => 'select',
                  tableName         => 'amd_people_all_v',
                  pError_location   => 30,
                  key1              => 'wk_employeeNo=' || wk_employeeNo);
               DBMS_OUTPUT.put_line (
                     'getViaBemsId: wkr_employeeNo='
                  || wk_employeeNo
                  || ' select amd_people_all_v 3 sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END;
      ELSE
         getViaBemsId;
      END IF;

      RETURN getBemsId.bems_id;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN NULL;
      WHEN OTHERS
      THEN
         IF SQLCODE <> -14551 AND SQLCODE <> -14552
         THEN
            -- cannot do a rollback inside a query
            ErrorMsg (sqlFunction       => 'getBemsId',
                      tableName         => 'amd_people_all_v',
                      pError_location   => 40,
                      key1              => 'wk_employeeNo=' || wk_employeeNo);
            DBMS_OUTPUT.put_line (
                  'getViaBemsId: wkr_employeeNo='
               || wk_employeeNo
               || ' select amd_people_all_v 4 sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
         ELSE
            DBMS_OUTPUT.put_line (
               'getBemsId: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM);
            DBMS_OUTPUT.put_line (
                  'getViaBemsId: wkr_employeeNo='
               || wk_employeeNo
               || ' select amd_people_all_v 5 sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            raise_application_error (
               -20001,
                  'getBemsId: sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM
               || ' wk_employeeNo='
               || wk_employeeNo);
         END IF;

         RETURN NULL;
   END getBemsId;



   /* function GetOffBaseRepairCost, logic same as previous load version */
   FUNCTION GetOffBaseRepairCost (pPartNo VARCHAR2)
      RETURN AMD_PART_LOCS.cost_to_repair%TYPE
   IS
      nsiSid   amd_national_stock_items.nsi_sid%TYPE := NULL;
   --
   --    Use only PART   number because POI1 does not have Cage Code.
   --
   BEGIN
      SELECT nsi_sid
        INTO nsiSid
        FROM amd_national_stock_items items, amd_spare_parts parts
       WHERE     parts.part_no = pPartNo
             AND parts.nsn = items.nsn
             AND parts.action_code <> 'D'
             AND items.action_code <> 'D';

      RETURN GETCOSTTOREPAIROFFBASE (nsiSid);
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN NULL;
   END GetOffBaseRepairCost;

   /* function get_off_base_tat, logic same as previous load version
      removed offbasediag time from previous version */
   FUNCTION GetOffBaseTurnAround (pPartno VARCHAR2)
      RETURN AMD_PART_LOCS.time_to_repair%TYPE
   IS
      -- goldpart      char(50);
      offBaseTurnAroundTime   AMD_PART_LOCS.time_to_repair%TYPE;

      offBaseCnt              NUMBER := 0;
   BEGIN
        SELECT AVG (completed_docdate - created_docdate)
          INTO offBaseTurnAroundTime
          FROM ORD1, amd_spare_parts parts
         WHERE     part = parts.part_no
               AND parts.action_code <> 'D'
               AND parts.nsn IN
                      (SELECT nsn
                         FROM amd_national_stock_items
                        WHERE prime_part_no = pPartNo AND action_code <> 'D')
               AND NVL (action_taken, '*') IN ('A',
                                               'B',
                                               'E',
                                               'G',
                                               'F',
                                               '*')
               AND order_type = 'J'
               AND completed_docdate IS NOT NULL
      GROUP BY nsn;

      offBaseCnt := offBaseCnt + SQL%ROWCOUNT;
      RETURN offBaseTurnAroundTime;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN NULL;
   END GetOffBaseTurnAround;

   FUNCTION getUnitCost (pPartNo VARCHAR2)
      RETURN NUMBER
   IS
      CURSOR costCur
      IS
           SELECT cap_price
             FROM PRC1
            WHERE part = pPartNo
         ORDER BY sc DESC;

      unitCost   NUMBER := 0;
   BEGIN
      FOR rec IN costCur
      LOOP
         unitCost := rec.cap_price;
         EXIT;
      END LOOP;

      RETURN unitCost;
   END getUnitCost;


   FUNCTION getMmac (pNsn VARCHAR2)
      RETURN VARCHAR2
   IS
      CURSOR macCur
      IS
         SELECT nsn_smic
           FROM NSN1
          WHERE nsn = pNsn;

      mMac   VARCHAR2 (2) := NULL;
   BEGIN
      FOR rec IN macCur
      LOOP
         mMac := rec.nsn_smic;
         EXIT;
      END LOOP;

      RETURN mMac;
   END;


   PROCEDURE performLogicalDelete (pPartNo VARCHAR2)
   IS
      nsiSid   AMD_NSNS.nsi_sid%TYPE;
      nsnCnt   NUMBER;
   BEGIN
     <<update_amd_spare_parts>>
      BEGIN
         UPDATE AMD_SPARE_PARTS
            SET nsn = NULL,
                action_code = Amd_Defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE part_no = pPartNo;
      EXCEPTION
         WHEN OTHERS
         THEN
            -- ignore trigger compile errors
            IF SQLCODE != -4098
            THEN
               DBMS_OUTPUT.put_line (
                     'update_amd_spare_parts: pPartNo='
                  || pPartNo
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
            END IF;
      END update_amd_spare_parts;

      BEGIN
         SELECT nsi_sid
           INTO nsiSid
           FROM AMD_NSI_PARTS
          WHERE part_no = pPartNo AND unassignment_date IS NULL;

         UPDATE AMD_NSI_PARTS
            SET unassignment_date = SYSDATE
          WHERE part_no = pPartNo AND nsi_sid = nsiSid;

         SELECT COUNT (*)
           INTO nsnCnt
           FROM AMD_NSI_PARTS
          WHERE nsi_sid = nsiSid AND unassignment_date IS NULL;

         IF (nsnCnt = 0)
         THEN
            UPDATE AMD_NATIONAL_STOCK_ITEMS
               SET action_code = Amd_Defaults.DELETE_ACTION,
                   last_update_dt = SYSDATE
             WHERE nsi_sid = nsiSid;
         END IF;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;
      END;
   END;


   FUNCTION onNsl (pPartNo VARCHAR2)
      RETURN BOOLEAN
   IS
      recCnt   NUMBER;
   BEGIN
      SELECT /*+ INDEX(an amd_nsns_nk01) */
            COUNT (*)
        INTO recCnt
        FROM AMD_NSNS an
       WHERE     nsi_sid IN
                    (SELECT nsi_sid
                       FROM AMD_NSI_PARTS
                      WHERE part_no = pPartNo AND unassignment_date IS NULL)
             AND nsn_type = 'C'
             AND nsn LIKE amd_defaults.getNonStockageList || '%';

      IF (recCnt != 0)
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END;


   /*  Date: 2/17/2012
        Desc: use the regular slic table using the link
        need to convert the param's to char(..) to
        match pslms_hg otherwise the varchar's won't
        match and return no_data_found

   */



   FUNCTION GetSmr (pPart VARCHAR2, pCage VARCHAR2)
      RETURN VARCHAR2
   IS
      smr_code   slic_hg_v.smrcodhg%TYPE;
      part_no    CHAR (50) := pPart;
      cage_cd    CHAR (13) := pCage;
   BEGIN
      IF mDebug AND MOD (psms_cnt, psmsThreshold) = 0
      THEN
         debugMsg (
               'GetSmr: '
            || ' pPart='
            || pPart
            || ' pCage='
            || pCage
            || ' psms_cnt='
            || psms_cnt
            || ' started:'
            || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
            pError_location   => 71);
      END IF;

      SELECT smrcodhg
        INTO smr_code
        FROM (  SELECT cagecdxh,
                       refnumha,
                       smrcodhg,
                       COUNT (smrcodhg) + LENGTH (TRIM (smrcodhg)),
                       LENGTH (smrcodhg),
                       DENSE_RANK ()
                       OVER (
                          PARTITION BY cagecdxh, refnumha
                          ORDER BY
                             COUNT (smrcodhg) + LENGTH (TRIM (smrcodhg)) DESC)
                          rnk
                  FROM slic_hg_v a
                 WHERE     cagecdxh = cage_cd
                       AND refnumha = part_no
                       AND smrcodhg <> '  '
              GROUP BY cagecdxh, refnumha, smrcodhg)
       WHERE rnk = 1 AND ROWNUM = 1;

      IF mDebug AND MOD (psms_cnt, psmsThreshold) = 0
      THEN
         debugMsg (
               'GetSmr: '
            || ' pPart='
            || pPart
            || ' pCage='
            || pCage
            || ' psms_cnt='
            || psms_cnt
            || ' ended:'
            || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
            pError_location   => 72);
      END IF;

      RETURN smr_code;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         IF mDebug AND MOD (psms_cnt, psmsThreshold) = 0
         THEN
            debugMsg (
                  'GetSmr: '
               || ' pPart='
               || pPart
               || ' pCage='
               || pCage
               || ' psms_cnt='
               || psms_cnt
               || ' ended:'
               || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
               pError_location   => 73);
         END IF;

         RETURN NULL;
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'select',
                   tableName         => 'pslms_hg',
                   pError_location   => 50,
                   key1              => 'part=' || pPart,
                   key2              => 'cage=' || pCage,
                   key3              => 'getSmr');
         DBMS_OUTPUT.put_line (
               'getsmr: pPar='
            || pPart
            || ' pCage='
            || pCage
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   --
   END getsmr;


   PROCEDURE GetPsmsData (pPartNo         VARCHAR2,
                          pCage           VARCHAR2,
                          pSlifeDay   OUT NUMBER,
                          pUnitVol    OUT NUMBER,
                          pSmrCode    OUT VARCHAR2)
   IS
      /* ------------------------------------------------------------------- */
      /*  This procedure returns PSMS data for the Part and Cage Code from   */
      /*  the specified PSMS instance. Any integer indicates Shelf Life in Days          */
      /* ------------------------------------------------------------------- */

      sLife     VARCHAR2 (2);
      part_no   CHAR (50) := pPartNo;
      cage_cd   CHAR (13) := pCage;
   BEGIN
      IF mDebug AND MOD (psms_cnt, psmsThreshold) = 0
      THEN
         debugMsg (
               'GetPsmsData: '
            || ' pPartNo='
            || pPartNo
            || ' pCage='
            || pCage
            || ' psms_cnt='
            || psms_cnt
            || ' started:'
            || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
            pError_location   => 77);
      END IF;

     -- IF (pPsmsInst = 'PSMSVEND') THEN
     <<getPslmsHa>>
      BEGIN
         SELECT shlifeha, (ulengtha * uwidthha * uheighha) / 1728
           INTO sLife, pUnitVol
           FROM slic_ha_v ha, TMP_AMD_SPARE_PARTS s
          WHERE     ha.cagecdxh = s.mfgr
                AND ha.refnumha = s.part_no
                AND ha.cagecdxh = cage_cd
                AND ha.refnumha = part_no;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            sLife := NULL;
            pUnitVol := NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (sqlFunction       => 'select',
                      tableName         => 'slic_ha_v',
                      pError_location   => 60,
                      key1              => 'part=' || pPartNo,
                      key2              => 'cage=' || pCage);
            DBMS_OUTPUT.put_line (
                  'getPsmlsHa: part='
               || pPartNo
               || ' pCage='
               || pCage
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END getPsmlsHa;

      IF (sLife IS NOT NULL)
      THEN
        <<getStorageDays>>
         BEGIN
            SELECT storage_days
              INTO pSlifeDay
              FROM AMD_SHELF_LIFE_CODES
             WHERE sl_code = sLife;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (sqlFunction       => 'select',
                         tableName         => 'amd_shelf_life_codes',
                         pError_location   => 70,
                         key1              => 'sLife=' || sLife);
               DBMS_OUTPUT.put_line (
                     'getStorageDays: sLife='
                  || sLife
                  || ' sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END getStorageDays;
      END IF;


      pSmrCode := GetSmr (pPartNo, pCage);

      IF mDebug AND MOD (psms_cnt, psmsThreshold) = 0
      THEN
         debugMsg (
               'GetPsmsData: '
            || ' pPartNo='
            || pPartNo
            || ' pCage='
            || pCage
            || ' psms_cnt='
            || psms_cnt
            || ' ended:'
            || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
            pError_location   => 94);
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'select',
                   tableName         => 'AMD_SHELF_LIFE_CODES',
                   pError_location   => 80,
                   key1              => 'part=' || pPartNo,
                   key2              => 'cage=' || pCage,
                   key3              => 'GetPsmsData');
         DBMS_OUTPUT.put_line (
               'getPsmsData: pPartNo='
            || pPartNo
            || ' pCage='
            || pCage
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END GetPsmsData;


   FUNCTION IsValidSmr (pSmrCode VARCHAR2)
      RETURN BOOLEAN
   IS
   BEGIN
      IF (SUBSTR (pSmrCode, 6, 1) IN ('T', 'P', 'N'))
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   END IsValidSmr;


   FUNCTION GetPrime (pNsn CHAR)
      RETURN VARCHAR2
   IS
      --
      -- Cursor selects primes w/matching part on same or other rec UNION with
      -- ONE record to use as default if no records satisfy above portion
      --
      TYPE primeRec IS RECORD
      (
         qNo          NUMBER,
         part_type    VARCHAR2 (15),
         part         cat1.part%TYPE,
         prime        cat1.prime%TYPE,
         manuf_cage   cat1.manuf_cage%TYPE
      );

      TYPE primeTab IS TABLE OF primeRec;

      primeRecs     primeTab;

      CURSOR primeCur
      IS
         SELECT DISTINCT
                1 qNo,
                DECODE (part, prime, '1 - Prime', '2 - Equivalent') partType,
                part part,
                prime prime,
                manuf_cage
           FROM CAT1 c1
          WHERE     c1.nsn = pNsn
                AND EXISTS
                       (SELECT 'x'
                          FROM CAT1 c2
                         WHERE c2.nsn = c1.nsn AND c2.part = c1.prime)
         UNION
         SELECT DISTINCT
                2 qNo,
                DECODE (part, prime, '1 - Prime', '2 - Equivalent') partType,
                TRIM (part) part,
                TRIM (prime) prime,
                TRIM (manuf_cage) manuf_cage
           FROM CAT1
          WHERE nsn = pNsn AND ROWNUM = 1
         ORDER BY qNo,
                  partType,
                  prime,
                  part;


      goodPrime     VARCHAR2 (50);
      firstPass     BOOLEAN := TRUE;
      primePrefix   VARCHAR2 (3);
      char1         VARCHAR2 (1);
      char2         VARCHAR2 (1);
      char3         VARCHAR2 (1);
      priority      NUMBER := 0;
   BEGIN
      OPEN primeCur;

      FETCH primeCur BULK COLLECT INTO primeRecs;

      CLOSE primeCur;

      IF primeRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN primeRecs.FIRST .. primeRecs.LAST
         LOOP
            --
            -- Set part of first rec as good prime in case good prime never shows.
            -- Funky logic used in Best Spares to determine good prime compares
            -- first 3 characters to determine good prime.
            --
            IF (firstPass)
            THEN
               goodPrime := primeRecs (indx).part;
               firstPass := FALSE;
            END IF;

            primePrefix := SUBSTR (primeRecs (indx).prime, 1, 3);
            char1 := SUBSTR (primeRecs (indx).prime, 1, 1);
            char2 := SUBSTR (primeRecs (indx).prime, 2, 1);
            char3 := SUBSTR (primeRecs (indx).prime, 3, 1);

            IF (primeRecs (indx).qNo = 1)
            THEN
               IF (    primeRecs (indx).part = primeRecs (indx).prime
                   AND primeRecs (indx).manuf_cage = '88277')
               THEN
                  goodPrime := primeRecs (indx).prime;
                  priority := 6;
               END IF;

               IF (    priority < 6
                   AND primeRecs (indx).part = primeRecs (indx).prime)
               THEN
                  goodPrime := primeRecs (indx).prime;
                  priority := 5;
               END IF;

               IF (priority < 5 AND primePrefix = '17B')
               THEN
                  goodPrime := primeRecs (indx).prime;
                  priority := 4;
               END IF;

               IF (priority < 4 AND primePrefix = '17P')
               THEN
                  goodPrime := primeRecs (indx).prime;
                  priority := 3;
               END IF;

               IF (    priority < 3
                   AND (    (   char1 != '1'
                             OR char2 != '7'
                             OR (char3 NOT IN ('P', 'B')))
                        AND (char1 > '9' OR char1 < '1' OR char2 != 'D')))
               THEN
                  goodPrime := primeRecs (indx).prime;
               END IF;
            END IF;
         END LOOP;
      END IF;

      RETURN goodPrime;
   END GetPrime;


   FUNCTION GetItemType (pSmrCode VARCHAR2)
      RETURN VARCHAR2
   IS
      itemType   VARCHAR2 (1);
      char1      VARCHAR2 (1);
      char6      VARCHAR2 (1);
   BEGIN
      char1 := SUBSTR (pSmrCode, 1, 1);
      char6 := SUBSTR (pSmrCode, 6, 1);

      -- Consumable when smr is P____N
      -- Repairable when smr is P____P
      --              or smr is P____T
      --
      IF (char1 = 'P')
      THEN
         IF (char6 = 'N')
         THEN
            itemType := 'C';
         ELSIF (char6 IN ('P', 'T'))
         THEN
            itemType := 'R';
         END IF;
      END IF;

      RETURN itemType;
   END GetItemType;


   FUNCTION getMic (pNsn VARCHAR2)
      RETURN VARCHAR2
   IS
      l67Mic   VARCHAR2 (1);
   BEGIN
      SELECT MIN (mic)
        INTO l67Mic
        FROM AMD_L67_SOURCE
       WHERE nsn = pNsn AND mic != '*' AND SUBSTR (doc_no, 1, 4) <> 'S005';

      RETURN l67Mic;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN NULL;
   END;


   PROCEDURE getOriginalBssmData (
      nsn           IN     amd_nsns.nsn%TYPE,
      part_no       IN     bssm_parts.PART_NO%TYPE,
      condemn_avg      OUT amd_national_stock_items.condemn_avg%TYPE,
      criticality      OUT amd_national_stock_items.criticality%TYPE,
      nrts_avg         OUT amd_national_stock_items.nrts_avg%TYPE,
      rts_avg          OUT amd_national_stock_items.rts_avg%TYPE,
      amc_demand       OUT amd_national_stock_items.amc_demand%TYPE)
   IS
      PROCEDURE getByPartNo
      IS
      BEGIN
         SELECT condemn,
                criticality,
                nrts,
                rts,
                amc_demand
           INTO condemn_avg,
                criticality,
                nrts_avg,
                rts_avg,
                amc_demand
           FROM bssm_parts bp, AMD_NSNS nsns
          WHERE     lock_sid = ORIGINAL_DATA
                AND bp.part_no = getOriginalBssmData.part_no
                AND bp.nsn = nsns.nsn
                AND bp.nsn IN
                       (SELECT nsn
                          FROM AMD_NSNS
                         WHERE     nsi_sid = nsns.nsi_sid
                               AND nsn_type = CURRENT_NSN);
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            condemn_avg := NULL;
            criticality := NULL;
            nrts_avg := NULL;
            rts_avg := NULL;
            amc_demand := NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (
               sqlFunction       => 'select',
               tableName         => 'bssm_parts',
               pError_location   => 90,
               key1              => 'part=' || getOriginalBssmData.part_no,
               key2              => 'nsn=' || getOriginalBssmData.nsn,
               key3              => 'locksid=' || ORIGINAL_DATA);
            DBMS_OUTPUT.put_line (
                  'getByPartNo: part_no='
               || getOriginalBssmData.part_no
               || ' nsn='
               || getOriginalBssmData.nsn
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END getByPartNo;
   BEGIN
      SELECT condemn,
             criticality,
             nrts,
             rts,
             amc_demand
        INTO condemn_avg,
             criticality,
             nrts_avg,
             rts_avg,
             amc_demand
        FROM bssm_parts bp, AMD_NSNS nsns
       WHERE     lock_sid = ORIGINAL_DATA
             AND nsns.nsn = getOriginalBssmData.nsn
             AND bp.nsn IN
                    (SELECT nsn
                       FROM AMD_NSNS
                      WHERE nsi_sid = nsns.nsi_sid AND nsn_type = CURRENT_NSN);
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         getByPartNo;
      WHEN OTHERS
      THEN
         ErrorMsg (
            sqlFunction       => 'select',
            tableName         => 'bssm_parts',
            pError_location   => 100,
            key1              => 'part=' || getOriginalBssmData.part_no,
            key2              => 'nsn=' || getOriginalBssmData.nsn,
            key3              => 'locksid=' || ORIGINAL_DATA);
         DBMS_OUTPUT.put_line (
               'getOriginalBssmData: part_no='
            || getOriginalBssmData.part_no
            || ' nsn='
            || getOriginalBssmData.nsn
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END getOriginalBssmData;

   FUNCTION getCalculatedData (nsn       IN amd_nsns.nsn%TYPE,
                               part_no   IN bssm_parts.PART_NO%TYPE)
      RETURN amd_national_stock_items.mtbdr_computed%TYPE
   IS
      mtbdr_computed   amd_national_stock_items.MTBDR_COMPUTED%TYPE := NULL;


      PROCEDURE getOriginalByPart
      IS
      BEGIN
         SELECT mtbdr_computed
           INTO mtbdr_computed
           FROM bssm_parts bp
          WHERE     bp.lock_sid = ORIGINAL_DATA
                AND (   bp.part_no = getCalculatedData.part_no
                     OR bp.part_no IS NULL)
                AND bp.nsn = getCalculatedData.nsn
                AND (   amd_utils.ISNSNACTIVEYORN (bp.nsn) = 'Y'
                     OR amd_utils.ISPARTACTIVEYORN (bp.part_no) = 'Y');
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (
               sqlFunction       => 'select',
               tableName         => 'bssm_parts and amd_nsns',
               pError_location   => 110,
               key1              => 'part=' || getCalculatedData.part_no,
               key2              => 'nsn=' || getCalculatedData.nsn,
               key3              => 'locksid=' || ORIGINAL_DATA);
            DBMS_OUTPUT.put_line (
                  'getOriginalByPart: part_no='
               || getCalculatedData.part_no
               || ' nsn='
               || getCalculatedData.nsn
               || ' lock_sid='
               || ORIGINAL_DATA
               || ' returning mtbdr_computed = null'
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
      END getOriginalByPart;


      PROCEDURE getOriginalDataByNsn
      IS
      BEGIN
         SELECT mtbdr_computed
           INTO mtbdr_computed
           FROM bssm_parts p1
          WHERE     nsn = getCalculatedData.nsn
                AND (part_no = getCalculatedData.part_no OR part_no IS NULL)
                AND lock_sid = ORIGINAL_DATA
                AND mtbdr_computed IS NOT NULL
                AND (   amd_utils.ISNSNACTIVEYORN (nsn) = 'Y'
                     OR amd_utils.ISPARTACTIVEYORN (part_no) = 'Y');
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            getOriginalByPart;
         WHEN OTHERS
         THEN
            ErrorMsg (
               sqlFunction       => 'select',
               tableName         => 'bssm_parts and amd_nsns',
               pError_location   => 120,
               key1              => 'part=' || getCalculatedData.part_no,
               key2              => 'nsn=' || getCalculatedData.nsn,
               key3              => 'locksid=' || ORIGINAL_DATA);
            DBMS_OUTPUT.put_line (
                  'getOriginalDataByNsn: part_no='
               || getCalculatedData.part_no
               || ' nsn='
               || getCalculatedData.nsn
               || ' lock_sid='
               || ORIGINAL_DATA
               || ' returning mtbdr_computed = null'
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
      END getOriginalDataByNsn;

      PROCEDURE getCleanedDataByPart
      IS
         cnt   NUMBER := 0;

         CURSOR bssmPartInfo
         IS
            SELECT mtbdr_computed
              INTO mtbdr_computed
              FROM bssm_parts bp
             WHERE     bp.lock_sid = CLEANED_DATA
                   AND mtbdr_computed IS NOT NULL
                   AND (   bp.part_no = getCalculatedData.part_no
                        OR bp.part_no IS NULL)
                   AND bp.nsn =
                          (SELECT nsn
                             FROM bssm_parts
                            WHERE     (   part_no = getCalculatedData.part_no
                                       OR part_no IS NULL)
                                  AND nsn = getCalculatedData.nsn
                                  AND lock_sid = ORIGINAL_DATA)
                   AND (   amd_utils.ISNSNACTIVEYORN (bp.nsn) = 'Y'
                        OR amd_utils.ISPARTACTIVEYORN (
                              getCalculatedData.part_no) = 'Y');
      BEGIN
         FOR rec IN bssmPartInfo
         LOOP
            cnt := cnt + 1;

            IF cnt = 1
            THEN
               mtbdr_computed := rec.mtbdr_computed;
            END IF;
         END LOOP;

         IF cnt > 1
         THEN
            DBMS_OUTPUT.put_line (
                  'getCleanedDataByPart: '
               || cnt
               || ' rows retrieved for part_no='
               || getCalculatedData.part_no
               || ' and lock_sid='
               || ORIGINAL_DATA);
         END IF;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            getOriginalDataByNsn;
         WHEN OTHERS
         THEN
            ErrorMsg (
               sqlFunction       => 'select',
               tableName         => 'bssm_parts and amd_nsns',
               pError_location   => 130,
               key1              => 'part=' || getCalculatedData.part_no,
               key2              => 'nsn=' || getCalculatedData.nsn,
               key3              => 'locksid=' || ORIGINAL_DATA);
            DBMS_OUTPUT.put_line (
                  'getCleanedDataByPart: part_no='
               || getCalculatedData.part_no
               || ' nsn='
               || getCalculatedData.nsn
               || ' lock_sid='
               || ORIGINAL_DATA
               || ' returning mtbdr_computed = null'
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
      END getCleanedDataByPart;
   BEGIN
      SELECT mtbdr_computed
        INTO mtbdr_computed
        FROM bssm_parts p1
       WHERE     nsn = getCalculatedData.nsn
             AND (part_no = getCalculatedData.part_no OR part_no IS NULL)
             AND lock_sid = CLEANED_DATA
             AND mtbdr_computed IS NOT NULL
             AND (   amd_utils.ISNSNACTIVEYORN (nsn) = 'Y'
                  OR EXISTS
                        (SELECT NULL
                           FROM bssm_parts p2
                          WHERE     p1.nsn = p2.nsn
                                AND (   p1.part_no = p2.part_no
                                     OR p2.part_no IS NULL)
                                AND p2.nsn = getCalculatedData.nsn
                                AND lock_sid = ORIGINAL_DATA
                                AND (   amd_utils.isPartActiveYorN (
                                           p2.part_no) = 'Y'
                                     OR amd_utils.IsNsnActiveYorN (p2.nsn) =
                                           'Y')));

      RETURN mtbdr_computed;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         getCleanedDataByPart;
         RETURN mtbdr_computed;
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'select',
                   tableName         => 'bssm_parts and amd_nsns',
                   pError_location   => 140,
                   key1              => 'part=' || getCalculatedData.part_no,
                   key2              => 'nsn=' || getCalculatedData.nsn,
                   key3              => 'locksid=' || CLEANED_DATA);
         DBMS_OUTPUT.put_line (
               'getCalculatedData: part_no='
            || getCalculatedData.part_no
            || ' nsn='
            || getCalculatedData.nsn
            || ' lock_sid='
            || CLEANED_DATA
            || ' returning mtbdr_computed = null'
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RETURN mtbdr_computed;
   END getCalculatedData;


   PROCEDURE getCleanedBssmData (
      nsn                              IN     amd_nsns.nsn%TYPE,
      part_no                          IN     bssm_parts.part_no%TYPE,
      condemn_avg_cleaned                 OUT amd_national_stock_items.condemn_avg_cleaned%TYPE,
      criticality_cleaned                 OUT amd_national_stock_items.criticality_cleaned%TYPE,
      mtbdr_cleaned                       OUT amd_national_stock_items.mtbdr_cleaned%TYPE,
      nrts_avg_cleaned                    OUT amd_national_stock_items.nrts_avg_cleaned%TYPE,
      rts_avg_cleaned                     OUT amd_national_stock_items.rts_avg_cleaned%TYPE,
      order_lead_time_cleaned             OUT amd_national_stock_items.order_lead_time_cleaned%TYPE,
      planner_code_cleaned                OUT amd_national_stock_items.planner_code_cleaned%TYPE,
      smr_code_cleaned                    OUT amd_national_stock_items.smr_code_cleaned%TYPE,
      unit_cost_cleaned                   OUT amd_national_stock_items.unit_cost_cleaned%TYPE,
      cost_to_repair_off_base_cleand      OUT amd_national_stock_items.cost_to_repair_off_base_cleand%TYPE,
      time_to_repair_off_base_cleand      OUT amd_national_stock_items.time_to_repair_off_base_cleand%TYPE,
      amc_demand_cleaned                  OUT amd_national_stock_items.amc_demand_cleaned%TYPE)
   IS
      line_no   NUMBER := 0;
   BEGIN
      line_no := line_no + 1;
      condemn_avg_cleaned := Amd_Clean_Data.GetCondemnAvg (nsn, part_no);
      line_no := line_no + 1;
      criticality_cleaned := Amd_Clean_Data.GetCriticality (nsn, part_no);
      line_no := line_no + 1;
      mtbdr_cleaned := Amd_Clean_Data.GetMtbdr (nsn, part_no);
      line_no := line_no + 1;
      nrts_avg_cleaned := Amd_Clean_Data.GetNrtsAvg (nsn, part_no);
      line_no := line_no + 1;
      rts_avg_cleaned := Amd_Clean_Data.GetRtsAvg (nsn, part_no);
      line_no := line_no + 1;
      order_lead_time_cleaned :=
         Amd_Utils.months2CalendarDays (
            Amd_Clean_Data.GetOrderLeadTime (nsn, part_no));
      line_no := line_no + 1;
      planner_code_cleaned :=
         UPPER (Amd_Clean_Data.GetPlannerCode (nsn, part_no));
      line_no := line_no + 1;
      smr_code_cleaned := UPPER (Amd_Clean_Data.GetSmrCode (nsn, part_no));
      line_no := line_no + 1;
      unit_cost_cleaned := Amd_Clean_Data.GetUnitCost (nsn, part_no);
      line_no := line_no + 1;
      cost_to_repair_off_base_cleand :=
         Amd_Clean_Data.GetCostToRepairOffBase (nsn, part_no);
      line_no := line_no + 1;
      time_to_repair_off_base_cleand :=
         Amd_Utils.months2CalendarDays (
            Amd_Clean_Data.GetTimeToRepairOffBase (nsn, part_no));
      line_no := line_no + 1;
      amc_demand_cleaned := Amd_Clean_Data.GETAMCDEMAND (nsn);
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'getCleanedBssmData',
                   tableName         => 'bssm_parts',
                   pError_location   => 150,
                   key1              => TO_CHAR (line_no),
                   key2              => nsn,
                   key3              => part_no);
         DBMS_OUTPUT.put_line (
               'getCleanedBssmData: nsn='
            || nsn
            || ' part_no='
            || part_no
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END getCleanedBssmData;


   PROCEDURE getBssmData (
      nsn                              IN     amd_nsns.nsn%TYPE,
      part_no                          IN     bssm_parts.part_no%TYPE,
      condemn_avg                         OUT amd_national_stock_items.condemn_avg%TYPE,
      criticality                         OUT amd_national_stock_items.criticality%TYPE,
      mtbdr_computed                      OUT amd_national_stock_items.mtbdr_computed%TYPE,
      nrts_avg                            OUT amd_national_stock_items.nrts_avg%TYPE,
      rts_avg                             OUT amd_national_stock_items.rts_avg%TYPE,
      amc_demand                          OUT amd_national_stock_items.amc_demand%TYPE,
      condemn_avg_cleaned                 OUT AMD_NATIONAL_STOCK_ITEMS.condemn_avg_cleaned%TYPE,
      criticality_cleaned                 OUT AMD_NATIONAL_STOCK_ITEMS.criticality_cleaned%TYPE,
      mtbdr_cleaned                       OUT AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE,
      nrts_avg_cleaned                    OUT AMD_NATIONAL_STOCK_ITEMS.nrts_avg_cleaned%TYPE,
      rts_avg_cleaned                     OUT AMD_NATIONAL_STOCK_ITEMS.rts_avg_cleaned%TYPE,
      order_lead_time_cleaned             OUT AMD_NATIONAL_STOCK_ITEMS.order_lead_time_cleaned%TYPE,
      planner_code_cleaned                OUT AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE,
      smr_code_cleaned                    OUT AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE,
      unit_cost_cleaned                   OUT AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE,
      cost_to_repair_off_base_cleand      OUT AMD_NATIONAL_STOCK_ITEMS.cost_to_repair_off_base_cleand%TYPE,
      time_to_repair_off_base_cleand      OUT AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base_cleand%TYPE,
      amc_demand_cleaned                  OUT amd_national_stock_items.amc_demand_cleaned%TYPE)
   IS
   BEGIN
      getOriginalBssmData (nsn           => nsn,
                           part_no       => part_no,
                           condemn_avg   => condemn_avg,
                           criticality   => criticality,
                           nrts_avg      => nrts_avg,
                           rts_avg       => rts_avg,
                           amc_demand    => amc_demand);

      getCleanedBssmData (
         nsn                              => nsn,
         part_no                          => part_no,
         condemn_avg_cleaned              => condemn_avg_cleaned,
         criticality_cleaned              => criticality_cleaned,
         mtbdr_cleaned                    => mtbdr_cleaned,
         nrts_avg_cleaned                 => nrts_avg_cleaned,
         rts_avg_cleaned                  => rts_avg_cleaned,
         order_lead_time_cleaned          => order_lead_time_cleaned,
         planner_code_cleaned             => planner_code_cleaned,
         smr_code_cleaned                 => smr_code_cleaned,
         unit_cost_cleaned                => unit_cost_cleaned,
         cost_to_repair_off_base_cleand   => cost_to_repair_off_base_cleand,
         time_to_repair_off_base_cleand   => time_to_repair_off_base_cleand,
         amc_demand_cleaned               => amc_demand_cleaned);

      mtbdr_computed := getCalculatedData (nsn => nsn, part_no => part_no);
      planner_code_cleaned :=
         amd_utils.validatePlannerCode (planner_code_cleaned);
   END getBssmData;

   PROCEDURE getRmadsData (
      part_no         IN     amd_rmads_source_tmp.part_no%TYPE,
      qpei_weighted      OUT amd_rmads_source_tmp.QPEI_WEIGHTED%TYPE,
      mtbdr              OUT amd_rmads_source_tmp.MTBDR%TYPE)
   IS
   BEGIN
      SELECT qpei_weighted,
             CASE
                WHEN FLOOR (
                        MONTHS_BETWEEN (SYSDATE, cat1.created_datetime) / 12) <
                        5
                THEN
                   mtbdr
                ELSE
                   NULL
             END
                mtbdr
        INTO qpei_weighted, mtbdr
        FROM AMD_RMADS_SOURCE_TMP, cat1
       WHERE part_no = getRmadsData.part_no AND part_no = cat1.part;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         qpei_weighted := NULL;
         mtbdr := NULL;
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'select',
                   tableName         => 'amd_rmads_source_tmp,cat1',
                   pError_location   => 160,
                   key1              => getRmadsData.part_no);
         DBMS_OUTPUT.put_line (
               'getRmadsData: part_no='
            || getRmadsData.part_no
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END getRmadsData;

   FUNCTION getOrderLeadTime (part IN cat1.part%TYPE)
      RETURN NUMBER
   IS
      ave_cap_lead_time   cat1.AVE_CAP_LEAD_TIME%TYPE;
   BEGIN
      SELECT ave_cap_lead_time
        INTO getOrderLeadTime.ave_cap_lead_time
        FROM CAT1
       WHERE part = (getOrderleadTime.part);

      IF ave_cap_lead_time = 0
      THEN
         ave_cap_lead_time := NULL;
      END IF;

      RETURN ave_cap_lead_time;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN NULL;
   END getOrderLeadTime;

   PROCEDURE setDebugThreshold (VALUE IN NUMBER := NULL)
   IS
   BEGIN
      IF VALUE IS NULL
      THEN
         SELECT ROUND (COUNT (*) / 10)
           INTO debugThreshold
           FROM amd_spare_parts
          WHERE action_code <> amd_defaults.getDELETE_ACTION;
      ELSE
         debugThreshold := VALUE;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         debugThreshold := 10000;
   END setDebugThreshold;

   PROCEDURE setPsmsThreshold (VALUE IN NUMBER := NULL)
   IS
   BEGIN
      IF VALUE IS NULL
      THEN
         SELECT ROUND (COUNT (*) / 10)
           INTO psmsThreshold
           FROM amd_spare_parts
          WHERE action_code <> amd_defaults.getDELETE_ACTION;
      ELSE
         psmsThreshold := VALUE;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         psmsThreshold := 500;
   END setPsmsThreshold;

   PROCEDURE setStartDebugRec (VALUE IN NUMBER)
   IS
   BEGIN
      startDebugRec := VALUE;
   END setStartDebugRec;

   FUNCTION getStartDebugRec
      RETURN NUMBER
   IS
   BEGIN
      RETURN startDebugRec;
   END getStartDebugRec;

   FUNCTION getDebugThreshold
      RETURN NUMBER
   IS
   BEGIN
      RETURN debugThreshold;
   END getDebugThreshold;



   PROCEDURE LoadGold
   IS
      bulk_errors       EXCEPTION;
      PRAGMA EXCEPTION_INIT (bulk_errors, -24381);

      TYPE tmpRecs IS TABLE OF tmp_amd_spare_parts%ROWTYPE
         INDEX BY PLS_INTEGER;

      recsOut           tmpRecs;

      TYPE catRec IS RECORD
      (
         nsn                   cat1.nsn%TYPE,
         part_type             VARCHAR2 (10),
         part                  cat1.part%TYPE,
         prime                 cat1.prime%TYPE,
         manuf_cage            cat1.manuf_cage%TYPE,
         source_code           cat1.source_code%TYPE,
         noun                  cat1.noun%TYPE,
         serial_mandatory_b    cat1.serial_mandatory_b%TYPE,
         ims_designator_code   cat1.ims_designator_code%TYPE,
         smrc                  cat1.smrc%TYPE,
         um_cap_code           cat1.um_cap_code%TYPE,
         user_ref7             cat1.user_ref7%TYPE,
         um_show_code          cat1.um_show_code%TYPE
      );

      TYPE catTab IS TABLE OF catRec;

      catRecs           catTab;

      CURSOR catCur
      IS
         SELECT nsn,
                DECODE (prime, part, 'PRIME', 'EQUIVALENT') partType,
                part,
                prime,
                manuf_cage,
                source_code,
                noun,
                serial_mandatory_b,
                ims_designator_code,
                smrc,
                um_cap_code,
                user_ref7,
                um_show_code
           FROM CAT1
          WHERE     source_code = amd_defaults.getSourceCode
                AND nsn NOT LIKE 'N%'
         UNION
         SELECT nsn,
                DECODE (prime, part, 'PRIME', 'EQUIVALENT') partType,
                part,
                prime,
                manuf_cage,
                source_code,
                noun,
                serial_mandatory_b,
                ims_designator_code,
                smrc,
                um_cap_code,
                TRIM (user_ref7) user_ref7,
                um_show_code
           FROM CAT1
          WHERE     source_code = amd_defaults.getSourceCode
                AND nsn LIKE amd_defaults.getNonStockageList || '%'
                AND part = prime
         ORDER BY nsn, partType DESC, part;



      loadNo            NUMBER;
      nsn               VARCHAR2 (50);
      prevNsn           VARCHAR2 (50) := 'prevNsn';
      nsnStripped       VARCHAR2 (50);
      goodPrime         VARCHAR2 (50);
      primeInd          VARCHAR2 (1);
      itemType          VARCHAR2 (1);
      smrCode           VARCHAR2 (6);
      orderUom          VARCHAR2 (2);
      orderleadTime     NUMBER;
      plannerCode       VARCHAR2 (8);
      nsnType           VARCHAR2 (1);
      hasPrimeRec       BOOLEAN;
      sequenced         BOOLEAN;
      l67Mic            VARCHAR2 (1);
      unitCost          NUMBER;
      unitOfIssue       VARCHAR2 (2);
      mMac              VARCHAR2 (2);
      rowsInserted      NUMBER := 0;
      loopStartTime     NUMBER := 0;
      cur_line          NUMBER := 0;
      trigger_problem   BOOLEAN := FALSE;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_spare_parts',
         pError_location   => 170,
         pKey1             => 'loadGold',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
      Mta_Truncate_Table ('tmp_amd_spare_parts', 'reuse storage');

      loadNo := Amd_Utils.GetLoadNo ('GOLD', 'TMP_AMD_SPARE_PARTS');

      OPEN catCur;

      FETCH catCur BULK COLLECT INTO catRecs;

      CLOSE catCur;


      IF catRecs.FIRST IS NOT NULL
      THEN
         writeMsg (
            pTableName        => 'tmp_amd_spare_parts',
            pError_location   => 210,
            pKey1             => 'cat1_loop',
            pKey2             =>    'started at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'));


         FOR indx IN catRecs.FIRST .. catRecs.LAST
         LOOP
           <<cat1_proc>>
            BEGIN
               loopStartTime := DBMS_UTILITY.get_time;

               IF (catRecs (indx).nsn LIKE
                      amd_defaults.getNonStockageList || '%')
               THEN
                  sequenced := TRUE;
                  nsn :=
                     Amd_Nsl_Sequence_Pkg.SequenceTheNsl (
                        catRecs (indx).prime);
               ELSE
                  sequenced := FALSE;
                  nsn := catRecs (indx).nsn;
               END IF;

               cur_line := 10;

               IF (nsn != prevNsn)
               THEN
                  prevNsn := nsn;
                  nsnStripped := Amd_Utils.FormatNsn (nsn);

                  -- If sequenceTheNsl() returned an NSL$ then it is assumed to be
                  -- the prime, otherwise, run it through the getPrime() logic.
                  --
                  IF (nsn LIKE amd_defaults.getNonStockageList || '%')
                  THEN
                     IF (NOT onNsl (catRecs (indx).part))
                     THEN
                        -- An NSL starts the part/nsn process so 'delete' the part
                        -- so the diff will think it's a brand new part and
                        -- assign it its own nsi_sid.
                        --
                        performLogicalDelete (catRecs (indx).part);
                     END IF;

                     goodPrime := catRecs (indx).part;
                  ELSE
                     goodPrime := GetPrime (nsn);
                  END IF;

                  cur_line := 20;

                  nsnType := 'C';
                  cur_line := 30;
                  plannerCode :=
                     amd_utils.validatePlannerCode (
                        catRecs (indx).ims_designator_code);
                  cur_line := 40;
                  itemType := NULL;
                  cur_line := 50;
                  smrCode := catRecs (indx).smrc;

                  cur_line := 60;

                  IF LENGTH (catRecs (indx).um_show_code) <= 2
                  THEN
                     unitOfIssue := catRecs (indx).um_show_code;
                  ELSIF LENGTH (catRecs (indx).um_show_code) > 2
                  THEN
                     IF UPPER (catRecs (indx).um_show_code) = 'KIT'
                     THEN
                        unitOfIssue := 'KT';
                     ELSE
                        unitOfIssue :=
                           SUBSTR (catRecs (indx).um_show_code, 1, 2);
                     END IF;
                  END IF;

                  cur_line := 70;

                  IF LENGTH (catRecs (indx).um_cap_code) <= 2
                  THEN
                     orderUom := catRecs (indx).um_cap_code;
                  ELSE
                     IF LENGTH (catRecs (indx).um_cap_code) > 2
                     THEN
                        orderUom := SUBSTR (catRecs (indx).um_cap_code, 1, 2);
                     END IF;
                  END IF;

                  cur_line := 80;

                  IF (IsValidSmr (smrCode))
                  THEN
                     itemType := GetItemType (smrCode);
                  END IF;
               END IF;

               -- if GetPrime() returned a null that means that the nsn no longer
               -- exists in Gold. This happens when a part goes from an NCZ to an NSL
               --
               IF (goodPrime IS NULL OR catRecs (indx).part = goodPrime)
               THEN
                  primeInd := 'Y';
               ELSE
                  primeInd := 'N';
               END IF;

               cur_line := 90;

               l67Mic := getMic (nsnStripped);
               cur_line := 100;

               unitCost := getUnitCost (catRecs (indx).part);
               cur_line := 110;

               mMac := getMmac (catRecs (indx).nsn);
               cur_line := 120;

               IF     mDebug
                  AND (   rowsInserted > startDebugRec
                       OR MOD (indx, debugThreshold) = 0)
               THEN
                  debugMsg (
                        'rowsInserted='
                     || rowsInserted
                     || ' part='
                     || catRecs (indx).part
                     || ' time:'
                     || (DBMS_UTILITY.get_time - loopStartTime),
                     pError_location   => 220);
               END IF;
            EXCEPTION
               WHEN OTHERS
               THEN
                  ErrorMsg (sqlFunction       => 'select',
                            tableName         => 'cat1',
                            key1              => catRecs (indx).part,
                            key2              => 'cur_line=' || cur_line,
                            pError_location   => 230);
                  DBMS_OUTPUT.put_line (
                        'cat1_proc: part='
                     || catRecs (indx).part
                     || ' sqlcode='
                     || SQLCODE
                     || ' sqlerrm='
                     || SQLERRM);
                  RAISE;
            END cat1_proc;

           -- 4/13/05 DSE created insertTmpAmdSpareParts block of code

           <<insertTmpAmdSpareParts>>
            DECLARE
               mtbdr                            AMD_NATIONAL_STOCK_ITEMS.mtbdr%TYPE;
               mtbdr_cleaned                    AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE;
               qpei_weighted                    AMD_NATIONAL_STOCK_ITEMS.qpei_weighted%TYPE;
               condemn_avg                      AMD_NATIONAL_STOCK_ITEMS.condemn_avg%TYPE;
               condemn_avg_cleaned              AMD_NATIONAL_STOCK_ITEMS.condemn_avg_cleaned%TYPE;
               criticality                      AMD_NATIONAL_STOCK_ITEMS.criticality%TYPE;
               criticality_cleaned              AMD_NATIONAL_STOCK_ITEMS.criticality_cleaned%TYPE;
               nrts_avg                         AMD_NATIONAL_STOCK_ITEMS.nrts_avg%TYPE;
               nrts_avg_cleaned                 AMD_NATIONAL_STOCK_ITEMS.nrts_avg_cleaned%TYPE;
               cost_to_repair_off_base_cleand   AMD_NATIONAL_STOCK_ITEMS.cost_to_repair_off_base_cleand%TYPE;
               time_to_repair_off_base_cleand   AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base_cleand%TYPE;
               order_lead_time_cleaned          AMD_NATIONAL_STOCK_ITEMS.order_lead_time_cleaned%TYPE;
               planner_code_cleaned             AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE;
               rts_avg                          AMD_NATIONAL_STOCK_ITEMS.rts_avg%TYPE;
               rts_avg_cleaned                  AMD_NATIONAL_STOCK_ITEMS.rts_avg_cleaned%TYPE;
               smr_code_cleaned                 AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE;
               unit_cost_cleaned                AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE;
               cost_to_repair_off_base          AMD_NATIONAL_STOCK_ITEMS.cost_to_repair_off_base%TYPE;
               time_to_repair_off_base          AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base%TYPE;
               mtbdr_computed                   amd_national_stock_items.mtbdr_computed%TYPE;
               amc_demand                       amd_national_stock_items.amc_demand%TYPE;
               amc_demand_cleaned               amd_national_stock_items.amc_demand_cleaned%TYPE;

               PROCEDURE addRec (indx IN NUMBER)
               IS
               BEGIN
                  recsOut (indx).part_no := catRecs (indx).part;
                  cur_line := 130;
                  recsOut (indx).mfgr := catRecs (indx).manuf_cage;
                  cur_line := 140;
                  recsOut (indx).icp_ind := catRecs (indx).source_code;
                  cur_line := 150;
                  recsOut (indx).item_type := itemType;
                  cur_line := 160;
                  recsOut (indx).nomenclature := catRecs (indx).noun;
                  cur_line := 170;
                  recsOut (indx).nsn := nsnStripped;
                  cur_line := 180;
                  recsOut (indx).nsn_type := nsnType;
                  cur_line := 190;
                  recsOut (indx).planner_code := plannerCode;
                  cur_line := 200;

                  IF LENGTH (catRecs (indx).um_cap_code) <= 2
                  THEN
                     recsOut (indx).order_uom := catRecs (indx).um_cap_code;
                     cur_line := 210;
                  ELSE
                     IF LENGTH (catRecs (indx).um_cap_code) > 2
                     THEN
                        recsOut (indx).order_uom :=
                           SUBSTR (catRecs (indx).um_cap_code, 1, 2);
                     END IF;
                  END IF;

                  IF useBizDays
                  THEN
                     recsOut (indx).order_lead_time :=
                        amd_utils.bizDays2CalendarDays (
                           getOrderLeadTime (catRecs (indx).part));
                     cur_line := 220;
                  ELSE
                     recsOut (indx).order_lead_time :=
                        getOrderLeadTime (catRecs (indx).part);
                     cur_line := 220;
                  END IF;

                  recsOut (indx).prime_ind := primeInd;
                  cur_line := 230;
                  recsOut (indx).serial_flag :=
                     catRecs (indx).serial_mandatory_b;
                  cur_line := 240;
                  recsOut (indx).smr_code := smrCode;
                  cur_line := 250;
                  recsOut (indx).acquisition_advice_code :=
                     catRecs (indx).user_ref7;
                  cur_line := 260;
                  recsOut (indx).unit_cost := unitCost;
                  cur_line := 270;
                  recsOut (indx).mic := l67Mic;
                  cur_line := 280;
                  recsOut (indx).mmac := mMac;
                  cur_line := 290;
                  recsOut (indx).unit_of_issue := unitOfIssue;
                  cur_line := 300;
                  recsOut (indx).mtbdr := mtbdr;
                  cur_line := 310;
                  recsOut (indx).mtbdr_computed := mtbdr_computed;
                  cur_line := 320;
                  recsOut (indx).mtbdr_cleaned := mtbdr_cleaned;
                  cur_line := 330;
                  recsOut (indx).qpei_weighted := qpei_weighted;
                  cur_line := 340;
                  recsOut (indx).condemn_avg := condemn_avg;
                  cur_line := 350;
                  recsOut (indx).condemn_avg_cleaned := condemn_avg_cleaned;
                  cur_line := 360;
                  recsOut (indx).criticality := criticality;
                  cur_line := 370;
                  recsOut (indx).criticality_cleaned := criticality_cleaned;
                  cur_line := 380;
                  recsOut (indx).nrts_avg_cleaned := nrts_avg_cleaned;
                  cur_line := 390;
                  recsOut (indx).nrts_avg := nrts_avg;
                  cur_line := 400;
                  recsOut (indx).time_to_repair_off_base_cleand :=
                     time_to_repair_off_base_cleand;
                  cur_line := 410;
                  recsOut (indx).order_lead_time_cleaned :=
                     order_lead_time_cleaned;
                  cur_line := 420;
                  recsOut (indx).planner_code_cleaned := planner_code_cleaned;
                  cur_line := 430;
                  recsOut (indx).rts_avg := rts_avg;
                  cur_line := 440;
                  recsOut (indx).rts_avg_cleaned := rts_avg_cleaned;
                  cur_line := 450;
                  recsOut (indx).smr_code_cleaned := smr_code_cleaned;
                  cur_line := 460;
                  recsOut (indx).unit_cost_cleaned := unit_cost_cleaned;
                  cur_line := 470;
                  recsOut (indx).cost_to_repair_off_base :=
                     cost_to_repair_off_base;
                  cur_line := 480;
                  recsOut (indx).time_to_repair_off_base :=
                     time_to_repair_off_base;
                  cur_line := 490;
                  recsOut (indx).amc_demand := amc_demand;
                  cur_line := 500;
                  recsOut (indx).amc_demand_cleaned := amc_demand_cleaned;
                  cur_line := 510;
                  recsOut (indx).last_update_dt := SYSDATE;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     ErrorMsg (sqlFunction       => 'addRec',
                               tableName         => 'tmp_amd_spare_parts',
                               pError_location   => 180,
                               key1              => catRecs (indx).part,
                               key2              => 'cur_line=' || cur_line);
                     DBMS_OUTPUT.put_line (
                           'addRec: part='
                        || catRecs (indx).part
                        || ' sqlcode='
                        || SQLCODE
                        || ' sqlerrm='
                        || SQLERRM);
                     RAISE;
               END addRec;
            BEGIN
               getBssmData (
                  nsn                              => nsnStripped,
                  part_no                          => catRecs (indx).part,
                  condemn_avg                      => condemn_avg,
                  criticality                      => criticality,
                  mtbdr_computed                   => mtbdr_computed,
                  nrts_avg                         => nrts_avg,
                  rts_avg                          => rts_avg,
                  amc_demand                       => amc_demand,
                  condemn_avg_cleaned              => condemn_avg_cleaned,
                  criticality_cleaned              => criticality_cleaned,
                  mtbdr_cleaned                    => mtbdr_cleaned,
                  nrts_avg_cleaned                 => nrts_avg_cleaned,
                  rts_avg_cleaned                  => rts_avg_cleaned,
                  order_lead_time_cleaned          => order_lead_time_cleaned,
                  planner_code_cleaned             => planner_code_cleaned,
                  smr_code_cleaned                 => smr_code_cleaned,
                  unit_cost_cleaned                => unit_cost_cleaned,
                  cost_to_repair_off_base_cleand   => cost_to_repair_off_base_cleand,
                  time_to_repair_off_base_cleand   => time_to_repair_off_base_cleand,
                  amc_demand_cleaned               => amc_demand_cleaned);

               getRmadsData (part_no         => catRecs (indx).part,
                             qpei_weighted   => qpei_weighted,
                             mtbdr           => mtbdr);

               cur_line := 520;

               IF primeInd = 'Y'
               THEN
                  cur_line := 530;
                  cost_to_repair_off_base :=
                     GetOffBaseRepairCost (catRecs (indx).part);
                  cur_line := 540;
                  time_to_repair_off_base :=
                     GetOffBaseTurnAround (catRecs (indx).part);
               END IF;

               cur_line := 550;
               rowsInserted := rowsInserted + 1;
               cur_line := 560;
               addRec (rowsInserted);
               cur_line := 570;

               IF recsOut.COUNT >= bulkInsertThreshold
               THEN
                  FORALL i IN recsOut.FIRST .. recsOut.LAST SAVE EXCEPTIONS
                     INSERT INTO tmp_amd_spare_parts
                          VALUES recsOut (i);

                  recsOut.delete;
               END IF;

               cur_line := 580;

               IF MOD (indx, debugThreshold) = 0
               THEN
                  debugMsg (
                     'indx=' || indx || ' part=' || catRecs (indx).part,
                     pError_location   => 250);
               END IF;
            EXCEPTION
               WHEN bulk_errors
               THEN
                  FOR j IN 1 .. SQL%BULK_EXCEPTIONS.COUNT
                  LOOP
                     ErrorMsg (
                        sqlFunction       => 'insert',
                        tableName         => 'tmp_amd_spare_parts',
                        pError_location   => 190,
                        key1              =>    'index='
                                             || TO_CHAR (
                                                   SQL%BULK_EXCEPTIONS (j).ERROR_INDEX),
                        key2              => SQLERRM (
                                               SQL%BULK_EXCEPTIONS (j).ERROR_CODE));

                     IF SQL%BULK_EXCEPTIONS (j).ERROR_CODE = -4098
                     THEN
                        trigger_problem := TRUE;
                     END IF;
                  END LOOP;

                  IF NOT trigger_problem
                  THEN
                     DBMS_OUTPUT.put_line (
                           'insertTmpAmdSpareParts: 1'
                        || ' sqlcode='
                        || SQLCODE
                        || ' sqlerrm='
                        || SQLERRM);
                     RAISE;
                  END IF;
               WHEN OTHERS
               THEN
                  ErrorMsg (sqlFunction       => 'insert',
                            tableName         => 'tmp_amd_spare_parts',
                            pError_location   => 200,
                            key1              => nsnStripped,
                            key2              => catRecs (indx).part,
                            key3              => catRecs (indx).manuf_cage,
                            key4              => 'cur_line=' || cur_line);

                  IF SQLCODE = -4098
                  THEN
                     trigger_problem := TRUE;
                  END IF;

                  IF NOT trigger_problem
                  THEN
                     DBMS_OUTPUT.put_line (
                           'insertTmpAmdSpareParts: 2'
                        || ' sqlcode='
                        || SQLCODE
                        || ' sqlerrm='
                        || SQLERRM);
                     RAISE;
                  END IF;
            END insertTmpAmdSpareParts;

            cur_line := 590;


            IF MOD (indx, debugThreshold) = 0
            THEN
               debugMsg ('indx=' || indx || ' part=' || catRecs (indx).part,
                         pError_location   => 280);
            END IF;
         --end loop;
         END LOOP;

         writeMsg (
            pTableName        => 'tmp_amd_spare_parts',
            pError_location   => 290,
            pKey1             => 'cat1_loop',
            pKey2             =>    'ended at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'));

         writeMsg (
            pTableName        => 'tmp_amd_spare_parts',
            pError_location   => 212,
            pKey1             => 'bulk_insert',
            pKey2             =>    'started at '
                                 || TO_CHAR (SYSDATE,
                                             'MM/DD/YYYY HH:MI:SS AM'));

        <<bulk_insert>>
         BEGIN
            FORALL i IN recsOut.FIRST .. recsOut.LAST SAVE EXCEPTIONS
               INSERT INTO tmp_amd_spare_parts
                    VALUES recsOut (i);

            writeMsg (
               pTableName        => 'tmp_amd_spare_parts',
               pError_location   => 214,
               pKey1             => 'bulk_insert',
               pKey2             =>    'ended at '
                                    || TO_CHAR (SYSDATE,
                                                'MM/DD/YYYY HH:MI:SS AM'));
         EXCEPTION
            WHEN bulk_errors
            THEN
               FOR j IN 1 .. SQL%BULK_EXCEPTIONS.COUNT
               LOOP
                  ErrorMsg (
                     sqlFunction       => 'insert',
                     tableName         => 'tmp_amd_spare_parts',
                     pError_location   => 215,
                     key1              =>    'index='
                                          || TO_CHAR (
                                                SQL%BULK_EXCEPTIONS (j).ERROR_INDEX),
                     key2              => SQLERRM (
                                            SQL%BULK_EXCEPTIONS (j).ERROR_CODE));
               END LOOP;

               DBMS_OUTPUT.put_line (
                     'loadGold: bulk_insert sqlcode='
                  || SQLCODE
                  || ' sqlerrm='
                  || SQLERRM);
               RAISE;
         END bulk_insert;
      END IF;

      writeMsg (
         pTableName        => 'tmp_amd_spare_parts',
         pError_location   => 220,
         pKey1             => 'loadGold',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => 'rowsInserted=' || TO_CHAR (rowsInserted));

      DBMS_OUTPUT.put_line (
            'loadGold: '
         || rowsInserted
         || ' rows inserted to tmp_amd_spare_parts');


      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'loadGold',
                   tableName         => 'tmp_amd_spare_parts',
                   pError_location   => 230,
                   key1              => 'cur_line=' || cur_line);
         DBMS_OUTPUT.put_line (
               'loadGold had an error - check amd_load_details. rowsInserted='
            || rowsInserted
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END LoadGold;


   PROCEDURE LoadRblPairs
   IS
      CURSOR rblpairs
      IS
           SELECT old_nsn,
                  new_nsn,
                  subgroup_code,
                  part_pref_code,
                  SYSDATE,
                  'A'
             FROM amd_isgp_rbl_pairs_v
         ORDER BY old_nsn, subgroup_code, part_pref_code;

      dup_cnt   NUMBER := 0;
      ins_cnt   NUMBER := 0;
   BEGIN
      mta_truncate_table ('AMD_RBL_PAIRS', 'reuse storage');


      --Populate data into table AMD_RBL_PAIRS
      FOR rec IN rblpairs
      LOOP
        <<insertRblPairs>>
         BEGIN
            INSERT INTO AMD_RBL_PAIRS (old_nsn,
                                       new_nsn,
                                       subgroup_code,
                                       part_pref_code,
                                       last_update_dt,
                                       action_code)
                 VALUES (rec.old_nsn,
                         rec.new_nsn,
                         rec.subgroup_code,
                         rec.part_pref_code,
                         SYSDATE,
                         'A');

            ins_cnt := ins_cnt + 1;
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX
            THEN
               dup_cnt := dup_cnt + 1;
               DBMS_OUTPUT.put_line (
                     'duplicate: '
                  || rec.old_nsn
                  || ','
                  || rec.new_nsn
                  || ','
                  || rec.subgroup_code
                  || ','
                  || rec.part_pref_code);
         END insertRblPairs;
      END LOOP;

      IF dup_cnt > 0
      THEN
         DBMS_OUTPUT.put_line ('number of duplicates=' || dup_cnt);
      END IF;

      DBMS_OUTPUT.put_line ('LoadRblPairs: rows inserted=' || ins_cnt);
   END LoadRblPairs;



   PROCEDURE LoadPsms
   IS
      TYPE t_shelf_life_tab IS TABLE OF tmp_amd_spare_parts.SHELF_LIFE%TYPE;

      TYPE t_unit_volume_tab IS TABLE OF tmp_amd_spare_parts.UNIT_VOLUME%TYPE;

      TYPE t_smr_code_tab IS TABLE OF tmp_amd_spare_parts.SMR_CODE%TYPE;

      TYPE t_item_type_tab IS TABLE OF tmp_amd_spare_parts.ITEM_TYPE%TYPE;

      shelf_life_tab      t_shelf_life_tab;
      unit_volume_tab     t_unit_volume_tab;
      smr_code_tab        t_smr_code_tab;
      item_type_tab       t_item_type_tab;
      part_no_tab         t_part_no_tab;

      CURSOR F77
      IS
         SELECT TRIM (tp.part_no) part_no,
                CASE
                   WHEN SUBSTR (slic.smr_code, 6, 1) IN ('P', 'T', 'N')
                   THEN
                      TRIM (slic.smr_code)
                   ELSE
                      tp.smr_code
                END
                   smr_code,
                CASE
                   WHEN SUBSTR (slic.smr_code, 1, 1) = 'P'
                   THEN
                      CASE
                         WHEN SUBSTR (slic.smr_code, 6, 1) IN ('P', 'T')
                         THEN
                            'R'                                  -- repairable
                         WHEN SUBSTR (slic.smr_code, 6, 1) = 'N'
                         THEN
                            'C'                                  -- consumable
                         ELSE
                            tp.item_type
                      END
                   ELSE
                      tp.item_type
                END
                   item_type,
                slic.storage_days,
                slic.unit_volume
           FROM TMP_AMD_SPARE_PARTS tp, slic_ha_shelf_life_v slic
          WHERE     slic.part_no = CAST (tp.part_no AS CHAR (50))
                AND slic.mfgr = CAST (tp.mfgr AS CHAR (5));

      cnt                 NUMBER := 0;
      loadPsmsStartTime   NUMBER := DBMS_UTILITY.get_time;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_spare_parts',
         pError_location   => 240,
         pKey1             => 'loadPsms',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      --
      --     Get the load_no for insert into amd_load_status table
      --

      --
      -- select ICP Part/CAGE and check to see if the part is existing in PSMS.
      --
      OPEN f77;

      FETCH f77
         BULK COLLECT INTO part_no_tab,
              smr_code_tab,
              item_type_tab,
              shelf_life_tab,
              unit_volume_tab;

      CLOSE f77;

      IF part_no_tab.FIRST IS NOT NULL
      THEN
        <<bulkUpdt>>
         BEGIN
            FORALL i IN part_no_tab.FIRST .. part_no_tab.LAST
               UPDATE tmp_amd_spare_parts
                  SET shelf_life = shelf_life_tab (i),
                      unit_volume = unit_volume_tab (i),
                      smr_code = smr_code_tab (i),
                      item_type = item_type_tab (i)
                WHERE part_no = part_no_tab (i) AND smr_code IS NULL;

            FOR i IN part_no_tab.FIRST .. part_no_tab.LAST
            LOOP
               cnt := cnt + SQL%BULK_ROWCOUNT (i);
            END LOOP;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (sqlFunction       => 'bulk_update',
                         tableName         => 'tmp_amd_spare_parts',
                         pError_location   => 260,
                         key1              => 'bulkUpdt');
               DBMS_OUTPUT.put_line (
                  'bulkUpdt: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM);
               RAISE;
         END bulkUpdt;
      END IF;

      DBMS_OUTPUT.put_line (
         'loadPsms: ' || cnt || ' rows loaded to tmp_amd_spare_parts');
      writeMsg (
         pTableName        => 'tmp_amd_spare_parts',
         pError_location   => 270,
         pKey1             => 'loadPsms',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => 'rowsUpdated=' || TO_CHAR (cnt),
         pKey4             =>    'elapsedTime='
                              || (DBMS_UTILITY.get_time - loadPsmsStartTime));

      COMMIT;
      debugMsg (
         'loadPsms secs:' || (DBMS_UTILITY.get_time - loadPsmsStartTime),
         pError_location   => 350);
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (sqlFunction       => 'load',
                   tableName         => 'tmp_amd_spare_parts',
                   pError_location   => 280,
                   key1              => 'loadPsms',
                   key2              => 'cnt=' || cnt);
         DBMS_OUTPUT.put_line (
               'loadPsms: cnt='
            || cnt
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END LoadPsms;



   PROCEDURE LoadMain
   IS
      TYPE mainRec IS RECORD
      (
         part_no     tmp_amd_spare_parts.part_no%TYPE,
         nsn         tmp_amd_spare_parts.nsn%TYPE,
         prime_ind   tmp_amd_spare_parts.prime_ind%TYPE,
         smrCode6    VARCHAR2 (1)
      );

      TYPE mainTab IS TABLE OF mainRec;

      mainRecs             mainTab;

      TYPE t_order_quantity_tab
         IS TABLE OF tmp_amd_spare_parts.ORDER_QUANTITY%TYPE;

      order_quantity_tab   t_order_quantity_tab := t_order_quantity_tab ();
      part_no_tab          t_part_no_tab := t_part_no_tab ();


      CURSOR f77Cur
      IS
           SELECT part_no,
                  nsn,
                  prime_ind,
                  SUBSTR (smr_code, 6, 1) smrCode6
             FROM TMP_AMD_SPARE_PARTS
         ORDER BY nsn, prime_ind DESC;



      loadNo               NUMBER;
      cnt                  NUMBER := 0;
      maxPoDate            DATE;
      maxPo                VARCHAR2 (20);
      leadTime             NUMBER;
      orderUom             VARCHAR2 (2);
      orderQuantity        NUMBER;
      orderQty             NUMBER;
      poAge                NUMBER;
      prevNsn              VARCHAR2 (15) := 'prevNsn';
      loadMainStartTime    NUMBER := DBMS_UTILITY.get_time;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_spare_parts',
         pError_location   => 290,
         pKey1             => 'loadMain',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
      COMMIT;
      --
      --     Get the load_no for insert into amd_load_status table
      --
      loadNo := Amd_Utils.GetLoadNo ('MAIN', 'TMP_AMD_SPARE_PARTS');

      OPEN f77Cur;

      FETCH f77Cur BULK COLLECT INTO mainRecs;

      CLOSE f77Cur;

      IF mainRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN mainRecs.FIRST .. mainRecs.LAST
         LOOP
            --
            -- Attempt to get some values from tmp_main.(Only look at po's that
            -- have a length of 9.)
            --
            BEGIN
               --
               -- select the latest PO date.
               --
               SELECT MAX (TO_DATE (po_date, 'RRMMDD')) po_date,
                      (TRUNC (SYSDATE) - MAX (TO_DATE (po_date, 'RRMMDD')))
                         po_age
                 INTO maxPoDate, poAge
                 FROM TMP_MAIN
                WHERE     part_no = mainRecs (indx).part_no
                      AND LENGTH (SUBSTR (po_no, 1, INSTR (po_no, ' ') - 1)) =
                             9;

               --
               -- get latest PO
               --
               SELECT MAX (po_no)
                 INTO maxPo
                 FROM TMP_MAIN
                WHERE     part_no = mainRecs (indx).part_no
                      AND po_date = TO_CHAR (maxPoDate, 'RRMMDD')
                      AND LENGTH (SUBSTR (po_no, 1, INSTR (po_no, ' ') - 1)) =
                             9;

               SELECT --total_lead_time,  -- getting lead_time from Cat1 table  3/1/07
                      DISTINCT order_qty
                 INTO                                              --leadTime,
                     orderQuantity
                 FROM TMP_MAIN
                WHERE     part_no = mainRecs (indx).part_no
                      AND po_date = TO_CHAR (maxPoDate, 'RRMMDD')
                      AND po_no = maxPo
                      AND LENGTH (SUBSTR (po_no, 1, INSTR (po_no, ' ') - 1)) =
                             9;



               -- We apply the order_quantity we got from the prime part
               -- to all the equivalent parts so we only set it here when the
               -- prime rec comes in.  The prime rec is the first rec in the
               -- nsn series due to the sort order of the cursor.
               --
               IF (mainRecs (indx).nsn != prevNsn)
               THEN
                  prevNsn := mainRecs (indx).nsn;
                  orderQty := orderQuantity;
               END IF;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  orderQuantity := NULL;
               WHEN OTHERS
               THEN
                  ErrorMsg (sqlFunction       => 'loadMain',
                            tableName         => 'tmp_main',
                            pError_location   => 280,
                            key1              => mainRecs (indx).part_no,
                            key2              => maxPoDate,
                            key3              => maxPo);
                  COMMIT;
                  DBMS_OUTPUT.put_line (
                        'loadMain: part_no='
                     || mainRecs (indx).part_no
                     || ' maxPoDate='
                     || maxPoDate
                     || ' maxPo='
                     || maxPo
                     || ' sqlcode='
                     || SQLCODE
                     || ' sqlerrm='
                     || SQLERRM);
                  RAISE;
            END;

            order_quantity_tab.EXTEND;
            part_no_tab.EXTEND;
            order_quantity_tab (order_quantity_tab.LAST) := orderQty;
            part_no_tab (part_no_tab.LAST) := mainRecs (indx).part_no;

            /*
            UPDATE TMP_AMD_SPARE_PARTS SET
    --            order_lead_time = Amd_Utils.bizDays2CalendarDays(leadTime),
    --            order_uom = orderUom,
                order_quantity  = orderQty
            WHERE
                part_no       = mainRecs(indx).part_no;
             */
            cnt := cnt + 1;
         END LOOP;

         FORALL i IN order_quantity_tab.FIRST .. order_quantity_tab.LAST
            UPDATE tmp_amd_spare_parts
               SET order_quantity = order_quantity_tab (i)
             WHERE part_no = part_no_tab (i);
      END IF;

      DBMS_OUTPUT.put_line (
         'loadMain: ' || cnt || ' rows updated in tmp_amd_spare_parts');
      writeMsg (
         pTableName        => 'tmp_amd_spare_parts',
         pError_location   => 300,
         pKey1             => 'loadMain',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => 'rowsUpdated=' || TO_CHAR (cnt));

      COMMIT;
   END LoadMain;

   PROCEDURE LoadWecm
   IS
   BEGIN
      BEGIN
         UPDATE tmp_amd_spare_parts
            SET wesm_indicator = 'Y'
          WHERE     (SUBSTR (nsn, 5, 9)) IN
                       (SELECT DISTINCT w1.niin
                          FROM L11 w1,
                               active_niins w2,
                               tmp_amd_spare_parts w3
                         WHERE     w1.niin = w2.niin
                               AND w1.niin = SUBSTR (w3.nsn, 5, 9))
                AND prime_ind = 'Y';

         DBMS_OUTPUT.put_line (
               'loadWecm: '
            || SQL%ROWCOUNT
            || ' rows updated in tmp_amd_spare_parts');
      END;
   END LoadWecm;

   PROCEDURE LoadTempNsns
   IS
      RAW_DATA   NUMBER := 0;

      TYPE nsnRec IS RECORD
      (
         part         amd_spare_parts.part_no%TYPE,
         nsnTemp      mils.status_line%TYPE,
         dataSource   VARCHAR2 (4)
      );

      TYPE nsnTab IS TABLE OF nsnRec;

      nsnRecs    nsnTab;

      CURSOR tempNsnCur
      IS
         -- From MILS table
         SELECT DISTINCT
                asp.part_no part,
                RTRIM (SUBSTR (m.status_line, 8, 15)) nsnTemp,
                'MILS' dataSource
           FROM AMD_SPARE_PARTS asp, MILS m
          WHERE     m.default_name = 'A0E'
                AND asp.part_no = RTRIM (SUBSTR (m.status_line, 81, 30))
                AND asp.nsn != RTRIM (SUBSTR (m.status_line, 8, 15))
                AND 'NSL' != RTRIM (SUBSTR (m.status_line, 8, 15))
         UNION
         -- From CHGH table, "FROM" column
         SELECT DISTINCT
                asp.part_no part,
                RTRIM (REPLACE (m."FROM", '-', NULL)) nsnTemp,
                'CHGH' dataSource
           FROM AMD_SPARE_PARTS asp, CHGH m
          WHERE     m.field = 'NSN'
                AND asp.part_no = m.key_value1
                AND asp.nsn != RTRIM (REPLACE (m."FROM", '-', NULL))
                AND 'NSL' != RTRIM (REPLACE (m."FROM", '-', NULL))
         UNION
         -- From CHGH table, "TO" column
         SELECT DISTINCT
                asp.part_no part,
                RTRIM (REPLACE (m."TO", '-', NULL)) nsnTemp,
                'CHGH' dataSource
           FROM AMD_SPARE_PARTS asp, CHGH m
          WHERE     m.field = 'NSN'
                AND asp.part_no = m.key_value1
                AND asp.nsn != RTRIM (REPLACE (m."TO", '-', NULL))
                AND 'NSL' != RTRIM (REPLACE (m."TO", '-', NULL))
         UNION
         -- From BSSM_PARTS table
         SELECT DISTINCT bp.part_no, bp.nsn nsnTemp, 'BSSM' dataSource
           FROM bssm_parts bp,
                (SELECT nsn
                   FROM bssm_parts
                  WHERE nsn LIKE 'NSL#%' AND lock_sid = RAW_DATA
                 MINUS
                 SELECT nsn
                   FROM AMD_NSNS
                  WHERE nsn LIKE 'NSL#%') nslQ
          WHERE     bp.nsn = nslQ.nsn
                AND bp.lock_sid = RAW_DATA
                AND bp.part_no IS NOT NULL
         ORDER BY 1;

      nsn        VARCHAR2 (16);
      nsiSid     NUMBER;
      loadNo     NUMBER;
      mmacCode   NUMBER;
      cnt        NUMBER := 0;
   BEGIN
      writeMsg (
         pTableName        => 'amd_nsns',
         pError_location   => 310,
         pKey1             => 'loadTempNsns',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      loadNo := Amd_Utils.GetLoadNo ('MILS', 'AMD_NSNS');

      OPEN tempNsnCur;

      FETCH tempNsnCur BULK COLLECT INTO nsnRecs;

      CLOSE tempNsnCur;

      IF nsnRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN nsnRecs.FIRST .. nsnRecs.LAST
         LOOP
            BEGIN
               IF (nsnRecs (indx).nsnTemp = 'NSL')
               THEN
                  nsn :=
                     Amd_Nsl_Sequence_Pkg.SequenceTheNsl (
                        nsnRecs (indx).part);
               ELSIF (nsnRecs (indx).nsnTemp LIKE 'NSL#%')
               THEN
                  nsn := nsnRecs (indx).nsnTemp;
               ELSE
                  -- Need to ignore last 2 char's of nsn from MILS if not numeric.
                  -- So if last 2 characters are not numeric an exception will
                  -- occur and the nsn will be truncated to 13 characters.
                  --
                  nsn := nsnRecs (indx).nsnTemp;

                  IF (nsnRecs (indx).dataSource = 'MILS')
                  THEN
                     BEGIN
                        mmacCode := SUBSTR (nsn, 14, 2);
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           nsn := SUBSTR (nsn, 1, 13);
                     END;
                  END IF;
               END IF;

               nsiSid := Amd_Utils.GetNsiSid (pPart_no => nsnRecs (indx).part);

               INSERT INTO AMD_NSNS (nsn,
                                     nsn_type,
                                     nsi_sid,
                                     creation_date)
                    VALUES (nsn,
                            'T',
                            nsiSid,
                            SYSDATE);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;        -- nsiSid not found generates this, just ignore
               WHEN DUP_VAL_ON_INDEX
               THEN
                  NULL;               -- we don't care if nsn is already there
               WHEN OTHERS
               THEN
                  Amd_Utils.InsertErrorMsg (
                     pLoad_no   => loadNo,
                     pKey_1     => 'amd_load.LoadTempNsns',
                     pKey_2     => 'Exception: OTHERS',
                     pKey_3     => 'insert into amd_nsns');
            END;

            cnt := cnt + 1;
         END LOOP;
      END IF;

      DBMS_OUTPUT.put_line (
         'loadTempNsns: ' || cnt || ' rows inserted to amd_nsns');
      writeMsg (
         pTableName        => 'amd_nsns',
         pError_location   => 320,
         pKey1             => 'loadTempNsns',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => 'cnt=' || TO_CHAR (cnt));
      COMMIT;
   END loadTempNsns;


   FUNCTION insertRow (planner_code IN VARCHAR2)
      RETURN NUMBER
   IS
      PROCEDURE doUpdate
      IS
      BEGIN
         UPDATE AMD_PLANNERS
            SET planner_description = insertRow.planner_code,
                action_code = Amd_Defaults.INSERT_ACTION,
                last_update_dt = SYSDATE
          WHERE planner_code = insertRow.planner_code;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_planners',
                      pError_location   => 330,
                      key1              => insertRow.planner_code);
            DBMS_OUTPUT.put_line (
                  'doUpdate: planner_code='
               || insertRow.planner_code
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END doUpdate;
   BEGIN
     <<insertAmdPlanners>>
      BEGIN
         INSERT INTO AMD_PLANNERS (planner_code,
                                   planner_description,
                                   action_code,
                                   last_update_dt)
              VALUES (insertRow.planner_code,
                      insertRow.planner_code,
                      Amd_Defaults.INSERT_ACTION,
                      SYSDATE);
      EXCEPTION
         WHEN STANDARD.DUP_VAL_ON_INDEX
         THEN
            doUpdate;
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'insert',
                      tableName         => 'amd_planners',
                      pError_location   => 340,
                      key1              => insertRow.planner_code);
            DBMS_OUTPUT.put_line (
                  'insertAmdPlanners: planner_code='
               || insertRow.planner_code
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END insertAmdPlanners;

      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN FAILURE;
   END insertRow;

   FUNCTION updateRow (planner_code IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
     <<updateAmdPlanners>>
      BEGIN
         UPDATE AMD_PLANNERS
            SET planner_description = updateRow.planner_code,
                last_update_dt = SYSDATE,
                action_code = Amd_Defaults.UPDATE_ACTION
          WHERE planner_code = updateRow.planner_code;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_planners',
                      pError_location   => 350,
                      key1              => updateRow.planner_code);
            DBMS_OUTPUT.put_line (
                  'updateAmdPlanners: planner_code='
               || updateRow.planner_code
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END updateAmdPlanners;

      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN FAILURE;
   END updateRow;

   FUNCTION deleteRow (planner_code IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
     <<deleteAmdPlanners>>
      BEGIN
         UPDATE AMD_PLANNERS
            SET last_update_dt = SYSDATE,
                action_code = Amd_Defaults.DELETE_ACTION
          WHERE planner_code = deleteRow.planner_code;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_planners',
                      pError_location   => 360,
                      key1              => deleteRow.planner_code);
            DBMS_OUTPUT.put_line (
                  'deleteAmdPlanners: planner_code='
               || deleteRow.planner_code
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END deleteAmdPlanners;

      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN FAILURE;
   END deleteRow;

   FUNCTION getNewUsers
      RETURN resultSetCursor
   IS
      newUsers   resultSetCursor;
   BEGIN
      OPEN newUsers FOR
           SELECT Amd_Load.getBemsId (employee_NO) bems_id,
                  stable_email,
                  last_name,
                  first_name
             FROM AMD_USE1, amd_people_all_v
            WHERE     employee_status = 'A'
                  AND ims_designator_code IS NOT NULL
                  AND LENGTH (ims_designator_code) = 3
                  AND Amd_Load.getBemsId (employee_no) =
                         amd_people_all_v.bems_id
         ORDER BY bems_id;

      RETURN newUsers;
   END getNewUsers;

   FUNCTION insertUsersRow (bems_id        IN VARCHAR2,
                            stable_email   IN VARCHAR2,
                            last_name      IN VARCHAR2,
                            first_name     IN VARCHAR2)
      RETURN NUMBER
   IS
      PROCEDURE doUpdate
      IS
      BEGIN
         UPDATE amd_users
            SET stable_email = TRIM (insertUsersRow.stable_email),
                last_name = TRIM (insertUsersRow.last_name),
                first_name = TRIM (insertUsersRow.first_name),
                action_code = amd_defaults.INSERT_ACTION,
                last_update_dt = SYSDATE
          WHERE bems_id = insertUsersRow.bems_id;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_users',
                      pError_location   => 370,
                      key1              => bems_id);
            DBMS_OUTPUT.put_line (
                  'doUpdate: bems_id='
               || bems_id
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END doUpdate;
   BEGIN
      INSERT INTO AMD_USERS (bems_id,
                             stable_email,
                             last_name,
                             first_name,
                             action_code,
                             last_update_dt)
           VALUES (TRIM (bems_id),
                   TRIM (stable_email),
                   TRIM (last_name),
                   TRIM (first_name),
                   Amd_Defaults.INSERT_ACTION,
                   SYSDATE);

      RETURN SUCCESS;
   EXCEPTION
      WHEN STANDARD.DUP_VAL_ON_INDEX
      THEN
         doUpdate;
         RETURN success;
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction       => 'insert',
                   tableName         => 'amd_users',
                   pError_location   => 380,
                   key1              => bems_id);
         DBMS_OUTPUT.put_line (
               'insertUsersRow: bems_id='
            || bems_id
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END insertUsersRow;

   FUNCTION updateUsersRow (bems_id        IN VARCHAR2,
                            stable_email   IN VARCHAR2,
                            last_name      IN VARCHAR2,
                            first_name     IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
      UPDATE AMD_USERS
         SET stable_email = TRIM (updateUsersRow.stable_email),
             last_name = TRIM (updateUsersRow.last_name),
             first_name = TRIM (updateUsersRow.first_name),
             action_code = Amd_Defaults.UPDATE_ACTION,
             last_update_dt = SYSDATE
       WHERE bems_id = updateUsersRow.bems_id;

      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction       => 'update',
                   tableName         => 'amd_users',
                   pError_location   => 390,
                   key1              => bems_id);
         DBMS_OUTPUT.put_line (
               'updateUsersRows: bems_id='
            || bems_id
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END updateUsersRow;

   FUNCTION deleteUsersRow (bems_id IN VARCHAR2)
      RETURN NUMBER
   IS
      last_name      AMD_USERS.last_name%TYPE;
      first_name     AMD_USERS.first_name%TYPE;
      stable_email   AMD_USERS.stable_email%TYPE;
   BEGIN
      UPDATE AMD_USERS
         SET action_code = Amd_Defaults.DELETE_ACTION,
             last_update_dt = SYSDATE
       WHERE bems_id = deleteUsersRow.bems_id;

     <<getData>>
      BEGIN
         SELECT stable_email, last_name, first_name
           INTO stable_email, last_name, first_name
           FROM AMD_USERS
          WHERE bems_id = deleteUsersRow.bems_id;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'select',
                      tableName         => 'amd_users',
                      pError_location   => 400,
                      key1              => bems_id);
            DBMS_OUTPUT.put_line (
                  'getData: besm_id='
               || bems_id
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END getData;

      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction       => 'update',
                   tableName         => 'amd_users',
                   pError_location   => 410,
                   key1              => bems_id);
         DBMS_OUTPUT.put_line (
               'deleteUsersRow: bems_id='
            || bems_id
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE;
   END deleteUsersRow;

   PROCEDURE loadUsers
   IS
      TYPE bemsIdTab IS TABLE OF amd_users.bems_id%TYPE;

      bemsIdRecs   bemsIdTab;

      CURSOR currentUsers
      IS
         SELECT bems_id
           FROM AMD_USERS
          WHERE action_code != Amd_Defaults.DELETE_ACTION;

      CURSOR newUsers
      IS
         SELECT Amd_Load.getBemsId (employee_NO) bems_id
           FROM AMD_USE1
          WHERE     employee_status = 'A'
                AND Amd_Load.getBemsId (employee_no) NOT IN
                       (SELECT bems_id
                          FROM AMD_USERS
                         WHERE action_code != Amd_Defaults.DELETE_ACTION)
                AND ims_designator_code IS NOT NULL
                AND LENGTH (ims_designator_code) = 3;

      CURSOR deletedUsers
      IS
         SELECT bems_id
           FROM AMD_USERS
          WHERE     bems_id NOT IN
                       (SELECT Amd_Load.getBemsId (employee_no) bems_id
                          FROM AMD_USE1
                         WHERE     employee_status = 'A'
                               AND ims_designator_code IS NOT NULL
                               AND LENGTH (ims_designator_code) = 3)
                AND action_code != Amd_Defaults.DELETE_ACTION;

      bems_id      AMD_USERS.BEMS_ID%TYPE;

      inserted     NUMBER := 0;
      deleted      NUMBER := 0;
   BEGIN
      writeMsg (
         pTableName        => 'amd_users',
         pError_location   => 420,
         pKey1             => 'loadUsers',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));


      OPEN newUsers;

      FETCH newUsers BULK COLLECT INTO bemsIdRecs;

      CLOSE newUsers;

      IF bemsIdRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN bemsIdRecs.FIRST .. bemsIdRecs.LAST
         LOOP
            IF bemsIdRecs (indx) IS NOT NULL
            THEN
              <<insertAmdUsers>>
               BEGIN
                  INSERT
                    INTO AMD_USERS (bems_id, action_code, last_update_dt)
                     VALUES (
                               bemsIdRecs (indx),
                               Amd_Defaults.INSERT_ACTION,
                               SYSDATE);

                  inserted := inserted + 1;
               EXCEPTION
                  WHEN STANDARD.DUP_VAL_ON_INDEX
                  THEN
                     NULL; -- ignore because some users have multiple planner codes
               END insertAmdUsers;
            END IF;
         END LOOP;
      END IF;

      OPEN deletedUsers;

      FETCH deletedUsers BULK COLLECT INTO bemsIdRecs;

      CLOSE deletedUsers;

      IF bemsIdRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN bemsIdRecs.FIRST .. bemsIdRecs.LAST
         LOOP
            UPDATE AMD_USERS
               SET action_code = Amd_Defaults.DELETE_ACTION,
                   last_update_dt = SYSDATE
             WHERE bems_id = bemsIdRecs (indx);

            deleted := deleted + 1;
         END LOOP;
      END IF;

      writeMsg (
         pTableName        => 'amd_users',
         pError_location   => 430,
         pKey1             => 'loadUsers',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => 'inserted=' || TO_CHAR (inserted),
         pKey4             => 'deleted=' || TO_CHAR (deleted));

      COMMIT;
   END loadUsers;


   FUNCTION insertPlannerLogons (planner_code   IN VARCHAR2,
                                 logon_id       IN VARCHAR2,
                                 data_source    IN VARCHAR2)
      RETURN NUMBER
   IS
      PROCEDURE doUpdate
      IS
      BEGIN
         UPDATE AMD_PLANNER_LOGONS
            SET action_code = Amd_Defaults.INSERT_ACTION,
                last_update_dt = SYSDATE
          WHERE     planner_code = insertPlannerLogons.planner_code
                AND logon_id = insertPlannerLogons.logon_id
                AND data_source = insertPlannerLogons.data_source;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_planner_logons',
                      pError_location   => 440,
                      key1              => insertPlannerLogons.planner_code,
                      key2              => insertPlannerLogons.logon_id,
                      key3              => insertPlannerLogons.data_source);
            DBMS_OUTPUT.put_line (
                  'doUpdate: planner_code='
               || insertPlannerLogons.planner_code
               || ' logon_id='
               || insertPlannerLogons.logon_id
               || ' data_source='
               || insertPlannerLogons.data_source
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END doUpdate;
   BEGIN
      debugMsg (
            'planner_code='
         || planner_code
         || ' logon_id='
         || logon_id
         || ' data_source='
         || data_source,
         pError_location   => 520);

     <<insertAmdPlannerLogons>>
      BEGIN
         INSERT INTO AMD_PLANNER_LOGONS (planner_code,
                                         logon_id,
                                         data_source,
                                         action_code,
                                         last_update_dt)
              VALUES (insertPlannerLogons.planner_code,
                      insertPlannerLogons.logon_id,
                      insertPlannerLogons.data_source,
                      Amd_Defaults.INSERT_ACTION,
                      SYSDATE);
      EXCEPTION
         WHEN STANDARD.DUP_VAL_ON_INDEX
         THEN
            doUpdate;
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'insert',
                      tableName         => 'amd_planner_logons',
                      pError_location   => 450,
                      key1              => insertPlannerLogons.planner_code,
                      key2              => insertPlannerLogons.logon_id,
                      key3              => insertPlannerLogons.data_source);
            DBMS_OUTPUT.put_line (
                  'insertAmdPlannerLogons: planner_code='
               || insertPlannerLogons.planner_code
               || ' logon_id='
               || insertPlannerLogons.logon_id
               || ' data_source='
               || insertPlannerLogons.data_source
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END insertAmdPlannerLogons;


      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction       => 'insertPlannerLogons',
                   tableName         => 'amd_planner_logons',
                   pError_location   => 540);
         RETURN FAILURE;
   END insertPlannerLogons;

   FUNCTION updatePlannerLogons (planner_code   IN VARCHAR2,
                                 logon_id       IN VARCHAR2,
                                 data_source    IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
     <<updateAmdPlannerLogons>>
      BEGIN
         UPDATE AMD_PLANNER_LOGONS
            SET last_update_dt = SYSDATE,
                action_code = Amd_Defaults.UPDATE_ACTION
          WHERE     planner_code = updatePlannerLogons.planner_code
                AND logon_id = updatePlannerLogons.logon_id
                AND data_source = updatePlannerLogons.data_source;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_planner_logons',
                      pError_location   => 460,
                      key1              => updatePlannerLogons.planner_code,
                      key2              => updatePlannerLogons.logon_id,
                      key3              => updatePlannerLogons.data_source);
            DBMS_OUTPUT.put_line (
                  'updateAmdPlannerLogons: planner_code='
               || updatePlannerLogons.planner_code
               || ' logon_id='
               || updatePlannerLogons.logon_id
               || ' data_source='
               || updatePlannerLogons.data_source
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END updateAmdPlannerLogons;


      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction       => 'updatePlannerLogons',
                   tableName         => 'amd_planner_logons',
                   pError_location   => 560);
         RETURN FAILURE;
   END updatePlannerLogons;

   FUNCTION deletePlannerLogons (planner_code   IN VARCHAR2,
                                 logon_id       IN VARCHAR2,
                                 data_source    IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
     <<deleteAmdPlannerLogons>>
      BEGIN
         UPDATE AMD_PLANNER_LOGONS
            SET last_update_dt = SYSDATE,
                action_code = Amd_Defaults.DELETE_ACTION
          WHERE     planner_code = deletePlannerLogons.planner_code
                AND logon_id = deletePlannerLogons.logon_id
                AND data_source = deletePlannerLogons.data_source;
      EXCEPTION
         WHEN OTHERS
         THEN
            errorMsg (sqlFunction       => 'update',
                      tableName         => 'amd_planner_logons',
                      pError_location   => 470,
                      key1              => deletePlannerLogons.planner_code,
                      key2              => deletePlannerLogons.logon_id,
                      key3              => deletePlannerLogons.data_source);
            DBMS_OUTPUT.put_line (
                  'deleteAmdPlanners: planner_code='
               || deletePlannerLogons.planner_code
               || ' logon_id='
               || deletePlannerLogons.logon_id
               || ' data_source='
               || deletePlannerLogons.data_source
               || ' sqlcode='
               || SQLCODE
               || ' sqlerrm='
               || SQLERRM);
            RAISE;
      END deleteAmdPlanners;


      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         errorMsg (sqlFunction       => 'deletePlannerLogons',
                   tableName         => 'amd_planner_logons',
                   pError_location   => 580);
         RETURN FAILURE;
   END deletePlannerLogons;

   -- For future use
   -- The following procedures: loadGoldPsmsMain, preProcess, postProcess, and postDiffProcess,
   -- may be used to replace the bulky sql scripts currently used by amd_loader.ksh
   PROCEDURE loadGoldPsmsMain (startStep   IN NUMBER := 1,
                               endStep     IN NUMBER := 3)
   IS
      batch_job_number     amd_batch_jobs.BATCH_JOB_NUMBER%TYPE
                              := amd_batch_pkg.getActiveJob;
      batch_step_number    amd_batch_job_steps.BATCH_STEP_NUMBER%TYPE;
      LOAD_GOLD   CONSTANT VARCHAR2 (8) := 'loadGold';
      LOAD_PSMS   CONSTANT VARCHAR2 (8) := 'loadPsms';
      LOAD_MAIN   CONSTANT VARCHAR2 (8) := 'loadMain';
   BEGIN
      IF batch_job_number IS NULL
      THEN
         DBMS_OUTPUT.put_line (
               'loadGoldPsmsMain: start_step='
            || startStep
            || ' endStep='
            || endStep
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE no_active_job;
      END IF;

      FOR step IN startStep .. endStep
      LOOP
         IF step = 1
         THEN
            IF NOT amd_batch_pkg.isStepComplete (
                      batch_job_number   => batch_job_number,
                      system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                      description        => LOAD_GOLD)
            THEN
               amd_batch_pkg.start_step (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_GOLD,
                  package_name       => THIS_PACKAGE,
                  procedure_name     => LOAD_GOLD);

               loadGold;
            END IF;
         ELSIF step = 2
         THEN
            IF NOT amd_batch_pkg.isStepComplete (
                      batch_job_number   => batch_job_number,
                      system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                      description        => LOAD_PSMS)
            THEN
               amd_batch_pkg.start_step (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_PSMS,
                  package_name       => THIS_PACKAGE,
                  procedure_name     => LOAD_PSMS);

               loadPsms;
            END IF;
         ELSIF step = 3
         THEN
            IF NOT amd_batch_pkg.isStepComplete (
                      batch_job_number   => batch_job_number,
                      system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                      description        => LOAD_MAIN)
            THEN
               amd_batch_pkg.start_step (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_MAIN,
                  package_name       => THIS_PACKAGE,
                  procedure_name     => LOAD_MAIN);

               loadMain;
            END IF;
         END IF;

         debugMsg ('loadGoldPsmsMain: completed step ' || step,
                   pError_location   => 590);
         batch_step_number :=
            amd_batch_pkg.getActiveStep (
               batch_job_number   => batch_job_number,
               system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);

         IF batch_step_number IS NOT NULL
         THEN
            amd_batch_pkg.end_step (
               batch_job_number    => batch_job_number,
               system_id           => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
               batch_step_number   => batch_step_number);
         END IF;

         COMMIT;
      END LOOP;
   END loadGoldPsmsMain;

   PROCEDURE preProcess (startStep IN NUMBER := 1, endStep IN NUMBER := 3)
   IS
   BEGIN
      loadGoldPsmsMain (startStep, endStep);
   END preProcess;

   PROCEDURE postProcess (startStep IN NUMBER := 1, endStep IN NUMBER := 18)
   IS
      batch_job_number                          amd_batch_jobs.BATCH_JOB_NUMBER%TYPE
         := amd_batch_pkg.getActiveJob (
               system_id   => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);
      batch_step_number                         amd_batch_job_steps.BATCH_STEP_NUMBER%TYPE;

      THE_AMD_PARTPRIME_PKG            CONSTANT VARCHAR2 (17) := 'amd_partprime_pkg';
      THE_AMD_PART_LOC_FORECASTS_PKG   CONSTANT VARCHAR2 (26)
         := 'amd_part_loc_forecasts_pkg' ;
      THE_AMD_SPARE_PARTS_PKG          CONSTANT VARCHAR2 (19)
                                                   := 'amd_spare_parts_pkg' ;
      THE_AMD_SPARE_NETWORKS_PKG       CONSTANT VARCHAR2 (22)
         := 'amd_spare_networks_pkg' ;
      THE_AMD_DEMAND_PKG               CONSTANT VARCHAR2 (10) := 'amd_demand';
      THE_AMD_PART_LOCS_LOAD_PKG       CONSTANT VARCHAR2 (22)
         := 'amd_part_locs_load_pkg' ;
      THE_AMD_FROM_BSSM_PKG            CONSTANT VARCHAR2 (17)
                                                   := 'amd_from_bssm_pkg' ;
      THE_AMD_CLEANED_FROM_BSSM_PKG    CONSTANT VARCHAR2 (25)
         := 'amd_cleaned_from_bssm_pkg' ;

      DELETE_INVALID_PARTS             CONSTANT VARCHAR2 (18)
                                                   := 'deleteinvalidParts' ;
      DIFF_PART_TO_PRIME               CONSTANT VARCHAR2 (15)
                                                   := 'DiffPartToPrime' ;
      LOAD_LATEST_RBL_RUN              CONSTANT VARCHAR2 (16)
                                                   := 'LoadLatestRblRun' ;
      LOAD_CURRENT_BACKORDER           CONSTANT VARCHAR2 (20)
                                                   := 'loadCurrentBackOrder' ;
      LOAD_TEMP_NSNS                   CONSTANT VARCHAR2 (12)
                                                   := 'loadtempnsns' ;
      AUTO_LOAD_SPARE_NETWORKS         CONSTANT VARCHAR2 (24)
         := 'auto_load_spare_networks' ;
      LOAD_AMD_DEMANDS                 CONSTANT VARCHAR2 (14)
                                                   := 'loadamddemands' ;
      LOAD_BASC_UK_DEMANDS             CONSTANT VARCHAR2 (17)
                                                   := 'loadBascUkdemands' ;
      AMD_DEMAND_A2A                   CONSTANT VARCHAR2 (14)
                                                   := 'amd_demand_a2a' ;
      LOAD_GOLD_INVENTORY              CONSTANT VARCHAR2 (17)
                                                   := 'loadGoldInventory' ;
      LOAD_AMD_PART_LOCATIONS          CONSTANT VARCHAR2 (20)
                                                   := 'LoadAmdPartLocations' ;
      LOAD_AMD_BASE_FROM_BSSM_RAW      CONSTANT VARCHAR2 (22)
         := 'LoadAmdBaseFromBssmRaw' ;
   BEGIN
      IF batch_job_number IS NULL
      THEN
         RAISE amd_load.no_active_job;
      END IF;

      FOR step IN startStep .. endStep
      LOOP
         IF step = 1
         THEN
            NULL;
         ELSIF step = 2
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => DIFF_PART_TO_PRIME,
                  package_name       => THE_AMD_PARTPRIME_PKG,
                  procedure_name     => DIFF_PART_TO_PRIME)
            THEN
               NULL;
            END IF;
         ELSIF step = 3
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_LATEST_RBL_RUN,
                  package_name       => THE_AMD_PART_LOC_FORECASTS_PKG,
                  procedure_name     => LOAD_LATEST_RBL_RUN)
            THEN
               amd_part_loc_forecasts_pkg.LoadLatestRblRun;
            END IF;
         ELSIF step = 4
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_CURRENT_BACKORDER,
                  package_name       => THE_AMD_SPARE_PARTS_PKG,
                  procedure_name     => LOAD_CURRENT_BACKORDER)
            THEN
               amd_spare_parts_pkg.loadCurrentBackOrder;
            END IF;
         ELSIF step = 5
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_TEMP_NSNS,
                  package_name       => THIS_PACKAGE,
                  procedure_name     => LOAD_TEMP_NSNS)
            THEN
               amd_load.loadtempnsns;
            END IF;
         ELSIF step = 6
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => AUTO_LOAD_SPARE_NETWORKS,
                  package_name       => THE_AMD_SPARE_NETWORKS_PKG,
                  procedure_name     => AUTO_LOAD_SPARE_NETWORKS)
            THEN
               amd_spare_networks_pkg.auto_load_spare_networks;
            END IF;
         ELSIF step = 7
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_AMD_DEMANDS,
                  package_name       => THE_AMD_DEMAND_PKG,
                  procedure_name     => LOAD_AMD_DEMANDS)
            THEN
               amd_demand.loadAmdBssmSourceTmpAmdDemands;
            END IF;
         ELSIF step = 8
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_BASC_UK_DEMANDS,
                  package_name       => THE_AMD_DEMAND_PKG,
                  procedure_name     => LOAD_BASC_UK_DEMANDS)
            THEN
               amd_demand.loadDepotDemands;
            END IF;
         ELSIF step = 9
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => AMD_DEMAND_A2A,
                  package_name       => THE_AMD_DEMAND_PKG,
                  procedure_name     => AMD_DEMAND_A2A)
            THEN
               amd_demand.load_amd_demands_table;
            END IF;
         ELSIF step = 10
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_GOLD_INVENTORY,
                  package_name       => THE_AMD_INVENTORY_PKG,
                  procedure_name     => LOAD_GOLD_INVENTORY)
            THEN
               amd_inventory.loadGoldInventory;
            END IF;
         ELSIF step = 11
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_AMD_PART_LOCATIONS,
                  package_name       => THE_AMD_PART_LOCS_LOAD_PKG,
                  procedure_name     => LOAD_AMD_PART_LOCATIONS)
            THEN
               amd_part_locs_load_pkg.LoadAmdPartLocations;
            END IF;
         ELSIF step = 12
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => LOAD_AMD_BASE_FROM_BSSM_RAW,
                  package_name       => THE_AMD_FROM_BSSM_PKG,
                  procedure_name     => LOAD_AMD_BASE_FROM_BSSM_RAW)
            THEN
               amd_from_bssm_pkg.LoadAmdBaseFromBssmRaw;
            END IF;
         ELSIF step = 13
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'UpdateAmdAllBaseCleaned',
                  package_name       => THE_AMD_CLEANED_FROM_BSSM_PKG,
                  procedure_name     => 'UpdateAmdAllBaseCleaned')
            THEN
              <<cleaned>>
               BEGIN
                  amd_cleaned_from_bssm_pkg.UpdateAmdAllBaseCleaned;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     ErrorMsg (sqlFunction       => 'call',
                               key1              => 'updateAmdAllBaseCleaned',
                               pError_location   => 5);
                     DBMS_OUTPUT.put_line (
                           'loadGold: exception calling amd_cleaned_from_bssm_pkg.UpdateAmdAllBaseCleaned'
                        || 'sqlcode('
                        || SQLCODE
                        || ') sqlerrm('
                        || SQLERRM
                        || ')');
               END cleaned;
            END IF;
         ELSIF step = 14
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'LoadAmdReqs',
                  package_name       => THIS_PACKAGE,
                  procedure_name     => 'LoadAmdReqs')
            THEN
               amd_reqs_pkg.LoadAmdReqs;
            END IF;
         ELSIF step = 15
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'LoadTmpAmdPartFactors',
                  package_name       => THIS_PACKAGE,
                  procedure_name     => 'LoadTmpAmdPartFactors')
            THEN
               amd_part_factors_pkg.LoadTmpAmdPartFactors;
            END IF;
         ELSIF step = 16
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'ProcessA2AVirtualLocs',
                  package_name       => THIS_PACKAGE,
                  procedure_name     => 'ProcessA2AVirtualLocs')
            THEN
               NULL;             --amd_part_factors_pkg.ProcessA2AVirtualLocs;
            END IF;
         ELSIF step = 17
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'LoadTmpAmdPartLocForecasts_Add',
                  package_name       => THIS_PACKAGE,
                  procedure_name     => 'LoadTmpAmdPartLocForecasts_Add')
            THEN
               amd_part_loc_forecasts_pkg.LoadTmpAmdPartLocForecasts_Add;
            END IF;
         ELSIF step = 18
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'LoadTmpAmdLocPartLeadtime',
                  package_name       => THIS_PACKAGE,
                  procedure_name     => 'LoadTmpAmdLocPartLeadtime')
            THEN
               amd_location_part_leadtime_pkg.LoadTmpAmdLocPartLeadtime;
            END IF;
         END IF;

         debugMsg ('postProcess: completed step ' || step,
                   pError_location   => 600);
         batch_step_number :=
            amd_batch_pkg.getActiveStep (
               batch_job_number   => batch_job_number,
               system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);

         IF batch_step_number IS NOT NULL
         THEN
            amd_batch_pkg.end_step (
               batch_job_number    => batch_job_number,
               system_id           => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
               batch_step_number   => batch_step_number);
         END IF;

         COMMIT;
      END LOOP;
   END postProcess;

   PROCEDURE postDiffProcess (startStep   IN NUMBER := 1,
                              endStep     IN NUMBER := 3)
   IS
      batch_job_number    amd_batch_jobs.BATCH_JOB_NUMBER%TYPE
         := amd_batch_pkg.getActiveJob (
               system_id   => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);
      batch_step_number   amd_batch_job_steps.BATCH_STEP_NUMBER%TYPE;
   BEGIN
      IF batch_job_number IS NULL
      THEN
         DBMS_OUTPUT.put_line (
               'postDiffProcess: startStep='
            || startStep
            || ' endStep='
            || endStep
            || ' sqlcode='
            || SQLCODE
            || ' sqlerrm='
            || SQLERRM);
         RAISE amd_load.no_active_job;
      END IF;

      FOR step IN startStep .. endStep
      LOOP
         IF step = 1
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'UpdateSpoTotalInventory',
                  package_name       => THE_AMD_INVENTORY_PKG,
                  procedure_name     => 'UpdateSpoTotalInventory')
            THEN
               amd_inventory.UpdateSpoTotalInventory;
            END IF;
         ELSIF step = 2
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'LoadTmpAmdLocPartOverride',
                  package_name       => THIS_PACKAGE,
                  procedure_name     => 'LoadTmpAmdLocPartOverride')
            THEN
               amd_location_part_override_pkg.LoadTmpAmdLocPartOverride;
            END IF;
         ELSIF step = 3
         THEN
            IF amd_batch_pkg.didStepStart (
                  batch_job_number   => batch_job_number,
                  system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
                  description        => 'LoadZeroTslA2A',
                  package_name       => THIS_PACKAGE,
                  procedure_name     => 'LoadZeroTslA2A')
            THEN
               NULL; -- procdure amd_location_part_override_pkg.LoadZeroTslA2A has been removed
            END IF;
         END IF;

         debugMsg ('postDiffProcess: completed step ' || step,
                   pError_location   => 610);
         batch_step_number :=
            amd_batch_pkg.getActiveStep (
               batch_job_number   => batch_job_number,
               system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);

         IF batch_step_number IS NOT NULL
         THEN
            amd_batch_pkg.end_step (
               batch_job_number    => batch_job_number,
               system_id           => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
               batch_step_number   => batch_step_number);
         END IF;

         COMMIT;
      END LOOP;
   END postDiffProcess;

   PROCEDURE disableAmdConstraints
   IS
   BEGIN
      debugMsg ('start disableAmdContraints', pError_location => 620);
      mta_disable_constraint ('amd_part_loc_time_periods',
                              'amd_part_loc_time_periods_fk01');
      mta_disable_constraint ('amd_part_locs', 'amd_part_locs_fk01');
      mta_disable_constraint ('amd_part_locs', 'amd_part_locs_fk02');
      mta_disable_constraint ('amd_maint_task_distribs',
                              'amd_maint_task_distribs_fk01');
      mta_disable_constraint ('amd_bods', 'amd_bods_fk02');
      mta_disable_constraint ('amd_part_next_assemblies',
                              'amd_part_next_assemblies_fk01');
      mta_disable_constraint ('amd_demands', 'amd_demands_fk01');
      mta_disable_constraint ('amd_demands', 'amd_demands_fk02');
      mta_disable_constraint ('amd_demands', 'amd_demands_pk');
      debugMsg ('end disableAmdContraints', pError_location => 630);
      COMMIT;
   END disableAmdConstraints;

   PROCEDURE truncateAmdTables
   IS
   BEGIN
      debugMsg ('start truncateAmdTables', pError_location => 640);
      mta_truncate_table ('tmp_amd_demands', 'reuse storage');
      mta_truncate_table ('tmp_amd_part_locs', 'reuse storage');
      mta_truncate_table ('tmp_amd_spare_parts', 'reuse storage');
      mta_truncate_table ('tmp_lcf_icp', 'reuse storage');
      mta_truncate_table ('amd_bssm_source', 'reuse storage');
      mta_truncate_table ('amd_maint_task_distribs', 'reuse storage');
      mta_truncate_table ('amd_part_loc_time_periods', 'reuse storage');
      mta_truncate_table ('amd_flight_stats', 'reuse storage');
      debugMsg ('end truncateAmdTables', pError_location => 650);
      COMMIT;
   END truncateAmdTables;

   PROCEDURE enableAmdConstraints
   IS
   BEGIN
      debugMsg ('start enableAmdConstraints', pError_location => 660);
      mta_enable_constraint ('amd_part_loc_time_periods',
                             'amd_part_loc_time_periods_fk01');
      mta_enable_constraint ('amd_part_locs', 'amd_part_locs_fk01');
      mta_enable_constraint ('amd_part_locs', 'amd_part_locs_fk02');
      mta_enable_constraint ('amd_maint_task_distribs',
                             'amd_maint_task_distribs_fk01');
      mta_enable_constraint ('amd_bods', 'amd_bods_fk02');
      mta_enable_constraint ('amd_part_next_assemblies',
                             'amd_part_next_assemblies_fk01');
      mta_enable_constraint ('amd_demands', 'amd_demands_fk01');
      mta_enable_constraint ('amd_demands', 'amd_demands_fk02');
      mta_enable_constraint ('amd_demands', 'amd_demands_pk');
      debugMsg ('end enableAmdConstraints', pError_location => 670);
      COMMIT;
   END enableAmdConstraints;

   PROCEDURE prepAmdDatabase
   IS
      batch_job_number    amd_batch_jobs.BATCH_JOB_NUMBER%TYPE
         := amd_batch_pkg.getActiveJob (
               system_id   => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);
      batch_step_number   amd_batch_job_steps.BATCH_STEP_NUMBER%TYPE;
   BEGIN
      debugMsg ('start prepAmdDatabase', pError_location => 680);

      IF batch_job_number IS NULL
      THEN
         DBMS_OUTPUT.put_line (
            'prepAmdDatabase: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM);
         RAISE amd_load.no_active_job;
      END IF;

      amd_batch_pkg.start_step (
         batch_job_number   => batch_job_number,
         system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
         description        => 'disableAmdConstraints',
         package_name       => THIS_PACKAGE,
         procedure_name     => 'disableAmdConstraints');
      disableAmdConstraints;
      batch_step_number :=
         amd_batch_pkg.getActiveStep (
            batch_job_number   => batch_job_number,
            system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);
      amd_batch_pkg.end_step (
         batch_job_number    => batch_job_number,
         system_id           => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
         batch_step_number   => batch_step_number);

      amd_batch_pkg.start_step (
         batch_job_number   => batch_job_number,
         system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
         description        => 'truncateAmdTables',
         package_name       => THIS_PACKAGE,
         procedure_name     => 'truncateAmdTables');
      truncateAmdTables;
      batch_step_number :=
         amd_batch_pkg.getActiveStep (
            batch_job_number   => batch_job_number,
            system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);
      amd_batch_pkg.end_step (
         batch_job_number    => batch_job_number,
         system_id           => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
         batch_step_number   => batch_step_number);

      amd_batch_pkg.start_step (
         batch_job_number   => batch_job_number,
         system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
         description        => 'enableAmdConstraints',
         package_name       => THIS_PACKAGE,
         procedure_name     => 'enableAmdConstraints');
      enableAmdConstraints;
      batch_step_number :=
         amd_batch_pkg.getActiveStep (
            batch_job_number   => batch_job_number,
            system_id          => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP);
      amd_batch_pkg.end_step (
         batch_job_number    => batch_job_number,
         system_id           => amd_batch_pkg.ASSET_MANAGEMENT_DESKTOP,
         batch_step_number   => batch_step_number);

      debugMsg ('end prepAmdDatabase', pError_location => 690);
      COMMIT;
   END prepAmdDatabase;

   PROCEDURE version
   IS
   BEGIN
      writeMsg (pTableName        => 'amd_load',
                pError_location   => 480,
                pKey1             => 'amd_load',
                pKey2             => '$Revision:   1.97  $');
      DBMS_OUTPUT.put_line ('amd_load: $Revision:   1.97  $');
   END version;

   FUNCTION getVersion
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN '$Revision:   1.97  $';
   END getVersion;

   PROCEDURE validatePartStructure
   IS
      CURSOR NoNsn4SpareParts
      IS
         SELECT *
           FROM amd_spare_parts
          WHERE nsn IS NULL;

      CURSOR NoNsn4Items
      IS
         SELECT *
           FROM amd_National_Stock_Items
          WHERE nsn IS NULL;

      CURSOR NoPrimePart
      IS
         SELECT *
           FROM amd_national_stock_items
          WHERE prime_part_no IS NULL;

      CURSOR NotDeleted
      IS
         SELECT nsi_sid, prime_part_no
           FROM amd_national_stock_items items, amd_spare_parts parts
          WHERE     prime_part_no = part_no
                AND items.action_code <> amd_defaults.DELETE_ACTION
                AND parts.action_code = amd_defaults.DELETE_ACTION;

      cntNoNsnParts    NUMBER := 0;
      cntNoNsnItems    NUMBER := 0;
      cntNoPrimePart   NUMBER := 0;
      cntNotDeleted    NUMBER := 0;
   BEGIN
      FOR rec IN NoNsn4SpareParts
      LOOP
         cntNoNsnParts := cntNoNsnParts + 1;
         writeMsg (pTableName        => 'amd_spare_parts',
                   pError_location   => 490,
                   pKey1             => 'part_no=' || rec.part_no,
                   pKey2             => 'No Nsn',
                   pKey3             => 'action_code=' || rec.action_code);
      END LOOP;

      FOR rec IN NoNsn4Items
      LOOP
         cntNoNsnItems := cntNoNsnItems + 1;
         writeMsg (pTableName        => 'amd_national_stock_items',
                   pError_location   => 500,
                   pKey1             => 'prime_part_no=' || rec.prime_part_no,
                   pKey2             => 'No Nsn',
                   pKey3             => 'action_code=' || rec.action_code);
      END LOOP;

      FOR rec IN NoPrimePart
      LOOP
         cntNoPrimePart := cntNoPrimePart + 1;
         writeMsg (pTableName        => 'amd_national_stock_items',
                   pError_location   => 510,
                   pKey1             => 'nsi_sid=' || rec.nsi_sid,
                   pKey2             => 'No Prime Part',
                   pKey3             => 'action_code=' || rec.action_code,
                   pKey4             => 'nsn=' || rec.nsn);
      END LOOP;

      FOR rec IN NotDeleted
      LOOP
         cntNotDeleted := cntNotDeleted + 1;

         UPDATE amd_national_stock_items
            SET action_code = amd_defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE nsi_sid = rec.nsi_sid;
      END LOOP;

      DBMS_OUTPUT.put_line ('cntNoNsnParts=' || cntNoNsnParts);
      DBMS_OUTPUT.put_line ('cntNoNsnItems=' || cntNoNsnItems);
      DBMS_OUTPUT.put_line ('cntNoPrimePart=' || cntNoPrimePart);
      DBMS_OUTPUT.put_line ('cntNotDeleted=' || cntNotDeleted);
      writeMsg (
         pTableName        => 'amd_spare_parts',
         pError_location   => 520,
         pKey1             => 'cntNoNsnParts=' || TO_CHAR (cntNoNsnParts));
      writeMsg (
         pTableName        => 'amd_national_stock_items',
         pError_location   => 530,
         pKey1             => 'cntNoNsnItems=' || TO_CHAR (cntNoNsnItems));
      writeMsg (
         pTableName        => 'amd_national_stock_items',
         pError_location   => 540,
         pKey1             => 'cntNoPrimePart=' || TO_CHAR (cntNoPrimePart));
      writeMsg (
         pTableName        => 'amd_national_stock_items',
         pError_location   => 550,
         pKey1             => 'cntNotDeleted=' || TO_CHAR (cntNotDeleted));
      COMMIT;
   END validatePartStructure;

   -- added 4/2/2007 by DSE
   FUNCTION getORIGINAL_DATA
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN ORIGINAL_DATA;
   END getORIGINAL_DATA;

   FUNCTION getCLEANED_DATA
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN CLEANED_DATA;
   END getCLEANED_DATA;

   FUNCTION getCURRENT_NSN
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN CURRENT_NSN;
   END getCURRENT_NSN;

   -- added 6/25/2008 by dse
   PROCEDURE setBulkInsertThreshold (VALUE IN NUMBER)
   IS
   BEGIN
      bulkInsertThreshold := VALUE;
   END setBulkInsertThreshold;

   FUNCTION setBulkInsertThreshold (VALUE IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      setBulkInsertThreshold (VALUE);
      RETURN getBulkInsertThreshold;
   END setBulkInsertThreshold;

   FUNCTION getBulkInsertThreshold
      RETURN NUMBER
   IS
   BEGIN
      RETURN bulkInsertThreshold;
   END getBulkInsertThreshold;

   FUNCTION setDebug (VALUE IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      setDebug (VALUE);
      RETURN getDebug;
   END setDebug;

   PROCEDURE setDebug (VALUE IN VARCHAR2)
   IS                                                       -- added 6/30/2008
   BEGIN
      mDebug :=
         (LOWER (VALUE) IN ('1',
                            'y',
                            't',
                            'yes',
                            'true'));

      IF mDebug
      THEN
         DBMS_OUTPUT.ENABLE (100000);
      ELSE
         DBMS_OUTPUT.DISABLE;
      END IF;
   END setDebug;

   FUNCTION getDebug
      RETURN VARCHAR2
   IS
   BEGIN
      IF mDebug
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getDebug;

   FUNCTION getUseBizDays
      RETURN VARCHAR2
   IS
   BEGIN
      IF useBizDays
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getUseBizDays;

   PROCEDURE setUseBizDays (VALUE IN VARCHAR2)
   IS
   BEGIN
      useBizDays :=
         (LOWER (VALUE) IN ('1',
                            'y',
                            't',
                            'yes',
                            'true'));
   END setUseBizDays;

   FUNCTION setUseBizDays (VALUE IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      setUseBizDays (VALUE);
      RETURN getUseBizDays;
   END setUseBizDays;
BEGIN
  <<getDebugParam>>
   DECLARE
      param   AMD_PARAM_CHANGES.PARAM_VALUE%TYPE;
   BEGIN
      param := amd_defaults.GetParamValue ('debugAmdLoad');

      IF param IS NOT NULL
      THEN
         mDebug :=
            (LOWER (param) IN ('1',
                               'y',
                               't',
                               'yes',
                               'true'));
      ELSE
         mDebug := FALSE;
      END IF;

      param := amd_defaults.GetParamValue ('useBizDays');

      IF param IS NOT NULL
      THEN
         useBizDays :=
            (LOWER (param) IN ('1',
                               'y',
                               't',
                               'yes',
                               'true'));
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         mDebug := FALSE;
   END getDebugParam;

   bulkInsertThreshold :=
      NVL (TO_NUMBER (amd_defaults.GETPARAMVALUE ('bulkInsertThreshold')),
           bulkInsertThreshold);
END Amd_Load;
/


DROP PACKAGE BODY AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG AS
/*
      $Author:   zf297a  $
    $Revision:   1.22  $
        $Date:   24 Feb 2009 11:18:36  $
    $Workfile:   AMD_LOCATION_PART_LEADTIME_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_LOCATION_PART_LEADTIME_PKG.pkb.-arc  $
/*   
/*      Rev 1.22   24 Feb 2009 11:18:36   zf297a
/*   Removed a2a code
/*   
/*      Rev 1.21   24 Sep 2008 11:20:24   zf297a
/*   Fixed locPartLeadtime_cur by qualifying spo_prime_part_no with table amd_sent_to_a2a
/*   
/*      Rev 1.20   18 Feb 2008 14:50:22   zf297a
/*   implemented function getVersion
/*   
/*      Rev 1.19   18 Feb 2008 14:44:14   zf297a
/*   For the loadAllA2A make sure the part is prime and that it is active.
/*   
/*      Rev 1.18   03 Dec 2007 13:18:42   zf297a
/*   Removed close of locPartLeadTime cursor since it is already closed by the processLocPartLeadTime procedure.
/*   
/*      Rev 1.17   07 Nov 2007 17:25:48   zf297a
/*   Use bulk collect for all the cursors.
/*   
/*      Rev 1.16   12 Sep 2007 14:01:22   zf297a
/*   Removed commit from for loop.
/*   
/*      Rev 1.15   Nov 28 2006 14:35:20   zf297a
/*   fixed insertTmpA2A_LPLT - for INSERT_ACTION or UPDATE_ACTION check to see if the part is in amd_sent_to_a2a with action_code <> DELETE_ACTION then insert it into tmp_a2a_loc_part_lead_time.  For DELETE_ACTION's check to see if the part is in amd_sent_to_a2a with any action_code then insert it into tmp_a2a_loc_part_lead_time.
/*   
/*      Rev 1.14   Oct 25 2006 09:19:46   zf297a
/*   Implemented functions:
/*   getVIRTUAL_COD_SPO_LOCATION
/*   getVIRTUAL_UAB_SPO_LOCATION
/*   getUK_LOCATION         
/*   getBASC_LOCATION
/*   getLEADTIMETYPE
/*   getBULKLIMIT.
/*   Added dbms_output.put_line to the version procedure.
/*   
/*   
/*      Rev 1.13   Jun 09 2006 11:51:06   zf297a
/*   implemented version
/*   
/*      Rev 1.12   Jun 01 2006 12:13:10   zf297a
/*   switched from dbms_output to amd_utils.writeMsg and from executed immediate to Mta_Truncate_Table
/*   
/*      Rev 1.11   May 12 2006 14:47:24   zf297a
/*   For the loadAll routines use all the action_codes and use the SendAllData property of the a2a_pkg in conjunction with the isPartValid and wasPartSent functions to determine if a part is sent as an A2A transaction.
/*   
/*      Rev 1.10   Mar 05 2006 14:14:38   zf297a
/*   Added amd_utils.debugMsg to record counts and procedure completion.
/*   
/*      Rev 1.9   Mar 03 2006 12:27:48   zf297a
/*   Removed function getBatchRunStart which has been replaced by amd_batch_pkg.getLastStartTime.  This will always return the last start time of the last job that has been run or is currently running.  This was data that has changed since the job started can always be sent as an A2A transaction even though it may have already been sent.  The small amount of repeat data should not be great.
/*   
/*      Rev 1.8   Feb 15 2006 14:00:46   zf297a
/*   Added cur ref, record type and a common process routine so that the data gets loaded the same no matter what selection criteria is used.
/*   
/*   
/*      Rev 1.7   Jan 04 2006 10:07:38   zf297a
/*   Made loadAllA2A and loadA2AByDate conform to the a2a_pkg.initA2A procedures.
/*   
/*      Rev 1.6   Jan 03 2006 12:45:50   zf297a
/*   Added date range to procedure loadA2AByDate
/*   
/*      Rev 1.5   Dec 29 2005 16:29:56   zf297a
/*   Added loadA2AByDate procedure
/*   
/*      Rev 1.4   Dec 15 2005 12:18:32   zf297a
/*   Added truncate of table tmp_a2a_loc_part_lead_time to LoadTmpAmdLocPartLeadtime
/*   
/*      Rev 1.3   Dec 07 2005 09:17:44   zf297a
/*   Added checks for isPartValid and wasPartSent.
/*   
/*      Rev 1.2   Dec 07 2005 08:37:56   zf297a
/*   Simplified errorMsg by making it a procedure with default values for most parameters.  Fixed loadAllA2A to ignore dup_value_on_index.
/*   
/*      Rev 1.1   Dec 06 2005 09:49:40   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*   
/*      Rev 1.0   Nov 30 2005 12:40:00   zf297a
/*   Initial revision.
/*   
/*      Rev 1.0   Nov 30 2005 12:31:04   zf297a
/*   Initial revision.
*/    

       
    PKGNAME CONSTANT VARCHAR2(50) := 'AMD_LOCATION_PART_LEADTIME_PKG' ;
         /* cursor used for data load */    
         /* previous spec, 0 and null same for avgRepairCycleTime from ramp */
         /* appears for BULK COLLECT to work, cursor needs to be 
         in column id order (i.e. cannot just qualify by field name) 
         and all columns have to be accounted for */            
         -- decode(nvl(GetAvgRepairCycleTime(ansi.nsn, loc_id), 0), 0, decode(IsPartRepairable(nsi_sid), 'Y', Amd_Defaults.TIME_TO_REPAIR_ONBASE, someOtherDefault ), GetAvgRepairCycleTime(ansi.nsn, loc_id)) time_to_repair,
         type locPartLeadtimeRec is record (
            part_no amd_spare_parts.spo_prime_part_no%type,
            loc_sid amd_spare_networks.loc_sid%type,
            time_to_repair ramp.AVG_REPAIR_CYCLE_TIME%TYPE,
            action_code amd_spare_parts.action_code%type,
            last_update_dt amd_spare_parts.last_update_dt%type
         ) ;
         type locPartLeadtimeTab is table of locPartLeadTimeRec ;
         locPartLeadtimeRecs locPartLeadtimeTab ;
         
        CURSOR locPartLeadtime_cur IS
              SELECT spo_prime_part_no, 
                   loc_sid, 
                   decode(nvl(GetAvgRepairCycleTime(parts.nsn, loc_id), 0), 0, Amd_Defaults.TIME_TO_REPAIR_ONBASE, GetAvgRepairCycleTime(parts.nsn, loc_id)) time_to_repair,
                   amd_defaults.INSERT_ACTION action_code,
                   sysdate last_update_dt  
                 FROM amd_spare_parts parts, 
                     amd_spare_networks asn
                 WHERE parts.is_spo_part = 'Y'
                and parts.part_no = parts.spo_prime_part_no 
                AND parts.action_code != Amd_Defaults.DELETE_ACTION
                AND asn.action_code != Amd_Defaults.DELETE_ACTION
                AND asn.loc_type in ('MOB', 'FSL') ;
    
    
    FUNCTION IsPartRepairable(pPartNo amd_spare_parts.part_no%TYPE ) RETURN VARCHAR2 IS
    BEGIN
        RETURN IsPartRepairable(amd_utils.GetNsiSidFromPartNo(pPartNo)) ;
    EXCEPTION WHEN OTHERS THEN
         RETURN null ;    
    END ;
    
    FUNCTION IsPartRepairable(pNsiSid amd_national_stock_items.nsi_sid%TYPE ) RETURN VARCHAR2 IS
         ansiRow amd_national_stock_items%ROWTYPE ;
         smr amd_national_stock_items.SMR_CODE%TYPE ; 
    BEGIN
         SELECT * INTO ansiRow
            FROM amd_national_stock_items
             WHERE nsi_sid = pNsiSid ;
         IF (ansiRow.smr_code_cleaned IS NOT NULL) THEN
             smr := ansiRow.smr_code_cleaned ;
         ELSIF (ansiRow.smr_code IS NOT NULL ) THEN
             smr := ansiRow.smr_code ;
         ELSE      
             smr := ansiRow.smr_code_defaulted ;
         END IF ;    
         IF (substr(smr, 6, 1) = 'T') THEN
             RETURN 'Y';
         ELSE
             RETURN 'N' ;
         END IF ;     
    EXCEPTION WHEN NO_DATA_FOUND THEN
         RETURN null ;
    END ;            
    
        procedure writeMsg(
                    pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                    pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                    pKey1 IN VARCHAR2 := '',
                    pKey2 IN VARCHAR2 := '',
                    pKey3 IN VARCHAR2 := '',
                    pKey4 in varchar2 := '',
                    pData IN VARCHAR2 := '',
                    pComments IN VARCHAR2 := '')  IS
        BEGIN
            Amd_Utils.writeMsg (
                    pSourceName => 'amd_location_part_leadtime_pkg',    
                    pTableName  => pTableName,
                    pError_location => pError_location,
                    pKey1 => pKey1,
                    pKey2 => pKey2,
                    pKey3 => pKey3,
                    pKey4 => pKey4,
                    pData    => pData,
                    pComments => pComments);
        end writeMsg ;
                
     PROCEDURE ErrorMsg(
         pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
         pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
         pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
         pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE,
         pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
         pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
         pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
         pKeywordValuePairs IN VARCHAR2 := '') IS
      result NUMBER ;
      key5 amd_load_details.KEY_5%type := pKeywordValuePairs ;
     BEGIN
      ROLLBACK;
      IF key5 = '' THEN
         key5 := pSqlFunction || '/' || pTableName ;
      ELSE
       key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
      END IF ;
      -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
      -- do not exceed the length of the column's that the data gets inserted into
      -- This is for debugging and logging, so efforts to make it not be the source of more
      -- errors is VERY important
      Amd_Utils.InsertErrorMsg (
        pLoad_no => Amd_Utils.GetLoadNo(
          pSourceName => SUBSTR(pSqlfunction,1,20),
          pTableName  => SUBSTR(pTableName,1,20)),
        pData_line_no => pError_location,
        pData_line    => 'amd_location_part_leadtime_pkg',
        pKey_1 => SUBSTR(pKey_1,1,50),
        pKey_2 => SUBSTR(pKey_2,1,50),
        pKey_3 => SUBSTR(pKey_3,1,50),
        pKey_4 => SUBSTR(pKey_4,1,50),
        pKey_5 =>  TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ||
             ' ' || substr(key5,1,50),
        pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
      COMMIT;
     END ErrorMsg;
                
    FUNCTION GetRampData(pNsn amd_nsns.nsn%TYPE, pLocSid amd_spare_networks.loc_sid%TYPE) RETURN ramp%ROWTYPE IS
        rampData ramp%ROWTYPE := null;
        locId amd_spare_networks.loc_id%TYPE;
    BEGIN
        locId := amd_utils.GetLocId(pLocSid);
        IF (locId IS null) THEN
            RETURN rampData;
        ELSE
            RETURN GetRampData(pNsn, locId);
        END IF;
    EXCEPTION WHEN OTHERS THEN
        RETURN null ;    
    END GetRampData;
    
    
    FUNCTION GetRampData(pNsn amd_nsns.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) RETURN ramp%ROWTYPE IS
        CURSOR rampData_cur (pNsn ramp.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) IS
            SELECT * 
            FROM
               ramp
            WHERE
               replace(current_stock_number, '-') = pNsn AND
               substr(sc, 8, 6) = pLocId;
        
        rampData rampData_cur%ROWTYPE := null;
        -- though currently ramp does not RETURN more than one record, design
        -- of ramp table allows. current_stock_number IS not part of key.
        -- use explicit CURSOR just in case.
    
        BEGIN
             IF (NOT rampData_cur%isopen) THEN
                    OPEN rampData_cur(pNsn, pLocId);
             END IF;
             FETCH rampData_cur INTO
                rampData;
             CLOSE rampData_cur;
        RETURN rampData;
    END GetRampData;
    
    FUNCTION GetAvgRepairCycleTime(pNsn amd_nsns.nsn%TYPE, pLocId amd_spare_networks.loc_id%TYPE) RETURN ramp.AVG_REPAIR_CYCLE_TIME%TYPE IS
        rampData ramp%ROWTYPE ;
    BEGIN
        rampData := GetRampData(pNsn, pLocId);
        RETURN rampData.avg_repair_cycle_time ;
    END GetAvgRepairCycleTime ; 
    
    
    
    PROCEDURE UpdateAmdLocPartLeadtime (
                pPartNo                        amd_location_part_leadtime.part_no%TYPE,
              pLocSid                     amd_spare_networks.loc_sid%TYPE, 
              pTimeToRepair                amd_location_part_leadtime.time_to_repair%TYPE,
              pActionCode                amd_location_part_leadtime.action_code%TYPE,
              pLastUpdateDt                amd_location_part_leadtime.last_update_dt%TYPE ) IS
              returnCode NUMBER ;
    BEGIN
               UPDATE amd_location_part_leadtime
              SET 
                    time_to_repair             = pTimeToRepair,
                  action_code                = pActionCode,
                  last_update_dt            = pLastUpdateDt
              WHERE
                    part_no = pPartNo AND
                  loc_sid = pLocSid ;
    exception when others then
              errorMsg(pSqlFunction => 'update',
                      pTablename => 'amd_location_part_leadtime',
                    pError_location => 10,
                    pKey_1 => pPartNo, pKey_2 => to_char(pLocSid) ) ;              
    END UpdateAmdLocPartLeadtime ;                                 
    
    
    
    PROCEDURE InsertAmdLocPartLeadtime (
              pPartNo                        amd_location_part_leadtime.part_no%TYPE,
              pLocSid                     amd_spare_networks.loc_sid%TYPE, 
              pTimeToRepair                amd_location_part_leadtime.time_to_repair%TYPE,
              pActionCode                amd_location_part_leadtime.action_code%TYPE,
              pLastUpdateDt                amd_location_part_leadtime.last_update_dt%TYPE ) IS
    BEGIN
         INSERT INTO amd_location_part_leadtime 
         (
                  part_no,
                loc_sid,
                time_to_repair,
                action_code,
                last_update_dt
         )
         VALUES 
         (
                  pPartNo,
                pLocSid,
                pTimeToRepair,
                pActionCode,
                pLastUpdateDt     
         ) ;    
    EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
               UpdateAmdLocPartLeadtime
               (
                  pPartNo,
                pLocSid,
                pTimeToRepair,
                pActionCode,
                sysdate
               ) ;     
          
    END InsertAmdLocPartLeadtime ;

    
    
    /*  
        -------------------------------------------------------------
        InsertRow, UpdateRow, DeleteRow called From Java diff program
        -------------------------------------------------------------     
    */
    
    FUNCTION InsertRow(
            pPartNo                      amd_location_part_leadtime.part_no%TYPE,
            pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
            pTimeToRepair                 amd_location_part_leadtime.time_to_repair%TYPE)
            RETURN NUMBER IS
            returnCode NUMBER ;        
    BEGIN
         BEGIN
               InsertAmdLocPartLeadtime
              (
                     pPartNo,
                pLocSid,
                pTimeToRepair,
                Amd_Defaults.INSERT_ACTION,
                sysdate
               ) ;    
         EXCEPTION WHEN OTHERS THEN
                    ErrorMsg( pSqlfunction => 'insert',
                       pTableName              => 'amd_location_part_leadtime',
                       pError_location       => 20,
                       pKey_1              => pPartNo,
                          pKey_2              => pLocSid) ;
                   RAISE ;      
         END ;          
         
          RETURN SUCCESS ;
    EXCEPTION WHEN OTHERS THEN
         RETURN FAILURE ;
    END InsertRow ;        
            
    
            
    FUNCTION UpdateRow(
            pPartNo                      amd_location_part_leadtime.part_no%TYPE,
            pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
            pTimeToRepair                 amd_location_part_leadtime.time_to_repair%TYPE)        RETURN NUMBER IS
            returnCode NUMBER ;
    BEGIN
         BEGIN
               UpdateAmdLocPartLeadtime
               (
                  pPartNo,
                pLocSid,
                pTimeToRepair,
                Amd_Defaults.UPDATE_ACTION,
                sysdate 
               ) ;
             
        EXCEPTION WHEN OTHERS THEN
                  ErrorMsg(
                   pSqlfunction             => 'update',
                   pTableName              =>'amd_location_part_leadtime',
                   pError_location       => 40,
                   pKey_1              => pPartNo,
                      pKey_2              => pLocSid) ;
                   RAISE ;        
         END ;
         RETURN SUCCESS ;       
    EXCEPTION WHEN OTHERS THEN
         RETURN FAILURE ;           
    END UpdateRow ;        
    
    
    
    FUNCTION DeleteRow(
            pPartNo                      amd_location_part_leadtime.part_no%TYPE,
            pLocSid                      amd_location_part_leadtime.loc_sid%TYPE,
            pTimeToRepair                 amd_location_part_leadtime.time_to_repair%TYPE)        RETURN NUMBER IS
            returnCode NUMBER ;
    BEGIN
         BEGIN
               UpdateAmdLocPartLeadtime
              (
                     pPartNo,
                pLocSid,
                pTimeToRepair,
                Amd_Defaults.DELETE_ACTION,
                sysdate
               ) ;
         EXCEPTION WHEN OTHERS THEN
                  ErrorMsg(pSqlFunction => 'update',
                   pTableName              =>'amd_location_part_leadtime',
                   pError_location       => 60,
                   pKey_1              => pPartNo,
                      pKey_2              => pLocSid) ;
                   RAISE ;        
         END ;          
         
         RETURN SUCCESS ;
    EXCEPTION WHEN OTHERS THEN     
            RETURN FAILURE ;
    END DeleteRow ;        
    
        
        
        
                    
    PROCEDURE LoadTmpAmdLocPartLeadtime IS
          returnCode NUMBER ;
    BEGIN
        mta_truncate_table('tmp_amd_location_part_leadtime','reuse storage');
        
        OPEN locPartLeadtime_cur ;
        fetch locPartLeadTime_cur bulk collect into locPartLeadTimeRecs ;
        close locPartLeadTime_cur ;
        
        if locPartLeadTimeRecs.first is not null then        
            FORALL indx IN locPartLeadTimeRecs.first ..locPartLeadTimeRecs.last -- SAVE EXCEPTIONS
                   INSERT INTO tmp_amd_location_part_leadtime
                   VALUES locPartLeadTimeRecs(indx) ;
            COMMIT ;
        end if ;            
    EXCEPTION WHEN OTHERS THEN
              ErrorMsg(
                   pSqlFunction             => 'forall insert',
                   pTableName              =>'tmp_amd_location_part_leadtime',
                   pError_location       => 160,
                   pKey_1 => 'failed') ;
             raise ;
    END ;    
    
    PROCEDURE LoadAmdLocPartLeadtime IS
        -- defaultTimeToRepair tmp_amd_location_part_leadtime.time_to_repair_defaulted%TYPE := amd_defaults.TIME_TO_REPAIR_ONBASE ;
         returnCode NUMBER ;
    BEGIN
        mta_truncate_table('amd_location_part_leadtime','reuse storage');
        
        OPEN locPartLeadtime_cur;
        fetch locPartLeadTime_cur bulk collect into locPartLeadTimeRecs ;
        close locPartLeadTime_cur ;
        
        if locPartLeadTimeRecs.first is not null then    
            FORALL indx IN locPartLeadTimeRecs.first .. locPartLeadTimeRecs.last -- SAVE EXCEPTIONS
               INSERT INTO amd_location_part_leadtime
               VALUES locPartLeadTimeRecs(indx) ;
            COMMIT ;
        end if ;            
    EXCEPTION WHEN OTHERS THEN
              ErrorMsg(
                   pSqlFunction     => 'forall insert',
                   pTableName              =>'amd_location_part_leadtime',
                   pError_location       => 170,
                   pKey_1          => 'load bulk insert') ;
             raise ;
    END ;              
              
    
    PROCEDURE LoadInitial IS
    BEGIN
         LoadTmpAmdLocPartLeadtime ;
         LoadAmdLocPartLeadtime ;
    END ;

    procedure version is
    begin
         writeMsg(pTableName => 'amd_location_part_leadtime_pkg', 
                 pError_location => 180, pKey1 => 'amd_location_part_leadtime_pkg', pKey2 => '$Revision:   1.22  $') ;
              dbms_output.put_line('amd_location_part_leadtime_pkg: $Revision:   1.22  $') ;         
    end version ;

    function getVersion return varchar2 is
    begin
        return '$Revision:   1.22  $' ;
    end getVersion ;
    
    -- added get functions to return constants 10/25/2006 by dse
    function getVIRTUAL_COD_SPO_LOCATION return amd_spare_networks.spo_location%type is
    begin
         return VIRTUAL_COD_SPO_LOCATION ;
    end getVIRTUAL_COD_SPO_LOCATION ;
    
    function getVIRTUAL_UAB_SPO_LOCATION return amd_spare_networks.spo_location%type is
    begin
         return VIRTUAL_UAB_SPO_LOCATION ;
    end getVIRTUAL_UAB_SPO_LOCATION ;
    
    function getUK_LOCATION              return amd_spare_networks.LOC_ID%type is
    begin
         return UK_LOCATION ;
    end getUK_LOCATION ;
    
    function getBASC_LOCATION             return amd_spare_networks.LOC_ID%type is
    begin
         return BASC_LOCATION ;
    end getBASC_LOCATION ;
         
    function getLEADTIMETYPE              return varchar2 is
    begin
         return LEADTIMETYPE ;
    end getLEADTIMETYPE ;
    
    function getBULKLIMIT                     return number is
    begin
         return BULKLIMIT ;
    end getBULKLIMIT ;
    
END AMD_LOCATION_PART_LEADTIME_PKG ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Location_Part_Override_Pkg AS

 /*
      $Author:   zf297a  $
    $Revision:   1.105
        $Date:   23 Feb 2015
    $Workfile:   AMD_LOCATION_PART_OVERRIDE_PKG.pkb  $

        Rev 1.105 2/23/15 added amd_defaults.getStartLocId
        
        Rev 1.104 2/13/15 commented out spo references
/*   
/*      Rev 1.103   10 Jun 2009 13:29:38   zf297a
/*   Initialize variables tsl_override_type and override_reason using data in amd_spo_types_v.
/*   
/*      Rev 1.102   24 Feb 2009 11:44:08   zf297a
/*   Removed A2A code
/*   
/*      Rev 1.101   19 Feb 2009 10:08:24   zf297a
/*   Implemented get/set for loadFMSdata.  Also, get the loadFMSdata switch from the amd_param_changes tab;e and make the default for loadFMSdata 'N' 
/*   
/*   loadUk, loadCAN, and loadAUS will only run if loadFMSdata = 'Y'
/*   
/*      Rev 1.100   14 Feb 2009 16:07:56   zf297a
/*   Implemented the new interface for loadWhse - endStep only goes to 4 now.
/*
/*      Rev 1.99   14 Feb 2009 14:44:26   zf297a
/*   Removed a2a code.
/*
/*      Rev 1.98   14 Feb 2009 07:30:24   zf297a
/*   Fixed procedure insertAmdLocPartOverride by altering the IF statement prior to inserting to amd_location_part_override and removing the check of the action_code.  All that is needed is the check of the tsl_override_qty.
/*
/*      Rev 1.97   13 Feb 2009 16:00:20   zf297a
/*   Implemented get/set routines for counters.  Fixed insert's to tmp_amd_location_part_override for procedure insertTmpAmdLocPartOverride.  Added some additional counters to make it easier to do a query and check the values after executing the load to tmp_amd_location_part_override.  For example:
/*   select amd_location_part_override_pkg.getTmpInsertCnt from dual
/*
/*      Rev 1.96   24 Sep 2008 10:47:06   zf297a
/*   qualified spo_prime_part_no using amd_sent_to_a2a
/*
/*      Rev 1.95   12 Aug 2008 17:06:50   zf297a
/*   made procedure errorMsg an autonomous_transaction so that its commit is independent of the main transaction and it can record the error message.
/*
/*      Rev 1.94   12 Aug 2008 11:33:52   zf297a
/*   Fixed getFirstLogonIdForPart to hand the condition where no data is found and attempt to the default via the part_no.
/*
/*      Rev 1.93   09 Apr 2008 13:49:16   zf297a
/*   Eliminate sending records with zero quantity for FSL's, MOB's, Atlanta Warehouse, and all other inserts into tmp tables except for sending updates and deleted for the tmp_a2a table.
/*
/*      Rev 1.92   19 Mar 2008 00:02:54   zf297a
/*   Use the new TSL_OVERRIDE_TYPE.
/*
/*      Rev 1.91   14 Feb 2008 11:39:34   zf297a
/*   Make sure that records with zero quantity are not written to tmp or amd tables.
/*
/*      Rev 1.90   12 Nov 2007 00:46:10   zf297a
/*   Fixed retrieving of amd_rsp_sum: used its override_type column and determined the rsp_level based on the override_type.
/*
/*      Rev 1.89   07 Nov 2007 01:24:32   zf297a
/*   Used bulk collect for all cursors.
/*
/*      Rev 1.88   02 Nov 2007 10:46:44   zf297a
/*   Make sure GetFirstLogonIdForPart returns the default logon id when it gets a NOT FOUND from the query.
/*
/*      Rev 1.87   01 Nov 2007 09:04:32   zf297a
/*   Implemented interface for loadRspTslA2A
/*
/*      Rev 1.86   31 Oct 2007 13:15:58   zf297a
/*   Subtract 1 from rsp_level when creating a tmp_a2a_loc_part_override transaction.
/*
/*      Rev 1.85   16 Oct 2007 09:25:26   zf297a
/*   Added amd_locpart_overid_consumables to the cursor of checkForDeletedSpoPrimeParts to make sure those LocPartOverrides get deleted too.
/*
/*      Rev 1.84   11 Oct 2007 12:55:10   zf297a
/*   Renumbered pError_location.  Implemented loadCan and modified LoadTmpAmdLocPartOverride
/*
/*      Rev 1.83   17 Sep 2007 07:26:58   zf297a
/*   Make sure that override_quantity is never null for table tmp_a2a_loc_part_override.  Also, make sure that the override types of ROQ Fixed and ROP Fixed go only with consumable parts and that TSL Fixedf go only with repairable parts.
/*
/*      Rev 1.82   12 Sep 2007 13:45:22   zf297a
/*   Removed commits from for loops and added the override_type colum to the update statement of the doUpdate procedure.
/*
/*      Rev 1.81   12 Sep 2007 13:29:58   zf297a
/*   Make sure parts with  an override type of TSL Fixed are "repairable".
/*
/*      Rev 1.80   28 Aug 2007 15:24:42   zf297a
/*   Fixed code that was causing ORA-01555 errors by eliminating periodic commits.
/*
/*      Rev 1.79   16 Aug 2007 23:14:06   zf297a
/*   Every query of tmp_a2a_loc_part_override qualified by its key, requires that it also check for the override_type that is created for repairable parts, since override_type is no part of the primary key... otherwise override_type belonging to consumables could be incorrectly retrieved or a query could return more than one row when onlly one row is expected.
/*
/*      Rev 1.78   06 Aug 2007 10:09:30   zf297a
/*   Added override_type as part of the key for tmp_a2a_loc_part_override.  Added ignoreStLouis flag so that the check of the St Louis tables could be turned off when that system is down.
/*
/*      Rev 1.77   20 Jun 2007 10:08:20   zf297a
/*   Enhanced the procedure errorMsg so it is less likely to fail.  Made all loadXXX routine retrieve only repairable parts.
/*
/*      Rev 1.76   15 Jun 2007 16:44:38   zf297a
/*   Add error checks for insertedTmpA2ALPO and changed formating of some of the code.
/*
/*      Rev 1.75   13 Jun 2007 20:06:50   zf297a
/*   Fixed the name of checkForDeletedSpoPrimeParts.
/*
/*      Rev 1.74   13 Jun 2007 19:35:24   zf297a
/*   For doupdate make sure the action belonging to insertedTmpA2ALPO.
/*   Add debug code to record the occurance of an incorrect action_code for non active spo_prime_part.  The trigger now handles this condition and makes it the correct value.
/*   Make sure the insert into tmp_a2a_loc_part_override uses the action code belonging to insertedTmpA2ALPO.
/*   Implemented a procedure to check for deleted spo prime part no and make sure the corresponding part_no in amd_location_part_override and amd_rsp_sum have an action code of D and generate the A2A transactions for this procedure.
/*   Add a dynamic debug flag that can be turned on using amd_param_changes with a key of debugLocPartOverride and a value of 1.  If the flag is not found, the debug variable gets set to false.
/*
/*      Rev 1.73   13 Jun 2007 18:57:18   zf297a
/*   For a delete_action check to see if a lpOverride exists for a given part/site_location.  If it does exist create the A2A delete transaction, otherwise don't create it
/*
/*      Rev 1.72   23 May 2007 14:24:20   zf297a
/*   For zero tsl's that are created via tran date and batch start time, include all part related tables and their last_update_dt.   By doing this, it will insure that all data that has changed for a given run will be processed.
/*
/*      Rev 1.71   21 May 2007 12:36:00   zf297a
/*   For procedure loadRspZeroTslA2A added a check to get only the spoPrimePartNo/rsp_locations that do NOT have an active rsp_level to all the routines that open the rspTsl cursor.
/*
/*      Rev 1.70   15 May 2007 09:27:40   zf297a
/*   Changed literal from a2a_pkg to amd_location_part_override_pkg for raise_application_error's.
/*
/*      Rev 1.69   13 Apr 2007 16:25:14   zf297a
/*   Added amd_defults.AMD_AUS_LOC_ID to cursor_peacetimeBasesSum
/*
/*      Rev 1.68   12 Apr 2007 15:31:40   zf297a
/*   changed cursors for loadZeroTslA2A to only reference amd_sent_to_a2a in the from clause
/*
/*   renamed loadZeroTsls to loadZeroRspTsls
/*
/*      Rev 1.67   12 Apr 2007 14:42:02   zf297a
/*   Implemented loadZeroTsls
/*
/*      Rev 1.66   12 Apr 2007 11:56:44   zf297a
/*   Replaced isPartActive with isSpoPrimePartActive since amd_location_part_override can only contain spo_prime_part's
/*
/*      Rev 1.65   12 Apr 2007 10:54:42   zf297a
/*   Move check of whether a part is active out of insertRow and updateRow and put it close to the point of creating a row in tmp_a2a_loc_part_override - insertedTmpA2ALPO.
/*
/*      Rev 1.64   12 Apr 2007 10:25:40   zf297a
/*   For insertRow and updateRow added check if the part is active to determine the value of the action_code.  If the part is not active then send a amd_defaults.DELETE_ACTION.
/*
/*      Rev 1.63   10 Apr 2007 21:34:34   zf297a
/*   replaced loadUkandAUS with two distinct procedures loadUK and loadAUS
/*
/*      Rev 1.62   03 Apr 2007 14:51:16   zf297a
/*   Implement loadTmpAmdLocationPartOverride with argiments startStep and endStep arguments to  with default values of 1 and 5 respectively.
/*
/*   For procedure loadWhse add arguments startStep and endStep with default values of 1 and 5 respectively.
/*
/*   For  procedure loadWhse and for the following cursors make sure that the part_no or spo_prime_part_no is not null:
/*   cursor_warehouse_parts
/*   cursor_peacetimeBasesSum
/*   cursor_wartimeRspSum
/*   cursor_peacetimeBO_Spo_Sum
/*   cursor_peacetimeSpoInv
/*
/*   Create separate nested procedures to  load the following cursors and record the start and end times to amd_load_details using writeMsg:
/*   cursor_warehouse_parts
/*   cursor_peacetimeBasesSum
/*   cursor_wartimeRspSum
/*   cursor_peacetimeBO_Spo_Sum
/*   cursor_peacetimeSpoInv
/*
/*   For debugging purposes, renumber all pError_location values.
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*   2
/*      Rev 1.61   22 Mar 2007 16:44:36   zf297a
/*   Changed LoadUk to LoadUkandAUS and added check for the AUS location id.  Fixed the query for stockFromWhse to use 'C17%CODAUSG' with a G at the end.
/*
/*      Rev 1.60   22 Mar 2007 09:57:06   zf297a
/*   For procedure sendZeroTslsForSpoPrimePart check if the spo_prime_part_no is an ACTIVE spo_prime_part_no in amd_sent_to_a2a instead of just seeing that it is a prime_part_no in amd_national_stock_items.
/*
/*      Rev 1.59   22 Mar 2007 08:40:14   zf297a
/*   Added raise_application_error for procedures errorMsg and writeMsg to guarantee that error information of trace information gets displayed.
/*
/*      Rev 1.58   21 Mar 2007 14:58:10   zf297a
/*   Use isPartSent to check that the part was sent to Data Systems - ie in amd_sent_to_a2a
/*
/*      Rev 1.57   21 Mar 2007 11:32:38   zf297a
/*   Check if a part exists in Data Systems and it has not been marked deleted before sending any deletes, otherwise DataSystems will flag it as an error when trying to delete parts that have already been deleted
/*
/*      Rev 1.56   02 Mar 2007 10:59:04   zf297a
/*   For procedures getAllBasses and getAllBasesNotSet change the default action codes to the "function based" variables.  For getAllBasesSent make sure there isn't an active record either in amd_rsp_sum or amd_location_part_override whose rsp_level or tsl_override_qty is greater than zero.
/*
/*      Rev 1.55   01 Mar 2007 14:43:40   zf297a
/*   Make sure getAllBases is generating DELETE's and sending a zero quantity for all the bases.  If there is already a DELETE tran for the part/base in tmp_a2a_loc_part_override, then don't generate another one.
/*
/*      Rev 1.54   01 Mar 2007 13:38:50   zf297a
/*   Fixed exists clause of queries in getAllBases and getAllBasesNotSent
/*
/*      Rev 1.53   01 Mar 2007 12:41:38   zf297a
/*   Implemented sendZeroTslsForSpoPrimePart
/*
/*      Rev 1.52   26 Jan 2007 09:53:10   zf297a
/*   implemented deleteRspTslA2A
/*
/*      Rev 1.51   Dec 19 2006 10:52:48   zf297a
/*   Fixed deleteRow to use an Update action_code, when the part is valid to be an A2A part, otherwise it will always send a Delete action_code.
/*
/*   Fixed the open cursor for getTestData, getDataByLastUpdateDt, and getAllData to use a DELETE action_code when the A2A part has been deleted from the amd_sent_to_a2a, otherwise send an UPDATE action_code when the action_code is DELETE for the amd_location_part_override row or when the amd_location_part_override row has an INSERT or UPDATE send amd_location_part_override.action_code.
/*
/*
/*
/*      Rev 1.50   Dec 13 2006 12:00:38   zf297a
/*   When a part/loc_sid is being deleted by the java diff applicaton, update the spo data with a zero quantity - i.e. insert a record with a quantity of zero and an action_code of UPDATE.
/*
/*   For all cursor queries make sure the quantity is zero when the action_code is DELETE and make sure that the UPDATE action gets sent for a row that has been deleted in amd_location_part_override.
/*
/*   Implemented isTmpA2AOkay - this just checks to be sure that every part that has been sent is associated with a location.
/*
/*      Rev 1.49   Dec 05 2006 15:14:50   zf297a
/*   Implemented new interface for processTsl.  The pDoAllA2A parameter was removed.  It was no longer necessary since the tsl cursor does all the filtering.  Removed unecessary code:
/*   insertTmpA2A - this is redundant code
/*   Removed all the unnecessary condition checks since the tsl cursor does all the fnecessary filtering.
/*   Resequenced values used for pError_location.
/*   in LoadAllA2A removed unused variables - doAllA2A, returnCode and rc.
/*   Fixed the open of the cursors to use the action_code from the amd_location_part_override for deleted rows, otherwise use the amd_sent_to_a2a action_code.
/*   For the unions of amd_rsp_sum make sure the mob is still valid by checking it against amd_spare_networks.  For the amd_rsp_sum data always use the amd_sent_to_a2a action_code and always send a zero for any row that has been deleted.
/*
/*      Rev 1.48   Dec 04 2006 13:57:22   zf297a
/*   Fixed processTsl - used trunc for date compare + checked each action_code per each record of the tsl cursor (tslCur).
/*
/*      Rev 1.47   Nov 28 2006 13:44:48   zf297a
/*   fixed getDataByLastUpdateDt - changed code layout for open.
/*
/*   fixed getDataByTranDtAndBatchTime - changed code layout for open.
/*
/*      Rev 1.46   Nov 28 2006 12:54:40   zf297a
/*   fixed insertTmpA2ALPO - for INSERT_ACTION or UPDATE_ACTION check to see if the part is in amd_sent_to_a2a with action_code <> DELETE_ACTION then insert it into tmp_a2a_loc_part_override.  For DELETE_ACTION's check to see if the part is in amd_sent_to_a2a with any action_code then insert it into tmp_a2a_loc_part_override.
/*
/*   fixed insertTmpA2A for INSERT_ACTION or UPDATE_ACTION check to see if the part is in amd_sent_to_a2a with action_code <> DELETE_ACTION then insert it into tmp_a2a_loc_part_override.  For DELETE_ACTION's check to see if the part is in amd_sent_to_a2a with any action_code then insert it into tmp_a2a_loc_part_override.
/*
/*   fixed getDataByLastUpdtDt to check if there is a part in amd_location_part_overrides that has changed for the given time period.
/*
/*   fixed getDataByTranDtAndBatchTime check if there is a part in amd_location_part_overrides that has changed for the given time period.
/*
/*      Rev 1.45   Oct 23 2006 11:05:28   zf297a
/*   Check pError_location in procedured errorMsg to make sure it is numeric.   Changed dup_val_on_index for insertedTmpA2ALPO to update tmp_a2a_loc_part_override and to record what has changed in amd_load_details.  This may provide the necessary information to eliminate this exception condition.
/*
/*      Rev 1.44   Oct 19 2006 11:08:26   zf297a
/*   Fixed all tslCur's to use the amd_sent_to_a2a.action_code and created a nested procedure for each unique Open of the tslCur and record the procedure's name in amd_load_details.
/*
/*      Rev 1.42   Oct 16 2006 08:41:44   zf297a
/*   For function getFirstLogonIdForPart only consider the action_code for amd_planners and amd_planner_logons since the part may have been deleted, but still needs to be sent with the proper logon_id when sending delete A2A transactions.
/*
/*      Rev 1.41   Oct 11 2006 11:03:46   zf297a
/*   When doing a loadAllA2A and getting data from amd_rsp_sum always use the action_code of amd_sent_to_a2a.spo_prime_part_no and send a zero quantity when the amd_rsp_sum.action_code = 'D' otherwise send the rsp_level.
/*
/*      Rev 1.40   Oct 09 2006 22:28:04   zf297a
/*   Fixed inner getActionCode function of insertTmpA2A of processTsl - used rsp_location / site_location for search of amd_rsp_sum.  Added additional exception handlers for getActionCode too.
/*
/*      Rev 1.39   Oct 09 2006 10:34:56   zf297a
/*   For A2A transactions give the action_code belonging to amd_location_part_override or amd_rsp_sum priority when it is a delete action, otherwise use the action_code from the associated amd_sent_to_a2a row.
/*
/*      Rev 1.38   Sep 05 2006 12:47:08   zf297a
/*   Renumbered pError_location's values
/*
/*      Rev 1.37   Aug 31 2006 16:02:12   zf297a
/*   Added more exception handlers.  Added dbms_output to version procedure.
/*
/*      Rev 1.36   Aug 31 2006 15:34:22   zf297a
/*   Replaced errorMsg function with errorMsg procedure
/*
/*      Rev 1.35   Aug 31 2006 14:56:12   zf297a
/*   Added more when others exceptions
/*   fixed loadAllA2A to use the amd_sent_to_a2a action_code
/*
/*      Rev 1.34   Aug 31 2006 12:03:18   zf297a
/*   Used not exists instead of function inInTmpA2AYorN
/*   Used action_code from amd_sent_to_a2a in most cases
/*
/*
/*      Rev 1.33   Jul 17 2006 11:21:00   zf297a
/*   Added cursor_spoSum for warehouse.  This amount get subtracted from the spo_total_inventory
/*
/*      Rev 1.32   Jun 16 2006 09:21:54   zf297a
/*   For LoadWhse added a cursor_rspSum which get summed with cursor_basesSum resulting in substracting out the rsp sum for the final tsl_override_qty that gets put into tmp_amd_location_part_override.
/*
/*      Rev 1.31   Jun 12 2006 13:22:32   zf297a
/*   use symbolic constants UK_LOCATION and BASC_LOCATION.
/*
/*      Rev 1.30   Jun 09 2006 11:56:00   zf297a
/*   implemented version
/*
/*      Rev 1.29   Jun 07 2006 11:11:04   zf297a
/*   For the loadAll unioned amd_rsp_sum with amd_location_part_overrides to get the non zero tsl's.
/*
/*      Rev 1.28   Jun 07 2006 09:45:06   zf297a
/*   for loadRspZeroTsl fixed the sql for the cursors where amd_location_part_override_pkg.isInTmpA2AYorN(spo_prime_part_no, mob || '_RSP') = 'N' is needed (the value was checked for was not all 'N''s and the mob was not concatenated with the literal '_RSP')
/*
/*      Rev 1.27   Jun 03 2006 20:25:54   zf297a
/*   enhanced the use of writeMsg
/*
/*      Rev 1.26   Jun 03 2006 19:09:54   zf297a
/*   added:
/*   and parts.action_code != amd_defaults.getDELETE_ACTION
/*   to the last open tsl cursor of procedure LoadZeroTslA2A
/*
/*      Rev 1.25   Jun 03 2006 18:59:36   zf297a
/*   fixed procedure amd_location_part_override_pkg.LoadZeroTslA2A(pDoAllA2A BOOLEAN, pSpoLocation VARCHAR2,from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE)
/*    to use select's similar to the following:
/*    SELECT distinct primes.spo_prime_part_no,
/*      amd_defaults.getINSERT_ACTION,
/*      sysdate,
/*      theLocation spo_location,
/*      ansi.nsn,
/*      ansi.nsi_sid,
/*      0 override_qty
/*      FROM (select distinct spo_prime_part_no from amd_sent_to_a2a where action_code <> 'D') primes,
/*      AMD_NATIONAL_STOCK_ITEMS ansi
/*      WHERE amd_location_part_override_pkg.isInTmpA2AYorN(primes.spo_prime_part_no, theLocation) = 'N'
/*      AND ansi.prime_part_no = primes.spo_prime_part_no
/*      AND ansi.action_code != Amd_Defaults.getDELETE_ACTION
/*
/*   and procedure amd_location_part_override_pkg.LoadZeroTslA2A(doAllA2A IN BOOLEAN := FALSE, from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE)
/*
/*   was fixed by adding an additional invocation of
/*   amd_location_part_override_pkg.LoadZeroTslA2A(pDoAllA2A BOOLEAN, pSpoLocation VARCHAR2,from_dt IN DATE := A2a_Pkg.start_dt, to_dt IN DATE := SYSDATE, useTestData IN BOOLEAN := FALSE)
/*
/*   for pSpoLocation equal to amd_location_part_override_pkg.THE_WAREHOUSE (FD2090).
/*
/*
/*      Rev 1.24   Jun 01 2006 22:20:24   zf297a
/*   Fiixed query for loadRspZeroTsl - added qualification for amd_spare_parts - part_no = spo_prime_part_no
/*
/*      Rev 1.23   Jun 01 2006 12:01:14   zf297a
/*   Added writeMsg to the beginning of processTsl
/*
/*      Rev 1.22   Jun 01 2006 10:57:52   zf297a
/*   Fixed loadRspZeroTsl's.  use amd_utils.writeMsg instead of dbms_output
/*
/*      Rev 1.21   May 31 2006 08:20:46   zf297a
/*   Used Mta_Truncate_Table for loadAllA2A instead of truncateIfOld
/*
/*      Rev 1.20   May 12 2006 14:00:36   zf297a
/*   For loadAllA2A include all action_codes and all parts that are in amd_sent_to_a2a  where the spo_prime_part_no is filled in too.
/*
/*      Rev 1.19   Apr 28 2006 13:16:24   zf297a
/*   Implemented the loadRspZeroTslA2A
/*
/*      Rev 1.18   Apr 21 2006 14:02:00   zf297a
/*   Made insertTmpA2ALPO public, so prototype could be removed.  Also made sure that insertTmpA2ALPO never updates an existing tmp_a2a record with a zero quantity.
/*
/*      Rev 1.17   Apr 20 2006 13:23:00   zf297a
/*   Added an insertTmpA2A routine for the processTsl procedure.  This routine is used only to insert zero tsl's.  If a tmp_a2a row exists already, it is not overwritten.
/*
/*      Rev 1.16   Mar 23 2006 09:08:56   zf297a
/*   Use truncateIfOld for tmp_a2a_loc_part_override - .  The table will get truncated if there is no active batch job or it will get truncated if there is an active batch job and the table has not changed since the batch job started.
/*
/*      Rev 1.15   Mar 06 2006 08:37:34   zf297a
/*   Removed unused references to amd_batch_jobs
/*
/*      Rev 1.14   Mar 05 2006 15:26:36   zf297a
/*   Added debug code.
/*
/*      Rev 1.13   Mar 05 2006 14:16:24   zf297a
/*   Added amd_utils.debugMsg to record counts and procedure completion.
/*   Added enhanced processing to tsl's.
/*
/*      Rev 1.12   Mar 03 2006 12:06:22   zf297a
/*   Moved boolean2Varchar2 to amd_utils.  Used amd_batch_pkg.getLastStartTime instead of amd_location_part_leadtime_pkg.getBatchRunStart.  This will retrieve the last batch start time even if the job has finished.  This way any data changed since the last batch job has been run, can have a2a transactions created for it.  (The only other choice with the previous method would be the "send all" method versus what has changed since the last batch start time).
/*   Added more qualification for the tsl cursor in procedure loadZeroTslA2APartsWithNoTsls
/*
/*
/*      Rev 1.11   Feb 24 2006 15:07:26   zf297a
/*   Streamlined routines handling TSL's.  Added some additional TSL loads.
/*
/*      Rev 1.10   Feb 17 2006 09:25:10   zf297a
/*   Changed requisition_objective to demand_level
/*
/*      Rev 1.9   Feb 15 2006 21:22:52   zf297a
/*   Added ref cursor's, type's and common process routines.
/*
/*      Rev 1.8   Jan 03 2006 12:56:26   zf297a
/*   Added date range to procedures loadZeroTslA2AByDate and loadA2AByDate
/*
/*      Rev 1.7   Jan 03 2006 09:13:06   zf297a
/*   Changed name from loadByDate to loadA2AByDate
/*
/*      Rev 1.6   Dec 30 2005 01:20:08   zf297a
/*   add loadByDate
/*
/*      Rev 1.5   Dec 15 2005 12:16:44   zf297a
/*   Added truncate table tmp_a2a_loc_part_override to LoadTmpAmdLocPartOverride
/*
/*      Rev 1.4   Dec 06 2005 09:52:36   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*
/*      Rev 1.3   Nov 15 2005 11:57:26   zf297a
/*   Add additional where clauses to load all the data.  Added return statement for insertedTmpA2ALPO.
/*
/*      Rev 1.2   Nov 10 2005 11:08:24   zf297a
/*   Added global counters for insert, update, and delete and public getter's.
/*
/*   Added a testData Cursor.
/*
/*   Added counters and displaying of start/end messages for all the load routines.
/*
/*      Rev 1.1   Oct 28 2005 12:46:04   zf297a
/*   Added check for wasPartSent before inserting to tmp_a2a_loc_part_override
/*
/*      Rev 1.0   Oct 19 2005 12:40:56   zf297a
/*   Initial revision.
/*
/*      Rev 1.0   Oct 18 2005 13:07:22   zf297a
/*   Initial revision.
         */

    type candiateRec is record (
        part_no amd_spare_parts.part_no%type,
        loc_sid amd_spare_networks.loc_sid%type
    ) ;
    type candidateTab is table of candiateRec ;
    candidateRecs candidateTab ;

    type stockRec is record (
        part_no amd_spare_parts.part_no%type,
        tsl_override_qty number
    ) ;
    type stockTab is table of stockRec ;
    stockRecs stockTab ;

    type partSumRec is record (
        part_no amd_spare_parts.part_no%type,
        qty number
    ) ;
    type partSumTab is table of partSumRec ;
    partSumRecs partSumTab ;

    type fslMobTab is table of amd_location_part_override%rowtype ;
    
    loadFMSdata varchar2(1) := 'N' ;

    PKGNAME CONSTANT VARCHAR2(30) := 'AMD_LOCATION_PART_OVERRIDE_PKG' ;

    gtZeroCnt NUMBER := 0 ;
    tmpInsertCnt NUMBER := 0 ;
    tmpUpdateCnt NUMBER := 0 ;
    insertCnt NUMBER := 0 ;
    updateCnt NUMBER := 0 ;
    deleteCnt NUMBER := 0 ;

    procedure writeMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 in varchar2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
                 pragma autonomous_transaction ;
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'amd_location_part_override_pkg',
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
        commit ;
    exception when others then
        -- trying to rollback or commit from trigger
        if sqlcode = 4092 then
            raise_application_error(-20010,
                substr('amd_location_part_override_pkg '
                    || sqlcode || ' '
                    || pError_Location || ' '
                    || pTableName || ' '
                    || pKey1 || ' '
                    || pKey2 || ' '
                    || pKey3 || ' '
                    || pKey4 || ' '
                    || pData, 1,2000)) ;
        else
            raise ;
        end if ;
    end writeMsg ;

    PROCEDURE ErrorMsg(
        pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
        pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
        pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
        pKey1 IN AMD_LOAD_DETAILS.KEY_1%TYPE := '',
        pKey2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
        pKey3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
        pKey4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
        pComments IN VARCHAR2 := '') IS

        pragma AUTONOMOUS_TRANSACTION ;

        key5 AMD_LOAD_DETAILS.KEY_5%TYPE := pComments ;
        error_location number ;
        load_no number ;

    BEGIN
      IF key5 = '' THEN
         key5 := pSqlFunction || '/' || pTableName ;
      ELSE
       key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
      END IF ;

      if pError_location is null then
        error_location := -9998 ;
      else
          if amd_utils.isNumber(pError_location) then
               error_location := pError_location ;
          else
               error_location := -9999 ;
          end if ;
     end if ;

      -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
      -- do not exceed the length of the column's that the data gets inserted into
      -- This is for debugging and logging, so efforts to make it not be the source of more
      -- errors is VERY important
      begin
        load_no := amd_utils.getLoadNo(pSourceName => substr(pSqlfunction,1,20), pTableName  => SUBSTR(pTableName,1,20)) ;
      exception when others then
        load_no := -1 ;  -- this should not happen
      end ;

      Amd_Utils.InsertErrorMsg (
        pLoad_no => load_no,
        pData_line_no => error_location,
        pData_line    => 'amd_location_part_override_pkg',
        pKey_1 => SUBSTR(pKey1,1,50),
        pKey_2 => SUBSTR(pKey2,1,50),
        pKey_3 => SUBSTR(pKey3,1,50),
        pKey_4 => SUBSTR(pKey4,1,50),
        pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS') ||
             ' ' || substr(key5,1,50),
        pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
        COMMIT;

    EXCEPTION WHEN OTHERS THEN
      if pSqlFunction is not null then dbms_output.put_line('pSqlFunction=' || pSqlfunction) ; end if ;
      if pTableName is not null then dbms_output.put_line('pTableName=' || pTableName) ; end if ;
      if pError_location is not null then dbms_output.put_line('pError_location=' || pError_location) ; end if ;
      if pKey1 is not null then dbms_output.put_line('key1=' || pKey1) ; end if ;
      if pkey2 is not null then dbms_output.put_line('key2=' || pKey2) ; end if ;
      if pKey3 is not null then dbms_output.put_line('key3=' || pKey3) ; end if ;
      if pKey4 is not null then dbms_output.put_line('key4=' || pKey4) ; end if ;
      if pComments is not null then dbms_output.put_line('pComments=' || pComments) ; end if ;
      dbms_output.put_line('sqlcode(' || SQLCODE || ') sqlerrm(' ||SQLERRM|| ')' ) ;
       raise_application_error(-20030,
            substr('amd_location_part_override_pkg '
                || sqlcode || ' '
                || pError_location || ' '
                || pSqlFunction || ' '
                || pTableName || ' '
                || pKey1 || ' '
                || pKey2 || ' '
                || pKey3 || ' '
                || pKey4 || ' '
                || pComments,1, 2000)) ;
    END ErrorMsg;


    PROCEDURE UpdateAmdLocPartOverride (
                pPartNo                        AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
              pLocSid                     AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
              pTslOverrideQty            AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE,
              pTslOverrideUser            AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE,
              pActionCode                AMD_LOCATION_PART_OVERRIDE.action_code%TYPE,
              pLastUpdateDt                AMD_LOCATION_PART_OVERRIDE.last_update_dt%TYPE) IS
    BEGIN
               UPDATE AMD_LOCATION_PART_OVERRIDE
              SET
                    tsl_override_qty             = pTslOverrideQty,
                  tsl_override_user          = pTslOverrideUser,
                  action_code                = pActionCode,
                  last_update_dt            = pLastUpdateDt
              WHERE
                    part_no = pPartNo AND
                  loc_sid = pLocSid ;
    exception when others then
         ErrorMsg(
                   pSqlfunction       => 'UpdateAmdLocPartOverride',
                   pTableName              => 'amd_location_part_override',
                   pError_location => 10) ;
         raise ;
    END UpdateAmdLocPartOverride ;

    PROCEDURE UpdateTmpAmdLocPartOverride (
                pPartNo                        AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
              pLocSid                     AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
              pTslOverrideQty            AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE,
              pTslOverrideUser            AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE,
              pActionCode                AMD_LOCATION_PART_OVERRIDE.action_code%TYPE,
              pLastUpdateDt                AMD_LOCATION_PART_OVERRIDE.last_update_dt%TYPE) IS
    BEGIN
               UPDATE TMP_AMD_LOCATION_PART_OVERRIDE
              SET
                    tsl_override_qty             = pTslOverrideQty,
                  tsl_override_user          = pTslOverrideUser,
                  action_code                = pActionCode,
                  last_update_dt            = pLastUpdateDt
              WHERE
                    part_no = pPartNo AND
                  loc_sid = pLocSid ;
              tmpUpdateCnt := tmpUpdateCnt + 1 ;
         exception when others then
         ErrorMsg(
                   pSqlfunction       => 'UpdateTmpAmdLocPartOverride',
                   pTableName              => 'tmp_amd_location_part_override',
                   pError_location => 20) ;
         raise ;
         END UpdateTmpAmdLocPartOverride ;


    PROCEDURE InsertTmpAmdLocPartOverride (
              pPartNo                        AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
              pLocSid                     AMD_LOCATION_PART_OVERRIDE.loc_sid%TYPE,
              pTslOverrideQty            AMD_LOCATION_PART_OVERRIDE.tsl_override_qty%TYPE,
              pTslOverrideUser            AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE,
              pActionCode                AMD_LOCATION_PART_OVERRIDE.action_code%TYPE,
              pLastUpdateDt                AMD_LOCATION_PART_OVERRIDE.last_update_dt%TYPE) IS
    BEGIN
        if pTslOverrideUser is null then
            dbms_output.put_line('pPartNo=' 
                || pPartNo 
                || ' ' || pLocSid 
                || ' ' || getfirstlogonidforpart
                            (amd_utils.getnsisidfrompartno (pPartNo))) ;
        end if ;                            
        if pTslOverrideQty > 0   then
             INSERT INTO TMP_AMD_LOCATION_PART_OVERRIDE
             (
                    part_no,
                    loc_sid,
                    tsl_override_qty,
                    tsl_override_user,
                    action_code,
                    last_update_dt
             )
             VALUES
             (
                    pPartNo,
                    pLocSid,
                    pTslOverrideQty,
                    pTslOverrideUser,
                    pActionCode,
                    pLastUpdateDt
             ) ;
         tmpInsertCnt := tmpInsertCnt + 1 ;
        end if ;
    EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
               UpdateTmpAmdLocPartOverride (
                     pPartNo,
                   pLocSid,
                   pTslOverrideQty,
                   pTslOverrideUser,
                   pActionCode,
                   SYSDATE ) ;
      when others then
         ErrorMsg(
                   pSqlfunction       => 'InsertTmpAmdLocPartOverride',
                   pTableName              => 'tmp_amd_location_part_override',
                   pError_location => 30) ;
        raise ;
    END InsertTmpAmdLocPartOverride ;

    PROCEDURE InsertAmdLocPartOverride (
              pPartNo                        AMD_LOCATION_PART_OVERRIDE.part_no%TYPE,
              pLocSid                     AMD_SPARE_NETWORKS.loc_sid%TYPE,
              pTslOverrideQty            NUMBER,
              pTslOverrideUser            VARCHAR2,
              pActionCode                VARCHAR2,
              pLastUpdateDt                DATE) IS
    BEGIN
         if pTslOverrideQty > 0  then
             INSERT INTO AMD_LOCATION_PART_OVERRIDE
             (
                    part_no,
                    loc_sid,
                    tsl_override_qty,
                    tsl_override_user,
                    action_code,
                    last_update_dt
             )
             VALUES
             (
                    pPartNo,
                    pLocSid,
                    pTslOverrideQty,
                    pTslOverrideUser,
                    pActionCode,
                    pLastUpdateDt
             ) ;
        end if ;
    exception
        when dup_val_on_index then
            UpdateAmdLocPartOverride (pPartNo,
                pLocSid,
                pTslOverrideQty,
                pTslOverrideUser,
                pActionCode,
                sysdate ) ;

        when others then
            ErrorMsg(pSqlfunction => 'InsertAmdLocPartOverride',
                pTableName => 'amd_location_part_override',
                pError_location => 40) ;
            raise ;

    END InsertAmdLocPartOverride ;





    FUNCTION InsertRow(pPartNo amd_location_part_override.PART_NO%type,
        pLocSid amd_location_part_override.LOC_SID%type,
        pTslOverrideQty amd_location_part_override.TSL_OVERRIDE_QTY%type ,
        pTslOverrideUser amd_location_part_override.TSL_OVERRIDE_USER%type )
    return number is

    begin

        InsertAmdLocPartOverride(pPartNo,
        pLocSid, pTslOverrideQty,
        pTslOverrideUser, Amd_Defaults.INSERT_ACTION,
        sysdate ) ;

        return success ;

    exception when others then
        errorMsg(pSqlfunction => 'insertAmd',
            pTableName => 'amd_location_part_override',
            pError_location => 170,
            pKey1 => pPartNo, pKey2 => pLocSid) ;
        raise ;
    end insertRow ;


    function updateRow(pPartNo amd_location_part_override.part_no%type,
        pLocSid amd_location_part_override.loc_sid%type,
        pTslOverrideQty    amd_location_part_override.tsl_override_qty%type ,
        pTslOverrideUser amd_location_part_override.tsl_override_user%type )
    return number is
    begin
        updateAmdLocPartOverride (pPartNo,
            pLocSid,
            pTslOverrideQty,
            pTslOverrideUser,
            Amd_Defaults.UPDATE_ACTION,
            sysdate ) ;
         return success ;

     exception when others then
        errorMsg(pSqlfunction => 'updateRow',
            pTableName => 'amd_location_part_override',
                    pError_location => 190,
            pKey1 => pPartNo, pKey2 => pLocSid) ;
        raise ;
    end updateRow ;



    function deleteRow(pPartNo amd_location_part_override.part_no%TYPE,
        pLocSid amd_location_part_override.loc_sid%type,
        pTslOverrideQty    amd_location_part_override.tsl_override_qty%type ,
        pTslOverrideUser amd_location_part_override.tsl_override_user%type )
    return number is
    begin
        updateAmdLocPartOverride (
            pPartNo,
            pLocSid,
            pTslOverrideQty,
            pTslOverrideUser,
            Amd_Defaults.DELETE_ACTION,
            sysdate ) ;
          return success ;

     exception when others then
        errorMsg(pSqlfunction => 'DeleteRow',
            pTableName => 'amd_location_part_override',
            pError_location => 210,
            pKey1 => pPartNo, pKey2 => pLocSid) ;
         raise ;
    end deleteRow ;

    function isNumeric(pString varchar2) return varchar2 is
             ret varchar2(1) ;
             I number ;
    begin
        begin
            if pString is null then
                ret := 'N' ;
            else
                I := to_number(pString) ;
                ret := 'Y' ;
            end if ;
        exception when others then
            ret := 'N' ;
        end ;

        return ret ;

    end isNumeric ;

    procedure loadUk IS

            candidateRecs candidateTab ;

        cursor spoPrimePartsForTheUK IS
            select spo_prime_part_no, loc_sid
            from amd_spare_parts parts, amd_spare_networks ntwks
            where parts.is_repairable = 'Y'
            and parts.is_spo_part = 'Y'
            and parts.part_no = parts.spo_prime_part_no
            and ntwks.loc_id = Amd_Defaults.AMD_UK_LOC_ID ;

        stockRecs stockTab ;

         cursor stockFromWhse IS
            select parts.spo_prime_part_no part_no,
                sum(nvl(stock_level, 0)) tsl_override_qty
            from whse w, amd_spare_parts parts
            where parts.part_no = parts.spo_prime_part_no
            and parts.is_spo_part = 'Y'
            and parts.is_repairable = 'Y'
            and w.part = parts.part_no
            and w.sc like 'C17%CODUKBG'
            group by spo_prime_part_no ;

        returnCode number ;

        type partNo_stock is table of number index by amd_spare_parts.part_no%type  ;
        partNo_stockLevel partNo_stock ;

        tslOverrideQty amd_location_part_override.tsl_override_qty%type ;
        stock_cnt number := 0 ;
        candidateRecCnt number := 0 ;
    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 230,
            pKey1 => 'LoadUk',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

        open stockFromWhse ;
        fetch stockFromWhse bulk collect into stockRecs ;
        close stockFromWhse ;

        if stockRecs.first is not null then
            for indx in stockRecs.first .. stockRecs.last loop
                <<saveQty>>
                begin
                    if ( stockRecs(indx).part_no is not null ) then
                        partNo_stockLevel(stockRecs(indx).part_no) := stockRecs(indx).tsl_override_qty ;
                    end if ;

                exception when others then
                    errorMsg(pSqlfunction => 'LoadUk',
                        pTableName => 'tmp_amd_location_part_override',
                        pError_location => 240,
                        pKey1 => 'partNo: ' || stockRecs(indx).part_no,
                        pKey2 => 'qty: ' || stockRecs(indx).tsl_override_qty) ;
                    raise ;
                end saveQty ;

                stock_cnt := stock_cnt + 1 ;
            end loop ;
        end if ;

        open spoPrimePartsForTheUK ;
        fetch spoPrimePartsForTheUK bulk collect into candidateRecs ;
        close spoPrimePartsForTheUK ;

        if candidateRecs.first is not null then
            for indx in candidateRecs.first .. candidateRecs.last loop

                tslOverrideQty := 0 ;
                <<tslQty>>
                begin
                    tslOverrideQty := partNo_stockLevel(candidateRecs(indx).part_no) ;
                exception when no_data_found then
                    tslOverrideQty := 0 ;
                end tslQty ;

                if tslOverrideQty > 0 then
                    gtZeroCnt := gtZeroCnt + 1 ;
                end if ;

                <<insertTemp>>
                begin
                    if (candidateRecs(indx).part_no = '008-877') then
                        dbms_output.put_line(getfirstlogonidforpart
                            (amd_utils.getnsisidfrompartno (candidateRecs(indx).part_no))) ;
                    end if ;                            
                    insertTmpAmdLocPartOverride(candidateRecs(indx).part_no,
                        candidateRecs(indx).loc_sid,
                        tslOverrideQty,
                        getfirstlogonidforpart
                            (amd_utils.getnsisidfrompartno (candidateRecs(indx).part_no)),
                        Amd_Defaults.INSERT_ACTION,
                        sysdate) ;
                exception when others then
                    errorMsg(pSqlfunction    => 'LoadUk',
                        pTableName => 'tmp_amd_location_part_override',
                        pError_location => 250,
                        pKey1 => 'partNo: ' || candidateRecs(indx).part_no,
                        pKey2 => 'locSid: ' || candidateRecs(indx).loc_sid) ;
                    raise ;
                end insertTemp ;

                candidateRecCnt := candidateRecCnt + 1 ;

            end loop ;
        end if ;


        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 260,
            pKey1 => 'LoadUk',
            pKey2 => 'ended at ' || to_char(sysdate,'MM/DD/YYYY HH:MI:SS AM'),
            pKey3 => 'stock_cnt=' || stock_cnt,
            pKey4 => 'candidateRecCnt=' || candidateRecCnt ) ;
        commit ;
    exception when others then
         errorMsg(pSqlfunction => 'LoadUk',
            pTableName => 'tmp_amd_location_part_override',
            pError_location => 270,
            pKey1 => 'stock_cnt=' || to_char(stock_cnt),
            pKey2 => 'candidateRecCnt=' || to_char(candidateRecCnt) ) ;
        raise ;
    end loadUk ;

    procedure loadAUS IS
           cursor spoPrimePartsForAUS IS
            select spo_prime_part_no, loc_sid
            from amd_spare_parts parts, amd_spare_networks ntwks
            where parts.is_repairable = 'Y'
            and parts.is_spo_part = 'Y'
            and parts.part_no = parts.spo_prime_part_no
            and ntwks.loc_id = Amd_Defaults.AMD_AUS_LOC_ID ;


         cursor stockFromWhse is
            select spo_prime_part_no part_no,
                sum(nvl(stock_level, 0)) tsl_override_qty
            from whse w, amd_spare_parts parts
            where w.part = parts.part_no
            and parts.is_spo_part = 'Y'
            and parts.part_no = parts.spo_prime_part_no
            and parts.is_repairable = 'Y'
            and w.sc like 'C17%CODAUSG'
            group by spo_prime_part_no ;

        returnCode NUMBER ;

        type partNo_stock is table of number index by amd_spare_parts.part_no%type  ;
        partNo_stockLevel partNo_stock ;

        tslOverrideQty amd_location_part_override.tsl_override_qty%type ;
        stock_cnt number := 0 ;
        candidateRecCnt number := 0 ;
    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 280,
            pKey1 => 'LoadAUS',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

        open stockFromWhse ;
        fetch stockFromWhse bulk collect into stockRecs ;
        close stockFromWhse ;

        if stockRecs.first is not null then
            for indx in stockRecs.first .. stockRecs.last loop
                    <<getQty>>
                begin
                    if ( stockRecs(indx).part_no is not null ) then
                        partNo_stockLevel(stockRecs(indx).part_no) := stockRecs(indx).tsl_override_qty ;
                    end if ;
                exception when others then
                    ErrorMsg(pSqlfunction => 'LoadAUS',
                        pTableName => 'tmp_amd_location_part_override',
                        pError_location => 290,
                        pKey1 => 'partNo: ' || stockRecs(indx).part_no,
                        pKey2 => 'qty: ' || stockRecs(indx).tsl_override_qty) ;
                    raise ;
                end getQty ;
                stock_cnt := stock_cnt + 1 ;
            end loop ;
        end if ;

        open spoPrimePartsForAUS ;
        fetch spoPrimePartsForAUS bulk collect into candidateRecs ;
        close spoPrimePartsForAUS ;

        if candidateRecs.first is not null then
            for indx in candidateRecs.first .. candidateRecs.last loop
                tslOverrideQty := 0 ;
                begin
                    tslOverrideQty := partNo_stockLevel(candidateRecs(indx).part_no) ;
                exception when no_data_found then
                    tslOverrideQty := 0 ;
                end ;

                <<insertTmp>>
                begin
                    insertTmpAmdLocPartOverride(candidateRecs(indx).part_no,
                        candidateRecs(indx).loc_sid,
                        tslOverrideQty,
                        getfirstlogonidforpart
                            (amd_utils.getnsisidfrompartno (candidateRecs(indx).part_no)),
                        Amd_Defaults.INSERT_ACTION,
                        sysdate) ;
                exception when others then
                    errorMsg(pSqlfunction => 'insertTmp',
                        pTableName => 'tmp_amd_location_part_override',
                        pError_location => 300,
                        pKey1 => 'partNo: '|| candidateRecs(indx).part_no,
                        pKey2 => 'locSid: '|| candidateRecs(indx).loc_sid) ;
                    raise ;
                end insertTmp ;

                candidateRecCnt := candidateRecCnt + 1 ;
            end loop ;
        end if ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 310,
            pKey1 => 'LoadAUS',
            pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
            pKey3 => 'stock_cnt=' || stock_cnt,
            pKey4 => 'candidateRecCnt=' || candidateRecCnt ) ;
        commit ;
    exception when others then
        errorMsg(pSqlfunction => 'LoadAUS',
            pTableName => 'tmp_amd_location_part_override',
            pError_location => 320,
            pKey1 => 'stock_cnt=' || to_char(stock_cnt),
            pKey2 => 'candidateRecCnt=' || to_char(candidateRecCnt) ) ;
        raise ;
    end loadAUS ;

    procedure loadCAN IS -- added 10/11/2007 by dse

           cursor spoPrimePartsForCAN IS
            select spo_prime_part_no, loc_sid
            from amd_spare_parts parts, amd_spare_networks ntwks
            where parts.is_repairable = 'Y'
            and parts.is_spo_part = 'Y'
            and parts.part_no = parts.spo_prime_part_no
            and ntwks.loc_id = Amd_Defaults.AMD_CAN_LOC_ID ;

         cursor stockFromWhse is
            select parts.spo_prime_part_no part_no,
                sum(nvl(stock_level, 0)) tsl_override_qty
            from whse w, amd_spare_parts parts
            where w.part = parts.part_no
            and parts.is_spo_part = 'Y'
            and parts.is_repairable = 'Y'
            and parts.part_no = parts.spo_prime_part_no
            and w.sc like 'C17%CODCANG'
            group by parts.spo_prime_part_no ;

        returnCode NUMBER ;
        type partNo_stock is table of number index by amd_spare_parts.part_no%type  ;
        partNo_stockLevel partNo_stock ;

        tslOverrideQty amd_location_part_override.tsl_override_qty%type ;
        stock_cnt number := 0 ;
        candidateRecCnt number := 0 ;
    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 330,
            pKey1 => 'LoadCAN',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

        open stockFromWhse;
        fetch stockFromWhse bulk collect into stockRecs ;
        close stockFromWhse ;

        if stockRecs.first is not null then
            for indx in stockRecs.first .. stockRecs.last loop
                begin
                    if ( stockRecs(indx).part_no is not null ) then
                        partNo_stockLevel(stockRecs(indx).part_no) := stockRecs(indx).tsl_override_qty ;
                    end if ;
                exception when others then
                    ErrorMsg(pSqlfunction => 'LoadCAN',
                        pTableName => 'tmp_amd_location_part_override',
                        pError_location => 340,
                        pKey1 => 'partNo: ' || stockRecs(indx).part_no,
                        pKey2 => 'qty: ' || stockRecs(indx).tsl_override_qty) ;
                    raise ;
                end ;

                stock_cnt := stock_cnt + 1 ;
            end loop ;
        end if ;

        open spoPrimePartsForCAN ;
        fetch spoPrimePartsForCAN bulk collect into candidateRecs ;
        close spoPrimePartsForCAN ;

        if candidateRecs.first is not null then
            for indx in candidateRecs.first .. candidateRecs.last loop
                tslOverrideQty := 0 ;

                <<getTsl>>
                begin
                    tslOverrideQty := partNo_stockLevel(candidateRecs(indx).part_no) ;
                exception when no_data_found then
                    tslOverrideQty := 0 ;
                end getTsl ;

                <<insertTmp>>
                begin
                    insertTmpAmdLocPartOverride(candidateRecs(indx).part_no,
                        candidateRecs(indx).loc_sid,
                        tslOverrideQty,
                        getfirstlogonidforpart
                            (amd_utils.getnsisidfrompartno (candidateRecs(indx).part_no)),
                        Amd_Defaults.INSERT_ACTION,
                        sysdate) ;
                exception when others then
                    errorMsg(pSqlfunction => 'LoadCAN',
                        pTableName => 'tmp_amd_location_part_override',
                        pError_location => 350,
                        pKey1 => 'partNo: '|| candidateRecs(indx).part_no,
                        pKey2 => 'locSid: '|| candidateRecs(indx).loc_sid) ;
                    raise ;
                end insertTmp ;

                candidateRecCnt := candidateRecCnt + 1 ;
            end loop ;
        end if ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 360,
            pKey1 => 'LoadCAN',
            pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
            pKey3 => 'stock_cnt=' || stock_cnt,
            pKey4 => 'candidateRecCnt=' || candidateRecCnt ) ;
        commit ;
    exception when others then
        errorMsg(pSqlfunction => 'LoadCAN',pTableName => 'tmp_amd_location_part_override',
            pError_location => 370,
            pKey1 => 'stock_cnt=' || to_char(stock_cnt),
            pKey2 => 'candidateRecCnt=' || to_char(candidateRecCnt) ) ;
        raise ;
    end loadCAN ;


    PROCEDURE LoadBasc IS
           cursor spoPrimePartsForBASC IS
            select spo_prime_part_no, loc_sid
            from amd_spare_parts parts, amd_spare_networks ntwks
            where parts.is_repairable = 'Y'
            and parts.is_spo_part = 'Y'
            and parts.part_no = parts.spo_prime_part_no
            and ntwks.loc_id = Amd_Defaults.AMD_BASC_LOC_ID ;


         cursor stockFromWhse is
            select spo_prime_part_no part_no,
                sum(nvl(stock_level, 0)) tsl_override_qty
            from whse w, amd_spare_parts parts
            where w.part = parts.part_no
            and parts.is_spo_part = 'Y'
            and parts.is_repairable = 'Y'
            and parts.part_no = parts.spo_prime_part_no
            and sc = 'C17PCAG'
            group by spo_prime_part_no ;

        returnCode number ;
        type partNo_stock is table of number index by amd_spare_parts.part_no%type  ;
        partNo_stockLevel partNo_stock ;

        tslOverrideQty AMD_LOCATION_PART_OVERRIDE.TSL_OVERRIDE_QTY%TYPE ;
        stock_cnt NUMBER := 0 ;
        candidateRecCnt NUMBER := 0 ;
    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 380,
            pKey1 => 'LoadBasc',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

        open stockFromWhse;
        fetch stockFromWhse bulk collect into stockRecs ;
        close stockFromWhse ;

        if stockRecs.first is not null then
            for indx in stockRecs.first .. stockRecs.last loop
                begin
                    if ( stockRecs(indx).part_no is not null ) then
                        partNo_stockLevel(stockRecs(indx).part_no) := stockRecs(indx).tsl_override_qty ;
                    end if ;
                exception when others then
                    errorMsg(pSqlfunction => 'LoadBasc',
                        pTableName => 'tmp_amd_location_part_override',
                        pError_location => 390,
                        pKey1 => 'partNo: ' || stockRecs(indx).part_no,
                        pKey2 => 'qty: '|| stockRecs(indx).tsl_override_qty) ;
                    raise ;
                end ;

                stock_cnt := stock_cnt + 1 ;

            end loop ;
        end if ;

        open spoPrimePartsForBASC ;
        fetch spoPrimePartsForBASC bulk collect into candidateRecs ;
        close spoPrimePartsForBASC ;

        if candidateRecs.first is not null then
            for indx in candidateRecs.first .. candidateRecs.last loop
                tslOverrideQty := 0 ;

                <<getTslQty>>
                begin
                    tslOverrideQty := partNo_stockLevel(candidateRecs(indx).part_no) ;
                exception when no_data_found then
                    tslOverrideQty := 0 ;
                end getTslQty ;

                <<insertTmp>>
                begin
                    insertTmpAmdLocPartOverride(candidateRecs(indx).part_no,
                        candidateRecs(indx).loc_sid,
                        tslOverrideQty,
                        getfirstlogonidforpart
                            (amd_utils.getnsisidfrompartno (candidateRecs(indx).part_no)),
                        Amd_Defaults.INSERT_ACTION,
                        sysdate) ;
                exception when others then
                    ErrorMsg(pSqlfunction => 'LoadBasc',
                        pTableName => 'tmp_amd_location_part_override',
                        pError_location => 400,
                        pKey1 => 'partNo: ' || candidateRecs(indx).part_no,
                        pKey2 => 'locSid: ' || candidateRecs(indx).loc_sid) ;
                    raise ;
                end insertTmp ;

                candidateRecCnt := candidateRecCnt + 1 ;
            end loop ;
        end if ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 410,
            pKey1 => 'LoadBasc',
            pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
            pKey3 => 'stock_cnt=' || stock_cnt,
            pKey4 => 'candidateRecCnt=' || candidateRecCnt) ;
        commit ;

    exception when others then
        errorMsg(pSqlfunction => 'LoadBasc',
            pTableName => 'tmp_amd_location_part_override',
            pError_location => 420,
            pKey1 => 'stock_cnt=' || to_char(stock_cnt),
            pKey2 => 'candidateRecCnt=' || to_char(candidateRecCnt)) ;
        raise ;
    end loadBasc ;


    procedure loadRampData IS

        rampRecs fslMobTab ;

        cursor rampData is
        select parts.spo_prime_part_no part_no,
            loc_sid,
            sum(nvl(r.demand_level,0)) demand_level,
            null,
            amd_defaults.INSERT_ACTION,
            sysdate
        from ramp r, amd_spare_parts parts, amd_spare_networks asn
        where r.sc like 'C170008%'
        and substr(r.sc, amd_defaults.getStartLocId, 6) = asn.loc_id
        and asn.loc_type in ('MOB', 'FSL')
        and replace(r.current_stock_number, '-') = parts.nsn
        and parts.spo_prime_part_no = parts.part_no
        and parts.is_spo_part = 'Y'
        and parts.is_repairable = 'Y'
        and Amd_Location_Part_Override_Pkg.IsNumeric(parts.nsn) = 'Y'
        and asn.action_code != Amd_Defaults.DELETE_ACTION
        group by  spo_prime_part_no , loc_sid
        having sum(nvl(r.demand_level,0))  > 0 ;

        type array is table of tmp_amd_location_part_override%rowtype;
        l_data array;
        returnCode number ;
        cur_cnt NUMBER := 0 ;
        req_cnt NUMBER := 0 ;

    BEGIN
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 430,
            pKey1 => 'loadRampData',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;


        open rampData ;
        fetch rampData bulk collect into rampRecs ;
        close rampData ;

        if rampRecs.first is not null then
            forall indx in rampRecs.first .. rampRecs.last
                insert into tmp_amd_location_part_override values rampRecs(indx) ;

            tmpInsertCnt := tmpInsertCnt + rampRecs.count ;
        end if ;
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 460,
            pKey1 => 'loadRampData',
            pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
            pKey3 => 'cur_cnt=' || cur_cnt,
            pKey4 => 'req_cnt=' || req_cnt) ;
            commit ;
    exception when others then
        ErrorMsg(pSqlfunction => 'loadRampData',
            pTableName => 'tmp_amd_location_part_override',
            pError_location => 470,
            pKey1 => 'cur_cnt=' || to_char(cur_cnt),
            pKey2 => 'req_cnt=' || to_char(req_cnt)) ;
         raise ;
    end loadRampData ;


    procedure loadWhse(startStep in number := 1, endStep in number := 4) is

            type whseTab is table of tmp_amd_location_part_override%rowtype ;
            whseRecs whseTab ;

        cursor cursor_warehouse_parts is
            select parts.spo_prime_part_no part_no,
                loc_sid,
                0 tsl_override_qty,
                null tsl_override_user,
                amd_defaults.INSERT_ACTION action_code,
                sysdate last_update_dt
            from amd_spare_parts parts, amd_spare_networks asn
            where parts.spo_prime_part_no = parts.part_no
            and parts.is_spo_part = 'Y'
            and parts.is_repairable = 'Y'
            and asn.loc_id = amd_defaults.amd_warehouse_locid
            and asn.action_code != Amd_Defaults.DELETE_ACTION
            and asn.spo_location is not null
            and spo_prime_part_no is not null ;

             -- get all those whse where the rbl run had 0 value for and
             --    1) sum all the tsls where FSL, MOB, UAB
             --    2) from Total Spo Inventory, subtract out those from 1)


            -- tmp_amd_location_part_override is already by spo prime, no need to determine
        cursor cursor_peacetimeBasesSum IS
              select part_no, sum(nvl(tsl_override_qty,0)) qty
                     from tmp_amd_location_part_override t, amd_spare_networks asn
                   where t.loc_sid = asn.loc_sid
                   and t.action_code != Amd_Defaults.DELETE_ACTION
                   and asn.action_code != Amd_Defaults.DELETE_ACTION
                   and ( loc_type in ('MOB', 'FSL', 'UAB', 'COD')
                            or
                         loc_id in (Amd_Defaults.AMD_BASC_LOC_ID, Amd_Defaults.AMD_UK_LOC_ID,
                                    amd_defaults.AMD_AUS_LOC_ID )
                       )
                   and asn.spo_location is not null
                   and part_no is not null
                   group by part_no ;

        cursor cursor_wartimeRspSum is
               select part_no, sum(nvl(rsp_level,0)) qty
               from amd_rsp_sum
               where part_no is not null
               group by part_no ;

        cursor cursor_peacetimeBO_Spo_Sum is
               select spo_prime_part_no,  qty
               from amd_backorder_spo_sum
               where spo_prime_part_no is not null
               order by spo_prime_part_no ;

                  -- get the whole list and the sum to spo prime
        cursor cursor_peacetimeSpoInv IS
            select spo_prime_part_no part_no,
            sum(nvl(spo_total_inventory,0)) qty
            from amd_spare_parts parts, amd_national_stock_items items
            where parts.part_no = parts.spo_prime_part_no
            and parts.is_spo_part = 'Y'
            and parts.is_repairable = 'Y'
            and parts.nsn = items.nsn
            and items.action_code <> 'D'
            and parts.spo_prime_part_no is not null
            group by spo_prime_part_no ;

        type partno_sum is table of number index by amd_spare_parts.part_no%type  ;
        -- arrays where index is nsi_sid, and the values are the sums
        partNoCandidates_sum partNo_sum ;
        partNoBases_sum partNo_sum ;
        partNoSpoInv_sum partNo_sum ;
        wareHouseLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE ;
        basesTsl_Rsp_Backorder_sum number ;
        sumOfSpoTotalInv number ;
        AtlantaWarehouseQty number ;
        returnCode NUMBER ;
        cur_cnt NUMBER := 0 ;
        baseSum_cnt NUMBER := 0 ;
        spoInv_cnt NUMBER := 0 ;
        rsp_cnt number := 0 ;
        spoSum_cnt number := 0 ;
        curStep number := 0 ;
            -- Calculation WareHouse TSLs

            procedure loadPeaceTimeBasesSum is
            begin
                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 480,
                        pKey1 => 'loadPeaceTimeBasesSum',
                        pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

                -- load partNoBases_sum array where each partNo index has the sum for the bases
                open cursor_peacetimeBasesSum ;
                fetch cursor_peacetimeBasesSum bulk collect into partSumRecs ;
                close cursor_peacetimeBasesSum ;

                if partSumRecs.first is not null then
                    for indx in partSumRecs.first .. partSumRecs.last LOOP
                        partNoBases_sum(partSumRecs(indx).part_no) := partSumRecs(indx).qty ;
                        baseSum_cnt := baseSum_cnt + 1 ;
                    end loop ;
                end if ;

                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 490,
                        pKey1 => 'loadPeaceTimeBasesSum',
                        pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
            exception when others then
                errorMsg(pSqlfunction => 'loadPeaceTimeBasesSum',pTableName => 'tmp_amd_location_part_override',
                   pError_location => 500) ;
                   raise ;
            end loadPeaceTimeBasesSum ;

            procedure loadWarTimeRspSum is
            begin
                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 510,
                        pKey1 => 'loadWarTimeRspSum',
                        pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

                open cursor_wartimeRspSum ;
                fetch cursor_wartimeRspSum bulk collect into partSumRecs ;
                close cursor_wartimeRspSum ;

                if partSumRecs.first is not null then
                    for indx in partSumRecs.first .. partSumRecs.last loop
                        begin
                             partNoBases_sum(partSumRecs(indx).part_no) := partNoBases_sum(partSumRecs(indx).part_no) + partSumRecs(indx).qty ;
                        exception when standard.no_data_found then
                             partNoBases_sum(partSumRecs(indx).part_no) := partSumRecs(indx).qty ;
                        end ;
                        rsp_cnt := rsp_cnt + 1 ;
                    end loop ;
                end if ;

                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 520,
                        pKey1 => 'loadWarTimeRspSum',
                        pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
            EXCEPTION WHEN OTHERS THEN
                ErrorMsg(pSqlfunction => 'loadWarTimeRspSum', pTableName => 'tmp_amd_location_part_override',
                   pError_location => 530) ;
                   raise ;
            end loadWarTimeRspSum ;

            procedure loadPeaceTimeBO_Spo_Sum is
            begin
                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 540,
                    pKey1 => 'loadPeaceTimeBO_Spo_Sum',
                    pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

                open cursor_peacetimeBO_Spo_Sum ;
                fetch cursor_peacetimeBO_Spo_Sum bulk collect into partSumRecs ;
                close cursor_peacetimeBO_Spo_Sum ;

                if partSumRecs.first is not null then
                    for indx in partSumRecs.first .. partSumRecs.last loop
                        begin
                             partNoBases_sum(partSumRecs(indx).part_no) := partNoBases_sum(partSumRecs(indx).part_no) + partSumRecs(indx).qty ;
                        exception when standard.no_data_found then
                             partNoBases_sum(partSumRecs(indx).part_no) := partSumRecs(indx).qty ;
                        end ;
                        spoSum_cnt := spoSum_cnt + 1 ;
                    end loop ;
                end if ;

                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 550,
                        pKey1 => 'loadPeaceTimeBO_Spo_Sum',
                        pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
            exception when others then
                errorMsg(pSqlfunction => 'loadPeaceTimeBO_Spo_Sum',pTableName => 'tmp_amd_location_part_override',
                   pError_location => 560) ;
                   raise ;
            end loadPeaceTimeBO_Spo_Sum ;

            procedure loadPeaceTimeSpoInv is
                lineNo number := 0 ;
                part_no amd_spare_parts.part_no%type ;
            begin
                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 570,
                        pKey1 => 'loadPeaceTimeSpoInv',
                        pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
                 -- load partNoSpoInv_sum array where each partNo index has the total_spo_inventory

                open cursor_peacetimeSpoInv ;
                fetch cursor_peacetimeSpoInv bulk collect into partSumRecs ;
                close cursor_peacetimeSpoInv ;

                if partSumRecs.first is not null then
                    for indx in partSumRecs.first .. partSumRecs.last loop
                        part_no := partSumRecs(indx).part_no ;
                        if amd_utils.ISNUMBER(partSumRecs(indx).qty) then
                            lineNo := 1; partNoSpoInv_sum(partSumRecs(indx).part_no) := partSumRecs(indx).qty ;
                            lineNo := 2 ;spoInv_cnt := spoInv_cnt + 1 ;
                        else
                            lineNo := 3;
                            writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 580,
                                    pKey1 => 'loadPeaceTimeSpoInv',
                                    pKey2 => 'partSumRecs(indx).part_no=' || partSumRecs(indx).part_no,
                                    pKey3 => 'qty not numeric') ;
                        end if ;
                    end loop ;
                end if ;

                lineNo := 4 ;
                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 590,
                        pKey1 => 'loadPeaceTimeSpoInv',
                        pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
            exception when others then
                errorMsg(pSqlfunction => 'loadPeaceTimeSpoInv', pTableName => 'tmp_amd_location_part_override',
                   pError_location => 600,pKey1 => to_char(lineNo),pKey2 => part_no) ;
                   raise ;
            end loadPeaceTimeSpoInv ;

            procedure loadWareHouseParts is
                insert_cnt number := 0 ;
            begin
                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 610,
                        pKey1 => 'loadWareHouseParts',
                        pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
        --        wareHouseLocSid := amd_utils.GetLocSid(amd_defaults.AMD_WAREHOUSE_LOCID) ;

                -- cycle thru each of the zero candidates
                -- line up the partNo and do the necessary calculation.
                -- per each partNo
                --        total_spo_inventory minus bases sum
                --        if result negative, make result zero

                open cursor_warehouse_parts ;
                fetch cursor_warehouse_parts bulk collect into whseRecs ;
                close cursor_warehouse_parts ;

                if whseRecs.first is not null then
                    for indx in whseRecs.first .. whseRecs.last loop
                        begin
                            begin
                                 basesTsl_Rsp_Backorder_sum := partNoBases_sum(whseRecs(indx).part_no) ;
                            exception when no_data_found then
                                 basesTsl_Rsp_Backorder_sum := 0 ;
                            end ;

                            begin
                                 sumOfSpoTotalInv := partNoSpoInv_sum(whseRecs(indx).part_no) ;
                            exception when no_data_found then
                                 sumOfSpoTotalInv := 0 ;
                            end ;

                            AtlantaWarehouseQty := sumOfSpoTotalInv - basesTsl_Rsp_Backorder_sum ;
                            if (AtlantaWarehouseQty < 0) then
                               AtlantaWarehouseQty := 0 ;
                            END IF ;
                            if AtlantaWarehouseQty > 0 then
                                insert into tmp_amd_location_part_override
                                    (
                                      part_no,
                                      loc_sid,
                                      tsl_override_qty,
                                      tsl_override_user,
                                      action_code,
                                      last_update_dt
                                    )
                                    values
                                    (
                                      whseRecs(indx).part_no,
                                      whseRecs(indx).loc_sid,
                                      AtlantaWarehouseQty,
                                      null,
                                      Amd_Defaults.INSERT_ACTION,
                                      sysdate
                                    ) ;
                                insert_cnt := insert_cnt + 1 ;
                                tmpInsertCnt := tmpInsertCnt + 1 ;
                            end if ;
                               /*
                                UPDATE tmp_amd_location_part_override
                                    SET tsl_override_AtlantaWarehouseQty = AtlantaWarehouseQty
                                    WHERE part_no = rec.part_no
                                    AND loc_sid = wareHouseLocSid ;
                                */
                        exception when others then
                            errorMsg(pSqlfunction => 'LoadWhse',pTableName => 'tmp_amd_location_part_override',
                           pError_location => 620, pKey1 => 'partNo: ' || whseRecs(indx).part_no) ;
                           raise ;
                        end ;
                        cur_cnt := cur_cnt + 1 ;
                    end loop ;
                end if ;
                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 630,
                        pKey1 => 'loadWareHouseParts',
                        pKey2 => 'insert_cnt=' || insert_cnt,
                        pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
                commit ;
            exception when others then
                errorMsg(pSqlfunction => 'loadWareHouseParts',pTableName => 'tmp_amd_location_part_override',
                   pError_location => 640) ;
                   raise ;
            end loadWareHouseParts ;


    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 650,
            pKey1 => 'LoadWhse',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;


        begin

            for i in startStep..endStep loop
                curStep := i ;
                case i
                    when 1 then loadPeaceTimeBasesSum ;
                    when 2 then loadWarTimeRspSum;
                    when 3 then loadPeaceTimeBO_Spo_Sum ;
                    when 4 then loadPeaceTimeSpoInv ;
                    -- don't need this to load zero tsl's when 5 then loadWareHouseParts ;
                end case ;
            end loop ;

        exception when others then
            errorMsg(pSqlfunction => 'LoadWhse',pTableName => 'tmp_amd_location_part_override',
                pError_location => 660) ;
            raise ;
        end ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 670,
                pKey1 => 'LoadWhse',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'cur_cnt=' || to_char(cur_cnt),
                pKey4 => 'baseSum_cnt=' || to_char(baseSum_cnt),
                pData => 'spoInv_cnt=' || to_char(spoInv_cnt)
                    || ' rsp_cnt=' || to_char(rsp_cnt)
                    || ' spoSum_cnt=' || to_char(spoSum_cnt)) ;
        commit ;
    exception when others then
        errorMsg(pSqlfunction => 'LoadWhse',pTableName => 'tmp_amd_location_part_override',
            pError_location => 680,
            pKey1 => 'curStep=' || curStep,
            pkey2 => 'cur_cnt=' || to_char(cur_cnt),
            pKey3 => 'baseSum_cnt=' || to_char(baseSum_cnt),
            pKey4 => 'spoInv_cnt=' || to_char(spoInv_cnt) ) ;
        raise ;
    end loadWhse ;


    function getFirstLogonIdForPart(pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE)
        RETURN AMD_PLANNER_LOGONS.logon_id%TYPE IS

        cursor cur( pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE ) IS
            select apl.*
            from amd_planner_logons apl, amd_planners ap, amd_national_stock_items ansi
            where ansi.nsi_sid = pNsiSid
            and amd_Preferred_Pkg.GetPreferredValue(ansi.planner_code_cleaned, ansi.planner_code)
                    = ap.planner_code
            and ap.planner_code = apl.planner_code
            and ap.action_code != Amd_Defaults.DELETE_ACTION
            and apl.action_code != Amd_Defaults.DELETE_ACTION
            order by apl.planner_code, data_source, logon_id ;
         retLogonId amd_planner_logons%rowtype := null ;

        procedure getLogonIdViaPart is
            part_no amd_spare_parts.part_no%type ;
        begin
            part_no := amd_utils.getPartNo(pNsiSid) ;
            if part_no is not null then
                if amd_utils.isPartConsumable(part_no) then
                    retLogonId.logon_id := amd_defaults.CONSUMABLE_LOGON_ID ;
                elsif amd_utils.isPartRepairable(part_no) then
                    retLogonId.logon_id := amd_defaults.REPAIRABLE_LOGON_ID ;
                end if ;
            end if ;
        exception
            when standard.no_data_found then
                null ; -- do nothing it cannot be found
            when others then
                errorMsg(pSqlfunction => 'getLogonIdViaPart',pTableName => 'amd_spare_parts',
                    pError_location => 685) ;
            raise ;
        end getLogonIdViaPart ;


    begin
        if not cur%isopen then
            open cur(pNsiSid) ;
        end if ;
        fetch cur into retLogonId ;
        if cur%notfound then
            getLogonIdViaPart ;
        end if ;
        close cur ;
        return retLogonId.logon_id ;
    exception
        when standard.no_data_found then
            getLogonIdViaPart ;
            return retLogonId.logon_id ;
        when others then
            errorMsg(pSqlfunction => 'GetFirstLogonIdForPart',pTableName => 'amd_planner_logons',
                pError_location => 690) ;
            raise ;
    end getFirstLogonIdForPart ;

    procedure loadOverrideUsers IS
        type overrideUserRec is record (
            part_no tmp_amd_location_part_override.part_no%type,
            loc_sid tmp_amd_location_part_override.LOC_SID%type
        ) ;

        type overrideUserTab is table of overrideUserRec ;
        overrideUserRecs overrideUserTab  ;

        cursor overrideUserscur is
             select part_no, loc_sid
             from tmp_amd_location_part_override 
             where tsl_override_user is null ; 

        tslOverrideUser AMD_LOCATION_PART_OVERRIDE.tsl_override_user%TYPE ;
        cur_cnt NUMBER := 0 ;
        update_cnt number := 0 ;

    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 700,
            pKey1 => 'LoadOverrideUsers',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

        open overrideUserscur ;
        fetch overrideUserscur bulk collect into overrideUserRecs ;
        close overrideUserscur ;

         if overrideUserRecs.first is not null then
             for indx in overrideUserRecs.first .. overrideUserRecs.last loop
                begin
                     -- if (lastNsiSid != overrideUserRecs(indx).nsi_sid) then
                        -- partNo_logonId(rec.part_no) := nvl(GetFirstLogonIdForPart(rec.nsi_sid), amd_defaults.GetLogonId(rec.nsn) ) ;
                        tslOverrideUser := getfirstlogonidforpart
                                            (amd_utils.getnsisidfrompartno (overrideUserRecs(indx).part_no)) ;
                        if tslOverrideUser is null then
                            dbms_output.put_line(overrideUserRecs(indx).part_no) ;
                            tslOverrideUser := 'SPO' ;
                        end if ;                            
                        update tmp_amd_location_part_override
                           set     tsl_override_user = tslOverrideUser
                           where    part_no = overrideUserRecs(indx).part_no
                           and loc_sid = overrideUserRecs(indx).loc_sid ;
                        update_cnt := update_cnt + 1 ;                           
                exception when others then
                        errorMsg(pSqlfunction => 'LoadOverrideUsers',pTableName => 'tmp_amd_location_part_override',
                            pError_location => 710,
                            pKey1    =>  'loc_sid=' || overrideUserRecs(indx).loc_sid,
                            pKey2 => 'partNo=' || overrideUserRecs(indx).part_no) ;
                       raise ;
                end ;
                cur_cnt := cur_cnt + 1 ;
             end loop ;
        end if ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 720,
                pKey1 => 'LoadOverrideUsers',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'cur_cnt=' || to_char(cur_cnt),
                pKey4 => 'update_cnt=' || to_char(update_cnt)) ;
        commit ;
    exception when others then
        errorMsg(pSqlfunction => 'LoadOverrideUsers',pTableName => 'tmp_amd_location_part_override',
            pError_location => 730, pKey1 => 'cur_cnt=' || to_char(cur_cnt) ) ;
        raise ;
    end loadOverrideUsers ;



    PROCEDURE LoadTmpAmdLocPartOverride( startStep in number := 1, endStep in number := 7) is
        curStep number := 0 ;
    BEGIN
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 880,
                pKey1 => 'LoadTmpAmdLocPartOverride',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

         Mta_Truncate_Table('tmp_amd_location_part_override','reuse storage');
         COMMIT ;
         for i in startStep..endStep loop
            curStep := i ;
             case i
                when 1 then loadRampData ;
                when 2 then 
                    if loadFMSdata = 'Y' then 
                        LoadUk ; 
                    end if ;
                when 3 then 
                    if loadFMSdata = 'Y' then 
                        LoadAUS ; 
                    end if ;
                when 4 then LoadBasc ;
                when 5 then 
                    if loadFMSdata = 'Y' then
                        LoadCAN ;
                    end if ;                        
                when 6 then LoadWhse ;
                when 7 then LoadOverrideUsers ;
             end case ;
        end loop ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 890,
                pKey1 => 'LoadTmpAmdLocPartOverride',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
        commit ;
    exception when others then
        ErrorMsg(
           pSqlfunction            => 'LoadTmpAmdLocPartOverride',
           pTableName              => 'tmp_amd_location_part_override',
           pError_location => 900,
           pKey1 => curStep) ;
        RAISE ;

    END LoadTmpAmdLocPartOverride;




    PROCEDURE LoadInitial IS
         returnCode NUMBER ;
    BEGIN
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 1060,
                 pKey1 => 'LoadInitial',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

         LoadTmpAmdLocPartOverride ;
          Mta_Truncate_Table('amd_location_part_override','reuse storage');
         COMMIT ;
         INSERT INTO AMD_LOCATION_PART_OVERRIDE
             SELECT * FROM TMP_AMD_LOCATION_PART_OVERRIDE where tsl_override_qty <> 0 ; -- Xzero
         COMMIT ;
         dbms_output.put_line('LoadInitial ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

    EXCEPTION WHEN OTHERS THEN
        ErrorMsg(pSqlfunction => 'LoadInitial', pTableName => 'tmp_amd_location_part_override',
                   pError_location => 1070 ) ;
        RAISE ;
    END LoadInitial ;

    -- added 02/13/09 dse
    function getGtZeroCnt return number is
    begin
    return gtZeroCnt ;
    end getGtZeroCnt ;
    procedure setGtZeroCnt(value in number) is
    begin
    gtZeroCnt := value ;
    end setGtZeroCnt ;

    function getTmpInsertCnt return number is
    begin
    return tmpInsertCnt ;
    end getTmpInsertCnt ;
    procedure setTmpInsertCnt(value in number) is
    begin
    tmpInsertCnt := value ;
    end setTmpInsertCnt ;

    function getTmpUpdateCnt return number is
    begin
    return tmpUpdateCnt ;
    end getTmpUpdateCnt ;
    procedure setTmpUpdateCnt(value in number) is
    begin
    tmpUpdateCnt := 0 ;
    end setTmpUpdateCnt ;

    -- added 11/7/05 dse
    FUNCTION getInsertCnt RETURN NUMBER IS
    BEGIN
         RETURN insertCnt ;
    END getInsertCnt ;
    procedure setInsertCnt(value in number) is
    begin
    insertCnt := value ;
    end setInsertCnt ;

    FUNCTION getUpdateCnt RETURN NUMBER IS
    BEGIN
         RETURN updateCnt ;
    END getUpdateCnt ;
    procedure setUpdateCnt(value in number) is
    begin
    updateCnt := value ;
    end setUpdateCnt ;

    FUNCTION getDeleteCnt RETURN NUMBER IS
    BEGIN
         RETURN deleteCnt ;
    END getDeleteCnt ;
    procedure setDeleteCnt(value in number) is
    begin
    deleteCnt := value ;
    end setDeleteCnt ;
/*
    FUNCTION getTSL_OVERRIDE_TYPE RETURN VARCHAR2 IS
    BEGIN
         RETURN TSL_OVERRIDE_TYPE ;
    END getTSL_OVERRIDE_TYPE ;

    FUNCTION getOVERRIDE_REASON RETURN VARCHAR2 IS
    BEGIN
         RETURN OVERRIDE_REASON ;
    END getOVERRIDE_REASON ;
*/
    FUNCTION getBULKLIMIT RETURN NUMBER IS
    BEGIN
         RETURN BULKLIMIT ;
    END getBULKLIMIT ;

    FUNCTION getCOMMITAFTER RETURN NUMBER IS
    BEGIN
         RETURN COMMITAFTER ;
    END getCOMMITAFTER ;

    FUNCTION getSUCCESS RETURN NUMBER IS
    BEGIN
         RETURN SUCCESS ;
    END getSUCCESS ;

    FUNCTION getFAILURE RETURN NUMBER IS
    BEGIN
         RETURN FAILURE ;
    END getFAILURE ;

    FUNCTION getTHE_WAREHOUSE RETURN VARCHAR2 IS
    BEGIN
         RETURN THE_WAREHOUSE ;
    END getTHE_WAREHOUSE ;

    procedure version is
    begin
         writeMsg(pTableName => 'amd_location_part_override_pkg',
                 pError_location => 1360, pKey1 => 'amd_location_part_override_pkg', pKey2 => '$Revision:   1.105  $') ;
         dbms_output.put_line('amd_location_part_override_pkg: $Revision:   1.105  $') ;
    end version ;

    function getVersion return varchar2 is
    begin
        return '$Revision:   1.105  $' ;
    end getVersion ;


        function ignoreStLouisYorN return varchar2 is
        begin
            if ignoreStLouis then
                return 'Y' ;
            else
                return 'N' ;
            end if ;
        end ignoreStLouisYorN ;

        procedure setDebug(switch in varchar2) is
        begin
            debug := upper(switch) in ('Y','T','YES','TRUE') ;
            if debug then
                dbms_output.ENABLE(100000) ;
            else
                dbms_output.DISABLE ;
            end if ;
        end setDebug ;

        function getDebugYorN return varchar2 is
        begin
            if debug then
                return 'Y' ;
            else
                return 'N' ;
            end if ;
        end getDebugYorN ;
        
        procedure setLoadFMSdata(value in varchar2) is
        begin
            loadFMSdata := value ;
        end setLoadFMSdata ;
        
        function getLoadFMSdata return varchar2 is
        begin
            return loadFMSdata ;
        end getLoadFMSdata ;                        


BEGIN

      <<getParams>>
      DECLARE
       param AMD_PARAM_CHANGES.PARAM_VALUE%TYPE ;

       function getIgnoreStLouis return boolean is
            ignoreStLouis varchar2(1) ;
        begin
            ignoreStLouis := trim(amd_defaults.getParamValue('ignoreStLouis')) ;
            if ignoreStLouis is null then
                return false ;
            else
                if ignoreStLouis = 'Y' then
                    return true ;
                else
                    return false ;
                end if ;
            end if ;
        end getIgnoreStLouis ;


      begin

          BEGIN
             SELECT param_value INTO param FROM AMD_PARAM_CHANGES WHERE param_key = 'debugLocPartOverride' ;
             debug := (param = '1');
          EXCEPTION WHEN OTHERS THEN
             debug := false ;
          end ;
          
          begin
            loadFMSdata := amd_defaults.getParamValue('loadFMSdata') ;
          exception when others then
            loadFMSdata := 'N' ;
          end ;                                   

          Amd_Location_Part_Override_Pkg.ignoreStLouis := getIgnoreStLouis() ;
      END getParams ;

      <<getTypes>>
      begin
        --select tsl_fixed_override into tsl_override_type from amd_spo_types_v ;
        --select fixed_tsl_load_override_reason into override_reason from amd_spo_types_v ;
        null;
      end getTypes ;


END Amd_Location_Part_Override_Pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_LP_OVERRIDE_CONSUMABL_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_lp_override_consumabl_Pkg AS
 /*
      $Author:   zf297a  $
    $Revision:   1.90
        $Date:   23 Feb 2015
    $Workfile:   AMD_LP_OVERRIDE_CONSUMABL_PKG.pkb  $
         
        Rev 1.90 2/23/15 dse added amd_defaults.getStartLocId
        
        Rev 1.89 removed spo related code and made literals 'Not Used'
/*   
/*      Rev 1.88   4 Feb 2015 added amd_defaults.getSourceCode   zf297a

/*      Rev 1.87   14 Jul 2009 10:53:14   zf297a
/*   Updated spo type literals
/*   
/*      Rev 1.86   10 Jun 2009 13:46:08   zf297a
/*   Initialize rop_type and roq_type variables using data from amd_spo_types_v.
/*   
/*      Rev 1.85   24 Feb 2009 13:20:38   zf297a
/*   Removed a2a code.
/*   
/*      Rev 1.84   14 Feb 2009 16:30:16   zf297a
/*   Removed invocation of any A2A procedure or function for package amd_location_part_override_pkg since all A2A code has been removed from that package.
/*   
/*      Rev 1.83   09 Dec 2008 15:35:02   zf297a
/*   For loadWhseX make sure that FD2090 whose calc = zero is not included.  Also, make sure that FD2090 wiith stock_levels in the whse do not have any detail recs in tmp_locpart_overid_consumables.
/*   
/*      Rev 1.82   08 Dec 2008 22:32:46   zf297a
/*   Fixed exists synntax error.
/*   
/*      Rev 1.81   08 Dec 2008 22:26:44   zf297a
/*   For loadWhseX make sure to include FD2090 when there is stock_level greater than 1 and there are no base rows.
/*   
/*      Rev 1.80   08 Dec 2008 12:38:02   zf297a
/*   For the loadWhseX routine fix the 2 inserts for a whse with a stock level greater than 1 to use only parts whose bases sum to zero
/*   
/*      Rev 1.79   07 Dec 2008 22:12:52   zf297a
/*   Make sure that ROQ's for FD2090's that just have gold whse data and no levels at tthe bases gets created with a value of 1.
/*   
/*      Rev 1.78   07 Dec 2008 21:46:30   zf297a
/*   Fixed duplicate errors for loadWhseX that occured by checking for the max(sc).
/*   
/*      Rev 1.77   07 Dec 2008 18:36:52   zf297a
/*   For all parts that have stock level in GOLD WHSE and  the part does not exist in tmp_locpart_overid_consumables, then create and ROP using the stock_level - 1 and a ROQ of 1.
/*   
/*      Rev 1.76   05 Dec 2008 14:20:48   zf297a
/*   Fixed Override Type for loadWhseX
/*   
/*      Rev 1.75   05 Dec 2008 12:52:20   zf297a
/*   Added boolean variable useLoadWhseX to control whether loadWhseX or loadWhse gets executed for procedure loadLocPartOverrides.
/*   
/*   Implemented setUseLoadWhseX, getUseLoadWhseX, loadWhseX, getTslOverrideUser, getTslOverrideUserByNsn.
/*   
/*   For loadWhseX use the data that has already been loaded into tmp_locpart_overid_consumables to create the FD2090 rows.
/*   
/*      Rev 1.74   04 Dec 2008 12:47:08   zf297a
/*   For the sumTheRecs procedure, use only the records whose rop + roq is not zero in the calc otherwise just use zero when summing.
/*   
/*      Rev 1.73   03 Dec 2008 09:48:04   zf297a
/*   Fixed debug literal in loadWhse - made it CAN instead of AUS
/*   
/*      Rev 1.72   20 Nov 2008 14:18:02   zf297a
/*   For procedure loadWhse removed this filter from the getRoq function: if ROP = 0 then ROQ = 0.  So, now when the ROP is zero the ROQ  value will be summed.  Added more debug code to the sum routine to make it easier to follow the summing process.
/*   
/*      Rev 1.71   20 Oct 2008 12:27:12   zf297a
/*   Fixed the dynamic query for loadWhseBase to use whseX as the alias for whse.
/*   Removed amd_sent_to_a2a from wesmParts cursor and replaced it with amd_spare_parts so that the new flags could be used: is_consumable and is_spo_part
/*   
/*      Rev 1.70   17 Oct 2008 21:12:54   zf297a
/*   For the dynamic cursor in processWhseParts add Max(created_datetime) as part of the where clause.  
/*   
/*   Add dump sql text routine for the same dynamic query.
/*   
/*      Rev 1.69   10 Oct 2008 01:15:48   zf297a
/*   Made the wesm_data cursor comply with the TSLCriteriaConsumable.doc
/*   
/*      Rev 1.68   10 Oct 2008 00:55:10   zf297a
/*   Got rid of all references to amd_sent_to_a2a and used amd_spare_parts with its is_consumable, is_spo_part, and spo_prime_part_no columns.
/*   
/*   Added debug code to all load routines and resequenced the error location numbers.
/*   
/*      Rev 1.67   10 Oct 2008 00:02:40   zf297a
/*   Fixed the lvls cursors: lvls_by_base and consumablesForLvls is use the same criteria for ROP/ROQ selection and switched from amd_sent_to_a2a to amd_spare_parts using its is_consumable, is_spo_part, and spo_prime_part_no columns to help select the data.
/*   
/*   Fixed dynamic cursor for loadWhseBase to use the same criteria as the dynamic cursor for processWhseParts for selecting ROP/ROQ and switched from amd_sent_to_a2a to amd_spare_parts using its is_consumable, is_spo_part, and spo_prime_part_no columns to help select the data.  Added debugMsg statements to display ROP/ROQ info for selected parts.
/*   
/*      Rev 1.66   09 Oct 2008 22:04:50   zf297a
/*   Made errorMsg and writeMsg autonomous transactions.
/*   Updated lvls_by_base to use amd_spare_parts instead of amd_sent_to_a2a and to use the new amd_spare_parts.is_consumable and amd_spare_parts.spo_prime_part_no.
/*   
/*   Modified ROP/ROQ summations for lvls_by_base and the dynamic query of processWhseParts to use the critieria specified in TSLCriteriaConsumable.doc.
/*   
/*      Rev 1.65   07 Oct 2008 15:01:08   zf297a
/*   Fixed cursor lvls_by_base and the dynamic query for processWhseParts to use "< 0" rather than "<= 0" when summing ROQ
/*
/*      Rev 1.64   06 Oct 2008 16:11:36   zf297a
/*   For procedure loadWhse, fixed the summing of ROQ for wesmParts.
/*
/*      Rev 1.63   21 May 2008 11:38:14   zf297a
/*   Use whse.stock_level - whse.reorder_point for the ROQ. Got rid of cursor consumableWhseParts because it was not being used.
/*   Added Canada into the loadWhse calc.
/*
/*      Rev 1.62   18 Apr 2008 09:05:28   zf297a
/*   Simplified the ROP selection and added Austrailia to the loadWhse.
/*
/*      Rev 1.61   09 Apr 2008 13:39:12   zf297a
/*   Eliminate literal test parts from isTestPart - use only parts in amd_test_parts
/*
/*      Rev 1.59   07 Apr 2008 16:41:10   zf297a
/*   Eliminated ROQ check in processRec
/*
/*      Rev 1.58   07 Apr 2008 16:08:30   zf297a
/*   Used wrong constant for ROQ in processRec - changed it to amd_defaults.ROQ
/*
/*      Rev 1.57   07 Apr 2008 16:05:52   zf297a
/*   Fixed the wesmParts query: needed to compare the amd_national_stock_items.action_code to amd_defaults.DELETE.
/*   Fixed the processRec procedure for loadWhse to use a default ROQ and a new equation for the ROP.
/*
/*      Rev 1.56   19 Mar 2008 00:01:44   zf297a
/*   Implemented interfaces isValidTslData and isValidTslDataYorN.  Put these new routines to use so that there is one place to change the criteria.
/*
/*      Rev 1.55   17 Mar 2008 10:45:16   zf297a
/*   Added boolean variable loadZeroTsls.  Implemented getLoadZeroTslsYorN and setLoadZeroTsls.  Resequenced the pError_location values.
/*   Filtered out all rop + roq that = zero.  The loadZeroTsls set to true would still allow zero tsl's - hopefully zero tsl's wil never be used again.
/*
/*      Rev 1.54   13 Mar 2008 11:50:10   zf297a
/*   Changed OVERRIDE_TYPE to TSL_OVERRIDE_TYPE
/*
/*      Rev 1.53   12 Mar 2008 15:28:22   zf297a
/*   Added boolean variables: debug and insertData.  debug defaults to false and insertData defaults to true so that the default behavior is to execute without debugging and to insert data into the Oracle tables.
/*
/*      Rev 1.52   12 Mar 2008 15:23:08   zf297a
/*   Implemented interfaces for getInsertData and setInsertData.  Removed all references to the spo_location suffix _RSP.  All RSP data will be handled by the amd_inventory and a2a_pkg packages.
/*
/*      Rev 1.51   14 Feb 2008 11:39:36   zf297a
/*   Make sure that records with zero quantity are not written to tmp or amd tables.
/*
/*      Rev 1.50   10 Jan 2008 00:54:08   zf297a
/*   Made it comply to spec rev 30
/*
/*      Rev 1.49   07 Jan 2008 12:40:28   zf297a
/*   The calc for ROP is still dependent on the ROQ value:
/*   if rop <= 0 then
/*       if rop = 0 then
/*           if roq < default then
/*               rop = default for ROP
/*           end if
/*       else
/*            rop = default for ROP
/*       end if
/*   end if
/*
/*      Rev 1.48   07 Jan 2008 09:31:36   zf297a
/*   Added enhanced debugging features: isTestPart now uses amd_test_parts as a data source, debug flag gets initialized via amd_param_changes or can be set via setDebug,  all dbms_output converted to use debugMsg which outputs via dbms_output and output to amd_load_details, added functions to return cursor's of the amd_load_details debug data, added procedure to delete all the debug rows, added getVersion function which returns the latest PVCS revision.
/*
/*      Rev 1.47   14 Dec 2007 09:40:46   zf297a
/*   Added parts to the test parts list.
/*
/*   Fixed  the wesmParts and lvls_by_base cursors to make rop and roq  independent.
/*
/*   For the loadWhse, processRec procedure make sure that rop is the default value if it is less than zero.
/*
/*   Fixed the dynamic query in nested procedure processWhseParts to make rop and roq independent.  Also, when adding to the sumRecs array treat the rop and roq independently.
/*
/*      Rev 1.46   07 Dec 2007 13:05:58   zf297a
/*   Fixed FD2090 calc in procedure loadWhse by adjusting BASC's ROQ column to be dynamic for nested procedure processWhseParts.
/*
/*      Rev 1.45   07 Dec 2007 00:27:52   zf297a
/*   For procedure doLPOverrideConsumablesDiff ignore duplicates since the diff's aging buffer may get full with this high value table.
/*
/*      Rev 1.44   05 Dec 2007 13:30:06   zf297a
/*   Removed debug code from doLPOverrideConsumablesDiff.
/*
/*      Rev 1.43   03 Dec 2007 13:17:18   zf297a
/*   implemented isTestPart to determine if a part belongs to the set of test parts.
/*   For loadWhse's FD2090 calc make sure ROP is greater than zero, otherwise use zero for both ROP and ROQ.
/*
/*      Rev 1.42   30 Nov 2007 12:00:44   zf297a
/*   Fixed the lvls_by_base cursor to use only records with a reorder_point > 0 per spec rev #28
/*
/*      Rev 1.41   29 Nov 2007 21:16:14   zf297a
/*   Fixed the roq column for the lvls_by_base cursor of the loadWhse routine - made sure that default roq was not returned.  (fixed bug 6-31B for ROQ calc)
/*
/*      Rev 1.40   28 Nov 2007 10:22:48   zf297a
/*   Round the tsl quantity when inserting into tmp_locpart_overid_consumables (bug # 6-29).
/*   Made sure the rop and roq from the whseData cursor are zero when the columns are null. (fixes bug 6-31 and 6-31B)
/*   Assign the values to the nonwesmSumRecs array for the levels by base, since this is the first time the array is used - therefore it needs initialized. (fixes bug 6-31 and 6-31B).
/*
/*      Rev 1.39   27 Nov 2007 18:12:42   zf297a
/*   Fixed calculation of FD2090 quantities by checking rop and roq for null values before trying to subtract them from the whse value.
/*
/*      Rev 1.38   19 Nov 2007 18:46:28   zf297a
/*   Fixed defaultTsls cursor by adding tsl_override_type to it.
/*
/*      Rev 1.37   15 Nov 2007 21:22:14   zf297a
/*   Add a part for debugging purposes.  Fix processRec of loadWhse to exclude records with BOTH ROP = the default ROP and ROQ = the default ROQ.
/*
/*      Rev 1.36   15 Nov 2007 00:10:42   zf297a
/*   Removed check for ROP/ROQ defaults for cursor wesmParts of procedure loadWhse and dynamic cursor in processWhseParts.
/*   Added tracing of an additional part + output the part no for each display using dbms_output.
/*
/*      Rev 1.35   09 Nov 2007 13:13:16   zf297a
/*   Removed trying to create recs for bulk insert - this method was too slow.
/*
/*      Rev 1.34   08 Nov 2007 22:51:40   zf297a
/*   Fixed summing of wesm and nonwesm parts for the loadWhse procedure.  Use bulk insert to load tmp_locpart_overid_consumables.
/*
/*      Rev 1.33   01 Nov 2007 22:24:30   zf297a
/*   For the loadDefaultTsls make sure that any part/location that is already in tmp_a2a_loc_part_override does not get created.
/*
/*      Rev 1.32   01 Nov 2007 18:23:02   zf297a
/*   Implemented the code to handle an action_code argument for the initialize procedure so that it can decide whether to delete data in tmp_a2a_loc_part_override, truncate all data from tmp_a2a_loc_part_override or to do nothing, which would imply that the table has already been prepared for initialization
/*
/*      Rev 1.31   01 Nov 2007 17:54:04   zf297a
/*   Don't delete RSP data that has been already loaded
/*
/*      Rev 1.30   01 Nov 2007 11:08:48   zf297a
/*   Make sure zero tsl's are consumables.
/*
/*      Rev 1.29   28 Oct 2007 16:40:06   zf297a
/*   User whse.user_ref3 for ROQ quantities.  Do include any default ROP or ROQ in the warehouse (FD2090) calculation.
/*
/*      Rev 1.28   26 Oct 2007 12:07:46   zf297a
/*   Converted dynamic sql to use bind variables.  Fixed whse retrievals to use whse.part instead of whse.prime.
/*
/*      Rev 1.27   24 Oct 2007 17:32:36   zf297a
/*   Implemented interfaces for the following constants:
/*   ROQ_TYPE
/*   ROP_TYPE
/*   GOLD_SOURCE
/*   WESM_SOURCE
/*   WHSE_LOCSID
/*   WHSE_LOCID
/*
/*   Implemented using amd_defaults to get ROP and ROQ default values.  Corrected cursors to use the correct ROP/ROQ default values.
/*
/*      Rev 1.26   18 Oct 2007 09:59:50   zf297a
/*   Fixed cursor lvls_by_base by using amd_defaults.getTSL_CONSUMABL_CALENDAR_DAYS instead of the 210 literal and removed a redundant check for a non-wesm part.
/*
/*      Rev 1.25   18 Oct 2007 09:55:46   zf297a
/*   Update cursor lvls_by_base to use the compatability_code when retriving the max(date_lvl_loaded)
/*
/*      Rev 1.24   16 Oct 2007 22:24:02   zf297a
/*   Fixed loadLvls by adding the compatability_code check for the max_dates.  This fixes bug 6-17C
/*
/*      Rev 1.23   16 Oct 2007 17:42:58   zf297a
/*   Fixed ROP for loadWesm - when it is null return -1.  Fixed Bug 6-7
/*
/*      Rev 1.22   12 Oct 2007 17:03:50   zf297a
/*   Implemented interfaces loadDefaultTsls, loadBasc, loadUK, loadAustrailia, and loadCanada.
/*   Update procedure loadWhse per spec rev 26.
/*
/*      Rev 1.21   11 Oct 2007 22:40:44   zf297a
/*   Added Canada (EY1414) and Warner Robins (FB2065) to lists of explicit loc_id's implemented proced loadZeroTsls
/*
/*      Rev 1.20   01 Oct 2007 09:20:38   zf297a
/*   Have the initialize procedure load amd_locpart_overid_consumables from tmp_locpart_overid_consumables ;;
/*
/*      Rev 1.19   28 Sep 2007 08:45:48   zf297a
/*   Fixed Bug#6-22: TSLs ROP Qty is 1 for non-WESM Parts when qualifying LVLS records have null or zero quantities.  TSLs: GOLD parts (i.e. non-WESM parts) that have qualifying GOLD.LVLS records where all 3 of the quantity fields are null or zero (i.e. Economic_Order_Qty, Approved_Lvl_Qty, and Reorder_Point) are sending an ROP qty of positive '1'.   This condition should send an ROP qty of negative '1'.
/*
/*      Rev 1.18   26 Sep 2007 16:57:38   zf297a
/*   Fixed cursor for loadWesm to make sure the roq is not zero
/*
/*      Rev 1.17   26 Sep 2007 11:50:36   zf297a
/*   Fixed the whse query for lvls to use the whseData cursor to get the values used in computing ROP and ROQ.  Also when no data is returned ROP = -1 and ROQ = 1.
/*
/*      Rev 1.16   25 Sep 2007 22:10:20   zf297a
/*   Fixed procedure loadWhse for Bug #6-10B where the ROP was being assigned a zero when it should not have been.  Also, change the whse query to a cursor sorted by the created_datetime in descending order so the most recent one is first.  When processing the cursor, only the first one is retrieved per each spo_prime_part_no.
/*
/*      Rev 1.15   19 Sep 2007 17:34:38   zf297a
/*   Moved procedure doUpdate to change its scope.  Added a boolean flag, canUpdate, to doInsert so that the invoking routine can determine if the tmp_locpart_overid_consumables table can be overlaid with the current passed parameters: currently the only invoking procedure to have it true is the loadWesm procedure since its data takes precedence over the loadLvlvs data.  Used procedure doInsert for loadLvls.  Added some code to laodRamp, but determined that it is only needed for repairables.
/*
/*      Rev 1.14   17 Sep 2007 10:06:54   zf297a
/*   When loading data from the ware house, make the rop and roq zero when the part cannot be found on the whse table.
/*
/*      Rev 1.13   14 Sep 2007 10:16:44   zf297a
/*   For procedure loadLvls changed cursor consumablesForLvls 's selection criteria to select wesm or non-wesm parts located at FSL's or select only wesm parts located at MOB's or always select parts located at bases EY1258','EY1746', or 'EY8780' .,
/*
/*      Rev 1.12   12 Sep 2007 13:50:56   zf297a
/*   Removed commits from for loops.
/*
/*      Rev 1.11   11 Sep 2007 16:01:50   zf297a
/*   Make sure the tsl_override_qty is not null before inserting or updating TMP_LOCPART_OVERID_CONSUMABLES.
/*
/*      Rev 1.10   10 Sep 2007 12:17:56   zf297a
/*   Added procedures doInsert and doUpdate to insert/update tmp_locpart_overid_consumables.  Streamlined loadWhse and loadWesm to use doInsert.  Changed queries for whse to sum data for each prime part retrieved.
/*
/*      Rev 1.9   20 Aug 2007 11:05:08   zf297a
/*   Fixed updateRow to use the action_code of  procedure doLPOverrideConsumab lesDiff  and fixed the insertRow to use the action_code of doLPOverrideConsumab lesDiff and to use sysdate for the last_update_dt.
/*
/*      Rev 1.8   17 Aug 2007 13:26:06   zf297a
/*   Make sure the diff function can handle inserting row's that have been logically deleted.
/*
/*      Rev 1.7   16 Aug 2007 23:35:54   zf297a
/*   Added errorMsg's to doLpOverrideConsumablesDiff.  Resequenced all pError_location numbers.
/*
/*      Rev 1.6   16 Aug 2007 14:16:44   zf297a
/*   Implemented interface for procedure version
/*
/*      Rev 1.5   16 Aug 2007 12:32:14   zf297a
/*   Added implementation of procedure loadAllA2A.
/*
/*      Rev 1.4   07 Aug 2007 10:08:26   zf297a
/*   Added check for loc_id's of EY1258, EY1746, EY8780
/*
/*      Rev 1.3   03 Aug 2007 13:54:00   zf297a
/*   Fixed the calc of whse_rop and whse_roq to be 1 if <= 0 or if no data is found for the given prime part.
/*
/*      Rev 1.2   03 Aug 2007 13:29:44   zf297a
/*   Fixed rop/roq calc for whse.  Used the isWesmPart function.
/*
/*      Rev 1.1   19 Jul 2007 14:37:10   zf297a
/*   implemented inerfaces for loadVirtualLocations and loadLocPartOverrides.
/*
/*      Rev 1.0   06 Jul 2007 17:27:10   zf297a
/*   Initial revision.
*/

    loggedDup boolean := false ;
    insertData boolean := true ;
    useLoadWhseX boolean := true ;
    debug boolean := false ;
    loadZeroTsls boolean := false ;

    DEBUG_KEY constant amd_load_details.key_3%type := 'amd_lp_override_consumabl_pkg.debugMsg' ;

    type ropRoqRec is record (
        spo_prime_part_no amd_spare_parts.spo_prime_part_no%type,
        spo_location amd_spare_networks.spo_location%type,
        rop number,
        roq number
    ) ;

    type whseRec is record (
        spo_prime_part_no amd_spare_parts.spo_prime_part_no%type,
        rop number,
        roq number
    ) ;
    type whseTab is table of whseRec ;

    type locPartOveridConsumablesTab is table of TMP_LOCPART_OVERID_CONSUMABLES%rowtype ;
    locPartOveridConsumablesRecs locPartOveridConsumablesTab := locPartOveridConsumablesTab() ;

    type consumablesWhsePartsCur is ref cursor return whseRec ;

    type partTab is table of amd_spare_parts.PART_NO%type ;
    testParts partTab ;



    procedure writeMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 in varchar2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
                
         pragma autonomous_transaction ;

    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'amd_lp_override_consumabl_pkg',
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
        commit ;                
    exception when others then
        -- trying to rollback or commit from trigger
        if sqlcode = 4092 then
            raise_application_error(-20010,
                substr('amd_lp_override_consumabl_pkg '
                    || sqlcode || ' '
                    || pError_Location || ' '
                    || pTableName || ' '
                    || pKey1 || ' '
                    || pKey2 || ' '
                    || pKey3 || ' '
                    || pKey4 || ' '
                    || pData, 1,2000)) ;
        else
            raise ;
        end if ;
    end writeMsg ;

    procedure debugMsg(msg in varchar2, pError_location in number) is
    begin
        if debug then
            writeMsg(pTableName => 'debugMsg', pError_location => pError_location,
               pKey1 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
               pKey2 => msg,
               pKey3 => DEBUG_KEY) ;
            dbms_output.put_line(msg) ;
        end if ;
    exception when others then
        null ; -- a debug error should not stop the application
    end debugMsg ;

    procedure deleteDebugMsgs is
    begin
        delete from amd_load_details where key_3 = DEBUG_KEY ;
        commit ;
    end deleteDebugMsgs ;

    function listDebugMsgs return msgCur is
        cur msgCur ;
    begin
        open cur for select amd_load_details.key_2 msg from amd_load_details
                                 where key_3 = DEBUG_KEY
                                 order by AMD_LOAD_DETAILS.LOAD_NO ;
        return cur ;
    end listDebugMsgs ;

    function listDebugMsgs(fromDate in date, toDate in date := sysdate) return msgCur is
        cur msgCur ;
    begin
        open cur for select amd_load_details.key_2 msg from amd_load_details
                                 where key_3 = DEBUG_KEY
                                 and to_date(AMD_LOAD_DETAILS.KEY_1,'MM/DD/YYYY HH:MI:SS AM')
                                 between fromDate and toDate
                                 order by AMD_LOAD_DETAILS.LOAD_NO ;
        return cur ;
    end listDebugMsgs ;

    function listDebugMsgs(textFilter in varchar2) return msgCur is
        cur msgCur ;
    begin
        if textFilter is null then
            open cur for select amd_load_details.key_2 msg from amd_load_details
                                     where key_3 = DEBUG_KEY
                                     order by AMD_LOAD_DETAILS.LOAD_NO ;
        else
            open cur for select amd_load_details.key_2 msg from amd_load_details
                                     where key_3 = DEBUG_KEY
                                     and key_2 like '%' || textFilter || '%'
                                     order by AMD_LOAD_DETAILS.LOAD_NO ;
        end if ;
        return cur ;
    end listDebugMsgs ;

    function getDebugCur return debugCur is
        cur debugCur ;
    begin
        open cur for select to_date(AMD_LOAD_DETAILS.KEY_1,'MM/DD/YYYY HH:MI:SS AM') timestamp,
                                 amd_load_details.key_2 msg from amd_load_details
                                 where key_3 = DEBUG_KEY
                                 order by amd_load_details.load_no ;
        return cur ;
    end getDebugCur ;

    function getDebugCur(fromDate in date, toDate in date := sysdate) return debugCur is
        cur debugCur ;
    begin
        open cur for select to_date(AMD_LOAD_DETAILS.KEY_1,'MM/DD/YYYY HH:MI:SS AM') timestamp,
                                 amd_load_details.key_2 msg from amd_load_details
                                 where key_3 = DEBUG_KEY
                                 and to_date(AMD_LOAD_DETAILS.KEY_1,'MM/DD/YYYY HH:MI:SS AM')
                                    between fromDate and toDate
                                 order by amd_load_details.load_no ;
        return cur ;
    end getDebugCur ;

    function getDebugCur(textFilter in varchar2) return debugCur is
        cur debugCur ;
    begin
        if textFilter is null then
            open cur for select to_date(AMD_LOAD_DETAILS.KEY_1,'MM/DD/YYYY HH:MI:SS AM') timestamp,
                                     amd_load_details.key_2 msg from amd_load_details
                                     where key_3 = DEBUG_KEY
                                     order by amd_load_details.load_no ;
        else
            open cur for select to_date(AMD_LOAD_DETAILS.KEY_1,'MM/DD/YYYY HH:MI:SS AM') timestamp,
                                     amd_load_details.key_2 msg from amd_load_details
                                     where key_3 = DEBUG_KEY
                                     and key_2 like '%' || textFilter || '%'
                                     order by amd_load_details.load_no ;
        end if ;

        return cur ;
    end getDebugCur ;

    PROCEDURE ErrorMsg(
        pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
        pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
        pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
        pKey1 IN AMD_LOAD_DETAILS.KEY_1%TYPE := '',
        pKey2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
        pKey3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
        pKey4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
        pComments IN VARCHAR2 := '') IS

        pragma autonomous_transaction ;

        key5 AMD_LOAD_DETAILS.KEY_5%TYPE := pComments ;
        error_location number ;
        load_no number ;

    BEGIN
      IF key5 = '' THEN
         key5 := pSqlFunction || '/' || pTableName ;
      ELSE
       key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
      END IF ;

      if pError_location is null then
        error_location := -9998 ;
      else
          if amd_utils.isNumber(pError_location) then
               error_location := pError_location ;
          else
               error_location := -9999 ;
          end if ;
     end if ;

      -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
      -- do not exceed the length of the column's that the data gets inserted into
      -- This is for debugging and logging, so efforts to make it not be the source of more
      -- errors is VERY important
      begin
        load_no := amd_utils.getLoadNo(pSourceName => substr(pSqlfunction,1,20), pTableName  => SUBSTR(pTableName,1,20)) ;
      exception when others then
        load_no := -1 ;  -- this should not happen
      end ;

      Amd_Utils.InsertErrorMsg (
        pLoad_no => load_no,
        pData_line_no => error_location,
        pData_line    => 'amd_lp_override_consumabl_pkg',
        pKey_1 => SUBSTR(pKey1,1,50),
        pKey_2 => SUBSTR(pKey2,1,50),
        pKey_3 => SUBSTR(pKey3,1,50),
        pKey_4 => SUBSTR(pKey4,1,50),
        pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS') ||
             ' ' || substr(key5,1,50),
        pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
        COMMIT;

    EXCEPTION WHEN OTHERS THEN
      if pSqlFunction is not null then dbms_output.put_line('pSqlFunction=' || pSqlfunction) ; end if ;
      if pTableName is not null then dbms_output.put_line('pTableName=' || pTableName) ; end if ;
      if pError_location is not null then dbms_output.put_line('pError_location=' || pError_location) ; end if ;
      if pKey1 is not null then dbms_output.put_line('key1=' || pKey1) ; end if ;
      if pkey2 is not null then dbms_output.put_line('key2=' || pKey2) ; end if ;
      if pKey3 is not null then dbms_output.put_line('key3=' || pKey3) ; end if ;
      if pKey4 is not null then dbms_output.put_line('key4=' || pKey4) ; end if ;
      if pComments is not null then dbms_output.put_line('pComments=' || pComments) ; end if ;
       raise_application_error(-20030,
            substr('amd_lp_override_consumabl_pkg '
                || sqlcode || ' '
                || pError_location || ' '
                || pSqlFunction || ' '
                || pTableName || ' '
                || pKey1 || ' '
                || pKey2 || ' '
                || pKey3 || ' '
                || pKey4 || ' '
                || pComments,1, 2000)) ;
    END ErrorMsg;


    function isTestPart(part_no in amd_test_parts.part_no%type) return boolean is
        result number ;
    begin

        if testParts.first is not null then
            for indx in testParts.first .. testParts.last loop
                if testParts(indx) = part_no then
                    return true ;
                end if ;
            end loop ;
        end if ;

        return false ;

    end isTestPart ;

    function isTestPartYorN(part_no in amd_test_parts.part_no%type) return varchar2 is
    begin
        if isTestPart(part_no)  then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isTestPartYorN ;

    function getRop(economic_order_qty in number, approved_lvl_qty in number , reorder_point in number) return number is
    begin

        if economic_order_qty > 0 then
            return reorder_point ;
        end if ;

        return 1 ;

    end getRop ;

    function getROQ(economic_order_qty in number, approved_lvl_qty in number, reorder_point in number) return number is
    begin

        if economic_order_qty > 0 then
            return economic_order_qty ;
        end if ;

        if approved_lvl_qty > 0 then
            return approved_lvl_qty - reorder_point ;
        end if ;

        return 1 ;

    end getROQ ;

    function getTslOverrideUserByNsn(nsn in amd_national_stock_items.nsn%type)  
            return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_USER%type  is
            
                nsi_sid amd_national_stock_items.NSI_SID%type ;
                
    begin
            nsi_sid := amd_utils.GETNSISID(pNsn => nsn) ;
            return amd_location_part_override_pkg.GETFIRSTLOGONIDFORPART(nsi_sid) ;
    end getTslOverrideUserByNsn ;

    function getTslOverrideUser(spo_prime_part_no in amd_spare_parts.spo_prime_part_no%type) 
            return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_USER%type  is
            
                nsn amd_national_stock_items.nsn%type ;
                
    begin
        nsn := amd_utils.getNsn(spo_prime_part_no) ;
        return getTslOverrideUserByNsn(nsn) ;
    end getTslOverrideUser ;

    function getSpoPrimePartNo(nsn in amd_rbl_pairs.new_nsn%type) return amd_rbl_pairs.NEW_NSN%type is
        spo_prime_part_no amd_spare_parts.SPO_PRIME_PART_NO%type ;
    begin
        begin
            select parts.spo_prime_part_no  into spo_prime_part_no
            from amd_national_stock_items items,
            amd_spare_parts parts
            where items.nsn = getSpoPrimePartNo.nsn
            and items.prime_part_no = parts.part_no
            and parts.part_no = parts.spo_prime_part_no
            and parts.is_spo_part = 'Y' ;
        exception when standard.NO_DATA_FOUND then
            spo_prime_part_no := null ;
        end ;
        return spo_prime_part_no ;
    end getSpoPrimePartNo ;

    procedure doUpdate(part_no in tmp_locpart_overid_consumables.part_no%type,
                spo_location in tmp_locpart_overid_consumables.spo_location%type,
                loc_sid in tmp_locpart_overid_consumables.loc_sid%type,
                tsl_override_type in tmp_locpart_overid_consumables.tsl_override_type%type,
                tsl_override_qty in tmp_locpart_overid_consumables.tsl_override_qty%type,
                tsl_override_user in tmp_locpart_overid_consumables.tsl_override_user%type,
                tsl_override_source in tmp_locpart_overid_consumables.tsl_override_source%type,
                update_cnt in out number) is



    begin
        if tsl_override_qty is not null then
            update tmp_locpart_overid_consumables
            set loc_sid = doUpdate.loc_sid,
            tsl_override_qty = doUpdate.tsl_override_qty,
            tsl_override_user = doUpdate.tsl_override_user,
            tsl_override_source = doupdate.tsl_override_source,
            last_update_dt = sysdate
            where part_no = doUpdate.part_no
            and spo_location = doupdate.spo_location
            and tsl_override_type = doUpdate.tsl_override_type ;
            update_cnt := update_cnt + 1 ;

            if update_cnt < 100 then
                -- record 1st 100 keys of recs updateds
                writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 10,
                   pKey1 => 'doUpdate.part_no=' || part_no,
                   pKey2 => 'spo_location=' || spo_location,
                   pKey3 => 'type=' || tsl_override_type,
                   pKey4 => 'loc_sid=' || to_char(loc_sid),
                   pData => 'source=' || tsl_override_source) ;
            end if ;
        end if ;

    exception
        when others then
             ErrorMsg(pSqlfunction => 'doUpdate',pTableName  => 'TMP_LOCPART_OVERID_CONSUMABLES',
               pError_location => 20,
               pKey1 => 'part_no=' || part_no,
               pKey2 => 'spo_location=' || spo_location,
               pKey3 => 'type=' || tsl_override_type,
               pKey4 => 'loc_sid=' || to_char(loc_sid),
               pComments => 'source=' || tsl_override_source) ;
             raise ;
    end doUpdate ;

    procedure doInsert(part_no in tmp_locpart_overid_consumables.part_no%type,
                spo_location in tmp_locpart_overid_consumables.spo_location%type,
                loc_sid in tmp_locpart_overid_consumables.loc_sid%type,
                tsl_override_type in tmp_locpart_overid_consumables.tsl_override_type%type,
                tsl_override_qty in tmp_locpart_overid_consumables.tsl_override_qty%type,
                tsl_override_user in tmp_locpart_overid_consumables.tsl_override_user%type,
                tsl_override_source in tmp_locpart_overid_consumables.TSL_OVERRIDE_SOURCE%type,
                insert_cnt in out number,
                update_cnt in out number,
                canUpdate in boolean,
                recs in out tmpLocPartOveridConsumablesTab) is
                rec tmp_locpart_overid_consumables%rowtype ;
    begin
        rec.part_no := part_no ;
        rec.spo_location := spo_location ;
        rec.loc_sid := loc_sid ;
        rec.tsl_override_type := tsl_override_type ;
        rec.tsl_override_qty := tsl_override_qty ;
        rec.tsl_override_user := tsl_override_user ;
        rec.tsl_override_source := tsl_override_source ;
        rec.action_code := amd_defaults.INSERT_ACTION ;
        rec.last_update_dt := sysdate ;
        insert_cnt := insert_cnt + 1 ;
        recs.extend ;
        recs(recs.last) := rec ;
    end doInsert ;


    procedure doInsert(part_no in tmp_locpart_overid_consumables.part_no%type,
                spo_location in tmp_locpart_overid_consumables.spo_location%type,
                loc_sid in tmp_locpart_overid_consumables.loc_sid%type,
                tsl_override_type in tmp_locpart_overid_consumables.tsl_override_type%type,
                tsl_override_qty in tmp_locpart_overid_consumables.tsl_override_qty%type,
                tsl_override_user in tmp_locpart_overid_consumables.tsl_override_user%type,
                tsl_override_source in tmp_locpart_overid_consumables.TSL_OVERRIDE_SOURCE%type,
                insert_cnt in out number,
                update_cnt in out number,
                canUpdate in boolean) is
    begin
        if isValidTslData(override_type => tsl_override_type, override_quantity => tsl_override_qty) then
            if isTestPart(part_no) then
                debugMsg('inserting ' || part_no || ' for location ' || spo_location, pError_location => 30) ;
            end if ;
            if insertData then
                insert into TMP_LOCPART_OVERID_CONSUMABLES
                (part_no, spo_location, loc_sid, tsl_override_type, tsl_override_qty, tsl_override_user, tsl_override_source)
                values (doInsert.part_no, doInsert.spo_location, doInsert.loc_sid ,
                    doInsert.tsl_override_type, round(doInsert.tsl_override_qty), doInsert.tsl_override_user, doInsert.tsl_override_source) ;
            end if ;
            insert_cnt := insert_cnt + 1 ;
        else
            if isTestPart(part_no) then
               if tsl_override_qty is null then -- Xzero
                    debugMsg('tsl_override_qty was null for ' || part_no || ' for location ' || spo_location, pError_location => 40) ;
               elsif  tsl_override_qty <> 0 then  -- Xzero
                    debugMsg('tsl_override_qty was zero for ' || part_no || ' for location ' || spo_location, pError_location => 50) ; -- Xzero
               end if;  -- Xzero
            end if ;

        end if ;

    exception
        when standard.DUP_VAL_ON_INDEX then
            if canUpdate then
                doUpdate(part_no,spo_location,loc_sid,tsl_override_type,tsl_override_qty,tsl_override_user,tsl_override_source, update_cnt) ;
            end if ;
        when others then
             ErrorMsg(pSqlfunction       => 'doInsert',pTableName  => 'TMP_LOCPART_OVERID_CONSUMABLES',
                       pError_location => 60, pKey1 => 'part_no=' || part_no,
                       pKey2 => 'spo_location=' || spo_location,
                       pKey3 => 'type=' || tsl_override_type,
                       pKey4 => 'loc_sid=' || to_char(loc_sid),
                       pComments => 'source=' || tsl_override_source) ;
             raise ;
    end doInsert ;


    procedure loadWhseBase(spo_location in varchar2, sc in varchar2) is
        insert_cnt number := 0 ;
        update_cnt number := 0 ;
        in_cnt number := 0 ;
        tsl_override_user TMP_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_USER%type ;
        loc_sid tmp_locpart_overid_consumables.loc_sid%type ;
        theCursor SYS_REFCURSOR ;
        rec ropRoqRec ;
        operator varchar2(6) ;
        type whseBaseRec is record (
            spo_prime_part_no amd_spare_parts.spo_prime_part_no%type,
            spo_location amd_locpart_overid_consumables.spo_location%type,
            rop number,
            roq number
        ) ;
        type whseBaseTab is table of whseBaseRec ;
        whseBaseRecs whseBaseTab ;
        recs tmpLocPartOveridConsumablesTab := tmpLocPartOveridConsumablesTab() ;
    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 70,
                pKey1 => 'loadWhseBase(' || spo_location || ',' || sc|| ')',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
                
        debugMsg('loadWhseBase started at ' 
        || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')
        || ' for spo_location='|| spo_location 
        || ' and sc=' || sc,
            pError_location => 80) ; 

        if instr(sc,'%') > 0 then
            operator := ' like ' ;
        else
            operator := ' = ' ;
        end if ;

        open theCursor for
            'select parts.spo_prime_part_no,
                    nwks.spo_location,
                    sum (case 
                        when whseX.reorder_point is not null then
                            round(whseX.reorder_point)
                        else
                            amd_defaults.getROP 
                    end)  rop,
                    sum (case when whseX.STOCK_LEVEL is not null
                         and whseX.reorder_point is not null
                         and whseX.STOCK_LEVEL - whseX.reorder_point >= 0 then
                                whseX.STOCK_LEVEL - whseX.reorder_point
                         else
                            amd_defaults.getROQ
                    end) roq
                    from whse whseX,
                    amd_spare_networks nwks,
                    amd_spare_parts parts
                    where parts.is_spo_part = ''Y'' 
                    and parts.IS_CONSUMABLE = ''Y'' 
                    and parts.part_no = parts.spo_prime_part_no
                    and parts.spo_prime_part_no = whseX.part
                    and whseX.sc ' || operator || ' :the_sc
            and whseX.created_datetime = (select max(created_datetime) 
                                      from whse 
                          where part = whseX.part 
                          and sc ' || operator || ' :the_sc)
                    and nwks.action_code <> amd_defaults.getDELETE_ACTION
                    and nwks.loc_id = :the_spo_location
                    and nwks.spo_location is not null
                    group by spo_location, spo_prime_part_no'
                    using sc, sc, spo_location ;

        fetch theCursor bulk collect into whseBaseRecs ;
        close theCursor ;
        if whseBaseRecs.first is not null then
            for indx in whseBaseRecs.first .. whseBaseRecs.last
            loop
                in_cnt := in_cnt + 1 ;

                tsl_override_user := getTslOverrideUser(whseBaseRecs(indx).spo_prime_part_no) ;
                if whseBaseRecs(indx).spo_location = WHSE_LOCID then
                    loc_sid := WHSE_LOCSID ;
                else
                    loc_sid := amd_utils.getLocSid(whseBaseRecs(indx).spo_location) ;
                end if ;
                if (whseBaseRecs(indx).rop + whseBaseRecs(indx).roq <> 0) or loadZeroTsls then

                    if isTestPart(whseBaseRecs(indx).spo_prime_part_no) then
                        debugMsg(whseBaseRecs(indx).spo_prime_part_no  
                        ||': rop= ' || whseBaseRecs(indx).rop 
                        || ' *** roq=' || whseBaseRecs(indx).roq || ' ***'
                        || ' spo_location=' || whseBaseRecs(indx).spo_location 
                        || ' loc_sid=' || loc_sid,  pError_location => 90) ;
                    end if ;

                    doinsert(part_no => whseBaseRecs(indx).spo_prime_part_no, spo_location => whseBaseRecs(indx).spo_location, loc_sid => loc_sid,
                        tsl_override_type => ROQ_TYPE, tsl_override_qty => whseBaseRecs(indx).roq, tsl_override_user => tsl_override_user,
                        tsl_override_source => GOLD_SOURCE,
                        insert_cnt => insert_cnt,
                        update_cnt => update_cnt,
                        canUpdate => false) ;
                        --recs => recs) ;


                    doinsert(part_no => whseBaseRecs(indx).spo_prime_part_no, spo_location => whseBaseRecs(indx).spo_location, loc_sid => loc_sid,
                        tsl_override_type => ROP_TYPE, tsl_override_qty => whseBaseRecs(indx).rop, tsl_override_user => tsl_override_user,
                        tsl_override_source => GOLD_SOURCE,
                        insert_cnt => insert_cnt,
                        update_cnt => update_cnt,
                        canUpdate => false) ;
                else
                    if isTestPart(whseBaseRecs(indx).spo_prime_part_no) then
                        debugMsg(whseBaseRecs(indx).spo_prime_part_no || ' rop + roq = 0', pError_location => 100) ;
                    end if ;
                end if ;
                    --recs => recs) ;
            end loop ;
        end if ;

        if recs.first is not null then
            forall indx in recs.first .. recs.last
                insert into tmp_locpart_overid_consumables
                values recs(indx) ;
            dbms_output.put_line(recs.count || ' recs loaded') ;
            commit ;
        else
            dbms_output.put_line('no recs loaded via bulk insert') ;
        end if ;
        
        debugMsg('loadWhseBase ended at ' 
        || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')
        || ' for spo_location='|| spo_location 
        || ' sc=' || sc
        || ' and records processed=' || in_cnt,
            pError_location => 110) ; 
            
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 120,
                pKey1 => 'loadWhseBase(' || spo_location || ',' || sc||  ')',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'in_cnt=' || to_char(in_cnt),
                pKey4 => 'insert_cnt=' || to_char(insert_cnt),
                pData => 'update_cnt=' || to_char(update_cnt)) ;
        commit ;

    end loadWhseBase ;

    procedure LoadBasc is
    begin
        loadWhseBase(spo_location => amd_defaults.AMD_BASC_LOC_ID, sc => amd_defaults.AMD_BASC_SC) ;
    end loadBasc ;

    procedure LoadUk is
    begin
        loadWhseBase(spo_location => amd_defaults.GETAMD_UK_LOC_ID, sc => amd_defaults.GETAMD_UK_SC) ;
    end loadUK;

    procedure LoadCanada is
    begin
        loadWhseBase(spo_location => amd_defaults.GETAMD_CAN_LOC_ID, sc => amd_defaults.GETAMD_CAN_SC) ;
    end loadCanada ;

    procedure loadAustrailia is
    begin
        loadWhseBase(spo_location => amd_defaults.GETAMD_AUS_LOC_ID, sc => amd_defaults.GETAMD_AUS_SC) ;
    end loadAustrailia ;



    procedure loadLvls is
        type lvlsRec is record (
            spo_prime_part_no amd_spare_parts.spo_prime_part_no%type,
            loc_sid amd_locpart_overid_consumables.loc_sid%type,
            spo_location amd_locpart_overid_consumables.spo_location%type,
            current_stock_number lvls.CURRENT_STOCK_NUMBER%type,
            nsn amd_national_stock_items.nsn%type,
            sran lvls.SRAN%type,
            rop number,
            roq number
        ) ;
        type lvlsTab is table of lvlsRec ;
        lvlsRecs lvlsTab ;

        cursor consumablesForLvls is
            select parts.spo_prime_part_no,
            nwks.loc_sid,
            amd_utils.getSpoLocation(nwks.loc_sid) spo_location,
            current_stock_number,
            items.nsn nsn,
            a.sran,
            case 
                when nvl(a.economic_order_qty,0) = 0 and nvl(a.approved_lvl_qty,0) = 0 then
                    amd_defaults.getROP -- -1
                else
                    nvl(reorder_point,0)                            
            end rop,
            case
                when nvl(a.economic_order_qty,0) > 0 then
                    round(a.economic_order_qty)
                        
                when nvl(a.approved_lvl_qty,0) > 0 then
                    case when a.approved_lvl_qty - nvl(a.reorder_point,0) <= 0 then
                            amd_defaults.getROQ --  1  
                         else 
                            round(a.approved_lvl_qty - nvl(a.reorder_point,0))
                    end
                        
                else -- eoconomic_order_qty is null or zero 
                     -- and apprved_lvl_qty is null or zero
                    amd_defaults.getROQ -- 1
            end roq
            from lvls a,
            amd_national_stock_items items,
            amd_spare_networks nwks,
            amd_spare_parts parts
            where items.action_code <> amd_defaults.getDELETE_ACTION
            and nwks.action_code <> amd_defaults.getDELETE_ACTION
            and a.COMPATIBILITY_CODE = 'C'
            and items.nsn = a.NSN
            and items.PRIME_PART_NO = parts.part_no
            and parts.part_no = parts.spo_prime_part_no
            and parts.is_spo_part = 'Y'
            and parts.is_consumable = 'Y'
            and a.date_lvl_loaded = (select max(date_lvl_loaded) from lvls where a.nsn = nsn and a.sran = sran and a.compatibility_code = 'C')
            and a.date_lvl_loaded between sysdate - amd_defaults.getTSL_CONSUMABL_CALENDAR_DAYS and sysdate
            and a.sran = nwks.LOC_ID
            and a.sran <> amd_defaults.GETAMD_WAREHOUSE_LOCID
            and (nwks.loc_type = 'FSL'
                  or (nwks.loc_type = 'MOB' and nvl(items.wesm_indicator,'N') = 'N')
                  or nwks.LOC_ID in (amd_defaults.getAMD_AUS_LOC_ID,
                                    amd_defaults.getAMD_CAN_LOC_ID,
                                    amd_defaults.getAMD_UK_LOC_ID)
                )
            and nwks.spo_location is not null
            order by niin, sran, document_datetime ;


            insert_cnt number := 0 ;
            update_cnt number := 0 ;
            in_cnt number := 0 ;
            spo_prime_part_no amd_spare_parts.SPO_PRIME_PART_NO%type ;
            rop number ;
            roq number ;
            tsl_override_user TMP_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_USER%type ;


    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 130,
                pKey1 => 'loadLvls',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

        debugMsg('loadLvls started at ' 
        || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
            pError_location => 140) ; 

        open consumablesForLvls ;
        fetch consumablesForLvls bulk collect into lvlsRecs ;
        close consumablesForLvls ;

        if lvlsRecs.first is not null then
            for indx in lvlsRecs.first .. lvlsRecs.last loop
                insert_cnt := in_cnt + 1 ;

                tsl_override_user := getTslOverrideUserByNsn(lvlsRecs(indx).nsn) ;

                if (lvlsRecs(indx).roq + lvlsRecs(indx).rop <> 0) or loadZeroTsls then
                    
                    if isTestPart(lvlsRecs(indx).spo_prime_part_no) then
                        debugMsg(lvlsRecs(indx).spo_prime_part_no  
                        ||': rop= ' || lvlsRecs(indx).rop 
                        || ' *** roq=' || lvlsRecs(indx).roq || ' ***'
                        || ' spo_location=' || lvlsRecs(indx).spo_location 
                        || ' loc_sid=' || lvlsRecs(indx).loc_sid,  pError_location => 150) ;
                    end if ;
                    
                    doinsert(part_no => lvlsRecs(indx).spo_prime_part_no, spo_location => lvlsRecs(indx).spo_location, loc_sid => lvlsRecs(indx).loc_sid,
                        tsl_override_type => ROQ_TYPE, tsl_override_qty => lvlsRecs(indx).roq, tsl_override_user => tsl_override_user,
                        tsl_override_source => GOLD_SOURCE,
                        insert_cnt => insert_cnt,
                        update_cnt => update_cnt,
                        canUpdate => false);


                    doinsert(part_no => lvlsRecs(indx).spo_prime_part_no, spo_location => lvlsRecs(indx).spo_location, loc_sid => lvlsRecs(indx).loc_sid,
                        tsl_override_type => ROP_TYPE, tsl_override_qty => lvlsRecs(indx).rop, tsl_override_user => tsl_override_user,
                        tsl_override_source => GOLD_SOURCE,
                        insert_cnt => insert_cnt,
                        update_cnt => update_cnt,
                        canUpdate => false) ;
                else
                    if isTestPart(lvlsRecs(indx).spo_prime_part_no) then
                        debugMsg(lvlsRecs(indx).spo_prime_part_no || ' rop + roq = 0', pError_location => 160) ;
                    end if ;
                end if ;
            end loop ;
        end if ;

        debugMsg('loadLvls ended at ' 
        || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')
        || ' in_cnt='|| in_cnt 
        || ' insert_cnt=' || insert_cnt
        || ' and update_cnt=' || update_cnt,
            pError_location => 170) ; 

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 180,
                pKey1 => 'loadLvls',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'in_cnt=' || to_char(in_cnt),
                pKey4 => 'insert_cnt=' || to_char(insert_cnt),
                pData => 'update_cnt=' || to_char(update_cnt)) ;
        commit ;
    end loadLvls ;

    procedure loadRamp  is
        /*
        cursor consumablesForRamp is
            select sent.spo_prime_part_no ,
            nwks.loc_sid,
            amd_utils.getSpoLocation(nwks.loc_sid) spo_location,
            current_stock_number,
            items.nsn nsn,
            ramp.sran,
            ramp.demand_level rop
            from ramp,
            cat1,
            amd_spare_networks nwks,
            amd_sent_to_a2a sent,
            amd_rbl_pairs rbl,
            amd_national_stock_items items
            where
            ( sent.spo_prime_part_no = sent.part_no
              and sent.action_code <> DELETE_ACTION
              and amd_utils.isPartConsumableYorN(sent.spo_prime_part_no) = 'Y'
            ) and (
                    ramp.SC like 'C170008FB%G'
                    and cat1.source_code = 'F77'
                    and amd_utils.isNumberYorN(amd_utils.formatNsn(ramp.CURRENT_STOCK_NUMBER)) = 'Y'
                    and ramp.DELETE_INDICATOR <> DELETE_ACTION
            ) and (
                substr(ramp.sc,8,6) = nwks.loc_id
                and nwks.loc_type in ( 'FSL','MOB')
                and nwks.SPO_LOCATION is not null
                and nwks.action_code <> DELETE_ACTION
            )
            and ramp.CURRENT_STOCK_NUMBER = cat1.NSN
            and (
                    ( amd_utils.formatNsn(ramp.current_stock_number) = rbl.old_nsn
                      and rbl.new_nsn = amd_utils.getNsn(sent.spo_prime_part_no)
                    )
                    or amd_utils.formatNsn( ramp.current_stock_number ) = amd_utils.getNsn(sent.spo_prime_part_no)

                )
            group by sent.spo_prime_part_no ;
        */
    begin
        null ;
    end loadRamp ;



    procedure loadWhse  is

        type sumTab is table of whseRec index by amd_spare_parts.spo_prime_part_no%type ;

        wesmSumRecs sumTab ;
        nonWesmSumRecs sumTab ;
        partIndx amd_spare_parts.spo_prime_part_no%type ;

        wesmRecs whseTab ;

        cursor wesmParts is
        select spo_prime_part_no,
        sum(
            case when L11.BOEING_BASE_MIN_LEVEL > 0 then
                    case when L11.BOEING_BASE_MIN_LEVEL = 1
                        and nvl(boeing_base_max_level,0) - nvl(boeing_base_min_level,0) <= 0 then
                            0
                        else round(L11.BOEING_BASE_MIN_LEVEL)
                    end
                 else
                    0 -- still pick up the part but do not factor in calc
            end) rop,
        sum(
             case when nvl(boeing_base_max_level,0) - nvl(boeing_base_min_level,0) > 0 then
                    case when nvl(boeing_base_max_level,0) - nvl(boeing_base_min_level,0) = 1
                        and L11.BOEING_BASE_MIN_LEVEL < 0 then
                            0
                        else round(nvl(boeing_base_max_level,0) - nvl(boeing_base_min_level,0))
                    end
                  else
                    0 -- still pick up the part but do not factor in calc
             end
            ) roq
        from
        L11, amd_national_stock_items items,
        amd_spare_networks nwks,
        amd_spare_parts parts,
        active_niins
        where source_of_supply = amd_defaults.getSourceCode
        and L11.niin = active_niins.niin
        and L11.nsn = items.nsn
        and items.prime_part_no = parts.part_no
        and parts.is_spo_part = 'Y'
        and parts.part_no = parts.spo_prime_part_no
        and parts.is_consumable = 'Y'
        and nwks.action_code <> amd_defaults.getDELETE_ACTION
        and L11.sran = substr(loc_id,3,4)
        and nwks.LOC_TYPE = 'MOB'
          and nwks.LOC_ID not in (amd_defaults.getAMD_UK_LOC_ID, amd_defaults.getAMD_BASC_LOC_ID,
                                amd_defaults.getAMD_WARNER_ROBINS_LOC_ID )
        and nwks.spo_location is not null
        group by spo_prime_part_no ;


        lvlsByBaseRecs whseTab ;

        cursor lvls_by_base is
            select parts.spo_prime_part_no spo_prime_part_no,
            sum (
                case 
                    when nvl(a.economic_order_qty,0) = 0 and nvl(a.approved_lvl_qty,0) = 0 then
                        amd_defaults.getROP -- -1
                    else
                        nvl(reorder_point,0)                            
                end) rop,
            sum (
                case
                    when nvl(a.economic_order_qty,0) > 0 then
                        round(a.economic_order_qty)
                        
                    when nvl(a.approved_lvl_qty,0) > 0 then
                        case when a.approved_lvl_qty - nvl(a.reorder_point,0) <= 0 then
                                amd_defaults.getROQ --  1  
                             else 
                                round(a.approved_lvl_qty - nvl(a.reorder_point,0))
                        end
                        
                    else -- eoconomic_order_qty is null or zero 
                         -- and apprved_lvl_qty is null or zero
                        amd_defaults.getROQ -- 1
                end) roq
            from lvls a,
            amd_national_stock_items items,
            amd_spare_networks nwks,
            amd_spare_parts parts
            where items.action_code <> amd_defaults.getDELETE_ACTION
            and nwks.action_code <> amd_defaults.getDELETE_ACTION
            and a.COMPATIBILITY_CODE = 'C'
            and items.nsn = a.NSN
            and items.prime_part_no = parts.part_no
            and parts.part_no = parts.spo_prime_part_no
            and parts.is_consumable = 'Y'
            and date_lvl_loaded = (select max(date_lvl_loaded) from lvls where a.nsn = nsn and a.sran = sran and a.compatibility_code = 'C')
            and date_lvl_loaded between sysdate - amd_defaults.getTSL_CONSUMABL_CALENDAR_DAYS and sysdate
            and a.sran = nwks.LOC_ID
            and a.sran <> amd_defaults.getAMD_WAREHOUSE_LOCID
            and (nwks.loc_type = 'FSL'
                  or nwks.loc_type = 'MOB'
                  or nwks.LOC_ID = amd_defaults.getAMD_WARNER_ROBINS_LOC_ID
                )
            and nwks.spo_location is not null
            and nvl(items.WESM_INDICATOR,'N') = 'N'
            group by parts.spo_prime_part_no ;

        in_cnt number := 0 ;
        insert_cnt number := 0 ;
        update_cnt number := 0 ;
        tsl_override_user tmp_locpart_overid_consumables.TSL_OVERRIDE_USER%type ;
        whse_rop number ;
        rop number ;
        whse_roq number ;
        roq number ;


        rec whseRec ;

        recs tmpLocPartOveridConsumablesTab := tmpLocPartOveridConsumablesTab() ;

        function getRop(rop in number, roq in number) return number is
        begin
            if nvl(rop,0) = 1 and nvl(roq,0) = 0 then
                return 0 ;
            else
                return nvl(rop,0) ;
            end if ;
        end getRop ;

        function getRoq(roq in number, rop in number) return number is
        begin
        -- removed filter per Rosalind Whitesides 11/20/2008
            --if nvl(roq,0) = 1 and nvl(rop,0) = 0 then
             --   return 0 ;
           -- else
                return nvl(roq,0) ;
            --end if ;
        end getRoq ;

        procedure sumTheRecs(recs in whseTab, sums in out sumTab) is
            rop number ;
            roq number ;

            procedure increment(amt in number, result in out number) is
            begin
                if result is null then
                    result := amt ;
                else
                    result := result + amt ;
                end if ;
            end increment ;

        begin
            debugMsg('start sum the recs',  pError_location => 190) ;
            if recs.first is not null then
                for indx in recs.first .. recs.last loop
                    in_cnt := in_cnt + 1 ;
                    rop := getRop(rop => recs(indx).rop, roq => recs(indx).roq) ;
                    roq := getRoq(roq => recs(indx).roq, rop => recs(indx).rop) ;

                    if isTestPart(recs(indx).spo_prime_part_no) then
                        debugMsg(recs(indx).spo_prime_part_no || ': base rop= ' || recs(indx).rop
                        || ' base roq=' || recs(indx).roq , pError_location => 200) ;
                        debugMsg(recs(indx).spo_prime_part_no || ': rop= ' || rop
                        || ' roq=' || roq, pError_location => 210) ;
                    end if ;
                    sums(recs(indx).spo_prime_part_no).spo_prime_part_no := recs(indx).spo_prime_part_no ;
                    if rop + roq <> 0 then
                        increment(amt => rop, result => sums(recs(indx).spo_prime_part_no).rop) ;
                        increment(amt => roq, result => sums(recs(indx).spo_prime_part_no).roq) ;
                    else
                        increment(amt => 0, result => sums(recs(indx).spo_prime_part_no).rop ) ;
                        increment(amt => 0, result => sums(recs(indx).spo_prime_part_no).roq) ;
                    end if ;
                    if isTestPart(recs(indx).spo_prime_part_no) then
                        debugMsg('sum of rop=' || sums(recs(indx).spo_prime_part_no).rop , pError_location => 212) ;
                        debugMsg('sum of roq=' || sums(recs(indx).spo_prime_part_no).roq , pError_location => 214) ;
                    end if ;
                end loop ;
            end if ;
        debugMsg('end sum the recs',  pError_location => 190) ;
        debugMsg('@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@', pError_location => 190) ;
        end sumTheRecs ;

        procedure processRec(rec in whseRec, tsl_override_source in tmp_locpart_overid_consumables.tsl_override_source%type) is
            cursor whseData(spo_prime_part_no in varchar2) is
                    select nvl(reorder_point,0) reorder_point,
                    nvl(stock_level,0) stock_level,
                    nvl(user_ref3,0) user_ref3, created_datetime
                    from whse
                    where prime = spo_prime_part_no
                    and part = prime
                    and substr(sc,1,3) = 'C17'
                    and substr(sc,amd_defaults.getStartLocId,7) = 'CTLATLG'
                    order by created_datetime desc ;
            recFound boolean := false ;
        begin
            tsl_override_user := getTslOverrideUser(rec.spo_prime_part_no) ;

            <<getWhseData>>
            begin
                recFound := false ;
                for warehouseRec in whseData(rec.spo_prime_part_no) loop
                    whse_rop := warehouseRec.stock_level ;
                    whse_roq := amd_defaults.ROQ ;
                    recFound := true ;
                    exit when 1 = 1 ;
                end loop ;
                if isTestPart(rec.spo_prime_part_no) then
                    debugMsg(rec.spo_prime_part_no ||': whse_rop=' || whse_rop || ' whse_roq=' || whse_roq || ' rec.rop= ' || rec.rop || ' rec.roq=' || rec.roq, pError_location => 220) ;
                end if ;
                if recFound then
                    rop := whse_rop - (nvl(rec.rop,0) + nvl(rec.roq,0) + 1) ;

                    roq := whse_roq ;

                    if rop <= 0 then
                        rop := amd_defaults.ROP ;
                    end if ;

                else
                    rop := amd_defaults.ROP ;
                    roq := amd_defaults.ROQ ;
                end if ;

                if isTestPart(rec.spo_prime_part_no) then
                    debugMsg(rec.spo_prime_part_no  ||': rop= ' || rop || ' *** roq=' || roq || ' ***', pError_location => 230) ;
                end if ;

            end getWhseData ;

            /*
                The default values for ROP or ROQ on any base is not to be used
                in the FD2090 calculation regardless of whether that value
                combination is derived from actual source data or is assigned a default
                value.
            */

            if (rop + roq = 0)  then
                if isTestPart(rec.spo_prime_part_no) then
                    debugMsg(rec.spo_prime_part_no || ' rop + roq = 0 ** part not sent to spo **', pError_location => 240) ;
                end if ;
            else
                doinsert(part_no => rec.spo_prime_part_no, spo_location => WHSE_LOCID, loc_sid => WHSE_LOCSID,
                    tsl_override_type => ROQ_TYPE, tsl_override_qty => roq, tsl_override_user => tsl_override_user,
                    tsl_override_source => tsl_override_source,
                    insert_cnt => insert_cnt,
                    update_cnt => update_cnt,
                    canUpdate => false) ;
                    --recs => recs) ;



                doinsert(part_no => rec.spo_prime_part_no, spo_location => WHSE_LOCID, loc_sid => WHSE_LOCSID,
                    tsl_override_type => ROP_TYPE, tsl_override_qty => rop, tsl_override_user => tsl_override_user,
                    tsl_override_source => tsl_override_source,
                    insert_cnt => insert_cnt,
                    update_cnt => update_cnt,
                    canUpdate => false) ;
                    --recs => recs) ;

                if isTestPart(rec.spo_prime_part_no) then
                    debugMsg(rec.spo_prime_part_no ||  ' accepted', pError_location => 250) ;
                end if ;
            end if ;
        exception when others then
             ErrorMsg(pSqlfunction => 'loadWhse',pTableName  => 'TMP_LOCPART_OVERID_CONSUMABLES',
               pError_location => 260,
               pKey1 => 'spo_prime_part_no=' || nvl(rec.spo_prime_part_no,'null'),
               pKey2 => 'rop=' || to_char(rec.rop),
               pKey3 => 'roq=' || to_char(rec.roq) ) ;
             raise ;
        end processRec ;

        procedure processWhseParts(spo_location in varchar2,
            sc in varchar2, operator in varchar2, wesm_part in varchar2,
            sumRecs in out sumTab)  is
            theCursor SYS_REFCURSOR ;
            theQuery varchar2(1000);

            whsePartRecs whseTab ;

        procedure dumpQuery is
        begin
        dbms_output.put_line('------------------------------,');
        dbms_output.put_line('select parts.spo_prime_part_no,');
        dbms_output.put_line(' sum(');
        dbms_output.put_line('    case ');
        dbms_output.put_line('        when whseX.reorder_point is not null then');
        dbms_output.put_line('            round(whseX.reorder_point)');
        dbms_output.put_line('        else');
        dbms_output.put_line('            amd_defaults.getROP ');
        dbms_output.put_line('    end)  rop,');
        dbms_output.put_line(' sum(');
        dbms_output.put_line('    case when whseX.STOCK_LEVEL is not null');
        dbms_output.put_line('         and whseX.reorder_point is not null');
        dbms_output.put_line('         and whseX.STOCK_LEVEL - whseX.reorder_point >= 0 then');
        dbms_output.put_line('                whseX.STOCK_LEVEL - whseX.reorder_point');
        dbms_output.put_line('         else');
        dbms_output.put_line('            amd_defaults.getROQ');
        dbms_output.put_line('    end) roq');
        dbms_output.put_line('from whse whseX,');
        dbms_output.put_line('amd_spare_networks nwks,');
        dbms_output.put_line('amd_spare_parts parts,');
        dbms_output.put_line('amd_national_stock_items items');
        dbms_output.put_line('where parts.is_spo_part = ''Y'' ');
        dbms_output.put_line('and parts.IS_CONSUMABLE = ''Y'' ');
        dbms_output.put_line('and parts.part_no = parts.spo_prime_part_no');
        dbms_output.put_line('and parts.spo_prime_part_no = whseX.part');
        dbms_output.put_line('and whseX.sc ' || operator || ' ''' || sc || '''');
        dbms_output.put_line('and whseX.created_datetime = (select max(created_datetime) ') ;
        dbms_output.put_line('         from whse ') ;
        dbms_output.put_line('  where part = whseX.part ') ;
        dbms_output.put_line('  and sc ' || operator || '''' || sc || ''')') ;
        dbms_output.put_line('and nwks.action_code <> ''D''');
        dbms_output.put_line('and parts.nsn = items.nsn');
        dbms_output.put_line('and items.action_code <> ''D''');
        dbms_output.put_line('and nvl(items.wesm_indicator,''N'') = ''' || wesm_part || '''');
        dbms_output.put_line('and nwks.loc_id = ''' || spo_location || '''');
        dbms_output.put_line('and nwks.spo_location is not null');
        dbms_output.put_line('group by  spo_prime_part_no');
        dbms_output.put_line('------------------------------,');
        end dumpQuery ;

        begin
            dbms_output.put_line('processWhseParts: spo_location=' || spo_location
            || ' sc=' || sc || ' operator=' || operator || ' wesm_part=' || wesm_part || ' roq=' || roq) ;
        if debug then
        dumpQuery ;
        end if ;
                
            open theCursor for
                'select parts.spo_prime_part_no,
                 sum(
                    case 
                        when whseX.reorder_point is not null then
                            round(whseX.reorder_point)
                        else
                            amd_defaults.getROP 
                    end)  rop,
                 sum(
                    case when whseX.STOCK_LEVEL is not null
                         and whseX.reorder_point is not null
                         and whseX.STOCK_LEVEL - whseX.reorder_point >= 0 then
                                whseX.STOCK_LEVEL - whseX.reorder_point
                         else
                            amd_defaults.getROQ
                    end) roq
                from whse whseX,
                amd_spare_networks nwks,
                amd_spare_parts parts,
                amd_national_stock_items items
                where parts.is_spo_part = ''Y'' 
                and parts.IS_CONSUMABLE = ''Y'' 
                and parts.part_no = parts.spo_prime_part_no
                and parts.spo_prime_part_no = whseX.part
                and whseX.sc ' || operator || ' :the_sc
        and whseX.created_datetime = (select max(created_datetime) 
                                  from whse 
                          where part = whseX.part 
                          and sc ' || operator || ' :the_sc)
                and nwks.action_code <> ''D''
                and parts.nsn = items.nsn
                and items.action_code <> ''D''
                and nvl(items.wesm_indicator,''N'') = :the_wesm_part
                and nwks.loc_id = :the_spo_location
                and nwks.spo_location is not null
                group by  spo_prime_part_no'
                using sc, sc, wesm_part, spo_location ;

            fetch theCursor bulk collect into whsePartRecs ;
            close theCursor ;

            sumTheRecs(recs => whsePartRecs, sums => sumRecs ) ;

        exception when others then
             ErrorMsg(pSqlfunction => 'processWhseParts',pTableName  => 'TMP_LOCPART_OVERID_CONSUMABLES',
               pError_location => 270,
               pKey1 => 'wesm_part=' || wesm_part,
               pKey2 => 'spo_location=' || spo_location,
               pKey3 => 'sc=' || sc,
               pKey4 => 'operator=' || operator) ;
            raise ;
        end processWhseParts ;


   begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 280,
                pKey1 => 'loadWhse',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')) ;

        debugMsg('process wesmParts', pError_location => 290) ;
        open wesmParts ;
        fetch wesmParts bulk collect into wesmRecs ;
        close wesmParts ;
        sumTheRecs(recs => wesmRecs, sums => wesmSumRecs) ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 300,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'wesmRecs.count=' || to_char(wesmRecs.count)) ;


        debugMsg('process wesm parts whsePart for UK', pError_location => 310) ;
        processWhseParts(spo_location => amd_defaults.AMD_UK_LOC_ID,
                            sc => amd_defaults.AMD_UK_SC,
                            operator => 'like', wesm_part =>'Y',
                            sumRecs => wesmSumRecs ) ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 320,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'processed wesm UK') ;

        debugMsg('process wesm parts whsePart for BASC', pError_location => 330) ;
        processWhseParts(spo_location => amd_defaults.AMD_BASC_LOC_ID,
                            sc => amd_defaults.AMD_BASC_SC,
                            operator => '=', wesm_part =>'Y',
                            sumRecs => wesmSumRecs) ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 340,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'processed wesm BASC') ;

        debugMsg('process wesm parts whsePart for AUS', pError_location => 350) ;
        processWhseParts(spo_location => amd_defaults.AMD_AUS_LOC_ID,
                            sc => amd_defaults.AMD_AUS_SC,
                            operator => 'like', wesm_part =>'Y',
                            sumRecs => wesmSumRecs) ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 360,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'processed wesm AUS') ;

        debugMsg('process wesm parts whsePart for CAN', pError_location => 370) ;
        processWhseParts(spo_location => amd_defaults.AMD_CAN_LOC_ID,
                            sc => amd_defaults.AMD_CAN_SC,
                            operator => 'like', wesm_part =>'Y',
                            sumRecs => wesmSumRecs) ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 380,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'processed wesm CAN') ;

        debugMsg('process wesmSumRecs', pError_location => 390) ;
        partIndx := wesmSumRecs.first ;
        while partIndx is not null loop
            if isTestPart(wesmSumRecs(partIndx).spo_prime_part_no) then
                debugMsg(wesmSumRecs(partIndx).spo_prime_part_no || ': rop= ' || wesmSumRecs(partIndx).rop || ' roq=' || wesmSumRecs(partIndx).roq, pError_location => 400) ;
            end if ;
            processRec(wesmSumRecs(partIndx), WESM_SOURCE) ;
            partIndx := wesmSumRecs.next(partIndx) ;
        end loop ;
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 410,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'wesmSumRecs.count=' || to_char(wesmSumRecs.count)) ;
        debugMsg('wesmSumRecs.count=' || wesmSumRecs.count, pError_location => 420) ;

        debugMsg('process lvls_by_base', pError_location => 430) ;
        open lvls_by_base ;
        fetch lvls_by_base bulk collect into lvlsByBaseRecs ;
        close lvls_by_base ;
        sumTheRecs(recs => lvlsByBaseRecs, sums => nonwesmSumRecs) ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 440,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'lvlsByBaseRecs.count=' || to_char(lvlsByBaseRecs.count)) ;

        debugMsg('process non-wesm parts whsePart for UK', pError_location => 450) ;
        processWhseParts(spo_location => amd_defaults.AMD_UK_LOC_ID,
                            sc => amd_defaults.AMD_UK_SC,
                            operator => 'like', wesm_part =>'N',
                            sumRecs => nonwesmSumRecs ) ;
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 460,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'processed nonwesm UK') ;

        debugMsg('process non-wesm parts whsePart for BASC', pError_location => 470) ;
        processWhseParts(spo_location => amd_defaults.AMD_BASC_LOC_ID,
                            sc => amd_defaults.AMD_BASC_SC,
                            operator => '=', wesm_part =>'N',
                            sumRecs => nonwesmSumRecs) ;
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 480,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'processed nonwesm BASC') ;

        debugMsg('process non-wesm parts whsePart for AUS', pError_location => 490) ;
        processWhseParts(spo_location => amd_defaults.AMD_AUS_LOC_ID,
                            sc => amd_defaults.AMD_AUS_SC,
                            operator => 'like', wesm_part =>'N',
                            sumRecs => nonwesmSumRecs) ;
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 500,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'processed nonwesm AUS') ;

        debugMsg('process non-wesm parts whsePart for CAN', pError_location => 510) ;
        processWhseParts(spo_location => amd_defaults.AMD_CAN_LOC_ID,
                            sc => amd_defaults.AMD_CAN_SC,
                            operator => 'like', wesm_part =>'N',
                            sumRecs => nonwesmSumRecs) ;
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 520,
                pKey1 => 'loadWhse',
                pKey2 => 'at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'processed nonwesm CAN') ;
        partIndx := nonwesmSumRecs.first ;
        while partIndx is not null loop
            processRec(nonwesmSumRecs(partIndx), NONWESM_SOURCE) ;
            partIndx := nonwesmSumRecs.next(partIndx) ;
        end loop ;

        if recs.first is not null then
            forall indx in recs.first .. recs.last
                insert into tmp_locpart_overid_consumables
                values recs(indx) ;
            commit ;
            debugMsg(recs.count || ' recs loaded', pError_location => 530) ;
        else
            debugMsg('no recs loaded via bulk insert', pError_location => 540) ;
        end if ;

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 550,
                pKey1 => 'loadWhse',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'in_cnt=' || to_char(in_cnt),
                pKey4 => 'insert_cnt=' || to_char(insert_cnt),
                pData => 'update_cnt=' || to_char(update_cnt) ) ;
    end loadWhse ;
    
    procedure loadWhseX  is
    begin
        insert into tmp_locpart_overid_consumables
        (part_no,spo_location,tsl_override_type,tsl_override_qty,tsl_override_user,
            tsl_override_source,loc_sid,last_update_dt)
            select
            part_no,'FD2090', 'Not Used', -- (select rop_fixed_override from amd_spo_types_v), 
            FleetLevel,    
            amd_lp_override_consumabl_pkg.getTslOverrideUser(part_no),
            'CALC',
            amd_lp_override_consumabl_pkg.GETWHSE_LOCSID,
            sysdate
            from (select a.part_no, 
           sum(a.tsl_override_qty) as sumROP,
           sum(b.tsl_override_qty) as sumROQ, 
            c.stock_level, 
            (c.stock_level -  sum(a.tsl_override_qty) -sum(b.tsl_override_qty) - 1) as FleetLevel
        from tmp_LOCPART_OVERID_CONSUMABLES a
            join tmp_LOCPART_OVERID_CONSUMABLES b
            on a.part_no = b.part_no
            and a.spo_location = b.spo_location
            and b.action_code <> 'D'
            and b.spo_location != 'FD2090'
            and b.tsl_override_type like 'ROQ%',
            whse c
        where a.part_no = c.part
        and a.spo_location != 'FD2090'
        and a.action_code <> 'D'
        and a.tsl_override_type like 'ROP%'
        and c.sc in (select max(sc) from whse d
            where a.part_no = d.part
            and d.sc like ('%CTLATL%'))
        having (c.stock_level -  sum(a.tsl_override_qty) -sum(b.tsl_override_qty) - 1) > 0
        group by a.part_no, c.stock_level
        order by a.part_no
        ) fleetLevels ;

        insert into tmp_locpart_overid_consumables
        (part_no,spo_location,tsl_override_type,tsl_override_qty,tsl_override_user,
            tsl_override_source,loc_sid,last_update_dt)
            select
            part_no,'FD2090', 'Not Used', -- (select roq_fixed_override from amd_spo_types_v), 
            1,    
            amd_lp_override_consumabl_pkg.getTslOverrideUser(part_no),
            'CALC',
            amd_lp_override_consumabl_pkg.GETWHSE_LOCSID,
            sysdate
            from (select a.part_no, 
           sum(a.tsl_override_qty) as sumROP,
           sum(b.tsl_override_qty) as sumROQ, 
            c.stock_level, 
            (c.stock_level -  sum(a.tsl_override_qty) -sum(b.tsl_override_qty) - 1) as FleetLevel
        from tmp_LOCPART_OVERID_CONSUMABLES a
            join tmp_LOCPART_OVERID_CONSUMABLES b
            on a.part_no = b.part_no
            and a.spo_location = b.spo_location
            and b.action_code <> 'D'
            and b.spo_location != 'FD2090'
            and b.tsl_override_type like 'ROQ%',
            whse c
        where a.part_no = c.part
        and a.spo_location != 'FD2090'
        and a.action_code <> 'D'
        and a.tsl_override_type like 'ROP%'
        and c.sc in (select max(sc) from whse d
            where a.part_no = d.part
            and d.sc like ('%CTLATL%'))
        having (c.stock_level -  sum(a.tsl_override_qty) -sum(b.tsl_override_qty) - 1) > 0
        group by a.part_no, c.stock_level
        order by a.part_no
        ) fleetLevels ;


    insert into tmp_locpart_overid_consumables
    (part_no,spo_location,tsl_override_type,tsl_override_qty,tsl_override_user,
    tsl_override_source,loc_sid,last_update_dt)              
    select
    part,'FD2090', 'Not Used', --(select rop_fixed_override from amd_spo_types_v), 
    stock_level - 1,    
    amd_lp_override_consumabl_pkg.getTslOverrideUser(part),
    'CALC',
    amd_lp_override_consumabl_pkg.GETWHSE_LOCSID,
    sysdate
    from whse a, amd_spare_parts b
    where a.created_datetime is not null
    and a.created_datetime = (select max(list.created_datetime)
                from whse list
                where list.part = a.part
                and list.sc like ('%CTLATL%'))
    and a.part = b.part_no
    and a.sc like '%CTLATL%'
    and b.action_code <> 'D'
    and b.is_spo_part = 'Y'
    and b.is_consumable = 'Y'
    and a.stock_level is not null
    and a.stock_level <> 0
    and  not exists (select null from tmp_locpart_overid_consumables
            where a.part = part_no and spo_location = 'FD2090'
            and tsl_override_type = 'Not Used') --(select rop_fixed_override from amd_spo_types_v) )
    and not exists (select null from tmp_locpart_overid_consumables
            where a.part = part_no and spo_location <> 'FD2090') ;    

        insert into tmp_locpart_overid_consumables
        (part_no,spo_location,tsl_override_type,tsl_override_qty,tsl_override_user,
    tsl_override_source,loc_sid,last_update_dt)              
    select
    part,'FD2090', 'Not Used', -- (select roq_fixed_override from amd_spo_types_v), 
    1,    
    amd_lp_override_consumabl_pkg.getTslOverrideUser(part),
    'CALC',
    amd_lp_override_consumabl_pkg.GETWHSE_LOCSID,
    sysdate
    from whse a, amd_spare_parts b
    where a.created_datetime is not null
    and a.created_datetime = (select max(list.created_datetime)
                from whse list
                where list.part = a.part
                and list.sc like ('%CTLATL%'))
    and a.part = b.part_no
    and a.sc like '%CTLATL%'
    and b.action_code <> 'D'
    and b.is_spo_part = 'Y'
    and b.is_consumable = 'Y'
    and a.stock_level is not null
    and a.stock_level <> 0
    and  not exists (select null from tmp_locpart_overid_consumables
            where a.part = part_no and spo_location = 'FD2090'
            and tsl_override_type = 'Not Used' ) --(select roq_fixed_override from amd_spo_types_v) ) 
    and not exists (select null from tmp_locpart_overid_consumables
            where a.part = part_no and spo_location <> 'FD2090') ;    

        
        
    
    end loadWhseX ;
    

    procedure loadWesm  is
        TYPE wesmRec IS RECORD (
            spo_prime_part_no amd_spare_parts.SPO_PRIME_PART_NO%type,
            loc_sid amd_location_part_override.LOC_SID%type,
            spo_location amd_locpart_overid_consumables.SPO_LOCATION%type,
            roq number,
            rop number,
            prime_part_no amd_national_stock_items.PRIME_PART_NO%type,
            nsn amd_national_stock_items.nsn%type,
            fsc l11.FSC%type,
            niin L11.NIIN%type,
            sran L11.sran%type,
            part L11.part%type,
            boeing_base_min_level L11.BOEING_BASE_MIN_LEVEL%type
        ) ;
        type wesmTab is table of wesmRec ;

        recs tmpLocPartOveridConsumablesTab := tmpLocPartOveridConsumablesTab() ;

        cursor wesm_data is
        select parts.spo_prime_part_no spo_prime_part_no, loc_sid,
        amd_utils.getSpoLocation(loc_sid) spo_location,
        case
            when boeing_base_max_level is not null and boeing_base_min_level is not null then
                case 
                    when boeing_base_max_level - boeing_base_min_level >= 1 then 
                        boeing_base_max_level - boeing_base_min_level
                    else
                        amd_defaults.ROQ
                end                                                
            else 
                amd_defaults.ROQ
        end roq,
        case
            when boeing_base_max_level is not null and boeing_base_min_level is not null then    
                case 
                    when boeing_base_max_level - boeing_base_min_level >= 1 then 
                        boeing_base_min_level
                    else
                        amd_defaults.ROP
                end
            else                                                                
                amd_defaults.getROP 
        end rop,
        items.prime_part_no,
        items.nsn,
        fsc, L11.niin, sran, part, boeing_base_min_level
        from L11,
        active_niins,
        amd_national_stock_items items,
        amd_spare_parts parts,
        amd_spare_networks nwks
        where source_of_supply = amd_defaults.getSourceCode
        and L11.niin = active_niins.niin
        and L11.nsn = items.nsn
        and items.nsn <> amd_defaults.getDELETE_ACTION
        and items.prime_part_no = parts.part_no
        and parts.is_spo_part = 'Y'
        and parts.is_consumable  = 'Y'
        and parts.part_no = parts.spo_prime_part_no
        and nwks.action_code <> amd_defaults.getDELETE_ACTION
        and L11.sran = substr(loc_id,3,4)
        and nwks.loc_id <> amd_defaults.GETAMD_WAREHOUSE_LOCID
        and (nwks.LOC_TYPE in ('MOB')
            or nwks.LOC_ID in (amd_defaults.getAMD_AUS_LOC_ID,amd_defaults.getAMD_UK_LOC_ID,
                                amd_defaults.getAMD_CAN_LOC_ID,amd_defaults.getAMD_WARNER_ROBINS_LOC_ID))
        and nwks.spo_location is not null ;

        wesmRecs wesmTab ;

        in_cnt number :=  0 ;
        insert_cnt number := 0 ;
        update_cnt number := 0 ;
        tsl_override_user tmp_locpart_overid_consumables.TSL_OVERRIDE_USER%type ;

    begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 560,
                pKey1 => 'loadWesm',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')) ;
        debugMsg('loadWesm started at ' 
        || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
            pError_location => 570) ; 
        open wesm_data ;
        fetch wesm_data bulk collect into wesmRecs ;
        close wesm_data ;

        if wesmRecs.first is not null then
            for indx in wesmRecs.first .. wesmRecs.last loop
                in_cnt := in_cnt + 1 ;

                tsl_override_user := getTslOverrideUserByNsn(wesmRecs(indx).nsn) ;

                if (wesmRecs(indx).roq + wesmRecs(indx).rop <> 0) or loadZeroTsls then
                
                    if isTestPart(wesmRecs(indx).spo_prime_part_no) then
                        debugMsg(wesmRecs(indx).spo_prime_part_no  
                        ||': rop= ' || wesmRecs(indx).rop 
                        || ' *** roq=' || wesmRecs(indx).roq || ' ***'
                        || ' spo_location=' || wesmRecs(indx).spo_location 
                        || ' loc_sid=' || wesmRecs(indx).loc_sid,  pError_location => 580) ;
                    end if ;

                    doInsert(part_no => wesmRecs(indx).spo_prime_part_no, spo_location => wesmRecs(indx).spo_location, loc_sid => wesmRecs(indx).loc_sid,
                        tsl_override_type => ROQ_TYPE, tsl_override_qty => wesmRecs(indx).roq, tsl_override_user => tsl_override_user,
                        tsl_override_source => WESM_SOURCE,
                        insert_cnt => insert_cnt,
                        update_cnt => update_cnt,
                        canUpdate => true) ;
                        --recs => recs) ;


                   doInsert(part_no => wesmRecs(indx).spo_prime_part_no, spo_location => wesmRecs(indx).spo_location, loc_sid => wesmRecs(indx).loc_sid,
                        tsl_override_type => ROP_TYPE, tsl_override_qty => wesmRecs(indx).rop, tsl_override_user => tsl_override_user,
                        tsl_override_source => WESM_SOURCE,
                        insert_cnt => insert_cnt,
                        update_cnt => update_cnt,
                        canUpdate => true) ;
                        --recs => recs) ;
                else
                    if isTestPart(wesmRecs(indx).spo_prime_part_no) then
                        debugMsg(wesmRecs(indx).spo_prime_part_no || ' rop + roq = 0', pError_location => 590) ;
                    end if ;
                end if ;


            end loop ;
        end if ;

        if recs.first is not null then
            forall indx in recs.first .. recs.last
                insert into tmp_locpart_overid_consumables
                values recs(indx) ;
            commit ;
            dbms_output.put_line(recs.count || ' recs loaded') ;
        else
            dbms_output.put_line('no recs loaded via bulk insert') ;
        end if ;

        debugMsg('loadWesm ended at ' 
        || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')
        || ' in_cnt='|| in_cnt 
        || ' insert_cnt=' || insert_cnt
        || ' and update_cnt=' || update_cnt,
            pError_location => 600) ; 

        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 610,
                pKey1 => 'loadWesm',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'in_cnt=' || to_char(in_cnt),
                pKey4 => 'insert_cnt=' || to_char(insert_cnt),
                pData => 'update_cnt=' || to_char(update_cnt) ) ;
        commit ;
    end loadWesm ;


     procedure loadVirtualLocations is
        type spoPrimePartTab is table of amd_spare_parts.spo_prime_part_no%type ;
        spoPrimePartRecs spoPrimePartTab ;

        cursor consumableParts is
        select spo_prime_part_no
        from amd_spare_parts 
        where is_spo_part = 'Y'
    and part_no = spo_prime_part_no
        and is_consumable = 'Y' ;

        recs tmpLocPartOveridConsumablesTab := tmpLocPartOveridConsumablesTab() ;


        insert_cnt number := 0 ;
        update_cnt number := 0 ;
        in_cnt number := 0 ;
        tsl_override_user tmp_locpart_overid_consumables.TSL_OVERRIDE_USER%type ;
     begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 620,
            pKey1 => 'loadVirtualLocations',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')) ;
        dbms_output.put_line('loadVirtualLocations') ;
        open consumableParts ;
        fetch consumableParts bulk collect into spoPrimePartRecs ;
        close consumableParts ;

        if spoPrimePartRecs.first is not null then
            for indx in spoPrimePartRecs.first .. spoPrimePartRecs.last loop
                in_cnt := in_cnt + 1 ;

                tsl_override_user := getTslOverrideUser(spoPrimePartRecs(indx) ) ;

               doInsert(part_no => spoPrimePartRecs(indx), spo_location => VIRTUAL_UAB, loc_sid => null,
                    tsl_override_type => ROQ_TYPE, tsl_override_qty => amd_defaults.ROQ, tsl_override_user => tsl_override_user,
                    tsl_override_source => GOLD_SOURCE,
                    insert_cnt => insert_cnt,
                    update_cnt => update_cnt,
                    canUpdate => false) ;
                    --recs => recs) ;

               doInsert(part_no => spoPrimePartRecs(indx), spo_location => VIRTUAL_COD, loc_sid => null,
                    tsl_override_type => ROP_TYPE, tsl_override_qty => amd_defaults.ROP, tsl_override_user => tsl_override_user,
                    tsl_override_source => GOLD_SOURCE,
                    insert_cnt => insert_cnt,
                    update_cnt => update_cnt,
                    canUpdate => false) ;
                    --recs => recs) ;

               doInsert(part_no => spoPrimePartRecs(indx), spo_location => VIRTUAL_COD, loc_sid => null,
                    tsl_override_type => ROQ_TYPE, tsl_override_qty => amd_defaults.ROQ, tsl_override_user => tsl_override_user,
                    tsl_override_source => GOLD_SOURCE,
                    insert_cnt => insert_cnt,
                    update_cnt => update_cnt,
                    canUpdate => false) ;
                    --recs => recs) ;


               doInsert(part_no => spoPrimePartRecs(indx), spo_location => VIRTUAL_UAB, loc_sid => null,
                    tsl_override_type => ROP_TYPE, tsl_override_qty => amd_defaults.ROP, tsl_override_user => tsl_override_user,
                    tsl_override_source => GOLD_SOURCE,
                    insert_cnt => insert_cnt,
                    update_cnt => update_cnt,
                    canUpdate => false) ;
                    --recs => recs) ;

            end loop ;
        end if ;
        if recs.first is not null then
            forall indx in recs.first .. recs.last
                insert into tmp_locpart_overid_consumables
                values recs(indx) ;
            dbms_output.put_line(recs.count || ' recs loaded') ;
            commit ;
        else
            dbms_output.put_line('no recs loaded via bulk insert') ;
        end if ;
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 630,
                pKey1 => 'loadVirtualLocations',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'in_cnt=' || to_char(in_cnt),
                pKey4 => 'insert_cnt=' || to_char(insert_cnt),
                pData => 'update_cnt=' || to_char(update_cnt)) ;
     end loadVirtualLocations ;

    function doLPOverrideConsumablesDiff(part_no in varchar2, spo_location in varchar2, tsl_override_type in varchar2,
        tsl_override_user in varchar2, tsl_override_source in varchar2, tsl_override_qty in number, loc_sid in number, action_code in varchar2) return number is


        procedure updateRow is
        begin
            update amd_locpart_overid_consumables
            set tsl_override_user = doLPOverrideConsumablesDiff.tsl_override_user,
            tsl_override_source = doLPOverrideConsumablesDiff.tsl_override_source,
            tsl_override_qty = doLPOverrideConsumablesDiff.tsl_override_qty,
            loc_sid = doLPOverrideConsumablesDiff.loc_sid,
            action_code = doLPOverrideConsumablesDiff.action_code,
            last_update_dt = sysdate
            where part_no = doLPOverrideConsumablesDiff.part_no
            and spo_location = doLPOverrideConsumablesDiff.spo_location
            and tsl_override_type = doLPOverrideConsumablesDiff.tsl_override_type ;

        exception when others then
            errorMsg(pSqlfunction       => 'update',pTableName  => 'AMD_LOCPART_OVERID_CONSUMABLES',
                pError_location => 640,
                pKey1 => 'part_no=' || part_no,
                   pKey2 => 'spo_location=' || spo_location,
                pKey3              => 'tsl_override_type=' || tsl_override_type,
                pKey4 => 'tsl_override_user=' || tsl_override_user ) ;
            raise ;
        end updateRow ;

        procedure insertRow is
            cur_action_code amd_locpart_overid_consumables.action_code%type ;
        begin
            if isValidTslData(override_type => tsl_override_type, override_quantity => tsl_override_qty) then
                insert into amd_locpart_overid_consumables
                (part_no, spo_location, tsl_override_type, tsl_override_user, tsl_override_source, tsl_override_qty, loc_sid, last_update_dt, action_code)
                values(part_no, spo_location, tsl_override_type, tsl_override_user, tsl_override_source, tsl_override_qty, loc_sid, sysdate, action_code) ;
            end if ; -- Xzero

        exception
            when standard.DUP_VAL_ON_INDEX then
                select action_code into cur_action_code from amd_locpart_overid_consumables
                where part_no = doLPOverrideConsumablesDiff.part_no
                and spo_location = doLPOverrideConsumablesDiff.spo_location
                and tsl_override_type = doLPOverrideConsumablesDiff.tsl_override_type ;
                if cur_action_code = 'D' then
                    updateRow ;
                else
                    raise ;
                end if ;
            when others then
                errorMsg(pSqlfunction       => 'insert',pTableName  => 'AMD_LOCPART_OVERID_CONSUMABLES',
                    pError_location => 650,
                    pKey1 => 'part_no=' || part_no,
                    pKey2 => 'spo_location=' || spo_location,
                    pKey3              => 'tsl_override_type=' || tsl_override_type,
                    pKey4 => 'tsl_override_user=' || tsl_override_user ) ;
                raise ;
        end insertRow ;



    begin

        /*
        writeMsg(pTableName => 'doLPOverrideConsumablesDiff', pError_location => 660,
           pKey1 => 'doUpdate.part_no=' || part_no,
           pKey2 => 'spo_location=' || spo_location,
           pKey3 => 'type=' || tsl_override_type,
           pKey4 => 'user=' || tsl_override_user,
           pData => 'source=' || tsl_override_source,
           pComments => 'qty=' || to_char(tsl_override_qty) || ' loc_sid=' || to_char(loc_sid) || ' action_code=' || action_code) ;

        return 0 ;
        */

        if action_code = 'A' then
            begin
                insertRow ;
            exception when standard.DUP_VAL_ON_INDEX then
                if not loggedDup then
                    writeMsg(pTableName => 'tmp_locpart_overid_consumables', pError_location => 670,
                        pKey1 => 'part_no=' || part_no,
                        pKey2 => 'spo_location=' || spo_location,
                        pKey3 => 'tsl_override_type=' || tsl_override_type,
                        pKey4 => 'DUP_VAL_ON_INDEX') ;
                    loggedDup := true ;
                end if ;
                return 0 ; -- row already exists: ignore since the diff's aging buffer may have gotten full
            end ;
        else
            updateRow ;
        end if ;

        declare
            result boolean ;
        begin
            result := true ;
            /* all A2A code has been eliminated from package amd_location_part_override_pkg
            result := amd_location_part_override_pkg.insertedTmpA2ALPO (
                  pPartNo    => part_no,
                  pBaseName    => spo_location,
                  pOverrideType => tsl_override_type,
                  pTslOverrideQty => tsl_override_qty,
                  pOverrideReason => amd_location_part_override_pkg.OVERRIDE_REASON,
                  pTslOverrideUser => tsl_override_user,
                  pBeginDate => sysdate,
                  pActionCode => action_code,
                  pLastUpdateDt => sysdate) ;
                  */
       end ;


        return 0 ;
    exception when others then
        errorMsg(pSqlfunction       => 'diff',pTableName  => 'AMD_LOCPART_OVERID_CONSUMABLES',
            pError_location => 680,
            pKey1 => 'part_no=' || part_no,
            pKey2 => 'spo_location=' || spo_location,
            pKey3 => 'tsl_override_type=' || tsl_override_type,
            pKey4 => 'tsl_override_user=' || tsl_override_user ) ;
        raise ;
    end doLPOverrideConsumablesDiff;

    procedure initialize(action_code in varchar2 := null) is
    begin
        mta_truncate_table('amd_locpart_overid_consumables','reuse storage') ;


        loadLocPartOverrides ;
        commit ;

        insert into amd_locpart_overid_consumables
            select * from tmp_locpart_overid_consumables where isValidTslDataYorN(tsl_override_type, tsl_override_qty) = 'Y' ;
        commit ;


    end initialize ;


     procedure loadLocPartOverrides is
     begin
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 690,
            pKey1 => 'loadLocPartOverrides',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')) ;
        mta_truncate_table('tmp_locpart_overid_consumables','reuse storage') ;
        loadWesm ; -- always run this first
        loadBasc ;
        loadUK ;
        loadCanada ;
        loadAustrailia ;
        loadLvls ;
        loadRamp ;
        if useLoadWhseX then
            loadWhseX ;
        else
            loadWhse ;
        end if ;                        
        if loadZeroTsls then
            loadVirtualLocations ;
        end if ;
        writeMsg(pTableName => 'tmp_amd_location_part_override', pError_location => 700,
            pKey1 => 'loadLocPartOverrides',
            pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')) ;
        commit ;
     end  loadLocPartOverrides ;


    function getROQ_TYPE return amd_locpart_overid_consumables.TSL_OVERRIDE_TYPE%type is
    begin
        return ROQ_TYPE ;
    end getROQ_TYPE ;

    function getROP_TYPE return amd_locpart_overid_consumables.tsl_override_type%type is
    begin
        return ROP_TYPE ;
    end getROP_TYPE ;

    function getGOLD_SOURCE return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type is
    begin
        return GOLD_SOURCE ;
    end getGOLD_SOURCE ;

    function getWESM_SOURCE return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type is
    begin
        return WESM_SOURCE ;
    end getWESM_SOURCE ;

    function getNONWESM_SOURCE return AMD_LOCPART_OVERID_CONSUMABLES.TSL_OVERRIDE_SOURCE%type is
    begin
        return NONWESM_SOURCE ;
    end getNONWESM_SOURCE ;

    function getWHSE_LOCSID return number is
    begin
        return WHSE_LOCSID ;
    end getWHSE_LOCSID ;

    function getWHSE_LOCID return number is
    begin
        return WHSE_LOCID ;
    end getWHSE_LOCID ;

    function getDebugYorN return varchar2 is
    begin
        if debug then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end getDebugYorN ;

    procedure setDebug(switch in varchar2) is
    begin
        debug := upper(switch) in ('Y','T','YES','TRUE') ;
        if debug then
            dbms_output.ENABLE(buffer_size => 1000000) ;
        end if ;
    end setDebug ;

    function getLoadZeroTslsYorN return varchar2 is
    begin
        if loadZeroTsls then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end getLoadZeroTslsYorN ;

    procedure setLoadZeroTsls(switch in varchar2) is
    begin
        loadZeroTsls := upper(switch) in ('Y','T','YES','TRUE') ;
    end setLoadZeroTsls ;

    function getInsertDataYorN return varchar2 is
    begin
        if insertData then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end getInsertDataYorN ;

    procedure setInsertData(switch in varchar2) is
    begin
        insertData := upper(switch) in ('Y','T','YES','TRUE') ;
    end setInsertData ;

    function isValidTslData(
        override_type in amd_locpart_overid_consumables.tsl_OVERRIDE_TYPE%type,
        override_quantity in amd_locpart_overid_consumables.tsl_OVERRIDE_qty%type) return boolean is
    begin
        return override_quantity is not null and (override_quantity <> 0 or override_type = ROP_TYPE) ;
    end isValidTslData ;

    function isValidTslDataYorN(override_type in AMD_LOCPART_OVERID_CONSUMABLES.tsl_OVERRIDE_TYPE%type,
        override_quantity in amd_locpart_overid_consumables.tsl_OVERRIDE_qty%type) return varchar2 is
    begin
        if isValidTslData(override_type, override_quantity) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isValidTslDataYorN ;

    procedure version IS
    begin
        writeMsg(pTableName => 'amd_lp_override_consumabl_pkg',
             pError_location => 730, pKey1 => 'amd_lp_override_consumabl_pkg', pKey2 => '$Revision:   1.90  $') ;
        dbms_output.put_line('amd_lp_override_consumabl_pkg: $Revision:   1.90  $') ;
    end version ;

    function getVersion return varchar2 is
    begin
        return '$Revision:   1.90  $' ;
    end getVersion ;
    
    procedure setUseLoadWhseX(value in varchar2) is
    begin
        useLoadWhseX := upper(value) in ('Y','YES','T','TRUE') ;
    end setUseLoadWhseX ;
    
    function getUseLoadWhseX return varchar2 is
    begin
        if useLoadWhseX then
            return 'Y' ;
        else
            return 'N' ;
        end if ;            
    end getUseLoadWhseX ;


begin
    declare
        function getDebug return boolean is
            debug varchar2(50) ;
        begin
            debug := trim(amd_defaults.getParamValue('debugAmd_lp_override_consumabl_pkg')) ;

            return debug is null or upper(debug) in ('Y','T','YES','TRUE') ;
        end getDebug ;
    begin
        amd_lp_override_consumabl_pkg.debug := getDebug ;
        if debug then
            debugMsg('*package init with debug at ' || to_char(sysdate,'MM/DD/YYYY HH:MI:SS AM'),
                pError_location => 740) ;
        end if ;
    end ;

    select part_no bulk collect into testParts from amd_test_parts ;
    --select rop_fixed_override into rop_type from amd_spo_types_v ;
    rop_type := 'Not Used' ; 
    --select roq_fixed_override into roq_type from amd_spo_types_v ;
    roq_type := 'Not used' ;
end Amd_lp_override_consumabl_Pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_MAINT_TASK_DISTRIBS_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_maint_task_distribs_pkg
is
    /*

       $Author:   c970183  $
     $Revision:   1.6  $
         $Date:   Jun 13 2005 09:02:46  $
     $Workfile:   amd_maint_task_distribs_pkg.pkb  $
	      $Log:   \\www-amssc-01\pds\archives\SDS-AMD\Database\Packages\amd_maint_task_distribs_pkg.pkb-arc  $

      Rev 1.6   Jun 13 2005 09:02:46   c970183
   Added PVCS keywords
*/
  ERRSOURCE constant varchar2(30) := 'Amd Mtd Pkg';
  smrCodeNotAcceptable exception;
   -------------------------------------------------------------------
   --  Date	  		  By			History
   --  ----			  --			-------
   --  10/25/01		  ks			initial implementation
   --  06/01/05		  ks			change reference to rampData
   -------------------------------------------------------------------



    -- ks: below comments lifted from previous package --

    /* ------------------------------------------------------------------- */
	/*  this procedure assigns the produce the values of condemnation,     */
	/*  repair this station and not repair this station rates.             */
	/*           */
	/*  the input will come from percent_base_condem, percent_base_repair  */
	/*  from ramp table in gold system.                                    */
	/*  the default rules are established as below :                       */
	/*  (per mary bacskai)      */
	/*  ------------------------------------------------------------------ */

	/*  ------------------------------------------------------------------

	this is the change required for maint task distribs. it's kinda a big change and it probably isn't quick,
	and i know we are on the hook to start reloading amd on a daily basis.
		sorry - take a look then lets talk about it.  i may be out of the office this afternoon, but will be in
	all day tomorrow if theres any questions.

	***************************************************************************************************************************

	amd_maint_task_distribs table currently only contains entries when there is a ramp record in gold
	for that nsn and segregation code. the model needs a maint task distribs entry for each part and location
	that it could possibly model for.  therefore, a row for every combination of part in amd_spare_parts
	and location in amd_spare_networks (with a location type of mob or fsl) must be created in the
	load process.  currently, these are the locations that require entries
	(use amd_spare_networks to determine the current mobs or fsls):

	loc_id        location_name        loc
	-------------      -------------------------      ---
	fb4418        charleston  afb           mob
	fb4479        mcchord ab                mob
	fb4419        altus afb      mob
	fb6242        jackson ang               mob
	fb4415        anderson afb              fsl
	fb4497        dover ab      fsl
	fb4480        elmendorf ab               fsl
	fb4405        hickam ab                  fsl
	fb4490        howard ab                  fsl
	fb4402        incirlik ab      fsl
	fb4411        kadena ab                  fsl
	fb4400        lajes field      fsl
	fb4484        mcguire ab                 fsl
	fb4488        pope      fsl
	fb4406        raf mildenhall            fsl
	fb4401        ramstein ab               fsl
	fb4403        rhein main ab             fsl
	fb4409        rota ns      fsl
	fb4427        travis      fsl
	fb4408        yokota ab      fsl
	this will increase the size of this table to approximately 20 records per prime in amd_spare_parts.
	to support this, please make the following changes to the load process:

	1.  if the cond, rts, and nrts fields are all present for an nsn/location in ramp, create a amd_maint_task_distribs
	per current process with an act_proj_ind of 'a' (for actual).  all other entries in this table will have an act_proj_ind
	of 'P' (projected), which states that a default was applied to one or more of these fields.
	2.  there should be one record for each of the  locations with a loc_type of 'MOB' or 'FSL' in amd_spare_networks
		for each part   number in amd_spare_parts.  an entire record must be create with an actual/projected indicator of 'P'
	with the appropriate defaults.
	3.  the former defaults no longer apply.  the matrix that was previously used to compensate for missing data has been
		replaced with an approach that relies heavily on the type of part it is (i.e. repairable or consumable).  repairable parts
		are identified by the 6th digit of the smr code (in amd_spare_parts) being equal to 'T'.  consumable parts have
	a 6th position of 'N', and quasi repairable parts have a 6th position of 'p.  the new defaults are as follows.
	parts with a 6th position of the smr code equal to 'T' default to 100% nrts if all three fields are missing.
		if some data is available, any remaining portion is put into nrts and the excess taken from rts.
	parts with a 6th position of the smr code equal to 'N' coded default is 100% cond if all three fields are missing.
		if some data is available, any unaccounted for percentage is added to cond, excess would be taken from cond
		and an error message to that effect should be produced. (consumable parts should not have any rts or nrts,
		so this smr code is probably in error and should be noted as such)
	when the 6th position of the smr code is 'P', the 5th position and the amd_spare_networks location type
		needs to be examined as well.  if characters 5-6 of the smr code are fp and the location is an fsl, the default is
		100% nrts.  if characters 5-6 of the smr code are fp and the location is an mob,
		the default is 95% rts, 5% cond, 0 nrts.  if characters 5-6 of the smr code are op,
		the default is 95% rts, 5% cond, 0 nrts.  if position 6 is 'P' and  5-6 is something other than fp or op,
		use 100% nrts at the fsl, 95% rts, 5% cond, 0 nrts at the  mobs.
	4.  the sum of cond, rts, and nrts must equal one.  if any one of these fields are blank then defaults should be
		applied to the unaccounted for portion.  if there is some available data, and it does not add up to 1,
		the unaccounted for portion should be added or subtracted per the above instructions based on the 6th position
		of the smr code.  if the sum is over 1.5, the following formula should be applied to find the rts:
		the cond would be .005, and the newly calculated rts will give you the ability to find nrts by subtracting
		the two existing   numbers from 1.

		rts = (rts/(nrts + rts)) x .995) and cond would be .005.

	other smr codes that aren't 'T', 'P' or 'N' (afo, xc, and paodd1 smrs are present in amd)
	will require further analysis
	and direction.

	1/31/2000

	per our discussion 5 minutes ago:
		1.  if the sum of the percent base repair and percent base condemn is greater than one,
		do not put a maint task distribs record in the table and send a message to
		the error report saying
		'warning - mtd percentage greater than 1'  with the part and location.
		(this will not keep the part from spare parts,  however)
		2.  nrts field is only calculated from percent base repair and percent base condemn
		fields in gold.
		if both of these fields are present and the total is not greater than 1,
		give that record an actual  projected indicator of 'a'.
		in all other cases the actual projected indicator will be 'P'.

	2/3/2000

	'P' coded parts at the mob when it's an 'a' (actual record - meaning there is a ramp record
	with a value (even zero) in percent base condemn and percent base repair) have an additional
	piece of logic -  to specify what to do with 'extra' percentages for 'P' coded.
	the 'extra' percentages should go into cond up to 5%, and the rest to rts.
	using some of our real life examples:
	ramp % cond = 0,  % repair = 99    in this case, the remaining percentage would go to cond,
	making the mtd nrts 0, rts .99, cond .01
	ramp % cond = 0,  % repair = 0      in this case, the first .05 goes to cond,
	the remaining .95 to rts, nrts still 0

		-------------------------------------------------------------------------------------- */
    -- ks: to avoid rewriting logic, changed all goto end_rep_rate to return.  procedure barely
	-- touched.
	procedure GetRepairRate(
							locType  in   varchar2,
							smr6     in   varchar2,
							smr5     in   varchar2,
							rampRts  in   number,
							rampCond in   number,
							rtsPc   out   number,
							nrtsPc  out   number,
							condPc  out   number) as

		cnt        number;
		temp       varchar2(20);
		lRampRts   number;
		lRampcond  number;
        ws_ramprts   number;
		ws_rampCond  number;

	begin
		--
		--  note:
		--        1) ramp has only rts and condemnation rates
		--        2) smr6 must be 'T', 'N', or 'P'
		--        3) locType must be 'ROR', 'MOB' or 'FSL'


		if smr6 = 'T'  and (locType in ('MOB', 'FSL')) then
            ws_ramprts  := 0;
            ws_rampCond := 0;
			nrtsPc      := 1.0000 ;
			rtsPc       := ws_ramprts;
			condPc      := ws_rampCond;

			return ;      -- goto end_rep_rate;
		end if;

        if smr6 = 'T'  and locType = 'ROR'  then
            ws_ramprts   := 0.995;
            ws_rampCond  := 0.005;
			nrtsPc       := 1.0000 - ws_ramprts - ws_rampCond;
			rtsPc        := ws_ramprts;
			condPc       := ws_rampCond;

			return ;      -- goto end_rep_rate;
		end if;


        if smr6 = 'P'  and locType = 'MOB'  then
            ws_ramprts  := 0.20;
            ws_rampCond := 0.80;
			nrtsPc      := 1.0000 - ws_ramprts - ws_rampCond;
			rtsPc       := ws_ramprts;
			condPc      := ws_rampCond;

			return ;      -- goto end_rep_rate;
		end if;

        if smr6 = 'P'  and locType = 'FSL'  then
            ws_ramprts  := 0;
            ws_rampCond := 1.0000;
			condPc      := 1.0000 - ws_ramprts;
			rtsPc       := ws_ramprts;
			nrtsPc      := 0;

			return ;      -- goto end_rep_rate;
		end if;


		if smr6 = 'P'  and locType = 'ROR'  then
            ws_ramprts   := 0;
            ws_rampCond  := 1.000;
			nrtsPc       := 1.0000 - ws_ramprts - ws_rampCond;
			rtsPc        := ws_ramprts;
			condPc       := ws_rampCond;

			return ;      -- goto end_rep_rate;
		end if;

		if smr6 = 'N' then
		    ws_ramprts  := 0;
            ws_rampCond := 1.0000;
			condPc      := 1.0000 - ws_ramprts;
			rtsPc       := ws_ramprts;
			nrtsPc      := 0;

			return ;      -- goto end_rep_rate;
		end if;

		if smr6 = 'P' and smr5 = 'O' then

			-- use same condition for both ramprts and rampCond for null or 0.00

			lRampRts  := nvl(ws_ramprts,0);   -- use local variable
			lRampcond := nvl(ws_rampCond,0);   -- use local variable

			if    lRampRts = 0 and lRampcond = 0 then
				nrtsPc := 0.00;
				rtsPc  := 0.95;
				condPc := 0.05;
				return ;      -- goto end_rep_rate;

			elsif lRampRts > 0 and lRampcond > 0 then
				rtsPc  := lRampRts;
				condPc := lRampcond;
				nrtsPc := 1 - rtsPc - condPc;
				return ;      -- goto end_rep_rate;

			elsif lRampRts > 0 and lRampcond = 0 then
				rtsPc  := lRampRts;
				if (1 - rtsPc) > 0.05 then
					condPc := 0.05;
					nrtsPc := 1 - rtsPc - condPc;
					return ;      -- goto end_rep_rate;
				else
					condPc := 1 - rtsPc;
					nrtsPc := 1 - rtsPc - condPc;  -- nrtsPc should be 0
					return ;      -- goto end_rep_rate;
				end if;

			elsif lRampRts = 0 and lRampcond > 0 then

				condPc := rampCond;
				if ( 1 - condPc ) > 0.95 then
					rtsPc  := 0.95;
					nrtsPc := 1 - condPc - rtsPc;
					return ;      -- goto end_rep_rate;
				else
					rtsPc  := 1 - condPc;
					nrtsPc := 1 - condPc - rtsPc; -- nrtsPc should be 0
					return ;      -- goto end_rep_rate;
				end if;

			end if;

		elsif smr6 = 'P' and smr5 != 'O' then

			-- for smr6 = 'P' and smr5 != 'O'

			if locType = 'MOB' then

				-- use same condition for both ramprts and rampCond for null or 0.00

				lRampRts  := nvl(ws_ramprts,0);   -- use local variable
				lRampcond := nvl(ws_rampCond,0);  -- use local variable

				if    lRampRts = 0 and lRampcond = 0 then

					nrtsPc := 0.00;
					rtsPc  := 0.95;
					condPc := 0.05;
					return ;      -- goto end_rep_rate;

				elsif lRampRts > 0 and lRampcond > 0 then

					rtsPc  := lRampRts;
					condPc := lRampcond;
					nrtsPc := 1 - rtsPc - condPc;
					return ;      -- goto end_rep_rate;

				elsif lRampRts > 0 and lRampcond = 0 then

					rtsPc  := lRampRts;
					if (1 - rtsPc) > 0.05 then
						condPc := 0.05;
						nrtsPc := 1 - rtsPc - condPc;
						return ;      -- goto end_rep_rate;
					else
						condPc := 1 - rtsPc;
						nrtsPc := 1 - rtsPc - condPc;  -- nrtsPc should be 0
						return ;      -- goto end_rep_rate;
					end if;

				elsif lRampRts = 0 and lRampcond > 0 then

					condPc := ws_rampCond;
					if ( 1 - condPc ) > 0.95 then
						rtsPc  := 0.95;
						nrtsPc := 1 - condPc - rtsPc;
						return ;      -- goto end_rep_rate;
					else
						rtsPc  := 1 - condPc;
						nrtsPc := 1 - condPc - rtsPc; -- nrtsPc should be 0
						return ;      -- goto end_rep_rate;
					end if;
				end if;
			else
				--locType = 'FSL' then

				condPc := nvl(ws_rampCond,0);
				rtsPc  := nvl(ws_ramprts,0);
				nrtsPc := 1.0000 - condPc - rtsPc;
				return ;      -- goto end_rep_rate;
			end if;
		end if;
  end GetRepairRate;


  procedure InsertIntoAmdMtd(pRec amd_maint_task_distribs%rowtype) is
  begin
  	   insert into amd_maint_task_distribs
	   		  (
			  nsi_sid,
			  loc_sid,
			  effective_date,
			  act_proj_ind,
			  cond,
			  cond_defaulted,
			  nrts,
			  nrts_defaulted,
			  rts,
			  rts_defaulted
			  )
	   values (
	   		  pRec.nsi_sid,
			  pRec.loc_sid,
			  pRec.effective_date,
			  pRec.act_proj_ind,
			  pRec.cond,
			  pRec.cond_defaulted,
			  pRec.nrts,
			  pRec.nrts_defaulted,
			  pRec.rts,
			  pRec.rts_defaulted
		);
  exception
  		   -- should not occur
  	   when dup_val_on_index then
	   		amd_utils.InsertErrorMsg(amd_utils.GetLoadNo(ERRSOURCE, 'AMD_MAINT_TASK_DISTRIBS'),pRec.nsi_sid, pRec.loc_sid, null, null, null, 'dup val on index');

  end InsertIntoAmdMtd;

  procedure loadAmdMtd is
  			-- ks: list will have mob, fsl and all parts to ror (exclude warehouse)
			-- this corresponds with current scope of amd_mtd and amd_repair_levels.
			-- ignore those that are logically deleted from ansi and asn so table is "current".
	 countRecs number := 0;
	 cursor mtdPartLocList_cur is
  		 select ansi.nsi_sid, ansi.nsn, ansi.prime_part_no as part_no, asn.loc_id, asn.loc_type, asn.loc_sid
		 from
		 	  amd_part_locs apl,
		 	  amd_national_stock_items ansi,
			  amd_spare_networks asn
		 where
		 	  apl.nsi_sid = ansi.nsi_sid and
			  apl.loc_sid = asn.loc_sid and
			  asn.loc_type in ('MOB', 'FSL', 'ROR') and
			  ansi.action_code != amd_defaults.DELETE_ACTION and
			  asn.action_code != amd_defaults.DELETE_ACTION;


	 amdMtdRec amd_maint_task_distribs%rowtype;
	 smrCode amd_national_stock_items.smr_code%type;
	 /* kcs change 06/01/05
	 rampData amd_part_locs_load_pkg.rampData_rec;
	 */
	 rampData ramp%ROWTYPE ;
	 rtsPc number;
	 nrtsPc number;
	 condPc number;
  begin
	 	 for mtdPartLoc in mtdPartLocList_cur
	 	 loop
		 	 begin
			 	  -- initialize those reused in loop
			 	rtsPc := null;
				nrtsPc := null;
				condPc := null;
			 	amdMtdRec := null;
			 	rampData := null;
				smrCode := null;

			 	amdMtdRec.nsi_sid := mtdPartLoc.nsi_sid;
				amdMtdRec.loc_sid := mtdPartLoc.loc_sid;
				 	-- ks: current rampData only has fsl or mob, not ror => don't bother looking if ROR or other
				if (mtdPartLoc.loc_type in ('FSL', 'MOB')) then
				 	rampData := amd_part_locs_load_pkg.GetRampData(mtdPartLoc.nsn, mtdPartLoc.loc_id);
				end if;
				if (rampData.percent_base_repair is not null) then
					amdMtdRec.rts := rampData.percent_base_repair / 100.00;
	  			end if;
				if (rampData.percent_base_condem is not null) then
					amdMtdRec.cond := rampData.percent_base_condem / 100.00;
				end if;

					--
					-- check ramp data, if invdate is null, default to
					-- sysdate and generate the warning message.
					--

				if (rampData.date_processed is null) then
					amdMtdRec.effective_date := trunc(SYSDATE);
					-- ins_err_msg(loadno, partno, locid, '', '', 'gold/spareinv',
					--		'no inv_date/date_processed found in ramp, use sysdate' );
				else
					amdMtdRec.effective_date := rampData.date_processed;
			  	end if;
				 	--
					-- if ramp has both rts and cond, actprojind = 'a',
					-- else actprojind = 'P'
					--

				if  ( (amdMtdRec.rts  is not null) and (amdMtdRec.cond is not null) ) then
					amdMtdRec.act_proj_ind := ACTUAL;
				else
					amdMtdRec.act_proj_ind := PROJECTED;
				end if;

					--
					-- if the sum of rts and cond from ramp is greater than 1,
					-- use default values
					-- and generate the error message
					--

				if (nvl(amdMtdRec.cond,0) + nvl(amdMtdRec.rts,0)) > 1 then
					amdMtdRec.cond := 0;
					amdMtdRec.rts  := 0;
					-- ins_err_msg(loadno, partno, cage, cat1nsn, rampsc,
					--		'gold/spareinv',
					--		'warning: '||cat1nsn||' has rts + cond > 1, use default values.' );
				end if;
				smrCode := amd_preferred_pkg.GetSmrCode(mtdPartLoc.nsn);
				if (Length(smrCode) < 6) then
				   raise smrCodeNotAcceptable;
				end if;
					-- ks: rtsPc, nrtsPc, condPc are OUT parameters
				GetRepairRate(mtdPartLoc.loc_type, substr(smrCode,6,1), substr(smrCode,5,1), amdMtdRec.rts, amdMtdRec.cond, rtsPc, nrtsPc, condPc);
				amdMtdRec.rts := null;
				amdMtdRec.rts_defaulted := rtsPc;
				amdMtdRec.nrts := null;
				amdMtdRec.nrts_defaulted := nrtsPc;
				amdMtdRec.cond := null;
				amdMtdRec.cond_defaulted := condPc;

				InsertIntoAmdMtd(amdMtdRec);
				countRecs := countRecs + 1;
				if (countRecs > COMMIT_AFTER) then
				   commit;
				   countRecs := 0;
				end if;
			exception
					 when smrCodeNotAcceptable then
					 	  -- ks: current direction: default nrts,rts,cond rely on 5th and 6th
						  -- position of smr, exclude creating mtd records if smr < 6 since no
						  -- current default logic for them.
					 	  null;
					 when no_data_found then
					 	  -- can be thrown when smr_code is null
						  null;
					 when others then
					 	  amd_utils.InsertErrorMsg(amd_utils.GetLoadNo(ERRSOURCE, 'loadamdmtd'),mtdpartloc.nsi_sid, mtdpartloc.loc_sid, null, null, null, substr(SQLCODE || ' ' || SQLERRM,1, 2000));

			end;
	 	 end loop;
		 commit;
  end loadAmdMtd;

begin
	 null;
end amd_maint_task_distribs_pkg;
/


DROP PACKAGE BODY AMD_OWNER.AMD_NSL_SEQUENCE_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_nsl_sequence_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.13  $
     $Date:   16 Oct 2007 11:24:38  $
    $Workfile:   amd_nsl_sequence_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_nsl_sequence_pkg.pkb-arc  $

      Rev 1.13   16 Oct 2007 11:24:38   zf297a
   Fixed writeMsg literal

      Rev 1.13   16 Oct 2007 11:21:50   zf297a
   Fixed literals in writeMsg

      Rev 1.12   16 Oct 2007 10:08:40   zf297a
   Fixed writeMsg in version procedure

      Rev 1.11   16 Oct 2007 10:05:52   zf297a
   implemented version interface

      Rev 1.10   25 Aug 2007 21:54:52   zf297a
   Added hint to sql statement in function getNslFromAmd to make sure Oracle uses the correct index in its execution plan.  This nested function's parent function, sequenceThsNsl, is invoked by amd_load.loadGold.

      Rev 1.9   Dec 01 2005 09:36:48   zf297a
   added pvcs keywords
*/
	/*
		Purpose: Use the following function to sequence
		an NSL.
		Douglas S. Elder	10/14/01	Initial Implementation
	*/
	function SequenceTheNSL(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.nsn%type is

		nsn amd_spare_parts.nsn%type := null ;

		function UseBssmNsls return boolean is
		begin
			if upper(amd_defaults.USE_BSSM_TO_GET_NSLs) = 'Y' then
				return true ;
			else
				return false ;
			end if ;
		exception when NO_DATA_FOUND then
			return false ;
		end UseBssmNsls ;

		function GetNslFromBssm(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.nsn%type is
			nsn amd_spare_parts.nsn%type := null ;
			RAW_DATA constant bssm_parts.lock_sid%type := '0';
		begin
			select distinct
				parts.nsn into nsn
			from bssm_parts parts
			where
				parts.part_no      = pPart_no
				and parts.lock_sid = RAW_DATA
				and nsn like 'NSL#%';

			return nsn ;
		exception when NO_DATA_FOUND then
			return null ;
		end GetNslFromBssm;

		function GetNslFromAmd(
							pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.nsn%type is
			nsn amd_spare_parts.nsn%type := null ;
		begin
			select /*+ INDEX(an amd_nsns_nk01) */

				an.nsn
			into nsn
			from
				amd_nsns an,
				amd_nsi_parts anp
			where
				anp.part_no      = pPart_no
				and anp.nsi_sid  = an.nsi_sid
				and anp.unassignment_date is null
				and an.nsn_type = 'C'
				and an.nsn like 'NSL%';

			return nsn;
		exception
			when NO_DATA_FOUND then
				return null ;
		end GetNslFromAmd;

	begin
		if UseBssmNsls() then
			nsn := GetNslFromBssm(pPart_no) ;
		end if;

		if (nsn is null) then
			nsn := GetNslFromAmd(pPart_no);
		end if;

		if nsn is null then
			-- BSSM and AMD have not assigned an NSL sequence
			-- number for this part, so AMD will generate
			-- one.
			declare
				nsn_seq_no number := 0 ;
			begin
				select amd_nsn_seq_no.nextval into nsn_seq_no from dual;
				nsn := 'NSL$' || lpad(nsn_seq_no,7,'0') ;
			end ;
		end if ;

		return nsn ;

	end SequenceTheNsl ;

    procedure writeMsg( -- added 10/16/2007 by dse
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 in varchar2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'amd_nsl_sequence_pkg',
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
    exception when others then
        -- trying to rollback or commit from trigger
        if sqlcode = 4092 then
            raise_application_error(-20010,
                substr('amd_nsl_sequence_pkg '
                    || sqlcode || ' '
                    || pError_Location || ' '
                    || pTableName || ' '
                    || pKey1 || ' '
                    || pKey2 || ' '
                    || pKey3 || ' '
                    || pKey4 || ' '
                    || pData, 1,2000)) ;
        else
            raise ;
        end if ;
    end writeMsg ;

    procedure version IS -- added 10/16/2007 by dse
    begin
        writeMsg(pTableName => 'amd_nsl_sequence_pkg',
             pError_location => 10, pKey1 => 'amd_nsl_sequence_pkg', pKey2 => '$Revision:   1.13  $') ;
        dbms_output.put_line('amd_nsl_sequence_pkg: $Revision:   1.13  $') ;
    end version ;


end amd_nsl_sequence_pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_on_order_date_filters_pkg AS
/******************************************************************************
       $Author:   zf297a  $
     $Revision:   1.4  $
         $Date:   Jun 09 2006 12:34:12  $
     $Workfile:   AMD_ON_ORDER_DATE_FILTERS_PKG.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_ON_ORDER_DATE_FILTERS_PKG.pkb.-arc  $
/*
/*      Rev 1.4   Jun 09 2006 12:34:12   zf297a
/*   implemented version
/*
/*      Rev 1.3   May 17 2006 14:58:36   zf297a
/*   removed start_date - not needed
/*
/*      Rev 1.2   May 17 2006 14:21:24   zf297a
/*   Added setScheduledReceiptDateCalDays and
/*   getScheduledReceiptDateCalDays
/*
/*      Rev 1.1   May 17 2006 13:25:08   zf297a
/*   Implemented procedures and functions using amd_on_order_date_filters table.
/*
/*      Rev 1.0   May 17 2006 12:24:26   zf297a
/*   Initial revision.
******************************************************************************/


	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_on_order_date_filters_pkg',
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	end writeMsg ;

	FUNCTION getOrderCreateDate(filter_name in amd_on_order_date_filters.FILTER_NAME%type, voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE IS
			 theDate date ;
	BEGIN
		 select order_create_date into theDate
		 from amd_on_order_date_filters
		 where filter_name = getOrderCreateDate.filter_name
		 and voucher_prefix = getOrderCreateDate.voucher_prefix ;
		 RETURN theDate ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getOrderCreateDate ;


	PROCEDURE setOrderCreateDate(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  					voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
								orderCreateDate IN amd_on_order_date_filters.ORDER_CREATE_DATE%type) IS
	BEGIN
		 update amd_on_order_date_filters
		 set order_create_date = orderCreateDate
		 where filter_name = setOrderCreateDate.filter_name
		 and voucher_prefix = setOrderCreateDate.voucher_prefix ;
	END setOrderCreateDate ;

	FUNCTION getScheduledReceiptDateFrom(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			 				voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE IS
			 theDate date ;
	BEGIN
		 select scheduled_receipt_date_from into theDate
		 from amd_on_order_date_filters
		 where filter_name = getScheduledReceiptDateFrom.filter_name
		 and voucher_prefix = getScheduledReceiptDateFrom.voucher_prefix ;
		 RETURN theDate ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getScheduledReceiptDateFrom ;

	FUNCTION getScheduledReceiptDateTo(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			 				voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type) RETURN DATE IS
			 theDate date ;
	BEGIN
		 select scheduled_receipt_date_to into theDate
		 from amd_on_order_date_filters
		 where filter_name = getScheduledReceiptDateTo.filter_name
		 and voucher_prefix = getScheduledReceiptDateTo.voucher_prefix ;
		 RETURN theDate ;
	EXCEPTION
		WHEN standard.NO_DATA_FOUND THEN
			 RETURN NULL ;
	END getScheduledReceiptDateTo ;

	PROCEDURE setScheduledReceiptDates(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										fromDate IN DATE, toDate DATE) IS
	BEGIN
		 update amd_on_order_date_filters
		 set scheduled_receipt_date_from = fromDate,
		 scheduled_receipt_date_to = toDate,
		 calendar_days = null
		 where filter_name = setScheduledReceiptDates.filter_name
		 and voucher_prefix = setScheduledReceiptDates.voucher_prefix ;
	END setScheduledReceiptDates ;

	PROCEDURE setScheduledReceiptDateCalDays(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										calendar_days IN NUMBER) IS
	BEGIN
		 update amd_on_order_date_filters
		 set scheduled_receipt_date_from = null,
		 scheduled_receipt_date_to = null,
		 calendar_days = setScheduledReceiptDateCalDays.calendar_days
		 where filter_name = setScheduledReceiptDateCalDays.filter_name
		 and voucher_prefix = setScheduledReceiptDateCalDays.voucher_prefix ;
	END setScheduledReceiptDateCalDays ;

   	procedure getScheduledReceiptDateCalDays(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  							voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
										calendar_days out amd_on_order_date_filters.CALENDAR_DAYS%type) IS
	BEGIN
		 select calendar_days into calendar_days
		 from amd_on_order_date_filters
		 where filter_name = getScheduledReceiptDateCalDays.filter_name
		 and voucher_prefix = getScheduledReceiptDateCalDays.voucher_prefix ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		 calendar_days := null ;
	END getScheduledReceiptDateCalDays ;

	PROCEDURE getOnOrderDateFilters(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
			  orderCreateDate 		  OUT amd_on_order_date_filters.ORDER_CREATE_DATE%type,
			  schedReceiptDateFrom 	  OUT amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_FROM%type,
			  schedReceiptDateTo 	  OUT amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_TO%type,
			  schedReceiptCalDays 	  OUT amd_on_order_date_filters.CALENDAR_DAYS%type) is
	BEGIN
		 select order_create_date, scheduled_receipt_date_from, scheduled_receipt_date_to, calendar_days
		 into orderCreateDate, schedReceiptDateFrom, schedReceiptDateTo, schedReceiptCalDays
		 from amd_on_order_date_filters
		 where filter_name = getOnOrderDateFilters.filter_name
		 and voucher_prefix = getOnOrderDateFilters.voucher_prefix ;
	END getOnOrderDateFilters ;

	PROCEDURE setOnOrderDateFilters(filter_name in amd_on_order_date_filters.FILTER_NAME%type,
			  voucher_prefix IN amd_on_order_date_filters.VOUCHER_PREFIX%type,
			  orderCreateDate 		  in amd_on_order_date_filters.ORDER_CREATE_DATE%type,
			  schedReceiptDateFrom 	  in amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_FROM%type,
			  schedReceiptDateTo 	  in amd_on_order_date_filters.SCHEDULED_RECEIPT_DATE_TO%type,
			  schedReceiptCalDays 	  in amd_on_order_date_filters.CALENDAR_DAYS%type) is
	BEGIN
		 begin
			 insert into amd_on_order_date_filters
			 (filter_name, voucher_prefix, order_create_date, scheduled_receipt_date_from, scheduled_receipt_date_to, calendar_days)
			 values( filter_name, voucher_prefix, orderCreateDate, schedReceiptDateFrom, schedReceiptDateTo, schedReceiptCalDays) ;
		 exception when standard.DUP_VAL_ON_INDEX then
		 	 update amd_on_order_date_filters
			 set order_create_date = orderCreateDate,
			 scheduled_receipt_date_from = schedReceiptDateFrom,
			 scheduled_receipt_date_to = schedReceiptDateTo,
			 calendar_days = schedReceiptCalDays
			 where filter_name = setOnOrderDateFilters.filter_name
			 and voucher_prefix = setOnOrderDateFilters.voucher_prefix ;
		 end ;
	END setOnOrderDateFilters ;

	FUNCTION isVoucher(voucher IN VARCHAR2) RETURN BOOLEAN IS
			theVoucher VARCHAR2(2) ;
	BEGIN
		 SELECT DISTINCT SUBSTR(gold_order_number,1,2) INTO theVoucher FROM AMD_ON_ORDER
		 WHERE LOWER(SUBSTR(gold_order_number,1,2)) = LOWER(isVoucher.voucher) ;
		 RETURN TRUE ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		 RETURN FALSE ;
	END isVoucher ;

	PROCEDURE clearOnOrderParams(filter_name in amd_on_order_date_filters.FILTER_NAME%type) IS
	BEGIN
		 update amd_on_order_date_filters
		 set order_create_date = null,
		 scheduled_receipt_date_from = null,
		 scheduled_receipt_date_to = null,
		 calendar_days = null
		 where filter_name = clearOnOrderParams.filter_name ;
	END clearOnOrderParams ;

	FUNCTION numberOfOnOrderParams(filter_name in amd_on_order_date_filters.FILTER_NAME%type) RETURN NUMBER IS
			 cnt NUMBER ;
	BEGIN
		SELECT COUNT(*) INTO cnt FROM AMD_ON_ORDER_DATE_FILTERS where filter_name = numberOfOnOrderParams.filter_name ;
		RETURN cnt ;
	EXCEPTION WHEN standard.NO_DATA_FOUND THEN
		RETURN 0 ;
	END numberOfOnOrderParams ;

	FUNCTION getVouchers RETURN ref_cursor IS
		 vouchers_cursor ref_cursor ;
	BEGIN
		 OPEN vouchers_cursor FOR
		 SELECT DISTINCT SUBSTR(gold_order_number,1,2) voucher
		 FROM AMD_ON_ORDER
		 ORDER BY voucher ;
		 RETURN vouchers_cursor ;
	END getVouchers ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_on_order_date_filters_pkg',
		 		pError_location => 10, pKey1 => 'amd_on_order_date_filters_pkg', pKey2 => '$Revision:   1.4  $') ;
	end version ;

END amd_on_order_date_filters_pkg;
/


DROP PACKAGE BODY AMD_OWNER.AMD_PARTPRIME_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Partprime_Pkg AS
/*
      $Author:   zf297a  $
    $Revision:   1.32  $
     $Date:   15 Jul 2009 15:08:50  $
    $Workfile:   AMD_PARTPRIME_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PARTPRIME_PKG.pkb.-arc  $
/*
/*      Rev 1.31   15 Jul 2009 15:08:50   zf297a
/*   Removed more a2a code
/*
/*      Rev 1.30   15 Jul 2009 13:50:40   zf297a
/*   Removed more a2a code.
/*
/*      Rev 1.29   15 Jul 2009 10:08:44   zf297a
/*   Removed A2A code.
/*
/*      Rev 1.28   15 Oct 2008 09:41:44   zf297a
/*   Added lots of debugMsg's.  For diffPartToPrime moved the code that does insert to tmp_a2a_part_info into a separate for loop.  Also, updated the amd_sent_to_a2a with null spo_prime_part_no's with one update statment.
/*
/*      Rev 1.27   26 Sep 2008 18:35:02   zf297a
/*   Made errorMsg act as autonomous transaction so that this routine may issue commits independent of the main transaction.
/*   Fixed getAmdPrimePart.
/*
/*      Rev 1.26   26 Sep 2008 17:50:46   zf297a
/*   Implemented interfaces for isSpoPrimePart, isSpoPrimePartYorN, and  getTwoWayRblPrimePart.  For getTwoWayRblPrimePart used the new view amd_twoway_rbl_pairs_v.
/*
/*      Rev 1.25   22 Sep 2008 19:38:58   zf297a
/*   implemented interfaces setSpoPrimePart , updateAllSpoPrimeParts, and updateSpoPrimePart
/*
/*      Rev 1.24   27 Jun 2008 11:59:56   zf297a
/*   Added some debug for diffPartToPrime plus extra commit's
/*
/*      Rev 1.23   29 May 2008 15:30:56   zf297a
/*   Added more debug code to diffPartToPrime.
/*
/*      Rev 1.22   23 May 2008 13:21:24   zf297a
/*   Implemented function getVersion.
/*
/*      Rev 1.21   15 May 2008 22:16:50   zf297a
/*   Added lots of debug code.
/*
/*      Rev 1.20   11 Feb 2008 08:46:36   zf297a
/*   Eliminated close of cursor partsToSend in procedure sendParts, since the procedure a2a_pkg.processParts uses a bulk collect and then closes the cursor.
/*
/*      Rev 1.19   06 Nov 2007 23:43:12   zf297a
/*   Added bulk collect for all cursors.
/*
/*      Rev 1.18   14 Aug 2007 15:54:20   zf297a
/*   Fixed diffPartToPrime to fill in spo_prime_part_no for consumable parts.
/*
/*      Rev 1.17   12 Jun 2007 21:51:00   zf297a
/*   Make sure any new spo prime part no has it data sent via an A2A PartInfo transaction
/*
/*      Rev 1.16   01 Mar 2007 13:51:36   zf297a
/*   removed truncation of amd_test_parts by the diffPartToPrime procedure
/*
/*      Rev 1.15   01 Mar 2007 12:44:48   zf297a
/*   Removed recording of changed spo prime part in amd_test_parts.  invoked sendZeroTslsForSpoPrimePart for the old prime part whenever the prime part changes.
/*
/*      Rev 1.14   28 Feb 2007 13:58:34   zf297a
/*   Replaced amd_location_part_override_pkg.deleteRspTslA2A with amd_location_part_override_pkg.loadRspZeroTslA2A
/*
/*      Rev 1.13   22 Feb 2007 00:04:30   zf297a
/*   Added mtbdr_computed to partInfoRec
/*
/*      Rev 1.11   30 Jan 2007 14:26:40   zf297a
/*   implemented interface updatePlannerCodesForSubParts
/*
/*      Rev 1.10   26 Jan 2007 09:40:04   zf297a
/*   Build a list of spo_prime_part_no's that are no longer used for spo in amd_test_data, then execute deleteRspTslA2A to generate delete transactions for those spo_prime_parts and the bases they are associated with.
/*
/*      Rev 1.9   19 Jan 2007 11:18:22   zf297a
/*   Make sure amd_sent_to_a2a's spo_prime_part_no is upated before generating the PartInfo A2A transaction.  This will gaurantee that the spo_prime_part_no is correct, whereas before the PartInfo transaction had the old spo_prime_part_no.
/*
/*      Rev 1.8   Nov 01 2006 12:35:28   zf297a
/*   Fixed DiffPartToPrime to use a2a_pkg.DiffPartToPrime
/*
/*      Rev 1.7   Oct 20 2006 12:23:14   zf297a
/*   Added code to make sure that a new spo_prime_part_no has been sent to the SPO.
/*
/*      Rev 1.6   Jun 09 2006 12:07:14   zf297a
/*   implemented interface version
/*
/*      Rev 1.5   Jun 07 2006 09:19:48   zf297a
/*   Optimizie DiffToPartPrime to send only parts that need to be sent rather than all the parts.
/*
/*      Rev 1.4   Jun 05 2006 10:55:12   zf297a
/*   Enhanced error reporting.  For DiffPartToPrime if not all the valid parts have been sent, then execute a2a_pkg.initA2APartInfo
/*
/*      Rev 1.3   Feb 03 2006 08:04:04   zf297a
/*   Converted to use the new amd_rbl_pairs table
/*
/*      Rev 1.2   Dec 15 2005 12:14:34   zf297a
/*   Added truncate of table tmp_a2a_part_alt_rel_delete to DiffPartToPrime
/*
/*      Rev 1.1   Dec 06 2005 10:27:20   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*
/*      Rev 1.0   Dec 01 2005 09:41:48   zf297a
/*   Initial revision.
*/
/* need to resolve - what if new_nsn is not a prime in amd ????? */
/*  need to clean up and streamline logic on this package */

    PKGNAME CONSTANT VARCHAR2(30) := 'AMD_PARTPRIME_PKG' ;
    debug boolean := false ;
    threshold number := 1000 ;

    PROCEDURE writeMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 IN VARCHAR2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
                 pragma autonomous_transaction ;
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'amd_partprime_pkg',
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
        commit ;
    END writeMsg ;

    PROCEDURE ErrorMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS

                 pragma autonomous_transaction ;

    BEGIN
        Amd_Utils.InsertErrorMsg (
                pLoad_no => Amd_Utils.GetLoadNo(pSourceName => 'amd_partprime_pkg',    pTableName  => pTableName),
                pData_line_no => pError_location,
                pData_line    => 'amd_partprime_pkg',
                pKey_1 => SUBSTR(pKey1,1,50),
                pKey_2 => SUBSTR(pKey2,1,50),
                pKey_3 => SUBSTR(pKey3,1,50),
                pKey_4 => SUBSTR(pKey4,1,50),
                pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pComments => 'sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||') ' || pComments);
        COMMIT;
    END errorMsg ;

    procedure setDebug(switch in varchar2) is
    begin
        debug := upper(switch) in ('Y','T','YES','TRUE') ;
        if debug then
            dbms_output.ENABLE(100000) ;
        else
            dbms_output.DISABLE ;
        end if ;
    end setDebug ;

    PROCEDURE debugMsg(msg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE, pError_Location IN NUMBER) IS
        pragma autonomous_transaction ;
    BEGIN
       IF debug THEN
           Amd_Utils.debugMsg(pMsg => msg,pPackage => 'amd_partPrime_pkg', pLocation => pError_location) ;
           COMMIT ; -- make sure the trace is kept
       END IF ;
    EXCEPTION WHEN OTHERS THEN
       IF SQLCODE = -14551 OR SQLCODE = -14552 THEN
       		NULL ; -- cannot do a commit inside a query, so ignore the error
       ELSE
       		RAISE ;
       END IF ;
    END debugMsg ;

    FUNCTION getNsiSid(pNsn VARCHAR2)
             RETURN NUMBER IS
        retNsiSid NUMBER ;
    BEGIN
        SELECT nsi_sid INTO retNsiSid
               FROM AMD_NSNS an
               WHERE  an.nsn = pNsn ;
        RETURN retNsiSid ;
    EXCEPTION WHEN NO_DATA_FOUND THEN
        RETURN NULL ;
    END ;


    FUNCTION getSuperPrimePartByNsiSid(pNsiSid NUMBER)
             RETURN VARCHAR2 IS
        retPrimePart AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE := NULL;
        partNo AMD_SPARE_PARTS.part_no%TYPE ;
    BEGIN
        SELECT prime_part_no INTO partNo
            FROM AMD_NATIONAL_STOCK_ITEMS
            WHERE nsi_sid = pNsiSid
            AND action_code != Amd_Defaults.DELETE_ACTION  ;
           RETURN getSuperPrimePart(partNo) ;
    EXCEPTION
              WHEN NO_DATA_FOUND THEN
                     RETURN NULL ;
              WHEN OTHERS THEN
                    ErrorMsg(
                   pTableName              => 'amd_national_stock_items',
                   pError_location => 10,
                   pKey1              => 'pNsiSid=' || TO_CHAR(pNsiSid) ) ;
                   RAISE ;
    END getSuperPrimePartByNsiSid;

    FUNCTION getTwoWayRblPrimePart(pNsn VARCHAR2)
             RETURN VARCHAR2 IS
         retPrimePart AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE := NULL;
         nsiSid NUMBER ;
    BEGIN
         select new_prime_part_no into retprimePart
         from amd_twoway_rbl_pairs_v
         where pNsn = old_nsn ;
         RETURN retPrimePart ;
    EXCEPTION
              WHEN NO_DATA_FOUND THEN
                      RETURN NULL ;
              WHEN OTHERS THEN
                    ErrorMsg(
                       pTableName              => 'amd_rbl_pairs/amd_nsns',
                       pError_location => 20,
                       pKey1              => 'pNsn=' || pNsn) ;
                   RAISE ;
    END getTwoWayRblPrimePart ;


    FUNCTION getAmdPrimePart(pNsn VARCHAR2)
             RETURN VARCHAR2 IS
         retPrimePart AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE := NULL;
    BEGIN
         SELECT items.prime_part_no INTO retPrimePart
                 FROM AMD_NATIONAL_STOCK_ITEMS items
                 WHERE items.nsn = pNsn
                and items.action_code <> 'D' ;
         RETURN retPrimePart ;
    EXCEPTION
              WHEN NO_DATA_FOUND THEN
                      RETURN NULL ;
              WHEN OTHERS THEN
                    ErrorMsg(
                   pTableName              => 'amd_national_stock_items',
                   pError_location => 30,
                   pKey1              => 'pNsn=' || pNsn) ;
                   RAISE ;
    END getAmdPrimePart ;


    FUNCTION getNsn(pPart VARCHAR2)
             RETURN VARCHAR2 IS
        retNsn AMD_NSNS.nsn%TYPE ;
    BEGIN
         SELECT nsn INTO retNsn
             FROM AMD_SPARE_PARTS asp
            WHERE asp.part_no = pPart AND action_code != Amd_Defaults.DELETE_ACTION;
         RETURN retNsn ;
    EXCEPTION
              WHEN NO_DATA_FOUND THEN
                      RETURN NULL ;
              WHEN OTHERS THEN
                    ErrorMsg(
                   pTableName              => 'amd_spare_parts',
                   pError_location => 40,
                   pKey1              => 'pPart=' || pPart) ;
                   RAISE ;
    END ;

    FUNCTION isSpoPrimePart(pPart VARCHAR2)
             RETURN BOOLEAN IS
        tmpPart AMD_SPARE_PARTS.part_no%TYPE ;
    BEGIN
        SELECT part_no INTO tmpPart
            FROM AMD_spare_parts
            WHERE part_no = pPart AND is_spo_part = 'Y' ;
        RETURN TRUE ;
    EXCEPTION
              WHEN NO_DATA_FOUND THEN
                  RETURN FALSE ;
              WHEN OTHERS THEN
                    ErrorMsg(
                   pTableName              => 'amd_spare_parts',
                   pError_location => 50,
                   pKey1              => 'pPart=' || pPart) ;
                   RAISE ;
    END isSpoPrimePart ;

    function isSpoPrimePartYorN(pPart VARCHAR2) return varchar2 is
    begin
        if isSpoPrimePart(pPart) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isSpoPrimePartYorN ;

    /*  main function with the business logic, try to keep most of it here */
    FUNCTION getSuperPrimePart(pPart VARCHAR2)
             RETURN VARCHAR2 IS
        retPrimePart AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE := NULL;
        nsn AMD_SPARE_PARTS.nsn%TYPE ;
    BEGIN
        nsn := getNsn(pPart) ;
        IF ( nsn IS NOT NULL ) THEN
           retPrimePart := getTwoWayRblPrimePart(nsn) ;
           IF ( (retPrimePart IS NULL) OR (NOT isSpoPrimePart(retPrimePart)) ) THEN
                 retPrimePart := getAmdPrimePart(nsn) ;
              if not isSpoPrimePart(retPrimePart) then
                retPrimePart := null ;
              end if ;
           END IF ;
        END IF ;
        RETURN retPrimePart ;
    EXCEPTION WHEN OTHERS THEN
      ErrorMsg(
       pTableName              => 'getSuperPrimePart',
       pError_location => 60,
       pKey1              => 'pPart=' || pPart) ;
       RAISE ;

    END ;




    FUNCTION getSuperPrimeNsiSid(pPart VARCHAR2)
             RETURN NUMBER IS
         retNsiSid NUMBER := NULL ;
         prime AMD_SPARE_PARTS.part_no%TYPE ;
    BEGIN
         prime := getSuperPrimePart(pPart) ;
         IF (prime IS NOT NULL ) THEN
              retNsiSid := Amd_Utils.GetNsiSidFromPartNo(prime) ;
         END IF ;
         RETURN retNsiSid ;
    EXCEPTION WHEN OTHERS THEN
                  ErrorMsg(
                   pTableName              => 'getSuperPrimeNsiSid',
                   pError_location => 80,
                   pKey1              => 'pPart=' || pPart) ;
                   RAISE ;
    END getSuperPrimeNsiSid;




    FUNCTION getSuperPrimeNsiSidByNsn_A2A(pNsn VARCHAR2) RETURN NUMBER IS
        retNsiSid NUMBER := NULL ;
        prime AMD_SPARE_PARTS.part_no%TYPE ;
    BEGIN
        prime := getAmdPrimePart(pNsn) ;
        prime := getSuperPrimePart(prime) ;
        IF (prime IS NULL ) THEN
            RETURN NULL ;
        ELSIF (NOT isSpoPrimePart(prime)) THEN
            RETURN NULL ;
        END IF ;
        RETURN Amd_Utils.GetNsiSidFromPartNo(prime) ;
    EXCEPTION
              WHEN NO_DATA_FOUND THEN
                  RETURN NULL ;
              WHEN OTHERS THEN
                  ErrorMsg(
                   pTableName              => 'getSuperPrimeNsiSidByNsn_A2A',
                   pError_location => 150,
                   pKey1              => 'pNsn=' || pNsn) ;
                   RAISE ;
    END getSuperPrimeNsiSidByNsn_A2A ;


    procedure setSpoPrimePart(part_no in amd_spare_parts.part_no%type,
        spo_prime_part_no in amd_spare_parts.spo_prime_part_no%type) is
    begin
        update amd_spare_parts
        set spo_prime_part_no = setSpoPrimePart.spo_prime_part_no,
        last_update_dt = sysdate
        where part_no = setSpoPrimePart.part_no ;
    exception
        when others then
            errorMsg(
                pTableName              => 'setSpoPrimePart',
                pError_location => 200,
                pKey1              => part_no,
                pKey2 => spo_prime_part_no ) ;
            raise ;
    end setSpoPrimePart ;

  procedure updateSpoPrimePart(last_update_dt in amd_spare_parts.last_update_dt%type
        := amd_batch_pkg.getLastStartTime) is

        cursor recentlyUpdatedParts is
        select part_no, spo_prime_part_no
        from amd_spare_parts
        where last_update_dt >= updateSpoPrimePart.last_update_dt
        and action_code <> amd_defaults.DELETE_ACTION
        and is_spo_part = 'Y' ;

        spo_prime_part_no amd_spare_parts.spo_prime_part_no%type ;
	cnt number := 0 ;
    begin
        writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 202,
            pKey1 => 'updateSpoPrimePart',
            pKey2 => to_char(last_update_dt,'MM/DD/YYYY HH:MI:SS AM'),
            pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')) ;
        for rec in recentlyUpdatedParts loop
            spo_prime_part_no := getSuperPrimePart(rec.part_no) ;
            if rec.spo_prime_part_no is null or rec.spo_prime_part_no <> spo_prime_part_no then
                setSpoPrimePart(rec.part_no,spo_prime_part_no) ;
	    	cnt := cnt + 1 ;
            end if ;
        end loop ;
        writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 204,
            pKey1 => 'updateSpoPrimePart',
            pKey2 => cnt || ' recs updated.',
	    pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')) ;
        commit ;
    end updateSpoPrimePart ;


    procedure updateAllSpoPrimeParts is
        cursor allActiveParts is
        select part_no, spo_prime_part_no
        from amd_spare_parts
        where action_code <> amd_defaults.DELETE_ACTION
        and is_spo_part = 'Y' ;

        spo_prime_part_no amd_spare_parts.spo_prime_part_no%type ;
    begin
        for rec in allActiveParts loop
            spo_prime_part_no := getSuperPrimePart(rec.part_no) ;
            if rec.spo_prime_part_no is null or rec.spo_prime_part_no <> spo_prime_part_no then
                setSpoPrimePart(rec.part_no,spo_prime_part_no) ;
            end if ;
        end loop ;
        commit ;
    end updateAllSpoPrimeParts ;

    FUNCTION areAllPartsSent RETURN BOOLEAN IS
             partsNotSent NUMBER ;
    BEGIN
	select count(*) into partsNotSent
	from amd_spare_parts parts
	where is_spo_part = 'Y'
	and part_no not in (select part_no from amd_spare_parts where part_no = parts.part_no) ;

         RETURN (partsNotSent > 0) ;
    END areAllPartsSent ;


    procedure setThreshold(value in number) is
    begin
        threshold := value ;
    end setThreshold ;

    function getThreshold return number is
    begin
        return threshold ;
    end getThreshold ;

    PROCEDURE version IS
    BEGIN
         writeMsg(pTableName => 'amd_partprime_pkg',
                 pError_location => 390, pKey1 => 'amd_partprime_pkg', pKey2 => '$Revision:   1.32  $') ;
    END version ;

    function getVersion return varchar2 is -- added 5/23/2008 by dse
    begin
        return '$Revision:   1.32  $' ;
    end getVersion ;

END Amd_Partprime_Pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_PART_FACTORS_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_PART_FACTORS_PKG
AS
   /*
        $Author:   zf297a  $
      $Revision:   1.18
          $Date:   16 May 2017
      $Workfile:   AMD_PART_FACTORS_PKG.pkb  $

            Rev 1.18 16 May 2017 DSE to maintain compatibility with the old Java code that calls
                                 deleteRow with the longer parameter list overload the deleteRow
                                 function.                                                 
            
            Rev 1.17 25 Jan 2017 DSE reformatted code

            Rev 1.16 added exception handlers for select's that should return one item only
            and fixed getRepairIndicator to use only the current nsn vs the temporary nsn ( nsn_type = 'C' )

            Rev 1.15 fixed deleteRow - only needed primary key for amd_part_factors and only needed to
            update action_code and last_update_dt

            Rev 1.14 removed truncation of tmp_a2a table
  /*
  /*      Rev 1.13   02 Jul 2009 13:10:40   zf297a
  /*   Moved mtd_rec to spec to make it public
  /*
  /*      Rev 1.12   24 Feb 2009 13:46:26   zf297a
  /*   Removed a2a code
  /*
  /*      Rev 1.11   13 Jan 2009 15:30:36   zf297a
  /*   Implement setDebug, getDebug, and getVersion.
  /*   Use the maint_task_distrib_exception to handle conditions where the nrts + rts + condemnation_rate is not equal to 1.
  /*   Add debugMsg, a procedure for errorMsg, and writeMsg.
  /*   Log cnts to amd_load_details when loading tmp_amd_part_factors.
  /*
  /*      Rev 1.10   07 Nov 2007 16:35:30   zf297a
  /*   Use bulk collect for all cursors.
  /*
  /*      Rev 1.9   16 Oct 2007 17:16:00   zf297a
  /*   Fixed literal being written out by the version procedure
  /*
  /*      Rev 1.8   12 Sep 2007 15:37:10   zf297a
  /*   Removed commits from for loops.
  /*
  /*      Rev 1.7   Nov 28 2006 14:54:58   zf297a
  /*   fixed insertTmpA2A_PF - for INSERT_ACTION or UPDATE_ACTION check to see if the part is in amd_sent_to_a2a with action_code <> DELETE_ACTION then insert it into tmp_a2a_part_factors.  For DELETE_ACTION's check to see if the part is in amd_sent_to_a2a with any action_code then insert it into tmp_a2a_part_factors.
  /*
  /*      Rev 1.6   Jun 09 2006 12:03:06   zf297a
  /*   implemented interface version
  /*
  /*      Rev 1.5   Mar 03 2006 12:38:32   zf297a
  /*   removed amd_location_part_leadtime_pkg.getBatchRunStart and replaced it with amd_batch_pkg.getLastStartTime, which will always return the start time of the last job regardless of whether it has completed or not.  This allows the procedures that select a2a data to be run even if the batch job has completed.  Only the data that has changed since the batch job started will be sent.  This should only be a small amount of data.
  /*
  /*      Rev 1.4   Jan 03 2006 13:03:18   zf297a
  /*   Added date range to procedure loadA2AByDate
  /*
  /*      Rev 1.3   Jan 03 2006 08:07:42   zf297a
  /*   Added procedure loadA2AByDate
  /*
  /*      Rev 1.2   Dec 16 2005 08:49:30   zf297a
  /*   Added truncate of tmp_a2a_part_factors table when tmp_amd_part_factors is loaded.
  /*
  /*      Rev 1.1   Dec 06 2005 10:30:26   zf297a
  /*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
  /*
  /*      Rev 1.0   Oct 31 2005 08:04:54   zf297a
  /*   Initial revision.
  */



   PKGNAME                   CONSTANT VARCHAR2 (30) := 'AMD_PART_FACTORS_PKG';
   FORWARD_SUPPLY_LOCATION   CONSTANT VARCHAR2 (3) := 'FSL';
   MAIN_OPERATING_BASE       CONSTANT VARCHAR2 (3) := 'MOB';
   debug                              BOOLEAN := FALSE;


   TYPE partFactorsRec IS RECORD
   (
      part_no    amd_spare_parts.spo_prime_part_no%TYPE,
      nsn        amd_national_stock_items.nsn%TYPE,
      loc_sid    amd_spare_networks.loc_sid%TYPE,
      loc_type   amd_spare_networks.loc_type%TYPE,
      loc_id     amd_spare_networks.loc_id%TYPE,
      rts        NUMBER,
      nrts       NUMBER,
      condemn    NUMBER
   );

   TYPE partFactorsTab IS TABLE OF partFactorsRec;

   partFactorsRecs                    partFactorsTab;


   FUNCTION ErrorMsg (
      pSourceName       IN amd_load_status.SOURCE%TYPE,
      pTableName        IN amd_load_status.TABLE_NAME%TYPE,
      pError_location   IN amd_load_details.DATA_LINE_NO%TYPE,
      pReturn_code      IN NUMBER,
      pKey1             IN VARCHAR2 := '',
      pKey2             IN VARCHAR2 := '',
      pKey3             IN VARCHAR2 := '',
      pData             IN VARCHAR2 := '',
      pComments         IN VARCHAR2 := '')
      RETURN NUMBER
   IS
   BEGIN
      ROLLBACK; -- rollback may not be complete if running with mDebug set to true
      amd_utils.InsertErrorMsg (
         pLoad_no        => amd_utils.GetLoadNo (pSourceName   => pSourceName,
                                                 pTableName    => pTableName),
         pData_line_no   => pError_location,
         pData_line      => pData,
         pKey_1          => SUBSTR (pKey1, 1, 50),
         pKey_2          => SUBSTR (pKey2, 1, 50),
         pKey_3          => pKey3,
         pKey_4          => TO_CHAR (pReturn_code),
         pKey_5          => TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MM:SS'),
         pComments       =>    'sqlcode('
                            || SQLCODE
                            || ') sqlerrm('
                            || SQLERRM
                            || ') '
                            || pComments);
      COMMIT;
      RETURN pReturn_code;
   END;


   PROCEDURE ErrorMsg (
      pSqlfunction         IN AMD_LOAD_STATUS.SOURCE%TYPE := 'errorMsg',
      pTableName           IN AMD_LOAD_STATUS.TABLE_NAME%TYPE := 'noname',
      pError_location         AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE := -100,
      pKey_1               IN AMD_LOAD_DETAILS.KEY_1%TYPE := '',
      pKey_2               IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
      pKey_3               IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
      pKey_4               IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
      pKeywordValuePairs   IN VARCHAR2 := '')
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;

      key5          AMD_LOAD_DETAILS.KEY_5%TYPE
                       := SUBSTR (pKeywordValuePairs, 1, 50);
      saveSqlCode   NUMBER := SQLCODE;
   BEGIN
      IF key5 = '' OR key5 IS NULL
      THEN
         key5 := pSqlFunction || '/' || pTableName;
      ELSE
         IF key5 IS NOT NULL
         THEN
            IF   LENGTH (key5)
               + LENGTH ('' || pSqlFunction || '/' || pTablename) < 50
            THEN
               key5 := key5 || ' ' || pSqlFunction || '/' || pTableName;
            END IF;
         END IF;
      END IF;

      -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
      -- do not exceed the length of the column's that the data gets inserted into
      -- This is for debugging and logging, so efforts to make it not be the source of more
      -- errors is VERY important

      DBMS_OUTPUT.put_line ('insertError@' || pError_location);

      Amd_Utils.InsertErrorMsg (
         pLoad_no        => Amd_Utils.GetLoadNo (
                              pSourceName   => SUBSTR (pSqlfunction, 1, 20),
                              pTableName    => SUBSTR (pTableName, 1, 20)),
         pData_line_no   => pError_location,
         pData_line      => 'amd_part_factors_pkg.',
         pKey_1          => SUBSTR (pKey_1, 1, 50),
         pKey_2          => SUBSTR (pKey_2, 1, 50),
         pKey_3          => SUBSTR (pKey_3, 1, 50),
         pKey_4          => SUBSTR (pKey_4, 1, 50),
         pKey_5          => SUBSTR (key5, 1, 50),
         pComments       => SUBSTR (
                                 'sqlcode('
                              || saveSQLCODE
                              || ') sqlerrm('
                              || SQLERRM
                              || ')',
                              1,
                              2000));

      IF SQLCODE <> -4092
      THEN
         COMMIT;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         DBMS_OUTPUT.enable (10000);
         DBMS_OUTPUT.put_line ('sql error=' || SQLCODE || ' ' || SQLERRM);

         IF pSqlFunction IS NOT NULL
         THEN
            DBMS_OUTPUT.put_line ('pSqlFunction=' || pSqlfunction);
         END IF;

         IF pTableName IS NOT NULL
         THEN
            DBMS_OUTPUT.put_line ('pTableName=' || pTableName);
         END IF;

         IF pError_location IS NOT NULL
         THEN
            DBMS_OUTPUT.put_line ('pError_location=' || pError_location);
         END IF;

         IF pKey_1 IS NOT NULL
         THEN
            DBMS_OUTPUT.put_line ('key1=' || pKey_1);
         END IF;

         IF pkey_2 IS NOT NULL
         THEN
            DBMS_OUTPUT.put_line ('key2=' || pKey_2);
         END IF;

         IF pKey_3 IS NOT NULL
         THEN
            DBMS_OUTPUT.put_line ('key3=' || pKey_3);
         END IF;

         IF pKey_4 IS NOT NULL
         THEN
            DBMS_OUTPUT.put_line ('key4=' || pKey_4);
         END IF;

         IF pKeywordValuePairs IS NOT NULL
         THEN
            DBMS_OUTPUT.put_line (
               'pKeywordValuePairs=' || pKeywordValuePairs);
         END IF;

         IF SQLCODE <> -4092
         THEN
            raise_application_error (
               -20030,
               SUBSTR (
                     'amd_part_factors_pkg '
                  || SQLCODE
                  || ' '
                  || pError_location
                  || ' '
                  || pSqlFunction
                  || ' '
                  || pTableName
                  || ' '
                  || pKey_1
                  || ' '
                  || pKey_2
                  || ' '
                  || pKey_3
                  || ' '
                  || pKey_4
                  || ' '
                  || pKeywordValuePairs,
                  1,
                  2000));
         END IF;
   END ErrorMsg;

   PROCEDURE debugMsg (msg               IN AMD_LOAD_DETAILS.DATA_LINE%TYPE,
                       pError_Location   IN NUMBER)
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      IF debug
      THEN
         Amd_Utils.debugMsg (pMsg        => msg,
                             pPackage    => 'amd_part_factors_pkg',
                             pLocation   => pError_location);
         COMMIT;                                -- make sure the trace is kept
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         IF SQLCODE = -14551 OR SQLCODE = -14552
         THEN
            NULL;    -- cannot do a commit inside a query, so ignore the error
         ELSE
            RAISE;
         END IF;
   END debugMsg;

   PROCEDURE writeMsg (
      pTableName        IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
      pError_location   IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
      pKey1             IN VARCHAR2 := '',
      pKey2             IN VARCHAR2 := '',
      pKey3             IN VARCHAR2 := '',
      pKey4             IN VARCHAR2 := '',
      pData             IN VARCHAR2 := '',
      pComments         IN VARCHAR2 := '')
   IS
   BEGIN
      Amd_Utils.writeMsg (pSourceName       => 'amd_part_factors_pkg',
                          pTableName        => pTableName,
                          pError_location   => pError_location,
                          pKey1             => pKey1,
                          pKey2             => pKey2,
                          pKey3             => pKey3,
                          pKey4             => pKey4,
                          pData             => pData,
                          pComments         => pComments);
   EXCEPTION
      WHEN OTHERS
      THEN
         --  ignoretrying to rollback or commit from trigger
         IF SQLCODE <> -4092
         THEN
            raise_application_error (
               -20010,
               SUBSTR (
                     'amd_part_factors_pkg '
                  || SQLCODE
                  || ' '
                  || pError_Location
                  || ' '
                  || pTableName
                  || ' '
                  || pKey1
                  || ' '
                  || pKey2
                  || ' '
                  || pKey3
                  || ' '
                  || pKey4
                  || ' '
                  || pData,
                  1,
                  2000));
         END IF;
   END writeMsg;


   FUNCTION defaultMtdToDataSys (pLocId amd_spare_networks.LOC_ID%TYPE)
      RETURN mtd_rec
   IS
      retRec   mtd_rec;
   BEGIN
      retRec.rts := 0;
      retRec.nrts := 0;
      retRec.condemn := 0;

      IF (pLocId = amd_defaults.AMD_WAREHOUSE_LOCID)
      THEN
         retRec.condemn := DEFAULT_WHSE_COND;
         retRec.rts := 1 - retRec.condemn;
      ELSE
         retRec.nrts := 1;
      END IF;

      IF retRec.rts + retRec.nrts + retRec.condemn <> 1
      THEN
         debugMsg (
            msg               =>    retRec.nrts
                                 || ','
                                 || retRec.rts
                                 || ', '
                                 || retRec.condemn
                                 || ' ='
                                 || (retRec.rts + retRec.nrts + retRec.condemn),
            pError_location   => 10);
         RAISE maint_task_distrib_exception;
      END IF;

      RETURN retRec;
   EXCEPTION
      WHEN maint_task_distrib_exception
      THEN
         ErrorMsg (
            pSqlfunction      => 'defaultMtd',
            pTableName        => 'tmp_amd_part_factors',
            pError_location   => 20,
            pKey_1            => pLocId,
            pKey_2            => retRec.nrts,
            pKey_3            => retRec.rts,
            pKey_4            =>    retRec.condemn
                                 || ' ='
                                 || (retRec.rts + retRec.nrts + retRec.condemn));
         RAISE;
   END defaultMtdToDataSys;

   FUNCTION GetCriticalityFromSubs (
      pSpoPrimePartNo    amd_spare_parts.spo_prime_part_no%TYPE)
      RETURN amd_national_stock_items.CRITICALITY%TYPE
   IS
      TYPE criticalityCleanedRec IS RECORD
      (
         criticality_cleaned   amd_national_stock_items.CRITICALITY_CLEANED%TYPE,
         criticality           amd_national_stock_items.CRITICALITY%TYPE
      );

      TYPE criticalityCleanedTab IS TABLE OF criticalityCleanedRec;

      criticalityCleanedRecs   criticalityCleanedTab;

      CURSOR criticalityCur
      IS
         SELECT criticality_cleaned, criticality
           FROM amd_spare_parts parts, amd_national_stock_items items
          WHERE     is_spo_part = 'Y'
                AND parts.spo_prime_part_no = pSpoPrimePartNo
                AND parts.part_no != parts.spo_prime_part_no
                AND items.prime_part_no = parts.spo_prime_part_no
                AND items.action_code != Amd_Defaults.DELETE_ACTION;

      retCrit                  amd_national_stock_items.CRITICALITY%TYPE
                                  := NULL;
      SubHasCritOfOne          BOOLEAN := FALSE;
   BEGIN
      OPEN criticalityCur;

      FETCH criticalityCur BULK COLLECT INTO criticalityCleanedRecs;

      CLOSE criticalityCur;

      IF criticalityCleanedRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN criticalityCleanedRecs.FIRST ..
                     criticalityCleanedRecs.LAST
         LOOP
            IF (amd_preferred_pkg.GetPreferredValue (
                   criticalityCleanedRecs (indx).criticality_cleaned,
                   criticalityCleanedRecs (indx).criticality) = 1)
            THEN
               SubHasCritOfOne := TRUE;
            END IF;
         END LOOP;
      END IF;

      IF (SubHasCritOfOne)
      THEN
         RETURN 1;
      ELSE
         RETURN NULL;
      END IF;
   END;

   FUNCTION CorrectCriticality (
      pCrit    amd_national_stock_items.CRITICALITY%TYPE)
      RETURN amd_national_stock_items.CRITICALITY%TYPE
   IS
   BEGIN
      IF (pCrit IS NULL)
      THEN
         RETURN NULL;
      ELSIF (pCrit <= 0)
      THEN
         RETURN 0;
      ELSIF (pCrit > 0 AND pCrit <= .1)
      THEN
         RETURN .1;
      ELSIF (pCrit > .1 AND pCrit <= .5)
      THEN
         RETURN .5;
      ELSIF (pCrit > .5)
      THEN
         RETURN 1;
      END IF;
   END;

   FUNCTION DetermineCriticality (
      pCrit      amd_national_stock_items.CRITICALITY%TYPE,
      pPartNo    amd_spare_parts.part_no%TYPE)
      RETURN amd_national_stock_items.CRITICALITY%TYPE
   IS
      retCrit   amd_national_stock_items.CRITICALITY%TYPE := NULL;
   BEGIN
      IF (pCrit IS NULL)
      THEN
         retCrit := GetCriticalityFromSubs (pPartNo);

         IF (retCrit IS NOT NULL)
         THEN
            RETURN correctCriticality (retCrit);
         ELSIF (amd_location_part_leadtime_pkg.IsPartRepairable (pPartNo) =
                   'Y')
         THEN
            RETURN CRITICALITY_REPAIRABLE_DEFAULT;
         ELSE
            RETURN CRITICALITY_CONSUMABLE_DEFAULT;
         END IF;
      ELSE
         RETURN correctCriticality (pCrit);
      END IF;
   END;



   FUNCTION DetermineCriticality (
      pCrit      amd_national_stock_items.CRITICALITY%TYPE,
      pNsiSid    amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.CRITICALITY%TYPE
   IS
      primePartNo   amd_national_stock_items.prime_part_no%TYPE := NULL;
   BEGIN
      IF (pCrit IS NULL)
      THEN
         SELECT prime_part_no
           INTO primePartNo
           FROM amd_national_stock_items
          WHERE     action_code != Amd_Defaults.DELETE_ACTION
                AND nsi_sid = pNsiSid;

         RETURN DetermineCriticality (pCrit, primePartNo);
      ELSE
         RETURN pCrit;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN NULL;
   END;

   /* current spec says to send a default nrts, rts, cond to vub, vcd, basc,
      others - mob, fsl, ctlatl, uk will use #'s from best spares.
      Below will have to be maintained */
   FUNCTION isAutoDefaulted (pLocRow amd_spare_networks%ROWTYPE)
      RETURN BOOLEAN
   IS
   BEGIN
      IF (    pLocRow.loc_id NOT IN
                 (Amd_Defaults.AMD_WAREHOUSE_LOCID,
                  Amd_Defaults.AMD_UK_LOC_ID)
          AND pLocRow.loc_type NOT IN
                 (FORWARD_SUPPLY_LOCATION, MAIN_OPERATING_BASE))
      THEN
         RETURN TRUE;
      ELSE
         RETURN FALSE;
      END IF;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN TRUE;
   END isAutoDefaulted;

   FUNCTION autoDefaultMtd
      RETURN mtd_rec
   IS
      retMtdRec   mtd_rec;
   BEGIN
      retMtdRec.nrts := 1;
      retMtdRec.rts := 0;
      retMtdRec.condemn := 0;
      RETURN retMtdRec;
   END autoDefaultMtd;

   FUNCTION ConvertMtdToDataSys (pLocId              amd_spare_networks.LOC_ID%TYPE,
                                 pCapabilityLevel    VARCHAR2,
                                 pRepairInd          VARCHAR2,
                                 pNrts               NUMBER,
                                 pRts                NUMBER,
                                 pCondemn            NUMBER)
      RETURN mtd_rec
   IS
      retRec   mtd_rec;
      tot      NUMBER;
   BEGIN
      retRec.rts := ROUND (NVL (pRts, 0), DP);
      retRec.nrts := ROUND (NVL (pNrts, 0), DP);
      retRec.condemn := 1 - (retRec.rts + retRec.nrts);

      tot := retRec.rts + retRec.nrts + retRec.condemn;

      IF (tot = 0 OR retRec.rts < 0 OR retRec.nrts < 0 OR retRec.condemn < 0)
      THEN
         RETURN defaultMtdToDataSys (pLocId);
      END IF;

      /* make the sum equal 1 */
      IF (tot != 1)
      THEN
         retRec.rts := ROUND (retRec.rts / tot, DP);
         retRec.nrts := ROUND (retRec.nrts / tot, DP);
         retRec.condemn := 1 - (retRec.rts + retRec.nrts);
      END IF;

      IF (pLocId = amd_defaults.AMD_WAREHOUSE_LOCID)
      THEN
         IF (retRec.rts = 1)
         THEN
            retRec.condemn := 0;
         ELSE
            retRec.condemn := ROUND (retRec.condemn / (1 - retRec.rts), DP);
         END IF;

         retRec.nrts := 0;
      /* not warehouse */
      ELSIF (    NVL (pCapabilityLevel, 'notO') = '0'
             AND NVL (pRepairInd, 'Y') = 'Y')
      THEN
         retRec.nrts := 1 - retRec.rts;
         retRec.condemn := 0;
      ELSE
         retRec.nrts := 1;
         retRec.condemn := 0;
         retRec.rts := 0;
      END IF;

      IF retRec.nrts + retRec.condemn + retRec.rts <> 1
      THEN
         debugMsg (
            msg               =>    retRec.nrts
                                 || ', '
                                 || retRec.rts
                                 || ', '
                                 || retRec.condemn
                                 || ' ='
                                 || (retRec.rts + retRec.nrts + retRec.condemn),
            pError_location   => 30);

         debugMsg (
            msg               =>    retRec.nrts / tot
                                 || ', '
                                 || retRec.rts / tot
                                 || ', '
                                 || retRec.condemn / tot,
            pError_location   => 40);

         retRec.rts := ROUND (retRec.rts / tot, DP);
         retRec.nrts := ROUND (retRec.nrts / tot, DP);
         retRec.condemn := 1 - (retRec.rts + retRec.nrts);

         debugMsg (
            msg               =>    retRec.nrts
                                 || ', '
                                 || retRec.rts
                                 || ', '
                                 || retRec.condemn
                                 || ' ='
                                 || (retRec.rts + retRec.nrts + retRec.condemn),
            pError_location   => 50);

         IF retRec.nrts + retRec.condemn + retRec.rts <> 1
         THEN
            RAISE maint_task_distrib_exception;
         END IF;
      END IF;

      RETURN retRec;
   EXCEPTION
      WHEN maint_task_distrib_exception
      THEN
         ErrorMsg (
            pSqlfunction         => 'convertMtd',
            pTableName           => 'tmp_amd_part_factors',
            pError_location      => 60,
            pKey_1               => pLocId,
            pKey_2               => retRec.nrts,
            pKey_3               => retRec.rts,
            pKey_4               =>    retRec.condemn
                                    || ' ='
                                    || (retRec.rts + retRec.nrts + retRec.condemn),
            pKeywordValuePairs   =>    pNrts
                                    || ', '
                                    || pRts
                                    || ', '
                                    || pCondemn
                                    || ', '
                                    || pCapabilityLevel
                                    || ', '
                                    || pRepairInd);
         RAISE;
   END ConvertMtdToDataSys;



   PROCEDURE UpdateAmdPartFactors (
      pPartNo          amd_part_factors.part_no%TYPE,
      pLocSid          amd_part_factors.loc_sid%TYPE,
      pPassUpRate      amd_part_factors.pass_up_rate%TYPE,
      pRts             amd_part_factors.rts%TYPE,
      pCmdmdRate       amd_part_factors.cmdmd_rate%TYPE,
      pActionCode      amd_part_factors.action_code%TYPE,
      pLastUpdateDt    amd_part_factors.last_update_dt%TYPE)
   IS
   BEGIN
      UPDATE amd_part_factors
         SET pass_up_rate = pPassUpRate,
             rts = pRts,
             cmdmd_rate = pCmdmdRate,
             action_code = pActionCode,
             last_update_dt = pLastUpdateDt
       WHERE part_no = pPartNo AND loc_sid = pLocSid;
   END UpdateAmdPartFactors;

   PROCEDURE UpdateTmpAmdPartFactors (
      pPartNo          amd_part_factors.part_no%TYPE,
      pLocSid          amd_part_factors.loc_sid%TYPE,
      pPassUpRate      amd_part_factors.pass_up_rate%TYPE,
      pRts             amd_part_factors.rts%TYPE,
      pCmdmdRate       amd_part_factors.cmdmd_rate%TYPE,
      pActionCode      amd_part_factors.action_code%TYPE,
      pLastUpdateDt    amd_part_factors.last_update_dt%TYPE)
   IS
   BEGIN
      UPDATE tmp_amd_part_factors
         SET pass_up_rate = pPassUpRate,
             rts = pRts,
             cmdmd_rate = pCmdmdRate,
             action_code = pActionCode,
             last_update_dt = pLastUpdateDt
       WHERE part_no = pPartNo AND loc_sid = pLocSid;
   END UpdateTmpAmdPartFactors;

   PROCEDURE InsertAmdPartFactors (
      pPartNo          amd_part_factors.part_no%TYPE,
      pLocSid          amd_spare_networks.loc_sid%TYPE,
      pPassUpRate      amd_part_factors.pass_up_rate%TYPE,
      pRts             amd_part_factors.rts%TYPE,
      pCmdmdRate       amd_part_factors.cmdmd_rate%TYPE,
      pActionCode      amd_part_factors.action_code%TYPE,
      pLastUpdateDt    amd_part_factors.last_update_dt%TYPE)
   IS
   BEGIN
      INSERT INTO amd_part_factors (part_no,
                                    loc_sid,
                                    pass_up_rate,
                                    rts,
                                    cmdmd_rate,
                                    action_code,
                                    last_update_dt)
           VALUES (pPartNo,
                   pLocSid,
                   pPassUpRate,
                   pRts,
                   pCmdmdRate,
                   pActionCode,
                   pLastUpdateDt);
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
         UpdateAmdPartFactors (pPartNo,
                               pLocSid,
                               pPassUpRate,
                               pRts,
                               pCmdmdRate,
                               pActionCode,
                               pLastUpdateDt);
   END InsertAmdPartFactors;

   PROCEDURE InsertTmpAmdPartFactors (
      pPartNo          amd_part_factors.part_no%TYPE,
      pLocSid          amd_part_factors.loc_sid%TYPE,
      pPassUpRate      amd_part_factors.pass_up_rate%TYPE,
      pRts             amd_part_factors.rts%TYPE,
      pCmdmdRate       amd_part_factors.cmdmd_rate%TYPE,
      pActionCode      amd_part_factors.action_code%TYPE,
      pLastUpdateDt    amd_part_factors.last_update_dt%TYPE)
   IS
      returnCode   NUMBER;
   BEGIN
      INSERT INTO tmp_amd_part_factors (part_no,
                                        loc_sid,
                                        pass_up_rate,
                                        rts,
                                        cmdmd_rate,
                                        action_code,
                                        last_update_dt)
           VALUES (pPartNo,
                   pLocSid,
                   pPassUpRate,
                   pRts,
                   pCmdmdRate,
                   pActionCode,
                   pLastUpdateDt);
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
         UpdateTmpAmdPartFactors (pPartNo,
                                  pLocSid,
                                  pPassUpRate,
                                  pRts,
                                  pCmdmdRate,
                                  pActionCode,
                                  pLastUpdateDt);
      WHEN OTHERS
      THEN
         returnCode :=
            ErrorMsg (
               pSourceName       => 'InsertTmpAmdPartFactors',
               pTableName        => 'tmp_amd_part_factors',
               pError_location   => 70,
               pReturn_code      => 99,
               pKey1             => pPartNo,
               pKey2             => pLocSid,
               pKey3             => TO_CHAR (pPassUpRate),
               pData             =>    'pRts='
                                    || pRts
                                    || ' pCmdmdRate='
                                    || pCmdmdRate,
               pComments         => PKGNAME);
         RAISE;
   END InsertTmpAmdPartFactors;

   FUNCTION InsertRow (
      pPartNo                amd_part_factors.part_no%TYPE,
      pLocSid                amd_part_factors.loc_sid%TYPE,
      pPassUpRate            amd_part_factors.pass_up_rate%TYPE,
      pRts                   amd_part_factors.rts%TYPE,
      pCmdmdRate             amd_part_factors.cmdmd_rate%TYPE,
      pCriticality           amd_national_stock_items.criticality%TYPE,
      pCriticalityChanged    amd_national_stock_items.criticality_changed%TYPE,
      pCriticalityCleaned    amd_national_stock_items.criticality_cleaned%TYPE)
      RETURN NUMBER
   IS
      locationInfo   amd_spare_networks%ROWTYPE;
      mtdRec         mtd_rec := NULL;
      crit           amd_national_stock_items.criticality%TYPE := NULL;
      returnCode     NUMBER;
   BEGIN
      BEGIN
         InsertAmdPartFactors (pPartNo,
                               pLocSid,
                               pPassUpRate,
                               pRts,
                               pCmdmdRate,
                               Amd_Defaults.INSERT_ACTION,
                               SYSDATE);
      EXCEPTION
         WHEN OTHERS
         THEN
            returnCode :=
               ErrorMsg (pSourceName       => 'InsertRow.InsertAmdPartFactors',
                         pTableName        => 'amd_part_factors',
                         pError_location   => 80,
                         pReturn_code      => 99,
                         pKey1             => pPartNo,
                         pKey2             => pLocSid,
                         pKey3             => '',
                         pData             => '',
                         pComments         => PKGNAME);
            RAISE;
      END;

      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN FAILURE;
   END InsertRow;

   FUNCTION UpdateRow (
      pPartNo                amd_part_factors.part_no%TYPE,
      pLocSid                amd_part_factors.loc_sid%TYPE,
      pPassUpRate            amd_part_factors.pass_up_rate%TYPE,
      pRts                   amd_part_factors.rts%TYPE,
      pCmdmdRate             amd_part_factors.cmdmd_rate%TYPE,
      pCriticality           amd_national_stock_items.criticality%TYPE,
      pCriticalityChanged    amd_national_stock_items.criticality_changed%TYPE,
      pCriticalityCleaned    amd_national_stock_items.criticality_cleaned%TYPE)
      RETURN NUMBER
   IS
      locationInfo   amd_spare_networks%ROWTYPE;
      mtdRec         mtd_rec := NULL;
      returnCode     NUMBER;
      crit           amd_national_stock_items.criticality%TYPE;
   BEGIN
      BEGIN
         UpdateAmdPartFactors (pPartNo,
                               pLocSid,
                               pPassUpRate,
                               pRts,
                               pCmdmdRate,
                               Amd_Defaults.UPDATE_ACTION,
                               SYSDATE);
      EXCEPTION
         WHEN OTHERS
         THEN
            returnCode :=
               ErrorMsg (pSourceName       => 'UpdateRow.UpdateAmdPartFactors',
                         pTableName        => 'tmp_amd_part_factors',
                         pError_location   => 90,
                         pReturn_code      => 99,
                         pKey1             => pPartNo,
                         pKey2             => pLocSid,
                         pKey3             => '',
                         pData             => '',
                         pComments         => PKGNAME);
            RAISE;
      END;

      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN FAILURE;
   END UpdateRow;

   FUNCTION DeleteRow (pPartNo    amd_part_factors.part_no%TYPE,
                       pLocSid    amd_part_factors.loc_sid%TYPE)
      RETURN NUMBER
   IS
      locationInfo   amd_spare_networks%ROWTYPE;
      mtdRec         mtd_rec := NULL;
      crit           amd_national_stock_items.criticality%TYPE := NULL;
      returnCode     NUMBER;
   BEGIN
      BEGIN
         UPDATE amd_part_factors
            SET action_code = amd_defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
          WHERE part_no = pPartNo AND loc_sid = pLocSid;
      EXCEPTION
         WHEN OTHERS
         THEN
            returnCode :=
               ErrorMsg (pSourceName       => 'DeleteRow.UpdateAmdPartFactors',
                         pTableName        => 'amd_part_factors',
                         pError_location   => 100,
                         pReturn_code      => 99,
                         pKey1             => pPartNo,
                         pKey2             => pLocSid,
                         pKey3             => '',
                         pData             => '',
                         pComments         => PKGNAME);
            RAISE;
      END;

      RETURN SUCCESS;
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN FAILURE;
   END DeleteRow;

   FUNCTION DeleteRow (
      pPartNo                amd_part_factors.part_no%TYPE,
      pLocSid                amd_part_factors.loc_sid%TYPE,
      pPassUpRate            amd_part_factors.pass_up_rate%TYPE,
      pRts                   amd_part_factors.rts%TYPE,
      pCmdmdRate             amd_part_factors.cmdmd_rate%TYPE,
      pCriticality           amd_national_stock_items.criticality%TYPE,
      pCriticalityChanged    amd_national_stock_items.criticality_changed%TYPE,
      pCriticalityCleaned    amd_national_stock_items.criticality_cleaned%TYPE)
      RETURN NUMBER
   IS
      locationInfo   amd_spare_networks%ROWTYPE;
      mtdRec         mtd_rec := NULL;
      crit           amd_national_stock_items.criticality%TYPE := NULL;
      returnCode     NUMBER;
   BEGIN
      RETURN deleteRow (pPartNo, pLocSid);
   EXCEPTION
      WHEN OTHERS
      THEN
         RETURN FAILURE;
   END DeleteRow;


   /*
        ----------------------------------------------
        Load related procedures
        ----------------------------------------------
   */



   FUNCTION GetRepairIndicator (pNsn        bssm_base_parts.nsn%TYPE,
                                pSran       bssm_base_parts.sran%TYPE,
                                pLockSid    bssm_locks.LOCK_SID%TYPE)
      RETURN VARCHAR2
   IS
      retRI   bssm_base_parts.repair_indicator%TYPE;
   BEGIN
      IF ( (pNsn IS NULL) OR (pSran IS NULL))
      THEN
         RETURN NULL;
      END IF;

      SELECT repair_indicator
        INTO retRI
        FROM bssm_base_parts bbp, amd_nsns an
       WHERE     bbp.lock_sid = pLockSid
             AND an.nsn = bbp.nsn
             AND an.nsn_type = 'C' -- use the current nsn vs the temporary nsn
             AND an.nsi_sid = (SELECT nsi_sid
                                 FROM amd_nsns
                                WHERE nsn = pNsn)
             AND bbp.sran = pSran;

      RETURN retRI;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN NULL;
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'GetRepairIndicator',
                   pTableName        => 'bssm_base_parts',
                   pError_location   => 110,
                   pKey_1            => pNsn,
                   pKey_2            => pSran,
                   pKey_3            => pLockSid);
         RAISE;
   END GetRepairIndicator;

   FUNCTION GetCapabilityLevel (pLocId amd_spare_networks.loc_id%TYPE)
      RETURN bssm_bases.capabilty_level%TYPE
   IS
      retCap   bssm_bases.capabilty_level%TYPE := NULL;
   BEGIN
      SELECT capabilty_level
        INTO retCap
        FROM bssm_bases
       WHERE     sran =
                    DECODE (
                       pLocId,
                       Amd_Defaults.AMD_WAREHOUSE_LOCID, Amd_Defaults.BSSM_WAREHOUSE_SRAN,
                       pLocId)
             AND lock_sid = '0';

      RETURN retCap;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN NULL;
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'GetCapabilityLevel',
                   pTableName        => 'bssm_bases',
                   pError_location   => 120,
                   pKey_1            => pLocId);
         RAISE;
   END GetCapabilityLevel;

   FUNCTION LoadTmpAmdPartFactorsByLocType (
      pLocType   IN amd_spare_networks.loc_type%TYPE)
      RETURN NUMBER
   IS
      -- no mapping of amd loc_id to bssm sran for this one, use ByLocId if needed

      CURSOR partFactors_cur
      IS
         SELECT spo_prime_part_no,
                ansi.nsn,
                loc_sid,
                loc_type,
                loc_id,
                amd_preferred_pkg.GetPreferredValue (rts_avg_cleaned,
                                                     rts_avg,
                                                     rts_avg_defaulted)
                   rts,
                amd_preferred_pkg.GetPreferredValue (nrts_avg_cleaned,
                                                     nrts_avg,
                                                     nrts_avg_defaulted)
                   nrts,
                amd_preferred_pkg.GetPreferredValue (condemn_avg_cleaned,
                                                     condemn_avg,
                                                     condemn_avg_defaulted)
                   condemn
           FROM amd_national_stock_items ansi,
                amd_spare_parts parts,
                amd_spare_networks asn
          WHERE     is_spo_part = 'Y'
                AND parts.part_no = parts.spo_prime_part_no
                AND parts.spo_prime_part_no = ansi.prime_part_no
                AND ansi.action_code != Amd_Defaults.DELETE_ACTION
                AND asn.action_code != Amd_Defaults.DELETE_ACTION
                AND asn.loc_type = pLocType;

      mtdRec         mtd_rec;
      locationInfo   amd_spare_networks%ROWTYPE;
      returnCode     NUMBER := 0;
      cnt            NUMBER := 0;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_part_factors',
         pError_location   => 130,
         pKey1             => 'loadTmpAmdPartFactorsByLocType',
         pKey3             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
      COMMIT;

      OPEN partFactors_cur;

      FETCH partFactors_cur BULK COLLECT INTO partFactorsRecs;

      CLOSE partFactors_cur;

      IF partFactorsRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN partFactorsRecs.FIRST .. partFactorsRecs.LAST
         LOOP
            BEGIN
               locationInfo.loc_type := partFactorsRecs (indx).loc_type;
               locationInfo.loc_id := partFactorsRecs (indx).loc_id;
               mtdRec := NULL;

               IF IsAutoDefaulted (locationInfo)
               THEN
                  mtdRec := AutoDefaultMtd;
               ELSE
                 <<convertMtd>>
                  BEGIN
                     mtdRec :=
                        convertMtdToDataSys (
                           locationInfo.loc_id,
                           GetCapabilityLevel (partFactorsRecs (indx).loc_id),
                           amd_preferred_pkg.GetPreferredValue (
                              GetRepairIndicator (
                                 partFactorsRecs (indx).nsn,
                                 partFactorsRecs (indx).loc_id,
                                 '2'),
                              GetRepairIndicator (
                                 partFactorsRecs (indx).nsn,
                                 partFactorsRecs (indx).loc_id,
                                 '0')),
                           partFactorsRecs (indx).nrts,
                           partFactorsRecs (indx).rts,
                           partFactorsRecs (indx).condemn);
                  EXCEPTION
                     WHEN maint_task_distrib_exception
                     THEN
                        ErrorMsg (
                           pSqlfunction      => 'select',
                           pTableName        => 'tmp_amd_part_factors',
                           pError_location   => 140,
                           pKey_1            => locationInfo.loc_id,
                           pKey_2            => partFactorsRecs (indx).nrts,
                           pKey_3            => partFactorsRecs (indx).rts,
                           pKey_4            =>    partFactorsRecs (indx).condemn
                                                || ' ='
                                                || (  partFactorsRecs (indx).rts
                                                    + partFactorsRecs (indx).nrts
                                                    + partFactorsRecs (indx).condemn));
                        RAISE;
                     WHEN OTHERS
                     THEN
                        ErrorMsg (
                           pSqlfunction      => 'select',
                           pTableName        => 'tmp_amd_part_factors',
                           pError_location   => 150,
                           pKey_1            => locationInfo.loc_id,
                           pKey_2            => partFactorsRecs (indx).nrts,
                           pKey_3            => partFactorsRecs (indx).rts,
                           pKey_4            =>    partFactorsRecs (indx).condemn
                                                || ' ='
                                                || (  partFactorsRecs (indx).rts
                                                    + partFactorsRecs (indx).nrts
                                                    + partFactorsRecs (indx).condemn));
                        RAISE;
                  END convertMtd;
               END IF;

               InsertTmpAmdPartFactors (partFactorsRecs (indx).part_no,
                                        partFactorsRecs (indx).loc_sid,
                                        mtdRec.nrts,
                                        mtdRec.rts,
                                        mtdRec.condemn,
                                        Amd_Defaults.INSERT_ACTION,
                                        SYSDATE);
               cnt := cnt + 1;
            EXCEPTION
               WHEN OTHERS
               THEN
                  returnCode :=
                     ErrorMsg (
                        pSourceName       => 'LoadTmpAmdPartFactorsByLocType',
                        pTableName        => 'tmp_amd_part_factors',
                        pError_location   => 160,
                        pReturn_code      => 99,
                        pKey1             =>    'locType:'
                                             || partFactorsRecs (indx).loc_type,
                        pKey2             =>    'partNo:'
                                             || partFactorsRecs (indx).part_no,
                        pKey3             =>    'locSid:'
                                             || partFactorsRecs (indx).loc_sid,
                        pData             =>    'cnt='
                                             || cnt
                                             || ' indx='
                                             || indx
                                             || ' partFactorsRecs.LAST='
                                             || partFactorsRecs.LAST,
                        pComments         => PKGNAME);
                  RAISE;
            END;
         END LOOP;

         COMMIT;
      END IF;

      writeMsg (
         pTableName        => 'tmp_amd_part_factors',
         pError_location   => 170,
         pKey1             => 'loadTmpAmdPartFactorsByLocType',
         pKey2             => 'cnt=' || cnt,
         pKey3             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      RETURN cnt;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'select',
                   pTableName        => 'tmp_amd_part_factors',
                   pError_location   => 180,
                   pKey_1            => pLocType);
         RAISE;
   END LoadTmpAmdPartFactorsByLocType;


   FUNCTION LoadTmpAmdPartFactors (
      pAmdLocId   IN amd_spare_networks.loc_id%TYPE,
      pBssmSran   IN bssm_base_parts.sran%TYPE)
      RETURN NUMBER
   IS
      CURSOR partFactors_cur
      IS
         SELECT spo_prime_part_no,
                ansi.nsn,
                loc_sid,
                loc_type,
                loc_id,
                amd_preferred_pkg.GetPreferredValue (rts_avg_cleaned,
                                                     rts_avg,
                                                     rts_avg_defaulted)
                   rts,
                amd_preferred_pkg.GetPreferredValue (nrts_avg_cleaned,
                                                     nrts_avg,
                                                     nrts_avg_defaulted)
                   nrts,
                amd_preferred_pkg.GetPreferredValue (condemn_avg_cleaned,
                                                     condemn_avg,
                                                     condemn_avg_defaulted)
                   condemn
           FROM amd_national_stock_items ansi,
                amd_spare_parts parts,
                amd_spare_networks asn
          WHERE     parts.is_spo_part = 'Y'
                AND parts.part_no = parts.spo_prime_part_no
                AND parts.spo_prime_part_no = ansi.prime_part_no
                AND ansi.action_code != Amd_Defaults.DELETE_ACTION
                AND asn.action_code != Amd_Defaults.DELETE_ACTION
                AND asn.loc_id = pAmdLocId;

      cnt            NUMBER := 0;
      mtdRec         mtd_rec;
      locationInfo   amd_spare_networks%ROWTYPE;
      returnCode     NUMBER;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_part_factors',
         pError_location   => 190,
         pKey1             => 'loadTmpAmdPartFactors',
         pKey3             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      OPEN partFactors_cur;

      FETCH partFactors_cur BULK COLLECT INTO partFactorsRecs;

      CLOSE partFactors_cur;

      IF partFactorsRecs.FIRST IS NOT NULL
      THEN
         FOR indx IN partFactorsRecs.FIRST .. partFactorsRecs.LAST
         LOOP
            BEGIN
               locationInfo.loc_type := partFactorsRecs (indx).loc_type;
               locationInfo.loc_id := partFactorsRecs (indx).loc_id;
               mtdRec := NULL;

               IF IsAutoDefaulted (locationInfo)
               THEN
                  mtdRec := AutoDefaultMtd;
               ELSE
                 <<convertMtd>>
                  BEGIN
                     mtdRec :=
                        convertMtdToDataSys (
                           locationInfo.loc_id,
                           GetCapabilityLevel (partFactorsRecs (indx).loc_id),
                           amd_preferred_pkg.GetPreferredValue (
                              GetRepairIndicator (
                                 partFactorsRecs (indx).nsn,
                                 partFactorsRecs (indx).loc_id,
                                 '2'),
                              GetRepairIndicator (
                                 partFactorsRecs (indx).nsn,
                                 partFactorsRecs (indx).loc_id,
                                 '0')),
                           partFactorsRecs (indx).nrts,
                           partFactorsRecs (indx).rts,
                           partFactorsRecs (indx).condemn);
                  EXCEPTION
                     WHEN maint_task_distrib_exception
                     THEN
                        ErrorMsg (
                           pSqlfunction      => 'select',
                           pTableName        => 'tmp_amd_part_factors',
                           pError_location   => 200,
                           pKey_1            => locationInfo.loc_id,
                           pKey_2            => partFactorsRecs (indx).nrts,
                           pKey_3            => partFactorsRecs (indx).rts,
                           pKey_4            =>    partFactorsRecs (indx).condemn
                                                || ' ='
                                                || (  partFactorsRecs (indx).rts
                                                    + partFactorsRecs (indx).nrts
                                                    + partFactorsRecs (indx).condemn));
                        RAISE;
                  END convertMtd;
               END IF;

               InsertTmpAmdPartFactors (partFactorsRecs (indx).part_no,
                                        partFactorsRecs (indx).loc_sid,
                                        mtdRec.nrts,
                                        mtdRec.rts,
                                        mtdRec.condemn,
                                        Amd_Defaults.INSERT_ACTION,
                                        SYSDATE);
               cnt := cnt + 1;
            EXCEPTION
               WHEN OTHERS
               THEN
                  returnCode :=
                     ErrorMsg (
                        pSourceName       => 'LoadTmpAmdPartFactors',
                        pTableName        => 'tmp_amd_part_factors',
                        pError_location   => 210,
                        pReturn_code      => 99,
                        pKey1             =>    'locType:'
                                             || partFactorsRecs (indx).loc_type,
                        pKey2             =>    'partNo:'
                                             || partFactorsRecs (indx).part_no,
                        pKey3             =>    'locSid:'
                                             || partFactorsRecs (indx).loc_sid,
                        pData             => '',
                        pComments         => PKGNAME);
                  RAISE;
            END;
         END LOOP;

         COMMIT;
      END IF;

      writeMsg (
         pTableName        => 'tmp_amd_part_factors',
         pError_location   => 220,
         pKey1             => 'loadTmpAmdPartFactors',
         pKey2             => 'cnt=' || cnt,
         pKey3             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      RETURN cnt;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'select',
                   pTableName        => 'tmp_amd_part_factors',
                   pError_location   => 230,
                   pKey_1            => pAmdLocId,
                   pKey_2            => pBssmSran);
         RAISE;
   END LoadTmpAmdPartFactors;



   FUNCTION LoadTmpAmdPartFactors (
      pAmdLocId   IN amd_spare_networks.loc_id%TYPE)
      RETURN NUMBER
   IS
   BEGIN
      RETURN LoadTmpAmdPartFactors (pAmdLocId, pAmdLocId);
   END;


   PROCEDURE LoadTmpAmdPartFactors
   IS
      NO_BSSM_SRAN   VARCHAR2 (6) := NULL;
      cnt            NUMBER := 0;
   BEGIN
      writeMsg (
         pTableName        => 'tmp_amd_part_factors',
         pError_location   => 240,
         pKey1             => 'loadTmpAmdPartFactors',
         pKey3             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      mta_truncate_table ('tmp_amd_part_factors', 'reuse storage');


      -- mob and fsls
      cnt := LoadTmpAmdPartFactorsByLocType (MAIN_OPERATING_BASE);
      cnt := cnt + LoadTmpAmdPartFactorsByLocType (FORWARD_SUPPLY_LOCATION);
      -- whse - bssm 'W'', amd 'CTLATL'
      cnt :=
           cnt
         + LoadTmpAmdPartFactors (amd_defaults.AMD_WAREHOUSE_LOCID,
                                  amd_defaults.BSSM_WAREHOUSE_SRAN);
      cnt := cnt + LoadTmpAmdPartFactors (amd_defaults.AMD_UK_LOC_ID);
      cnt := cnt + LoadTmpAmdPartFactors (amd_defaults.AMD_BASC_LOC_ID);

      writeMsg (
         pTableName        => 'tmp_amd_part_factors',
         pError_location   => 250,
         pKey1             => 'loadTmpAmdPartFactors',
         pKey2             => 'cnt=' || TO_CHAR (cnt),
         pKey3             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'loadTmpAmdPartFactors',
                   pTableName        => 'tmp_amd_part_factors',
                   pError_location   => 260);
         RAISE;
   END LoadTmpAmdPartFactors;


   PROCEDURE LoadInitial
   IS
      returnCode   NUMBER;
      doAllA2A     BOOLEAN := TRUE;
   BEGIN
      mta_truncate_table ('amd_part_factors', 'reuse storage');
      COMMIT;
      LoadTmpAmdPartFactors;

      INSERT INTO amd_part_factors
         SELECT * FROM tmp_amd_part_factors;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         returnCode :=
            ErrorMsg (pSourceName       => 'LoadInitial',
                      pTableName        => 'tmp_amd_part_factors',
                      pError_location   => 270,
                      pReturn_code      => 99,
                      pKey1             => '',
                      pKey2             => '',
                      pKey3             => '',
                      pData             => '',
                      pComments         => PKGNAME || ': LoadInitial');
         RAISE;
   END;

   PROCEDURE version
   IS
   BEGIN
      writeMsg (pTableName        => 'amd_part_factors_pkg',
                pError_location   => 280,
                pKey1             => 'amd_part_factors_pkg',
                pKey2             => '$Revision:   1.17  $');
   END version;

   FUNCTION getVersion
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN '$Revision:   1.17  $';
   END getVersion;


   PROCEDURE setDebug (VALUE IN VARCHAR2)
   IS
   BEGIN
      debug :=
         UPPER (VALUE) IN ('T',
                           'TRUE',
                           'Y',
                           'YES');
   END setDebug;

   FUNCTION getDebug
      RETURN VARCHAR2
   IS
   BEGIN
      IF debug
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getDebug;
END AMD_PART_FACTORS_PKG;
/


DROP PACKAGE BODY AMD_OWNER.AMD_PART_LOCS_LOAD_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_PART_LOCS_LOAD_PKG
IS
    /*

       $Author:   zf297a  $
     $Revision:   1.13  $
         $Date:   07 Dec 2011 23:59:08  $
     $Workfile:   amd_part_locs_load_pkg.pkb  $


      Rev 1.13    13 Feb 2012 used common routine and new amd_repair_cost_detail to calc avg cost  to repair off base zf297a

     Rev 1.12     07 Dec 2011 Made the ccn_prefix query more flexible by using the length of the ccn_prefix in the substr of the existential subquery and added function getVersion

      Rev 1.11   07 Nov 2007 23:59:08   zf297a
   Use bulk collect and bulk insert for major cursors.

      Rev 1.10   12 Sep 2007 15:39:36   zf297a
   Removed commits from for loops.

      Rev 1.9   15 May 2007 09:33:30   zf297a
   Eliminated writing "unique constraint" errors to amd_load_details when the procedure does not stop.  Added using mod to check for commit points.  Used enhanced writeMsg and errorMsg to write messages and errors to amd_load_details.  Added recording of "start" and "end" times to amd_load_details.

      Rev 1.8   Jun 09 2006 12:12:20   zf297a
   implemented version

      Rev 1.7   Dec 06 2005 10:33:56   zf297a
   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS

      Rev 1.4.1.1   Jun 13 2005 09:19:06   c970183
   Added PVCS keywords

*/
/*
	--  Date	  	  By			History
   	--  ----		  --			-------
   	--  10/10/01	  	  ks		initial implementation
   	--  12/11/01	  	  dse		Added named param for amd_preferred_pkg.GetUnitCost(.....
   	--  8/14/02		  ks            change fsl query to be more efficient.
	--  6/01/05		  ks		changes to support AMD 1.7.1 - change to RSP_ON_HAND, RSP_OBJECTIVE
	--					mod to queries for bssm, eg. lock_sid use '0' instead of 0
*/
  	ERRSOURCE constant varchar2(20) := 'amdpartlocsloadpkg';
    dups number := 0 ;
	procedure writeMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 in varchar2 := '',
				pData IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS
	BEGIN
		Amd_Utils.writeMsg (
				pSourceName => 'amd_part_locs_load_pkg',
				pTableName  => pTableName,
				pError_location => pError_location,
				pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
    exception when others then
        -- trying to rollback or commit from trigger
        if sqlcode = 4092 then
            raise_application_error(-20010,
                substr('amd_part_locs_load_pkg '
                    || sqlcode || ' '
                    || pError_Location || ' '
                    || pTableName || ' '
                    || pKey1 || ' '
                    || pKey2 || ' '
                    || pKey3 || ' '
                    || pKey4 || ' '
                    || pData, 1,2000)) ;
        else
            raise ;
        end if ;
	end writeMsg ;

	PROCEDURE ErrorMsg(
	    pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
	    pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
	    pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
	    pKey1 IN AMD_LOAD_DETAILS.KEY_1%TYPE := '',
	    pKey2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
	    pKey3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
	    pKey4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
        pComments IN VARCHAR2 := '') IS

        key5 AMD_LOAD_DETAILS.KEY_5%TYPE := pComments ;
        error_location number ;

    BEGIN
      ROLLBACK;
      IF key5 = '' THEN
         key5 := pSqlFunction || '/' || pTableName ;
      ELSE
       key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
      END IF ;
      if amd_utils.isNumber(pError_location) then
           error_location := pError_location ;
      else
           error_location := -9999 ;
      end if ;
      -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
      -- do not exceed the length of the column's that the data gets inserted into
      -- This is for debugging and logging, so efforts to make it not be the source of more
      -- errors is VERY important
      Amd_Utils.InsertErrorMsg (
        pLoad_no => Amd_Utils.GetLoadNo(
          pSourceName => SUBSTR(pSqlfunction,1,20),
          pTableName  => SUBSTR(pTableName,1,20)),
        pData_line_no => error_location,
        pData_line    => 'amd_part_locs_load_pkg',
        pKey_1 => SUBSTR(pKey1,1,50),
        pKey_2 => SUBSTR(pKey2,1,50),
        pKey_3 => SUBSTR(pKey3,1,50),
        pKey_4 => SUBSTR(pKey4,1,50),
        pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS') ||
             ' ' || substr(key5,1,50),
        pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
        COMMIT;

    EXCEPTION WHEN OTHERS THEN
	  if pSqlFunction is not null then dbms_output.put_line('pSqlFunction=' || pSqlfunction) ; end if ;
	  if pTableName is not null then dbms_output.put_line('pTableName=' || pTableName) ; end if ;
	  if pError_location is not null then dbms_output.put_line('pError_location=' || pError_location) ; end if ;
	  if pKey1 is not null then dbms_output.put_line('key1=' || pKey1) ; end if ;
	  if pkey2 is not null then dbms_output.put_line('key2=' || pKey2) ; end if ;
	  if pKey3 is not null then dbms_output.put_line('key3=' || pKey3) ; end if ;
	  if pKey4 is not null then dbms_output.put_line('key4=' || pKey4) ; end if ;
	  if pComments is not null then dbms_output.put_line('pComments=' || pComments) ; end if ;
       raise_application_error(-20030,
            substr('amd_part_locs_load_pkg '
                || sqlcode || ' '
                || pError_location || ' '
                || pSqlFunction || ' '
                || pTableName || ' '
                || pKey1 || ' '
                || pKey2 || ' '
                || pKey3 || ' '
                || pKey4 || ' '
                || pComments,1, 2000)) ;
	END ErrorMsg;

	function GetAmdNsiRec(pNsiSid amd_national_stock_items.nsi_sid%type) return amd_national_stock_items%rowtype is
			amdNsiRec amd_national_stock_items%rowtype := null;
		begin
	    	select *
			into amdNsiRec
			from amd_national_stock_items
			where nsi_sid = pNsiSid;
			return amdNsiRec;
		exception
			when no_data_found then
				 return amdNsiRec;
	end GetAmdNsiRec;

	/* function GetOffBaseRepairCost, logic same as previous load version */
	function  GetOffBaseRepairCost(pPartNo char) return amd_part_locs.cost_to_repair%type is
        nsiSid amd_national_stock_items.nsi_sid%type := null ;
		--
		--    Use only PART   number because POI1 does not have Cage Code.
		--
	begin
        select nsi_sid into nsiSid from amd_national_stock_items items,
        amd_spare_parts parts where parts.part_no = pPartNo
        and parts.nsn = items.nsn
        and parts.action_code <> 'D'
        and items.action_code <> 'D' ;

        return AMD_OWNER.GETCOSTTOREPAIROFFBASE( nsiSid) ;

	exception
		when no_data_found then
			 return null;
	end GetOffBaseRepairCost;

	/* function get_off_base_tat, logic same as previous load version
	   removed offbasediag time from previous version */
	function GetOffBaseTurnAround (pPartno char) return amd_part_locs.time_to_repair%type is
		-- goldpart      char(50);
		offBaseTurnAroundTime amd_part_locs.time_to_repair%type;

	begin
		select
			avg( completed_docdate  - created_docdate)
		into offBaseTurnAroundTime
		from ord1
		where
			part = pPartNo
			and nvl(action_taken,'*') in ('A', 'B', 'E', 'G', '*' )
			and order_type = 'J'
			and completed_docdate is not null
		group by part;
		return offBaseTurnAroundTime;
	exception
		when no_data_found then
			return null;
	end GetOffBaseTurnAround;

	function  GetOnBaseRepairCost (pPartno   varchar2) return   number is

		--
		-- on base repair cost is to be calculated using data
		-- from tmp_lccost table.
		-- this table will be loaded on a monthly basis from rmads and the result
		-- are stored in amd_on_base_repair_costs.
		--
		-- formular:
		--
		-- on base repair cost = average mhr * average dollars($20)
		--
		-- where average mhr is calculated by add up the manhours for each ajcn,
		--  and then divide by the   number of total ajcn for the part.
		--
		--  average dollars is default to $20 per hour at this time.
		--
		--  note: if no part found, default the on base repair cost to $40.00
		--
		onBaseRepairCost number;
	begin
		begin
			select
				on_base_repair_cost
			into onBaseRepairCost
			from amd_on_base_repair_costs
			where part_no = pPartno;
		exception
			when no_data_found then
				return null;
		end;
		return onBaseRepairCost;
	end GetOnBaseRepairCost;

		/* kcs change to ramp%ROWTYPE from rampData_rec */
	function GetRampData(pNsn ramp.nsn%type, pLocSid amd_spare_networks.loc_sid%type) return ramp%ROWTYPE is
		/* rampData rampData_rec := null; */
		rampData ramp%ROWTYPE := null;
		locId amd_spare_networks.loc_id%type;
	begin
		locId := amd_utils.GetLocId(pLocSid);
		if (locId is null) then
		    return rampData;
		else
			return GetRampData(pNsn, locId);
		end if;
	end GetRampData;

		/* kcs change to ramp%ROWTYPE from rampData_rec */
   	function GetRampData(pNsn ramp.nsn%type, pLocId amd_spare_networks.loc_id%type) return ramp%ROWTYPE is
	    cursor rampData_cur (pNsn ramp.nsn%type, pLocId amd_spare_networks.loc_id%type) is
			select *
			from
			   ramp
			where
			   current_stock_number = pNsn and
			   substr(sc, 8, 6) = pLocId;
		nsn ramp.current_stock_number%type;
		rampData rampData_cur%rowtype := null;
		-- though currently ramp does not return more than one record, design
		-- of ramp table allows. current_stock_number is not part of key.
		-- use explicit cursor just in case.

 	begin
		nsn := amd_utils.FormatNsn(pNsn, 'GOLD');
	  	if (not rampData_cur%isOpen) then
		   open rampData_cur(nsn, pLocId);
		end if;
		fetch rampData_cur into
			  rampData;
		close rampData_cur;
		return rampData;
  	end GetRampData;

	--
	-- Select all MOB's from AMD then
	-- remove MOB's from BSSM that have 'N''s
	-- and add FSL's from BSSM that have 'Y''s

	-- lifted from current version, modified to go to
	-- amd_national_stock_items table and add 'OFFBASE' parts.
	-- to minimize recoding, made cursor since amd_part_locs needs nsi and not nsn.

	-- Bob Eberlein's note says that bssm will only carry the current part in
	-- bssm_parts (i.e. not all versions of nsn like nsl, ncz, nsn).
	-- implies won't need to determine which one is "live" in his system
	-- and negates the potential for 3 "nsns" in bssm_parts relating to one nsi_sid.
	-- just pull nsi_sid by amd_nsns, in case bssm_parts one step behind (load
	-- currently less frequent than amd load).

	procedure LoadAmdPartLocations is
			amdNsiRec amd_national_stock_items%rowtype := null;
			amdPartLocsRec amd_part_locs%rowtype := null;
            type amdPartLocsTab is table of amd_part_locs%rowtype ;
            amdPartLocsRecs amdPartLocsTab := amdPartLocsTab() ;

			unitCost amd_spare_parts.unit_cost%type := null;
			locId amd_spare_networks.loc_id%type := null;
			partBaseCleanRec amd_cleaned_from_bssm_pkg.partBaseFields := null;
			/* kcs rampData rampData_rec; */
			rampData ramp%ROWTYPE ;
			countRecs number := 0;
        type partLocsMobRec is record (
            nsi_sid amd_national_stock_items.nsi_sid%type,
            loc_sid amd_spare_networks.loc_sid%type
        ) ;
        type partLocsMobTab is table of partLocsMobRec ;
        partLocsMobRecs partLocsMobTab ;

		cursor partLocsMobList_cur is
			    --
			    -- MOB SELECTION LOGIC
			    --
				--
				-- Select all MOB's from AMD
				--
				-- the order by is to speed up processing of records.
				-- some info is not location dependent currently and therefore
				-- does not have to be re-retrieved.  saves 80% time for 97k+ records.
				-- based on substr if smr null or < 3 chars will be not part of 1st select,
				-- though mdd would.  confirmed with laurie for now, consistent with previous load.
				select * from (
					select
						ansi.nsi_sid,
						asn.loc_sid
					from
						amd_national_stock_items ansi,
						amd_spare_networks asn
					where
						asn.loc_type = 'MOB'
						and substr(amd_preferred_pkg.GetSmrCode(ansi.nsn),3,1) != 'D'
						and ansi.action_code in ('A', 'C')
						and asn.action_code in ('A', 'C')
					--
					-- MOB EXCLUSION LOGIC
					--
					minus
					((select
						-- bbp.nsn
						an.nsi_sid,
						asn.loc_sid
					from
						bssm_base_parts bbp,
						amd_spare_networks asn,
						amd_nsns an
					where
						lock_sid         = '0'
						and bbp.nsn = an.nsn
						and bbp.sran     = asn.loc_id
						and asn.loc_type = 'MOB'
						and bbp.replacement_indicator = 'N'
						and asn.action_code in ('A', 'C')
					minus
					select
						-- bbp.nsn,
						an.nsi_sid,
						asn.loc_sid
					from
						bssm_base_parts bbp,
						amd_spare_networks asn,
						amd_nsns an
					where
						lock_sid         = '2'
						and bbp.nsn = an.nsn
						and bbp.sran     = asn.loc_id
						and asn.loc_type = 'MOB'
						and asn.action_code in ('A', 'C')
						and bbp.replacement_indicator = 'Y')

					union
					select
						-- bbp.nsn,
						an.nsi_sid,
						asn.loc_sid
					from
						bssm_base_parts bbp,
						amd_spare_networks asn,
						amd_nsns an
					where
						lock_sid         = '2'
						and bbp.nsn = an.nsn
						and bbp.sran     = asn.loc_id
						and asn.loc_type = 'MOB'
						and bbp.replacement_indicator = 'N'
						and asn.action_code in ('A', 'C'))
				) order by nsi_sid;

				--
				-- FSL SELECTION LOGIC
				--b1
				--
				-- Select valid combo's using capability logic and valid in
				-- locks 0 and 2
				--
		cursor partLocsFslList_cur is
			  select * from (
				(
				select
				-- bp.nsn,
					an.nsi_sid,
					asn.loc_sid
				from
					bssm_parts bp,
					bssm_bases bb,
					amd_spare_networks asn,
					amd_national_stock_items ansi,
					amd_nsns an
				where
					bp.capability_requirement > 0
					and bp.lock_sid         = '0'
					and bb.lock_sid         = '0'
					and sign((bp.capability_requirement - bb.capabilty_level)) != -1
					and bb.sran             = asn.loc_id
					and asn.loc_type        = 'FSL'
					-- and bp.nsn              = ansi.nsn
					and bp.nsn				= an.nsn
					and an.nsi_sid			= ansi.nsi_sid
					and ansi.action_code in ('A', 'C')
					and asn.action_code in ('A', 'C')

				union
				select
					 -- bbp.nsn,
					ansi.nsi_sid,
					asn.loc_sid
				from
					bssm_base_parts bbp,
					amd_spare_networks asn,
					amd_national_stock_items ansi,
					amd_nsns an
				where
					lock_sid         in ('0','2')
					and bbp.sran     = asn.loc_id
					and asn.loc_type = 'FSL'
					and asn.action_code in ('A', 'C')
					and ansi.action_code in ('A', 'C')
					and bbp.replacement_indicator = 'Y'
					and bbp.nsn      = an.nsn
					and an.nsi_sid = ansi.nsi_sid)
				--
				-- Subtract invalid combo's in locks 2 and 0
				--
				minus
				(select
					-- bbp.nsn,
					an.nsi_sid,
					asn.loc_sid
				from
					bssm_base_parts bbp,
					amd_spare_networks asn,
					amd_nsns an
				where
					lock_sid         = '2'
					and bbp.sran     = asn.loc_id
					and asn.loc_type = 'FSL'
					and bbp.replacement_indicator = 'N'
					and bbp.nsn = an.nsn
					and asn.action_code in ('A', 'C')
				union
				select
					  -- bbp.nsn
					an.nsi_sid,
					asn.loc_sid
				from
					bssm_base_parts bbp,
					amd_spare_networks asn,
					amd_nsns an
				where
					lock_sid         = '0'
					and bbp.sran     = asn.loc_id
					and asn.loc_type = 'FSL'
					and bbp.nsn = an.nsn
					and asn.action_code in ('A', 'C')
					and bbp.replacement_indicator = 'N'
					and not exists
						(select 'x'
						from bssm_base_parts bbp2
						where
							lock_sid      = '2'
							and bbp2.sran = bbp.sran
							and bbp2.nsn  = bbp.nsn
							and bbp2.replacement_indicator = 'Y'))
				) order by nsi_sid;

        type partLocsOffBaseRec is record (
            nsi_sid amd_national_stock_items.nsi_sid%type,
            prime_part_no amd_national_stock_items.prime_part_no%type,
            loc_sid amd_spare_networks.loc_sid%type
        ) ;
        type partLocsOffBaseTab is table of partLocsOffBaseRec ;
        partLocsOffBaseRecs partLocsOffBaseTab ;

		cursor partLocsOffBaseList_cur is
				select
					   ansi.nsi_sid,
					   ansi.prime_part_no,
					   asn.loc_sid
				from
					   amd_national_stock_items ansi,
					   amd_spare_networks asn
				where
					   asn.loc_id = OFFBASE_LOCID and
					   ansi.action_code in ('A', 'C') and
					   asn.action_code in ('A', 'C');
		/* changed to insert statement --
		cursor partLocsWareHouse_cur is
			    select
					   ansi.nsi_sid,
					   asn.loc_sid
				from
					   amd_national_stock_items ansi,
					   amd_spare_networks asn
				where
					   asn.loc_id = amd_from_bssm_pkg.AMD_WAREHOUSE_LOCID and
					   ansi.action_code in ('A', 'C') and
					   asn.action_code in ('A', 'C');
		*/
	-- end cursor definitions


		procedure InsertIntoAmdPartLocs(pRec amd_part_locs%rowtype) is
		begin
			 insert into amd_part_locs
			 		(
					nsi_sid,
					loc_sid,
					awt,
					awt_defaulted,
					cost_to_repair,
					cost_to_repair_defaulted,
					mic,
					mic_defaulted,
					removal_ind,
					removal_ind_defaulted,
					removal_ind_cleaned,
					repair_level_code,
					repair_level_code_defaulted,
					repair_level_code_cleaned,
					time_to_repair,
					time_to_repair_defaulted,
					tactical,
					action_code,
					last_update_dt,
					rsp_on_hand,
					rsp_objective,
					order_cost,
					holding_cost,
					backorder_fixed_cost,
					backorder_variable_cost
					)
			 values (
			 		pRec.nsi_sid,
					pRec.loc_sid,
					pRec.awt,
					pRec.awt_defaulted,
					pRec.cost_to_repair,
					pRec.cost_to_repair_defaulted,
					pRec.mic,
					pRec.mic_defaulted,
					pRec.removal_ind,
					pRec.removal_ind_defaulted,
					pRec.removal_ind_cleaned,
					pRec.repair_level_code,
					pRec.repair_level_code_defaulted,
					pRec.repair_level_code_cleaned,
					pRec.time_to_repair,
					pRec.time_to_repair_defaulted,
					pRec.tactical,
					pRec.action_code,
					pRec.last_update_dt,
					pRec.rsp_on_hand,
					pRec.rsp_objective,
					pRec.order_cost,
					pRec.holding_cost,
					pRec.backorder_fixed_cost,
					pRec.backorder_variable_cost
				);
		end InsertIntoAmdPartLocs;

	begin
			--
			-- load mobs into part locations
			--
        writeMsg(pTableName => 'amd_part_locs', pError_location => 10,
            pKey1 => 'LoadAmdPartLocations',
            pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

        open partLocsMobList_cur ;
        fetch partLocsMobList_cur bulk collect into partLocsMobRecs ;
        close partLocsMobList_cur ;

        if partLocsMobRecs.first is not null then
            begin
            for indx  in partLocsMobRecs.first .. partLocsMobRecs.last
            loop
                         -- minimize retrieving of amdNsiRec and onbaserepaircost, note order by in cursor
                         -- all of the hardcoded null assignments related to amdPartLocsRec fields,
                         -- could be taken out, already handled with
                         --	amdPartLocsRec := null.  takes up minimal time, left in for visibility.
                    rampData := null;
                    if (partLocsMobRecs(indx).nsi_sid != amdNsiRec.nsi_sid or amdNsiRec.nsi_sid is null) then
                       amdPartLocsRec := null;
                       amdNsiRec := GetAmdNsiRec(partLocsMobRecs(indx).nsi_sid);
                       amdPartLocsRec.nsi_sid := partLocsMobRecs(indx).nsi_sid;
                       amdPartLocsRec.cost_to_repair := GetOnBaseRepairCost(amdNsiRec.prime_part_no);
                       if (amdPartLocsRec.cost_to_repair is null) then
                            -- currently default is 40
                               amdPartLocsRec.cost_to_repair_defaulted := amd_defaults.COST_TO_REPAIR_ONBASE;
                       end if;
                    end if;

                    locId := amd_utils.GetLocId(partLocsMobRecs(indx).loc_sid);

                    amdPartLocsRec.loc_sid := partLocsMobRecs(indx).loc_sid;
                    amdPartLocsRec.awt := null;
                    amdPartLocsRec.awt_defaulted := null;

                    amdPartLocsRec.mic := null;
                    amdPartLocsRec.mic_defaulted := null;
                        -- Eric Honma, default MOB 'Y'  FSL 'N' for repair_indicator/repair_level_code
                        -- and removal indicator.
                        -- also part of exception table bssm_base_parts
                        -- if removal ind cleaned is 'N' then error in cursor
                    amdPartLocsRec.removal_ind := null;
                    amdPartLocsRec.removal_ind_defaulted := 'Y';
                        -- will retrieve all cleanable fields for bssm base parts
                        -- cleaning done as a post process to speed up
                    amdPartLocsRec.removal_ind_cleaned := null;
                    amdPartLocsRec.repair_level_code := null;
                    amdPartLocsRec.repair_level_code_defaulted := 'Y';
                    amdPartLocsRec.repair_level_code_cleaned := null;
                    rampData := GetRampData(amdNsiRec.nsn, locId);
                    amdPartLocsRec.time_to_repair := rampData.avg_repair_cycle_time;
                     -- lauries "command decision" treat null and 0 as same => need default.
                    if (nvl(amdPartLocsRec.time_to_repair,0) = 0) then
                       amdPartLocsRec.time_to_repair := null;
                       amdPartLocsRec.time_to_repair_defaulted := amd_defaults.TIME_TO_REPAIR_ONBASE;
                    end if;
                    amdPartLocsRec.tactical := 'Y';
                    amdPartLocsRec.action_code := amd_defaults.INSERT_ACTION;
                    amdPartLocsRec.last_update_dt := SYSDATE;
                    /* kcs changes to support bssm 603 and amd1.7.1
                    amdPartLocsRec.rsp_on_hand := rampData.wrm_balance;
                    amdPartLocsRec.rsp_objective := rampData.wrm_level;
                    */
                    amdPartLocsRec.rsp_on_hand := nvl(rampData.wrm_balance, 0) + nvl(rampData.spram_balance, 0) + nvl(rampData.hpmsk_balance, 0) ;
                    amdPartLocsRec.rsp_objective := nvl(rampData.wrm_level, 0) + nvl(rampData.spram_level, 0) + nvl(rampData.hpmsk_level_qty, 0) ;
                        -- filled in afterwards in separate process, bssm only source for now
                        -- look in amd_from_bssm_pkg,
                        -- null assignment here just to note
                    amdPartLocsRec.order_cost := null;
                    amdPartLocsRec.holding_cost := null;
                    amdPartLocsRec.backorder_fixed_cost := null;
                    amdPartLocsRec.backorder_variable_cost := null;
                        -- insert record to the dynamic table collection
                    amdPartLocsRecs.extend ;
                    amdPartLocsRecs(amdPartLocsRecs.last) := amdPartLocsRec ;
                    countRecs := countRecs + 1;
            end loop;

            forall indx in amdPartLocsRecs.first .. amdPartLocsRecs.last
                insert into amd_part_locs
                values amdPartLocsRecs(indx) ;

            commit;
            exception
                when others then
                    ErrorMsg(pSqlfunction => 'insert',
                        pTableName => 'amd_part_locs',
                        pError_location => 20,
                        pKey1 => amdPartLocsRec.nsi_sid,
                        pKey2 => amdPartLocsRec.loc_sid) ;

            end;
        end if ;

			--
			-- load fsls into part locations
        	--
        amdPartLocsRecs.delete ; -- empty table

	    amdNsiRec := null;
        open partLocsFslList_cur ;
        fetch partLocsFslList_cur bulk collect into partLocsMobRecs ;
        close partLocsFslList_cur ;

        if partLocsMobRecs.first is not null then
            begin
            for indx  in partLocsMobRecs.first .. partLocsMobRecs.last
            loop
                    rampData := null;
                         -- minimize retrieving of amdNsiRec and onbaserepaircost
                    if (partLocsMobRecs(indx).nsi_sid != amdNsiRec.nsi_sid or amdNsiRec.nsi_sid is null) then
                       amdPartLocsRec := null;
                       amdNsiRec := GetAmdNsiRec(partLocsMobRecs(indx).nsi_sid);
                       amdPartLocsRec.nsi_sid := partLocsMobRecs(indx).nsi_sid;
                       amdPartLocsRec.cost_to_repair := GetOnBaseRepairCost(amdNsiRec.prime_part_no);
                       if (amdPartLocsRec.cost_to_repair is null) then
                            -- currently default is 40
                            amdPartLocsRec.cost_to_repair_defaulted := amd_defaults.COST_TO_REPAIR_ONBASE;
                       end if;
                    end if;


                    locId := amd_utils.GetLocId(partLocsMobRecs(indx).loc_sid);

                    amdPartLocsRec.loc_sid := partLocsMobRecs(indx).loc_sid;
                    amdPartLocsRec.awt := null;
                    amdPartLocsRec.awt_defaulted := null;

                    amdPartLocsRec.mic := null;
                    amdPartLocsRec.mic_defaulted := null;
                        -- Eric Honma, default MOB 'Y'  FSL 'N' for repair_indicator/repair_level_code
                        -- and removal indicator.
                        -- also part of exception table bssm_base_parts
                        -- if removal ind cleaned is 'N' then error in cursor
                    amdPartLocsRec.removal_ind := null;
                    amdPartLocsRec.removal_ind_defaulted := 'N';
                        -- cleaning done as a post process to speed up
                    amdPartLocsRec.removal_ind_cleaned := null;
                    amdPartLocsRec.repair_level_code := null;
                    amdPartLocsRec.repair_level_code_defaulted := 'N';
                    amdPartLocsRec.repair_level_code_cleaned := null;
                    rampData := GetRampData(amdNsiRec.nsn, locId);
                    amdPartLocsRec.time_to_repair := rampData.avg_repair_cycle_time;
                     -- lauries "command decision" treat null and 0 as same => need default.
                    if (nvl(amdPartLocsRec.time_to_repair,0) = 0) then
                       amdPartLocsRec.time_to_repair := null;
                       amdPartLocsRec.time_to_repair_defaulted := amd_defaults.TIME_TO_REPAIR_ONBASE;
                    end if;
                    amdPartLocsRec.tactical := 'Y';
                    amdPartLocsRec.action_code := amd_defaults.INSERT_ACTION;
                    amdPartLocsRec.last_update_dt := SYSDATE;
                    /* kcs changes to support bssm 603 and amd1.7.1
                    amdPartLocsRec.rsp_on_hand := rampData.wrm_balance;
                    amdPartLocsRec.rsp_objective := rampData.wrm_level;
                    */
                    amdPartLocsRec.rsp_on_hand := nvl(rampData.wrm_balance, 0) + nvl(rampData.spram_balance, 0) + nvl(rampData.hpmsk_balance, 0) ;
                    amdPartLocsRec.rsp_objective := nvl(rampData.wrm_level, 0) + nvl(rampData.spram_level, 0) + nvl(rampData.hpmsk_level_qty, 0) ;	-- filled in afterwards in separate process, bssm only source for now
                        -- look in amd_from_bssm_pkg,
                        -- null assignment here just to note
                    amdPartLocsRec.order_cost := null;
                    amdPartLocsRec.holding_cost := null;
                    amdPartLocsRec.backorder_fixed_cost := null;
                    amdPartLocsRec.backorder_variable_cost := null;
                    amdPartLocsRecs.extend ;
                    amdPartLocsRecs(amdPartLocsRecs.last) := amdPartLocsRec ;
                    countRecs := countRecs + 1;
            end loop;
            forall indx in amdPartLocsRecs.first .. amdPartLocsRecs.last
                insert into amd_part_locs
                values amdPartLocsRecs(indx) ;
            commit;
            exception
                when others then
                    ErrorMsg(pSqlfunction => 'insert',
                        pTableName => 'amd_part_locs',
                        pError_location => 30,
                        pKey1 => amdPartLocsRec.nsi_sid,
                        pKey2 => amdPartLocsRec.loc_sid) ;
            end;
        end if ;

			--
			-- load offbase into part locations
			--
        amdPartLocsRecs.delete ; -- empty

        open partLocsOffBaseList_cur ;
        fetch partLocsOffBaseList_cur bulk collect into partLocsOffBaseRecs ;
        close partLocsOffBaseList_cur ;

        if partLocsOffBaseRecs.first is not null then
            begin
            for indx in partLocsOffBaseRecs.first .. partLocsOffBaseRecs.last
                -- partLocsOffBaseRec only has nsn and location.
                -- should change defaulted to pull from params table.
                -- cursors all tied to ansi so nsn, partno in cursor will be in ansi
            loop
                    amdPartLocsRec := null;
                    amdPartLocsRec.nsi_sid := partLocsOffBaseRecs(indx).nsi_sid;
                    amdPartLocsRec.loc_sid := partLocsOffBaseRecs(indx).loc_sid;
                    amdPartLocsRec.awt := null;
                    amdPartLocsRec.awt_defaulted := null;
                    amdPartLocsRec.cost_to_repair := GetOffBaseRepairCost(partLocsOffBaseRecs(indx).prime_part_no);
                    if (amdPartLocsRec.cost_to_repair is null) then
                            -- amd_preferred throws exception
                            -- currently unit cost is null.
                        begin
                            unitCost := amd_preferred_pkg.GetUnitCost( pNsi_Sid => partLocsOffBaseRecs(indx).nsi_sid);
                            amdPartLocsRec.cost_to_repair_defaulted := unitCost * (amd_defaults.UNIT_COST_FACTOR_OFFBASE);
                        exception
                            when no_data_found then
                                 amdPartLocsRec.cost_to_repair_defaulted := null;
                        end;
                    end if;
                    amdPartLocsRec.mic := null;
                        -- no real meaning of following for offbase, set to null
                    amdPartLocsRec.removal_ind := null;
                    amdPartLocsRec.removal_ind_defaulted := null;
                    amdPartLocsRec.removal_ind_cleaned := null;
                    amdPartLocsRec.repair_level_code := null;
                    amdPartLocsRec.repair_level_code_defaulted := null;
                    amdPartLocsRec.repair_level_code_cleaned := null;

                    amdPartLocsRec.time_to_repair := GetOffBaseTurnAround(partLocsOffBaseRecs(indx).prime_part_no);
                    if (amdPartLocsRec.time_to_repair is null) then
                       amdPartLocsRec.time_to_repair_defaulted := amd_defaults.TIME_TO_REPAIR_OFFBASE;
                    end if;
                    amdPartLocsRec.tactical := 'Y';
                    amdPartLocsRec.action_code := amd_defaults.INSERT_ACTION;
                    amdPartLocsRec.last_update_dt := SYSDATE;
                    amdPartLocsRec.rsp_on_hand := null;
                    amdPartLocsRec.rsp_objective := null;
                    amdPartLocsRec.order_cost := null;
                    amdPartLocsRec.holding_cost := null;
                    amdPartLocsRec.backorder_fixed_cost := null;
                    amdPartLocsRec.backorder_variable_cost := null;

                      -- insert record
                    amdPartLocsRecs.extend ;
                    amdPartLocsRecs(amdPartLocsRecs.last) := amdPartLocsRec ;
                    countRecs := countRecs + 1;
            end loop;

            forall indx in amdPartLocsRecs.first .. amdPartLocsRecs.last
                insert into amd_part_locs
                values amdPartLocsRecs(indx) ;

            commit;
            exception
                when others then
                    ErrorMsg(pSqlfunction => 'insert',
                        pTableName => 'amd_part_locs',
                        pError_location => 40,
                        pKey1 => amdPartLocsRec.nsi_sid,
                        pKey2 => amdPartLocsRec.loc_sid) ;
            end;
        end if ;
			--
			-- load warehouse parts
			--
		begin
			 insert into amd_part_locs
			 (nsi_sid, loc_sid, tactical, action_code, last_update_dt)
			 	select
					   ansi.nsi_sid,
					   asn.loc_sid,
					   'Y',
					   amd_defaults.INSERT_ACTION,
					   SYSDATE
				from
					   amd_national_stock_items ansi,
					   amd_spare_networks asn
				where
					   asn.loc_id = amd_from_bssm_pkg.AMD_WAREHOUSE_LOCID and
					   ansi.action_code in ('A', 'C') and
					   asn.action_code in ('A', 'C') ;
		exception
                when standard.DUP_VAL_ON_INDEX then
                    dups := dups + 1 ;
				when others then
                    ErrorMsg(pSqlfunction => 'insert',
                        pTableName => 'amd_part_locs',
                        pError_location => 50) ;
		end ;
        writeMsg(pTableName => 'amd_part_locs', pError_location => 60,
            pKey1 => 'LoadAmdPartLocations',
            pKey2 => 'dups=' || dups,
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
            pKey4 => 'countRecs=' || countRecs ) ;

		commit;

	end LoadAmdPartLocations;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_part_locs_load_pkg',
		 		pError_location => 70, pKey1 => 'amd_part_locs_load_pkg', pKey2 => '$Revision:   1.13  $') ;
	end version ;

    function getVersion return varchar2 is
    begin
        return '$Revision:   1.13  $' ;
    end getVersion ;


BEGIN
	 null;
END AMD_PART_LOCS_LOAD_PKG;
/


DROP PACKAGE BODY AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG AS
 /*
      $Author:   zf297a  $
	$Revision:   1.32  $
        $Date:   17 Jan 2012 $
    $Workfile:   AMD_PART_LOC_FORECASTS_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_PART_LOC_FORECASTS_PKG.pkb.-arc  $
/*
        Rev 1.32.1 17 Jan 2012 zf297a
        implemented getVersion function

/*      Rev 1.32   24 Feb 2009 13:56:52   zf297a
/*   Removed a2a code
/*
/*      Rev 1.31   07 Nov 2007 16:54:54   zf297a
/*   Use bulk collect for all cursors.
/*
/*      Rev 1.30   Oct 03 2007 11:54:46   c402417
/*   Added a check for either part is consumable or repairable before insert into tmp_a2a_ext_forecast.
/*
/*      Rev 1.29   Oct 02 2007 16:23:54   c402417
/*   Removed the filter FD2090 when insert into tmp_a2a_ext_forecast
/*
/*      Rev 1.28   12 Sep 2007 13:53:36   zf297a
/*   Removed commits from for loops.
/*
/*      Rev 1.27   07 Feb 2007 09:36:00   zf297a
/*   Filter out locations FD2090
/*
/*      Rev 1.26   31 Jan 2007 12:01:26   zf297a
/*   Modified hasValidDate to insist on a full month name beginning at the begining of the column NAME - ie MONTH DD, DDDD where DD is a two digit day and DDDD is a two digit year.
/*
/*      Rev 1.25   19 Jan 2007 14:02:44   zf297a
/*   Made the "duplicates" a single CONSTANT to gaurantee that the value is the same for every location it is used within the package.
/*
/*      Rev 1.24   17 Jan 2007 14:43:10   zf297a
/*   Chaned the pDuplicate value from 60 to 66.
/*
/*      Rev 1.23   Nov 28 2006 14:46:10   zf297a
/*   fixed insertTmpA2A_EF - for INSERT_ACTION or UPDATE_ACTION check to see if the part is in amd_sent_to_a2a with action_code <> DELETE_ACTION then insert it into tmp_a2a_ext_forecast.  For DELETE_ACTION's check to see if the part is in amd_sent_to_a2a with any action_code then insert it into tmp_a2a_ext_forecast.
/*
/*      Rev 1.22   Nov 01 2006 11:39:12   zf297a
/*   Implemented hasValidDate and hasValidDateYorN.  Used these new functions to filter out bad date formats in the name column of bssm_locks.
/*
/*      Rev 1.21   Sep 26 2006 16:22:12   zf297a
/*   Fixed insert into amd_bssm__s_base_part_periods
/*
/*      Rev 1.20   Sep 14 2006 10:07:30   zf297a
/*   Raise an applicaton error when no date is found for the latest Rbl Run from BSSM.
/*
/*      Rev 1.19   Sep 05 2006 12:52:00   zf297a
/*   Added dbms_output to version
/*
/*      Rev 1.18   Aug 18 2006 15:45:10   zf297a
/*   Implemented doExtForecast.
/*
/*      Rev 1.17   Aug 14 2006 14:13:50   zf297a
/*   Fixed code to generated ExtForecast deletes.
/*
/*      Rev 1.16   Aug 01 2006 12:15:00   zf297a
/*   Removed redundant getLatestRblRunBssm from for loop
/*
/*      Rev 1.15   Aug 01 2006 12:01:00   zf297a
/*   Fixed LoadLatestRblRun so that it will use the most recent date contained in the name field of bssm_locks.  Used Raise_Application_Error when no date is found in the name field.
/*
/*      Rev 1.14   Jul 26 2006 10:11:40   zf297a
/*   Implemented function getLatestRblRunBssm
/*
/*      Rev 1.13   Jul 26 2006 09:34:10   zf297a
/*   Made duplicate field a required field for all tmp_a2a's
/*
/*      Rev 1.12   Jun 12 2006 13:10:42   zf297a
/*   Fixed error messages.  Resequenced pError_location.  Enhanced use of writeMsg.  Fixed to_char format for minutes MI.
/*
/*      Rev 1.11   Jun 09 2006 12:17:28   zf297a
/*   implemented version
/*
/*      Rev 1.10   Jun 04 2006 21:47:58   zf297a
/*   Make sure LoadTmpAmdPartLocForecasts uses non-null spo_prime_part_no
/*
/*      Rev 1.9   Jun 01 2006 12:20:38   zf297a
/*   switched from dbms_output to amd_utils.writeMsg.
/*
/*      Rev 1.8   May 12 2006 14:41:56   zf297a
/*   Changed all loadAll routines to use all action_codes and to use the action_code data to create the A2A transactions.  Also use the SendAllData property of the a2a_pkg in conjunction with the isPartValid and the wasPartSent functions.
/*
/*      Rev 1.7   Apr 05 2006 12:42:38   zf297a
/*   Limitied loop of 60 periods to just 1 with a duplicate value of 60.
/*
/*      Rev 1.6   Feb 15 2006 21:52:08   zf297a
/*   Added a ref cursor, a type, and a common process routine.
/*
/*      Rev 1.4   Jan 03 2006 07:56:40   zf297a
/*   Added procedure loadA2AByDate
/*
/*      Rev 1.3   Dec 16 2005 14:29:38   zf297a
/*   Moved the truncate of tmp_a2a_ext_forecast from LoadTmpAmdPartLocForecast to LoadTmpAmdPartLocForecasts_Add.
/*
/*      Rev 1.2   Dec 15 2005 12:11:00   zf297a
/*   Added truncate of tmp_a2a_ext_forecast to LoadTmpAmdPartLocForecasts
/*
/*      Rev 1.1   Dec 06 2005 10:36:52   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*
/*      Rev 1.0   Dec 01 2005 09:44:12   zf297a
/*   Initial revision.
*/

-- will need to constantly diff after all to check for new and deleted parts --

	PKGNAME CONSTANT VARCHAR2(30) := 'AMD_PART_LOC_FORECASTS_PKG' ;
    DUPLICATES CONSTANT NUMBER := 66 ;

	-- REALLY_OLD_DATE CONSTANT DATE := TO_DATE('06/10/1965', 'MM/DD/YYYY') ;

		procedure writeMsg(
					pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
					pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
					pKey1 IN VARCHAR2 := '',
					pKey2 IN VARCHAR2 := '',
					pKey3 IN VARCHAR2 := '',
					pKey4 in varchar2 := '',
					pData IN VARCHAR2 := '',
					pComments IN VARCHAR2 := '')  IS
		BEGIN
			Amd_Utils.writeMsg (
					pSourceName => 'amd_part_loc_forecasts_pkg',
					pTableName  => pTableName,
					pError_location => pError_location,
					pKey1 => pKey1,
					pKey2 => pKey2,
					pKey3 => pKey3,
					pKey4 => pKey4,
					pData    => pData,
					pComments => pComments);
		end writeMsg ;

	FUNCTION ErrorMsg(
				pSourceName in amd_load_status.SOURCE%type,
				pTableName in amd_load_status.TABLE_NAME%type,
				pError_location in amd_load_details.DATA_LINE_NO%type,
				pReturn_code in number,
				pKey1 in varchar2 := '',
				pKey2 in varchar2 := '',
				pKey3 in varchar2 := '',
				pData in varchar2 := '',
				pComments in varchar2 := '') return number is
	BEGIN
		ROLLBACK; -- rollback may not be complete if running with mDebug set to true
		amd_utils.InsertErrorMsg (
				pLoad_no => amd_utils.GetLoadNo(pSourceName => pSourceName,	pTableName  => pTableName),
				pData_line_no => pError_location,
				pData_line    => pData,
				pKey_1 => substr(pKey1,1,50),
				pKey_2 => substr(pKey2,1,50),
				pKey_3 => pKey3,
				pKey_4 => to_char(pReturn_code),
				pKey_5 => to_char(sysdate,'MM/DD/YYYY HH:MI:SS'),
				pComments => 'sqlcode('||sqlcode||') sqlerrm('||sqlerrm||') ' || pComments);
		COMMIT;
		RETURN pReturn_code;
	END ;

	/*
	FUNCTION IsTableEmpty(pTableName VARCHAR2) RETURN NUMBER IS
		  returnCode NUMBER ;
		  sql_stmt varchar2(1000) ;
	BEGIN
		  IF pTableName IS NULL THEN
		  	 returnCode := -1 ;
		  END IF ;
		  sql_stmt := 'SELECT count(*) FROM ' || pTableName || ' where rownum < 2' ;
		  EXECUTE IMMEDIATE sql_stmt INTO returnCode ;
		  RETURN returnCode ;
	EXCEPTION WHEN OTHERS THEN
		  RETURN -1 ;
	END ;
	*/


	FUNCTION GetFirstDateOfMonth(pDate DATE) RETURN DATE IS
	BEGIN
		 IF ( pDate IS null ) THEN
		 	RETURN null ;
	 	 END IF ;
	  	 RETURN ( last_day(add_months(pDate, -1)) + 1 );
	END GetFirstDateOfMonth ;

	FUNCTION getLatestRblRunBssm(lockName in bssm_locks.NAME%type) RETURN DATE IS
			 str VARCHAR2(100) ;
	begin
	 		 /* spec denotes specific format of month Mon DD, YYYY  that will be in best spares
			 	text field */
			 str := lockName ;
		   	 IF owa_pattern.match(str, '(\w \d{2}, \d{4})(.*)') THEN
		   	  	  owa_pattern.CHANGE(str, '(\w \d{2}, \d{4})(.*)', '\1') ;
		   		  return to_date(str, 'Mon DD, YYYY') ;
		   	 END IF ;
			 raise_application_error(-20001,'No date found for the latest RBL Run.') ;
	end getLatestRblRunBssm ;

	FUNCTION hasValidDate(lockName in bssm_locks.NAME%type) RETURN boolean is
			 str VARCHAR2(100) ;
			 theDate date ;
			 result boolean ;
             sp number ;
	begin
	 		 /* spec denotes specific format of month Mon DD, YYYY  that will be in best spares
			 	text field */
			 result := false ;
			 str := trim(lockName) ;

               sp := instr(str,' ') ;
               if sp > 1 then
                    if substr(upper(str),1,sp - 1) in ('JANUARY', 'FEBRUARY', 'MARCH',
                            'APRIL','MAY','JUNE','JULY','AUGUST','SEPTEMBER','OCTOBER','NOVEMBER',
                            'DECEMBER') then
        		   	    IF owa_pattern.match(str, '(\w \d{2}, \d{4})(.*)') THEN
        		   	  	    owa_pattern.CHANGE(str, '(\w \d{2}, \d{4})(.*)', '\1') ;
        				    begin
		   		  	            theDate := to_date(str, 'MONTH DD, YYYY') ;
					            result := true ;
                            exception when others then
                                result := false ;
                            end ;
                        end if ;
                    end if ;
		   	 END IF ;
			 return result ;
	end hasValidDate ;

	function hasValidDateYorN(lockName in bssm_locks.NAME%type) RETURN varchar2 is
	begin
		 if hasValidDate(lockName) then
		 	return 'Y' ;
		 else
		 	return 'N' ;
		 end if ;
	end hasValidDateYorN ;


	FUNCTION getLatestRblRunAmd RETURN DATE IS
				-- for initial run --
		retLatestRblRun DATE := null ;
		returnCode NUMBER ;
	BEGIN
		retLatestRblRun := to_date(amd_defaults.GetParamValue(PARAMS_LATEST_RBL_RUN_DATE), 'MM/DD/YYYY') ;
		--IF ( retLatestRblRun IS null ) THEN
		--   retLatestRblRun := REALLY_OLD_DATE ;
		--END IF ;
		RETURN retLatestRblRun ;
	EXCEPTION WHEN OTHERS THEN
			returnCode := ErrorMsg(
					   pSourceName 	  	  => 'getLatestRblRunAmd',
					   pTableName  	  	  => 'amd_params - problem getting latest Rbl run',
					   pError_location 	  => 10,
					   pReturn_code	  	  => 99,
					   pKey1			  => '',
		   			   pKey2			  => '',
					   pKey3			  => '',
					   pData			  => '',
					   pComments		  => PKGNAME) ;
					   RAISE ;
	END getLatestRblRunAmd ;

	FUNCTION getCurrentPeriod RETURN DATE IS
	   	retCurPeriod DATE := null ;
		returnCode NUMBER ;
	BEGIN
		retCurPeriod := to_date(amd_defaults.GetParamValue( PARAMS_CURRENT_PERIOD_DATE ), 'MM/DD/YYYY') ;
		--IF ( retCurPeriod IS null ) THEN
		--   retCurPeriod := REALLY_OLD_DATE ;
		--END IF ;
			/* make sure 1st day of month */
		retCurPeriod := getFirstDateOfMonth(retCurPeriod) ;
		RETURN retCurPeriod ;
	EXCEPTION WHEN OTHERS THEN
			returnCode := ErrorMsg(
					   pSourceName 	  	  => 'getCurrentPeriod',
					   pTableName  	  	  => 'amd_params - problem getting current period',
					   pError_location 	  => 20,
					   pReturn_code	  	  => 99,
					   pKey1			  => '',
		   			   pKey2			  => '',
					   pKey3			  => '',
					   pData			  => '',
					   pComments		  => PKGNAME) ;
					   RAISE ;
	END getCurrentPeriod ;


	PROCEDURE setLatestRblRunAmd(pRblRunDate DATE) IS
	BEGIN
		UPDATE amd_param_changes
		SET param_value = to_char(pRblRunDate, 'MM/DD/YYYY'),
			effective_date = sysdate,
			user_id = PARAM_USER
		WHERE param_key = PARAMS_LATEST_RBL_RUN_DATE ;
		COMMIT ;
	END setLatestRblRunAmd ;


	PROCEDURE setCurrentPeriod(pCurrentPeriodDate DATE) IS
	BEGIN
		UPDATE amd_param_changes
		SET param_value = to_char(getFirstDateOfMonth(pCurrentPeriodDate), 'MM/DD/YYYY'),
			effective_date = sysdate,
			user_id = PARAM_USER
		WHERE param_key = PARAMS_CURRENT_PERIOD_DATE  ;
		COMMIT ;
	END setCurrentPeriod ;



	PROCEDURE LoadAmdBssmSBasePartPeriods(pLockSid bssm_s_base_part_periods.lock_sid%TYPE, pScenarioSid bssm_s_base_part_periods.scenario_sid%TYPE) IS
		returnCode NUMBER ;
		recordExists VARCHAR2(1) := null;
	BEGIN
		 -- make sure data exists before deleting local amd copy
		BEGIN
			SELECT 'x' INTO recordExists
			FROM bssm_s_base_part_periods
				  WHERE scenario_sid = pScenarioSid
				  AND lock_sid = pLockSid AND rownum = 1 ;
		EXCEPTION WHEN OTHERS THEN
			returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadAmdBssmSBasePartPeriods',
				   pTableName  	  	  => 'amd_bssm_s_base_part_periods',
				   pError_location 	  => 40,
				   pReturn_code	  	  => 99,
				   pKey1			  => 'lock_sid:' || pLockSid,
	   			   pKey2			  => 'scenario_sid:' || pScenarioSid,
				   pKey3			  => '',
				   pData			  => '',
				   pComments		  => PKGNAME || 'bssm locks indicates new run but problem retrieving bssm_s_base_part_periods.') ;
				   RAISE ;
		END ;
		BEGIN
			mta_truncate_table('amd_bssm_s_base_part_periods','reuse storage');
			COMMIT ;
			INSERT INTO amd_bssm_s_base_part_periods
				   SELECT
				     LOCK_SID,
  					 SCENARIO_SID,
  					 SCENARIO_PERIOD,
  					 NSN,
					 SRAN,
  					 TARGET_STOCK01,
  					 TARGET_STOCK02,
  					 TARGET_STOCK03,
  					 TARGET_STOCK04,
  					 TARGET_STOCK05,
  					 DEMAND_RATE01,
  					 DEMAND_RATE02,
  					 DEMAND_RATE03,
  					 DEMAND_RATE04,
  					 DEMAND_RATE05,
  					 STOCK_LEVEL01,
  					 STOCK_LEVEL02,
  					 STOCK_LEVEL03,
  					 STOCK_LEVEL04,
  					 STOCK_LEVEL05,
					  PERCENT_REPLACE01,
					  PERCENT_REPLACE02,
					  PERCENT_REPLACE03,
					  PERCENT_REPLACE04,
					  PERCENT_REPLACE05,
					  REORDER_QUANT01,
					  REORDER_QUANT02,
					  REORDER_QUANT03,
					  REORDER_QUANT04,
					  REORDER_QUANT05,
					  sysdate
					  FROM bssm_s_base_part_periods
					  WHERE scenario_sid = pScenarioSid
					  AND lock_sid = pLockSid ;
			COMMIT ;
		EXCEPTION WHEN OTHERS THEN
				 returnCode := ErrorMsg(
					   pSourceName 	  	  => 'LoadAmdBssmSBasePartPeriods',
					   pTableName  	  	  => 'amd_bssm_s_base_part_periods',
					   pError_location 	  => 50,
					   pReturn_code	  	  => 99,
					   pKey1			  => '',
		   			   pKey2			  => '',
					   pKey3			  => '',
					   pData			  => '',
					   pComments		  => PKGNAME) ;
					   RAISE ;
		END ;
	END ;

	--  amd_bssm_s_base_part_periods only can hold one rbl run, do not need to query by lock_sid scenario_sid
	PROCEDURE LoadTmpAmdPartLocForecasts IS
		 returnCode NUMBER ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_part_loc_forecasts', pError_location => 60,
				pKey1 => 'LoadTmpAmdPartLocForecasts',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

		 mta_truncate_table('tmp_amd_part_loc_forecasts', 'reuse storage') ;
		 COMMIT ;
	     INSERT INTO tmp_amd_part_loc_forecasts
		 		(loc_sid, part_no, forecast_qty, action_code, last_update_dt)
		 SELECT loc_sid,
		 		spo_prime_part_no,
				round(sum(nvl(demand_rate01, 0)), DP) forecast_qty,
				Amd_Defaults.INSERT_ACTION,
				SYSDATE
	 		   FROM amd_bssm_s_base_part_periods bsbpp,
			   		amd_nsns an,
					amd_spare_networks asn,
					amd_national_stock_items ansi,
					amd_spare_parts parts
	 		   WHERE parts.is_spo_part = 'Y'
			   and parts.part_no = parts.spo_prime_part_no
			   and bsbpp.nsn = an.nsn
			   AND an.nsi_sid = ansi.nsi_sid
		           AND ansi.prime_part_no = parts.part_no
			   AND decode(asn.loc_id, Amd_Defaults.AMD_WAREHOUSE_LOCID, Amd_Defaults.BSSM_WAREHOUSE_SRAN, asn.loc_id) = bsbpp.sran
		   	   AND ansi.action_code != Amd_Defaults.DELETE_ACTION
			   AND asn.action_code != Amd_Defaults.DELETE_ACTION
			   GROUP BY spo_prime_part_no, loc_sid
			   HAVING round(sum(nvl(demand_rate01, 0)), DP) > 0 ;

		writeMsg(pTableName => 'tmp_amd_part_loc_forecasts', pError_location => 70,
				pKey1 => 'LoadTmpAmdPartLocForecasts',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

	EXCEPTION WHEN OTHERS THEN
		returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadTmpAmdPartLocForecasts',
				   pTableName  	  	  => 'tmp_amd_part_loc_forecasts',
				   pError_location 	  => 80,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',
				   pData			  => '',
				   pComments		  => PKGNAME) ;
				   RAISE ;
	END LoadTmpAmdPartLocForecasts ;

	PROCEDURE LoadLatestRblRun IS
        type rblRec is record (
            lock_sid bssm_locks.lock_sid%type,
            rbl_scenario_sid bssm_locks.RBL_SCENARIO_SID%type,
            latestRblRunBssm date,
            last_data_date bssm_locks.LAST_DATA_DATE%type
        ) ;
        type rblTab is table of rblRec ;
        rblRecs rblTab ;

		 CURSOR rbl_cur IS
			 SELECT lock_sid, rbl_scenario_sid,
			 getLatestRblRunBssm(name) latestRblRunBssm, last_data_date
			 FROM bssm_locks
		 	 WHERE last_data_date = (SELECT max(last_data_date)
		  			    FROM bssm_locks
						WHERE rbl_scenario_sid IS NOT NULL)
		 	 AND rbl_scenario_sid IS NOT NULL
			 and hasValidDateYorN(name) = 'Y'
			 order by  getLatestRblRunBssm(name) ;

		     latestRblRunAmd DATE ;
			 latestRblRunBssm DATE := null ;
			 lockSid bssm_locks.lock_sid%TYPE ;
			 scenarioSid VARCHAR2(5) ;
			 str VARCHAR2(100) ;
			 rec rbl_cur%ROWTYPE ;
		returnCode NUMBER ;
		errorComment VARCHAR2(100) := null ;
	BEGIN
		latestRblRunAmd := getLatestRblRunAmd ;
	    -- use the last row with the most recent date for latestRblRunBssm
        open rbl_cur ;
        fetch rbl_cur bulk collect into rblRecs ;
        close rbl_cur ;

        if rblRecs.first is not null then
            FOR indx in rblRecs.first .. rblRecs.last
            LOOP
                 latestRblRunBssm := rblRecs(indx).latestRblRunBssm ;
                 scenarioSid := rblRecs(indx).rbl_scenario_sid ;
                 lockSid := rblRecs(indx).lock_sid ;
            END LOOP ;
        end if ;

		IF latestRblRunBssm IS NULL THEN
		    Raise_Application_Error(-20000, 'latestRblRunBssm date is null. Perhaps the pattern to match the date changed or bssm locks has no rbl run.') ;
		ELSIF (trunc(latestRblRunBssm) > trunc(latestRblRunAmd)) THEN
			  -- keep amd copy since runs can be accidently deleted from bssm side
			LoadAmdBssmSBasePartPeriods( lockSid, scenarioSid ) ;
		 	setLatestRblRunAmd(latestRblRunBssm) ;
		END IF ;

	EXCEPTION WHEN OTHERS THEN
		returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadExtForecastAndLatestRblRun',
				   pTableName  	  	  => 'amd_bssm_s_base_part_periods',
				   pError_location 	  => 90,
				   pReturn_code	  	  => 99,
				   pKey1			  => 'latestRblRunAmd:' || latestRblRunAmd,
	   			   pKey2			  => 'latestRblRunBssm:' || latestRblRunBssm,
				   pKey3			  => '',
				   pData			  => '',
				   pComments		  => PKGNAME || ': ' || errorComment) ;
				   RAISE ;
	END LoadLatestRblRun ;

	PROCEDURE LoadTmpAmdPartLocForecasts_Add IS
		currentPeriodAmd DATE 	  := 	getCurrentPeriod ;
		currentPeriod 	 DATE 	  := 	getFirstDateOfMonth(sysdate) ;
		returnCode NUMBER ;
	BEGIN
		setCurrentPeriod(currentPeriod) ;
		-- though rbl only quarterly run, parts can be added or deleted during each run
	    	-- which may be part of the last rbl run.  Load tmp_amd_part_loc_forecasts
			-- for subsequent diff whether new rbl run or not.
		LoadTmpAmdPartLocForecasts ;
	EXCEPTION WHEN OTHERS THEN
		returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadTmpAmdPartLocForecasts_Add',
				   pTableName  	  	  => 'tmp_amd_part_loc_forecasts',
				   pError_location 	  => 100,
				   pReturn_code	  	  => 99,
				   pKey1			  => 'currentPeriod:' || currentPeriod,
	   			   pKey2			  => 'currentPeriodAmd:' || currentPeriodAmd,
				   pKey3			  => '',
				   pData			  => '',
				   pComments		  => PKGNAME ) ;
				   RAISE ;
	END LoadTmpAmdPartLocForecasts_Add ;

	PROCEDURE UpdateAmdPartLocForecasts (
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE,
			pActionCode					amd_part_loc_forecasts.action_code%TYPE,
			pLastUpdateDt				amd_part_loc_forecasts.last_update_dt%TYPE ) IS
	BEGIN
		 UPDATE amd_part_loc_forecasts
		 SET
		 	 forecast_qty 	= pForecastQty,
		 	 action_code 	= pActionCode,
			 last_update_dt	= pLastUpdateDt
		 WHERE
		 	 part_no = pPartNo AND
			 loc_sid = pLocSid ;
	END	UpdateAmdPartLocForecasts ;

	PROCEDURE InsertAmdPartLocForecasts (
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE,
			pActionCode					amd_part_loc_forecasts.action_code%TYPE,
			pLastUpdateDt				amd_part_loc_forecasts.last_update_dt%TYPE ) IS
	BEGIN
	    INSERT INTO amd_part_loc_forecasts
			  (
			  	part_no,
			  	loc_sid,
				forecast_qty,
				action_code,
				last_update_dt
			  ) VALUES (
			  	pPartNo,
				pLocSid,
				pForecastQty,
				pActionCode,
				pLastUpdateDt
			  ) ;
	EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
		 	 UpdateAmdPartLocForecasts
			 (
			  	pPartNo,
				pLocSid,
				pForecastQty,
				pActionCode,
				pLastUpdateDt
			 ) ;

	END	InsertAmdPartLocForecasts ;



	FUNCTION InsertRow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE )
			return NUMBER IS
			returnCode NUMBER ;
	BEGIN
		BEGIN
		  	InsertAmdPartLocForecasts
			(
			 	pPartNo,
				pLocSid,
				pForecastQty,
				Amd_Defaults.INSERT_ACTION,
				sysdate
			) ;
		EXCEPTION WHEN OTHERS THEN
			returnCode := ErrorMsg(
				   pSourceName 	  	  => 'InsertRow.InsertAmdPartLocForecasts',
				   pTableName  	  	  => 'amd_part_loc_forecasts',
				   pError_location 	  => 110,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',
				   pData			  => '',
				   pComments		  => PKGNAME) ;
				   RAISE ;
		END ;
		RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;
	END InsertRow ;



	FUNCTION UpdateRow(
			pPartNo                  amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                  amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty			 amd_part_loc_forecasts.forecast_qty%TYPE )
			RETURN NUMBER IS
			returnCode NUMBER ;
	BEGIN
		 BEGIN
		 	   UpdateAmdPartLocForecasts
				 (
			  		 pPartNo,
					 pLocSid,
					 pForecastQty,
					 Amd_Defaults.UPDATE_ACTION,
					 sysdate
			 	 ) ;
		 EXCEPTION WHEN OTHERS THEN
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'UpdateRow.UpdateAmdPartLocForecasts',
				   pTableName  	  	  => 'amd_part_loc_forecasts',
				   pError_location 	  => 130,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',
				   pData			  => '',
				   pComments		  => PKGNAME) ;
				   RAISE ;
		 END ;

		RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;
	END UpdateRow ;


	FUNCTION DeleteRow(
			pPartNo                     amd_part_loc_forecasts.part_no%TYPE,
			pLocSid                     amd_part_loc_forecasts.loc_sid%TYPE,
			pForecastQty				amd_part_loc_forecasts.forecast_qty%TYPE )
			RETURN NUMBER IS
			returnCode NUMBER ;
	BEGIN
		BEGIN
		  	UpdateAmdPartLocForecasts
			 (
			  	pPartNo,
				pLocSid,
				pForecastQty,
				Amd_Defaults.DELETE_ACTION,
				sysdate
			 ) ;
		EXCEPTION WHEN OTHERS THEN
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'DeleteRow.UpdateAmdPartLocForecasts',
				   pTableName  	  	  => 'amd_part_loc_forecasts',
				   pError_location 	  => 150,
				   pReturn_code	  	  => 99,
				   pKey1			  => pPartNo,
	   			   pKey2			  => pLocSid,
				   pKey3			  => '',
				   pData			  => '',
				   pComments		  => PKGNAME) ;
				   RAISE ;
		END ;
		RETURN SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		RETURN FAILURE ;
	END DeleteRow ;



	PROCEDURE LoadInitial IS
		 returnCode NUMBER ;
	BEGIN
		writeMsg(pTableName => 'tmp_amd_part_loc_forecasts', pError_location => 250,
				pKey1 => 'LoadInitial',
				pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;

		LoadTmpAmdPartLocForecasts ;
		mta_truncate_table('amd_part_loc_forecasts','reuse storage');
		BEGIN
			 INSERT INTO amd_part_loc_forecasts
			 SELECT * FROM tmp_amd_part_loc_forecasts
			 	WHERE action_code != Amd_Defaults.DELETE_ACTION ;

		EXCEPTION WHEN OTHERS THEN
		 	returnCode := ErrorMsg(
				   pSourceName 	  	  => 'LoadInitial',
				   pTableName  	  	  => 'amd_part_loc_forecasts',
				   pError_location 	  => 260,
				   pReturn_code	  	  => 99,
				   pKey1			  => '',
	   			   pKey2			  => '',
				   pKey3			  => '',
				   pData			  => '',
				   pComments		  => PKGNAME || ': Insert into amd_part_loc_forecasts') ;
				   RAISE ;
		END ;

		writeMsg(pTableName => 'tmp_amd_part_loc_forecasts', pError_location => 270,
				pKey1 => 'LoadInitial',
				pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
	END LoadInitial ;

	procedure doExtForecast is
	begin
		 LoadLatestRblRun ;
		 LoadTmpAmdPartLocForecasts_Add ;
	end doExtForecast ;

	procedure version is
	begin
		 writeMsg(pTableName => 'amd_part_loc_forecasts_pkg',
		 		pError_location => 280, pKey1 => 'amd_part_loc_forecasts_pkg', pKey2 => '$Revision:   1.32  $') ;
		 dbms_output.put_line('amd_part_loc_forecasts_pkg: $Revision:   1.32  $') ;
	end version ;

    function getVersion return varchar2 is
    begin
        return '$Revision:   1.32  $' ;
    end getVersion ;



END AMD_PART_LOC_FORECASTS_PKG ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_PREFERRED_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER."AMD_PREFERRED_PKG"  is

    /*
	    PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.12  $
         $Date:   12 Aug 2008 08:52:06  $
     $Workfile:   amd_preferred_pkg.pkb  $
	      $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_preferred_pkg.pkb-arc  $

      Rev 1.12   12 Aug 2008 08:52:06   zf297a
   Added writeMsg to be used by procedure version.  Implemented the public function getVersion and public procedure version.

      Rev 1.11   31 Jul 2008 11:26:06   zf297a
   Changed the implementation of getPlannerCode(nsi_sid) so that it also may return the default planner code based on part_no (consumable or repairable).

   Add new function getPlannerCodeByPart

      Rev 1.10   May 06 2005 08:07:42   c970183
   changed dla_warehouse_stock and dla_warehouse_stock_cleaned to current_backorder and current_backorder_cleaned.  added pvcs keywords
   	  */
	function GetPreferredValue(pPreferred1 in varchar2, pPreferred2 in varchar2) return varchar2 is
	begin
		if pPreferred1 is not null then
			return pPreferred1 ;
		else
			return pPreferred2 ;
		end if ;
	end GetPreferredValue ;

	function GetPreferredValue(pPreferred1 in varchar2, pPreferred2 in varchar2, pPreferred3 in varchar2) return varchar2 is
	begin
		if pPreferred1 is not null then
			return pPreferred1 ;
		elsif pPreferred2 is not null then
			return pPreferred2 ;
		else
			return pPreferred3 ;
		end if ;
	end GetPreferredValue ;

	function GetPreferredValue(pPreferred1 in number, pPreferred2 in number) return number is
	begin
		if pPreferred1 is not null then
			return pPreferred1 ;
		else
			return pPreferred2 ;
		end if ;
	end GetPreferredValue ;

	function GetPreferredValue(pPreferred1 in number, pPreferred2 in number,  pPreferred3 in number) return number is
	begin
		if pPreferred1 is not null then
			return pPreferred1 ;
		elsif pPreferred2 is not null then
			return pPreferred2 ;
		else
			return pPreferred3 ;
		end if ;
	end GetPreferredValue ;

	function GetLocSid(pLoc_id in amd_spare_networks.loc_id%type) return amd_spare_networks.loc_sid%type is
		loc_sid amd_spare_networks.loc_sid%type := null ;
	begin
		select loc_sid into loc_sid
		from amd_spare_networks
		where loc_id = pLoc_id ;
		return loc_sid ;
	end GetLocSid ;

	function GetAddIncrement(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.add_increment%type is
		add_increment amd_national_stock_items.add_increment%type ;
		add_increment_cleaned amd_national_stock_items.add_increment_cleaned%type ;
	begin
		select add_increment, add_increment_cleaned
		into add_increment, add_increment_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(add_increment_cleaned, add_increment) ;
	end GetAddIncrement ;

	function GetAddIncrement(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.add_increment%type is
	begin
		return GetAddIncrement(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetAddIncrement ;

	function GetAmcBaseStock(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.amc_base_stock%type is
		amc_base_stock amd_national_stock_items.amc_base_stock%type ;
		amc_base_stock_cleaned amd_national_stock_items.amc_base_stock_cleaned%type ;
	begin
		select amc_base_stock, amc_base_stock_cleaned
		into amc_base_stock, amc_base_stock_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(amc_base_stock_cleaned, amc_base_stock) ;
	end GetAmcBaseStock ;

	function GetAmcBaseStock(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.amc_base_stock%type is
	begin
		return GetAmcBaseStock(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetAmcBaseStock ;

	function GetAmcDaysExperience(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.amc_days_experience%type is
		amc_days_experience amd_national_stock_items.amc_days_experience%type ;
		amc_days_experience_cleaned amd_national_stock_items.amc_days_experience_cleaned%type ;
	begin
		select amc_days_experience, amc_days_experience_cleaned
		into amc_days_experience, amc_days_experience_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(amc_days_experience_cleaned, amc_days_experience) ;
	end GetAmcDaysExperience ;

	function GetAmcDaysExperience(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.amc_days_experience%type is
	begin
		return GetAmcDaysExperience(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetAmcDaysExperience ;

	function GetAmcDemand(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.amc_demand%type is
		amc_demand amd_national_stock_items.amc_demand%type ;
		amc_demand_cleaned amd_national_stock_items.amc_demand_cleaned%type ;
	begin
		select amc_demand, amc_demand_cleaned
		into amc_demand, amc_demand_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(amc_demand_cleaned, amc_demand) ;
	end GetAmcDemand ;

	function GetAmcDemand(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.amc_demand%type is
	begin
		return GetAmcDaysExperience(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetAmcDemand ;

	function GetCapabilityRequirement(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.capability_requirement%type is
		capability_requirement amd_national_stock_items.capability_requirement%type ;
		capability_requirement_cleaned amd_national_stock_items.capability_requirement_cleaned%type ;
	begin
		select capability_requirement, capability_requirement_cleaned
		into capability_requirement, capability_requirement_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(capability_requirement_cleaned, capability_requirement) ;
	end GetCapabilityRequirement ;

	function GetCapabilityRequirement(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.capability_requirement%type is
	begin
		return GetCapabilityRequirement(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetCapabilityRequirement ;

	function GetCondemnAvg(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.condemn_avg%type is
		condemn_avg amd_national_stock_items.condemn_avg%type ;
		condemn_avg_cleaned amd_national_stock_items.condemn_avg_cleaned%type ;
	begin
		select condemn_avg, condemn_avg_cleaned
		into condemn_avg, condemn_avg_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(condemn_avg_cleaned, condemn_avg) ;
	end GetCondemnAvg;

	function GetCondemnAvg(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.condemn_avg%type is
	begin
		return GetCondemnAvg(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetCondemnAvg ;

	function GetCostToRepairOffBase(pNsi_sid in amd_part_locs.nsi_sid%type, pLoc_sid in amd_part_locs.loc_sid%type) return amd_part_locs.cost_to_repair%type is
		cost_to_repair_off_base amd_national_stock_items.cost_to_repair_off_base_cleand%type ;
		cost_to_repair_off_base_defltd amd_national_stock_items.cost_to_repair_off_base_cleand%type ;
		cost_to_repair_off_base_cleand amd_national_stock_items.cost_to_repair_off_base_cleand%type ;
	begin
		-- todo verify if this is the correct way to get
		-- these fields
		select cost_to_repair_off_base_cleand, cost_to_repair, cost_to_repair_defaulted
		into cost_to_repair_off_base_cleand, cost_to_repair_off_base, cost_to_repair_off_base_defltd
		from amd_national_stock_items items, amd_part_locs locs
		where locs.nsi_sid = pNsi_sid
		and locs.loc_sid = pLoc_sid
		and locs.nsi_sid = items.nsi_sid ;
		return GetPreferredValue(cost_to_repair_off_base_cleand, cost_to_repair_off_base, cost_to_repair_off_base_defltd) ;
	end GetCostToRepairOffBase ;

	function GetCostToRepairOffBase(pNsn in amd_nsns.nsn%type, pLoc_id in amd_spare_networks.loc_id%type) return amd_part_locs.cost_to_repair%type is
	begin
		return GetCostToRepairOffBase(amd_utils.GetNsiSid(pNsn => pNsn), GetLocSid(pLoc_id)) ;
	end GetCostToRepairOffBase ;

	function GetCurrentPrimeInd(pNsi_sid in amd_nsi_parts.nsi_sid%type, pPart_no in amd_nsi_parts.part_no%type) return amd_nsi_parts.prime_ind%type is
		prime_ind amd_nsi_parts.prime_ind%type := null ;
		prime_ind_cleaned amd_nsi_parts.prime_ind_cleaned%type := null ;
	begin
		select prime_ind, prime_ind_cleaned
		into prime_ind, prime_ind_cleaned
		from amd_nsi_parts
		where nsi_sid = pNsi_sid
		and part_no = pPart_no
		and assignment_date = (select max(assignment_date) from amd_nsi_parts where nsi_sid = pNsi_sid and part_no = pPart_no ) ;
		return GetPreferredValue(prime_ind_cleaned, prime_ind) ;
	end GetCurrentPrimeInd ;

	function GetCurrentPrimeInd(pNsn in amd_nsns.nsn%type, pPart_no in amd_nsi_parts.part_no%type ) return amd_nsi_parts.prime_ind%type is
	begin
		return GetCurrentPrimeInd(amd_utils.GetNsiSid(pNsn => pNsn), pPart_no) ;
	end GetCurrentPrimeInd ;

	function GetCriticality(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.criticality%type is
		criticality amd_national_stock_items.criticality%type ;
		criticality_cleaned amd_national_stock_items.criticality_cleaned%type ;
	begin
		select criticality, criticality_cleaned
		into criticality, criticality_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(criticality_cleaned, criticality) ;
	end GetCriticality ;

	function GetCriticality(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.criticality%type is
	begin
		return GetCriticality(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetCriticality ;

	function GetDistribUom(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.distrib_uom%type is
		distrib_uom amd_national_stock_items.distrib_uom%type ;
		distrib_uom_defaulted amd_national_stock_items.distrib_uom_defaulted%type ;
	begin
		select distrib_uom, distrib_uom_defaulted
		into distrib_uom, distrib_uom_defaulted
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(distrib_uom, distrib_uom_defaulted) ;
	end GetDistribUom ;

	function GetDistribUom(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.distrib_uom%type is
	begin
		return GetDistribUom(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetDistribUom ;

	function GetDlaDemand(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.dla_demand%type is
		dla_demand amd_national_stock_items.dla_demand%type ;
		dla_demand_cleaned amd_national_stock_items.dla_demand_cleaned%type ;
	begin
		select dla_demand, dla_demand_cleaned
		into dla_demand, dla_demand_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(dla_demand_cleaned, dla_demand) ;
	end GetDlaDemand ;

	function GetDlaDemand(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.dla_demand%type is
	begin
		return GetDlaDemand(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetDlaDemand ;

	function GetDlaWarehouseStock(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.current_backorder%type is
		dla_warehouse_stock amd_national_stock_items.current_backorder%type ;
		dla_warehouse_stock_cleaned amd_national_stock_items.current_backorder_cleaned%type ;
	begin
		select dla_warehouse_stock, dla_warehouse_stock_cleaned
		into dla_warehouse_stock, dla_warehouse_stock_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(dla_warehouse_stock_cleaned, dla_warehouse_stock) ;
	end GetDlaWarehouseStock ;

	function GetDlaWarehouseStock(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.current_backorder%type is
	begin
		return GetDlaWarehouseStock(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetDlaWarehouseStock ;

	function GetFedcCost(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.fedc_cost%type is
		fedc_cost amd_national_stock_items.fedc_cost%type ;
		fedc_cost_cleaned amd_national_stock_items.fedc_cost_cleaned%type ;
	begin
		select fedc_cost, fedc_cost_cleaned
		into fedc_cost, fedc_cost_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(fedc_cost_cleaned, fedc_cost) ;
	end GetFedcCost ;

	function GetFedcCost(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.fedc_cost%type is
	begin
		return GetFedcCost(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetFedcCost ;

	function GetItemType(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.item_type%type is
		item_type amd_national_stock_items.item_type%type ;
		item_type_cleaned amd_national_stock_items.item_type_cleaned%type ;
	begin
		select item_type, item_type_cleaned
		into item_type, item_type_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(item_type_cleaned, item_type) ;
	end GetItemType ;

	function GetItemType(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.item_type%type is
	begin
		return GetItemType(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetItemType ;

	function GetMicCodeLowest(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.mic_code_lowest%type is
		mic_code_lowest amd_national_stock_items.mic_code_lowest%type ;
		mic_code_lowest_cleaned amd_national_stock_items.mic_code_lowest_cleaned%type ;
	begin
		select mic_code_lowest, mic_code_lowest_cleaned
		into mic_code_lowest, mic_code_lowest_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(mic_code_lowest_cleaned, mic_code_lowest) ;
	end GetMicCodeLowest ;

	function GetMicCodeLowest(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.mic_code_lowest%type is
	begin
		return GetMicCodeLowest(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetMicCodeLowest ;

	function GetMtbdr(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.mtbdr%type is
		mtbdr amd_national_stock_items.mtbdr%type ;
		mtbdr_cleaned amd_national_stock_items.mtbdr_cleaned%type ;
        mtbdr_computed amd_national_stock_items.mtbdr_computed%type ;
	begin
		select mtbdr, mtbdr_cleaned, mtbdr_computed
		into mtbdr, mtbdr_cleaned, mtbdr_computed
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(mtbdr_cleaned, mtbdr_computed, mtbdr) ;
	end GetMtbdr ;

	function GetMtbdr(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.mtbdr%type is
	begin
		return GetMtbdr(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetMtbdr ;

	function GetNomenclature(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_spare_parts.nomenclature%type is
		nomenclature amd_spare_parts.nomenclature%type ;
		nomenclature_cleaned amd_national_stock_items.nomenclature_cleaned%type ;
	begin
		select nomenclature, nomenclature_cleaned
		into nomenclature, nomenclature_cleaned
		from amd_national_stock_items,
		amd_spare_parts parts
		where nsi_sid = pNsi_sid and
		prime_part_no = parts.part_no ;
		return GetPreferredValue(nomenclature_cleaned, nomenclature) ;
	end GetNomenclature ;

	function GetNomenclature(pNsn in amd_nsns.nsn%type) return amd_spare_parts.nomenclature%type is
	begin
		return GetNomenclature(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetNomenclature ;

	function GetNrtsAvg(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.nrts_avg%type is
		nrts_avg amd_national_stock_items.nrts_avg%type ;
		nrts_avg_cleaned amd_national_stock_items.nrts_avg_cleaned%type ;
	begin
		select nrts_avg, nrts_avg_cleaned
		into nrts_avg, nrts_avg_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(nrts_avg_cleaned, nrts_avg) ;
	end GetNrtsAvg ;

	function GetNrtsAvg(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.nrts_avg%type is
	begin
		return GetNrtsAvg(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetNrtsAvg ;

	function GetOrderLeadTime(pNsn in amd_spare_parts.nsn%type) return amd_spare_parts.order_lead_time%type is
		nsi_sid amd_national_stock_items.nsi_sid%type := null ;
		prime_part_no amd_national_stock_items.prime_part_no%type := null ;
	begin
		nsi_sid := amd_utils.GetNsiSid(pNsn => pNsn) ;
		select prime_part_no
		into prime_part_no
		from amd_national_stock_items
		where nsi_sid = GetOrderLeadTime.nsi_sid ;
		return GetOrderLeadTime(pPart_no => prime_part_no) ;
	end GetOrderLeadTime ;

	function GetOrderLeadTimeByNsn(pNsn in amd_spare_parts.nsn%type) return amd_spare_parts.order_lead_time%type is
	begin
		return GetOrderLeadTime(pNsn => pNsn) ;
	end GetOrderLeadTimeByNsn ;

	function GetOrderLeadTime(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.order_lead_time%type is
		order_lead_time amd_spare_parts.order_lead_time%type ;
		order_lead_time_defaulted amd_spare_parts.order_lead_time_defaulted%type ;
		order_lead_time_cleaned amd_national_stock_items.order_lead_time_cleaned%type ;
	begin
		select order_lead_time, order_lead_time_defaulted, order_lead_time_cleaned
		into order_lead_time, order_lead_time_defaulted, order_lead_time_cleaned
		from amd_spare_parts
		where part_no = pPart_no ;
		return GetPreferredValue(order_lead_time_cleaned, order_lead_time_defaulted, order_lead_time) ;
	end GetOrderLeadTime ;

	function GetOrderLeadTimeByPart(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.order_lead_time%type is
	begin
		return GetOrderLeadTime(pPart_no => pPart_no) ;
	end GetOrderLeadTimeByPart ;

	function GetOrderQuantity(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.order_quantity%type is
		order_quantity amd_national_stock_items.order_quantity%type := null ;
		order_quantity_defaulted amd_national_stock_items.order_quantity_defaulted%type := null ;
	begin
		select order_quantity, order_quantity_defaulted
		into order_quantity, order_quantity_defaulted
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(order_quantity, order_quantity_defaulted) ;
	end GetOrderQuantity ;

	function GetOrderQuantity(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.order_quantity%type is
	begin
		return GetOrderQuantity(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetOrderQuantity ;

	function GetOrderUom(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.order_uom%type is
		order_uom amd_spare_parts.order_uom%type := null ;
		order_uom_defaulted amd_spare_parts.order_uom_defaulted%type := null ;
		order_uom_cleaned amd_national_stock_items.order_uom_cleaned%type := null ;
	begin
		select order_uom, order_uom_defaulted, order_uom_cleaned
		into order_uom, order_uom_defaulted, order_uom_cleaned
		from amd_spare_parts
		where part_no = pPart_no ;
		return GetPreferredValue(order_uom_cleaned, order_uom, order_uom_defaulted) ;
	end GetOrderUom ;

	function GetPlannerCode(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.planner_code%type is
		planner_code amd_national_stock_items.planner_code%type := null ;
		planner_code_cleaned amd_national_stock_items.planner_code_cleaned%type := null ;
        planner_code_default amd_national_stock_items.planner_code%type := null ;
	begin
		select planner_code, planner_code_cleaned, amd_defaults.getplannerCode(nsn)
		into planner_code, planner_code_cleaned, planner_code_default
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(planner_code_cleaned, planner_code, planner_code_default) ;
	end GetPlannerCode ;

	function GetPlannerCode(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.planner_code%type is
	begin
		return GetPlannerCode(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetPlannerCode ;

    function getPlannerCodeByPart(part_no in amd_spare_parts.part_no%type) return amd_national_stock_items.planner_code%type is
    begin
        return getPlannerCode(pNsi_sid => amd_utils.GetNsiSid(pNsn => amd_utils.GETNSN(part_no))) ;
    end getPlannerCodeByPart ;

	function GetPrimeInd(pNsi_sid in amd_nsi_parts.nsi_sid%type, pPart_no in amd_nsi_parts.part_no%type) return amd_nsi_parts.prime_ind%type is
		prime_ind amd_nsi_parts.prime_ind%type := null ;
		prime_ind_cleaned amd_nsi_parts.prime_ind_cleaned%type := null ;
	begin
		select prime_ind, prime_ind_cleaned
		into prime_ind, prime_ind_cleaned
		from amd_nsi_parts
		where nsi_sid = pNsi_sid
		and part_no = pPart_no
		and assignment_date =
			(select max(assignment_date) from amd_nsi_parts where nsi_sid = pNsi_sid and part_no = pPart_no)
		and unassignment_date is null ;
		return GetPreferredValue(prime_ind_cleaned, prime_ind) ;
	end GetPrimeInd ;

	function GetPrimeInd(pNsn in amd_nsns.nsn%type, pPart_no in amd_nsi_parts.part_no%type) return amd_nsi_parts.prime_ind%type is
	begin
		return GetPrimeInd(amd_utils.GetNsiSid(pNsn => pNsn), pPart_no) ;
	end GetPrimeInd ;


	function GetQpeiWeighted(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.qpei_weighted%type is
		qpei_weighted amd_national_stock_items.qpei_weighted%type := null ;
		qpei_weighted_defaulted amd_national_stock_items.qpei_weighted_defaulted%type := null ;
	begin
		select qpei_weighted, qpei_weighted_defaulted
		into qpei_weighted, qpei_weighted_defaulted
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(qpei_weighted, qpei_weighted_defaulted) ;
	end GetQpeiWeighted ;

	function GetQpeiWeighted(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.qpei_weighted%type is
	begin
		return GetQpeiWeighted(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetQpeiWeighted ;

	function GetRtsAvg(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.rts_avg%type is
		rts_avg amd_national_stock_items.rts_avg%type := null ;
		rts_avg_defaulted amd_national_stock_items.rts_avg_defaulted%type := null ;
		rts_avg_cleaned amd_national_stock_items.rts_avg_cleaned%type := null ;
	begin
		select rts_avg, rts_avg_defaulted, rts_avg_cleaned
		into rts_avg, rts_avg_defaulted, rts_avg_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(rts_avg_cleaned, rts_avg, rts_avg_defaulted) ;
	end GetRtsAvg ;

	function GetRtsAvg(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.rts_avg%type is
	begin
		return GetRtsAvg(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetRtsAvg ;

	function GetRuInd(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.ru_ind%type is
		ru_ind amd_national_stock_items.ru_ind%type := null ;
		ru_ind_cleaned amd_national_stock_items.ru_ind_cleaned%type := null ;
	begin
		select ru_ind, ru_ind_cleaned
		into ru_ind, ru_ind_cleaned
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(ru_ind_cleaned, ru_ind) ;
	end GetRuInd ;

	function GetRuInd(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.ru_ind%type is
	begin
		return GetRuInd(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetRuInd ;

	function GetScrapValue(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.scrap_value%type is
		scrap_value amd_spare_parts.scrap_value%type := null ;
		scrap_value_defaulted amd_spare_parts.scrap_value_defaulted%type := null ;
	begin
		select scrap_value, scrap_value_defaulted
		into scrap_value, scrap_value_defaulted
		from amd_spare_parts
		where part_no = pPart_no ;
		return GetPreferredValue(scrap_value, scrap_value_defaulted) ;
	end GetScrapValue ;

	function GetShelfLife(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.shelf_life%type is
		shelf_life amd_spare_parts.shelf_life%type := null ;
		shelf_life_defaulted amd_spare_parts.shelf_life_defaulted%type := null ;
	begin
		select shelf_life, shelf_life_defaulted
		into shelf_life, shelf_life_defaulted
		from amd_spare_parts
		where part_no = pPart_no ;
		return GetPreferredValue(shelf_life, shelf_life_defaulted) ;
	end GetShelfLife ;

	function GetSmrCode(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.smr_code%type is
		smr_code amd_national_stock_items.smr_code%type := null ;
		smr_code_cleaned amd_national_stock_items.smr_code_cleaned%type := null ;
		smr_code_defaulted amd_national_stock_items.smr_code_defaulted%type := null ;
	begin
		select smr_code, smr_code_cleaned, smr_code_defaulted
		into smr_code, smr_code_cleaned, smr_code_defaulted
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(smr_code_cleaned, smr_code, smr_code_defaulted) ;
	end GetSmrCode ;

	function GetSmrCode(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.smr_code%type is
	begin
		return GetSmrCode(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetSmrCode ;

	function GetTimeToRepairOffBase(pNsi_sid in amd_part_locs.nsi_sid%type, pLoc_sid in amd_part_locs.loc_sid%type) return amd_part_locs.time_to_repair%type is
		time_to_repair_off_base amd_part_locs.time_to_repair%type := null ;
		time_to_repair_off_base_cleand amd_national_stock_items.time_to_repair_off_base_cleand%type := null ;
		time_to_repair_off_base_defltd amd_part_locs.time_to_repair_defaulted%type := null ;
	begin
		select time_to_repair, time_to_repair_off_base_cleand, time_to_repair_defaulted
		into time_to_repair_off_base, time_to_repair_off_base_cleand, time_to_repair_off_base_defltd
		from amd_national_stock_items items, amd_part_locs locs
		where locs.nsi_sid = pNsi_sid
		and locs.loc_sid = pLoc_sid
		and locs.nsi_sid = items.nsi_sid ;
		return GetPreferredValue(time_to_repair_off_base_cleand, time_to_repair_off_base, time_to_repair_off_base_defltd) ;
	end GetTimeToRepairOffBase ;

	function GetTimeToRepairOffBase(pNsn in amd_nsns.nsn%type, pLoc_id in amd_spare_networks.loc_id%type) return amd_part_locs.time_to_repair%type is
	begin
		return GetTimeToRepairOffBase(amd_utils.GetNsiSid(pNsn => pNsn), GetLocSid(pLoc_id)) ;
	end GetTimeToRepairOffBase ;

	function GetTimeToRepairOnBaseAvg(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_national_stock_items.time_to_repair_on_base_avg%type is
		time_to_repair_on_base_avg amd_national_stock_items.time_to_repair_on_base_avg%type := null ;
		time_to_repair_on_base_avg_cl amd_national_stock_items.time_to_repair_on_base_avg_cl%type := null ;
		time_to_repair_on_base_avg_df amd_national_stock_items.time_to_repair_on_base_avg_df%type := null ;
	begin
		select time_to_repair_on_base_avg, time_to_repair_on_base_avg_cl, time_to_repair_on_base_avg_df
		into time_to_repair_on_base_avg, time_to_repair_on_base_avg_cl, time_to_repair_on_base_avg_df
		from amd_national_stock_items
		where nsi_sid = pNsi_sid ;
		return GetPreferredValue(time_to_repair_on_base_avg_cl, time_to_repair_on_base_avg, time_to_repair_on_base_avg_df) ;
	end GetTimeToRepairOnBaseAvg ;

	function GetTimeToRepairOnBaseAvg(pNsn in amd_nsns.nsn%type) return amd_national_stock_items.time_to_repair_on_base_avg%type is
	begin
		return GetTimeToRepairOnBaseAvg(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetTimeToRepairOnBaseAvg ;

	function GetUnitCost(pNsi_sid in amd_national_stock_items.nsi_sid%type) return amd_spare_parts.unit_cost%type is
		unit_cost amd_spare_parts.unit_cost%type := null ;
		unit_cost_defaulted amd_spare_parts.unit_cost_defaulted%type := null ;
		unit_cost_cleaned amd_national_stock_items.unit_cost_cleaned%type := null ;
	begin
		select unit_cost, unit_cost_cleaned, unit_cost_defaulted
		into unit_cost, unit_cost_cleaned, unit_cost_defaulted
		from amd_spare_parts parts, amd_national_stock_items items
		where nsi_sid = pNsi_sid
		and items.prime_part_no = parts.part_no ;
		return GetPreferredValue(unit_cost_cleaned, unit_cost, unit_cost_defaulted) ;
	end GetUnitCost ;

	function GetUnitCost(pNsn in amd_nsns.nsn%type) return amd_spare_parts.unit_cost%type is
	begin
		return GetUnitCost(amd_utils.GetNsiSid(pNsn => pNsn)) ;
	end GetUnitCost ;

	function GetUnitCostByNsn(pNsn in amd_nsns.nsn%type) return amd_spare_parts.unit_cost%type is
	begin
		return GetUnitCost(pNsn => pNsn) ;
	end GetUnitCostByNsn ;

	function GetUnitCost(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.unit_cost%type is
		unit_cost amd_spare_parts.unit_cost%type := null ;
		unit_cost_defaulted amd_spare_parts.unit_cost_defaulted%type := null ;
		unit_cost_cleaned amd_national_stock_items.unit_cost_cleaned%type := null ;
	begin
		select unit_cost, unit_cost_cleaned, unit_cost_defaulted
		into unit_cost, unit_cost_cleaned, unit_cost_defaulted
		from amd_spare_parts parts, amd_national_stock_items items
		where part_no = pPart_no
		and items.nsn = parts.nsn ;
		return GetPreferredValue(unit_cost_cleaned, unit_cost, unit_cost_defaulted) ;
	end GetUnitCost ;

	function GetUnitCostByPart(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.unit_cost%type is
	begin
		return GetUnitCost(pPart_no => pPart_no) ;
	end GetUnitCostByPart ;

	function GetUnitVolume(pPart_no in amd_spare_parts.part_no%type) return amd_spare_parts.unit_volume%type is
		unit_volume amd_spare_parts.unit_volume%type := null ;
		unit_volume_defaulted amd_spare_parts.unit_volume_defaulted%type := null ;
	begin
		select unit_volume, unit_volume_defaulted
		into unit_volume, unit_volume_defaulted
		from amd_spare_parts
		where part_no = pPart_no ;
		return GetPreferredValue(unit_volume, unit_volume_defaulted) ;
	end GetUnitVolume ;

    PROCEDURE writeMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 IN VARCHAR2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'amd_preferred_pkg',
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
    exception when others then
        --  ignoretrying to rollback or commit from trigger
        if sqlcode <> -4092 then
            raise_application_error(-20010,
                substr('amd_preferred_pkg '
                    || sqlcode || ' '
                    || pError_Location || ' '
                    || pTableName || ' '
                    || pKey1 || ' '
                    || pKey2 || ' '
                    || pKey3 || ' '
                    || pKey4 || ' '
                    || pData, 1,2000)) ;
        end if ;
    END writeMsg ;

        function getVersion return varchar2 is
        begin
            dbms_output.put_line('$Revision:   1.12  $') ;
            return '$Revision:   1.12  $' ;
        end getVersion ;

        PROCEDURE version IS
        BEGIN
             writeMsg(pTableName => 'amd_preferred_pkg',
                     pError_location => 10, pKey1 => 'amd_preferred_pkg', pKey2 => '$Revision:   1.12  $') ;
              dbms_output.put_line('amd_preferred_pkg: $Revision:   1.12  $') ;
        END version ;

end amd_preferred_pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_REQS_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Reqs_Pkg IS
    /* 
        PVCS Keywords
        
       $Author:   zf297a  $
     $Revision:   1.23  $
         $Date:   12 Jun 2015 
     $Workfile:   AMD_REQS_PKG.pkb  $


        Rev 1.23   12 Jun 2015 DSE use to_loc_id
        
        Rev 1.22   23 Feb 2015 DSE use amd_defaults.getStartLocId whereever substr(sc,8 is used
   
/*      Rev 1.21   17 Feb 2015 DSE changed update exception from no_data_found to others
                   since the no_data_found exception will never occur for the update DML
                   
/*      Rev 1.20   24 Feb 2009 14:02:50   zf297a
/*   Removed a2a code.
/*   
/*      Rev 1.19   15 Jan 2009 23:52:48   zf297a
/*   Temporairly fixed insert's for tmp_a2a_backorder_info for the no longer needed loc_sid by using arbitrary constants.  This column needs to be eliminated.
/*   
/*      Rev 1.18   15 Jan 2009 15:57:04   zf297a
/*   converted from loc_sid to spo_location for amd_backorder_sum
/*   
/*      Rev 1.17   07 Nov 2007 22:47:14   zf297a
/*   Use bulk collect for all cursors and bulk inserts for tmp_amd_reqs.
/*   
/*      Rev 1.16   Apr 05 2007 11:34:48   c402417
/*   Remove all TRIM from WHERE clauses.
/*   
/*      Rev 1.15   Dec 07 2006 09:54:02   zf297a
/*   Removed debug code from UpdateRowBackorder and DeleteRowBackorder
/*   
/*      Rev 1.14   Nov 29 2006 13:47:34   c402417
/*   Modified the backorder diff functions since the changes in table amd_backorder_sum with modified column spo_prime_part_no instead of part_no .
/*   
/*      Rev 1.13   Jul 07 2006 13:50:28   zf297a
/*   Fixed InsertRowSpoSum to handle a logical insert of a previously deleted row.
/*   
/*      Rev 1.11   Jun 09 2006 12:25:16   zf297a
/*   implemented version
/*   
/*      Rev 1.10   Apr 28 2006 13:51:00   zf297a
/*   updated package end statment: end amd_reqs_pkg ;
/*   
/*      Rev 1.9   Mar 23 2006 15:43:22   c402417
/*   Changed the way to get site_location into tmp_a2a_backorder_info to use Amd_Utils.getSpoLocation.
/*   
/*      Rev 1.8   Feb 10 2006 12:08:40   c402417
/*   changed to use fuction getSiteLocation from the amd_reqs_pkg instead of from amd_utils_pkg.
/*   
/*      Rev 1.7   Feb 09 2006 13:39:28   c402417
/*   Emergency fix -  getting the right spo_location for site_location in table tmp_a2a_backorder_info.
/*   
/*      Rev 1.6   Dec 06 2005 09:30:10   zf297a
/*   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
/*   
/*      Rev 1.5   Dec 06 2005 09:10:34   zf297a
/*   Added check of isPartValid, wasPartSent, and site_location is not null for all invocations of doInsertTmpA2ABackOrderInfo.  Removed wasPartSent since it resides in the a2a_pkg.
/*   
/*      Rev 1.4   Dec 02 2005 13:50:04   zf297a
/*   Added doInsertTmpA2ABackOrderInfo and doUpdateTmpA2ABackOrderInfo.  Added errorMsg procedure. Changed insertRow, updateRow, and deleteRow to use doInsertTmpA2ABackOrderInfo
/*   
/*      Rev 1.3   Oct 05 2005 13:48:14   c402417
/*   Added function WasPartSent to make sure we sent backorder_info with part that exist in amd_sent_to_a2a.
/*   
/*      Rev 1.2   12 Aug 2005 10:43:16   c402417
/*   Changed sources for table amd_reqs .
/*   Added insert statement for table amd_backorder_sum which feeds table tmp_a2a_backorder_info for SPO .
/*   Added diff functions for table amd_reqs and amd_backorder_sum.
/*   
/*      Rev 1.1   May 06 2005 09:07:00   c970183
/*   fixed deleteRow and added PVCS keywords
   
   */
    ERRSOURCE CONSTANT VARCHAR2(20) := 'amd_req_pkg';
    PROCEDURE writeMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 IN VARCHAR2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'amd_reqs_pkg',    
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
    END writeMsg ;
    
    FUNCTION ErrorMsg(
                    pSqlFunction IN VARCHAR2,
                    pTableName IN VARCHAR2,
                    pErrorLocation IN NUMBER,
                    pReturn_code IN NUMBER,
                    pKey_1 IN VARCHAR2,
                     pKey_2 IN VARCHAR2 := '',
                    pKey_3 IN VARCHAR2 := '',
                    pKey_4 IN VARCHAR2 := '',                    
                    pKeywordValuePairs IN VARCHAR2 := '') RETURN NUMBER IS
    BEGIN
        ROLLBACK;
        Amd_Utils.InsertErrorMsg (
                pLoad_no => Amd_Utils.GetLoadNo(
                        pSourceName => pSqlFunction,
                        pTableName  => pTableName),
                pData_line_no => pErrorLocation,
                pData_line    => 'amd_reqs_pkg',
                pKey_1 => pKey_1,
                pKey_2 => pKey_2,
                pKey_3 => pKey_3,
                pKey_4 => pKey_4,
                pKey_5 => 'rc=' || TO_CHAR(pReturn_code) ||
                           ' ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ||
                           ' ' || pKeywordValuePairs,
                pComments => pSqlFunction || '/' || pTableName || ' sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')');
        COMMIT;
        RETURN pReturn_code;
    END ErrorMsg;
    -- added this procedure ...since function is not really necessary for most errors DSE 12/02/05
     PROCEDURE ErrorMsg(
         pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
         pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
         pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
         pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE,
          pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
         pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
         pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
         pKeywordValuePairs IN VARCHAR2 := '') IS
      result NUMBER ;
     BEGIN
       result := ErrorMsg(pSqlfunction => pSqlfunction,
                       pTableName => pTableName,
                       pErrorLocation => pError_location,
                       pReturn_code => FAILURE,
                       pKey_1 => pKey_1,
                       pKey_2 => pKey_2,
                       pKey_3 => pKey_3,
                       pKey_4 => pKey_4,
                       pKeywordValuePairs => pKeywordValuePairs) ;
    
     EXCEPTION WHEN OTHERS THEN
         COMMIT ;
     END ErrorMsg;

    PROCEDURE LoadAmdReqs IS
    
        type reqRec is record (
            request_id req1.REQUEST_ID%type,
            part_no req1.SELECT_FROM_PART%type,
            loc_sid amd_spare_networks.loc_sid%type,
            quantity number,
            action_code tmp_amd_reqs.action_code%type,
            last_update_dt tmp_amd_reqs.LAST_UPDATE_DT%type
        ) ;
        type reqTab is table of reqRec ;
        reqRecs reqTab ;
        
        -- backorder from req1 table in Gold
        CURSOR req1_cur IS
               SELECT
                         (REQ1.request_id) request_id,
                      (REQ1.select_from_part) part_no,
                      asn.loc_sid,
                         SUM((NVL(REQ1.qty_due,0) + NVL(REQ1.qty_reserved,0))) quantity,
                      amd_defaults.GETINSERT_ACTION action_code,
                      sysdate last_update_dt
               FROM
                         REQ1,
                         AMD_SPARE_PARTS asp,
                      AMD_SPARE_NETWORKS asn
               WHERE
                         REQ1.status IN ('U', 'O','H', 'R') AND
                      REQ1.request_priority IN (1,2,3,4,5) AND 
                      REQ1.mils_source_dic IS NOT NULL AND
                         asn.loc_id = SUBSTR(REQ1.request_id, 1, 6) AND
                         asp.part_no = REQ1.select_from_part AND
                      ((NVL(REQ1.qty_due,0) + NVL(REQ1.qty_reserved,0)) > 0 ) AND 
                      asn.action_code IN (Amd_Defaults.INSERT_ACTION,Amd_Defaults.UPDATE_ACTION)
                GROUP BY (REQ1.request_id),(REQ1.select_from_part), asn.loc_sid ;
        nsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE;
        
        -- backorder from tmp1 table in Gold
        CURSOR tmp1_cur IS
               SELECT
                         (TMP1.temp_out_id) temp_out_id,
                      (TMP1.from_part) part_no,
                      asn.loc_sid,
                         SUM(TMP1.qty_due) qty_due,
                      amd_defaults.getINSERT_ACTION action_code,
                      sysdate last_update_dt
               FROM
                         TMP1,
                      AMD_SPARE_NETWORKS asn,
                      AMD_SPARE_PARTS asp
               WHERE
                         TMP1.returned_voucher IS NULL AND 
                      TMP1.status = 'O' AND 
                         TMP1.TCN = 'LBR' AND
                      TMP1.qty_due != 0 AND
                      asn.loc_id = to_loc_id AND
                      asp.part_no = TMP1.from_part
               GROUP BY (TMP1.temp_out_id), (TMP1.from_part),asn.loc_sid ;
                      
          result   NUMBER ;

    BEGIN
    
         mta_truncate_table('TMP_AMD_REQS','reuse storage') ;
         
         open req1_cur ;
         fetch req1_cur bulk collect into reqRecs ;
         close req1_cur ;
         
         if reqRecs.first is not null then
            forall indx in reqRecs.first .. reqRecs.last        
                     INSERT INTO TMP_AMD_REQS
                     VALUES reqRecs(indx) ;
            commit ;                     
        end if ;                     
         
         BEGIN
             open tmp1_cur ;
             fetch tmp1_cur bulk collect into reqRecs ;
             close tmp1_cur ;
             
             if reqRecs.first is not null then
                forall indx in reqRecs.first .. reqRecs.last
                        INSERT INTO TMP_AMD_REQS
                        VALUES reqRecs(indx) ;
                COMMIT;
             end if ;      
        END loadAmdReqs;
  END;
    
    
    
    FUNCTION getSiteLocation(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN
             AMD_SPARE_NETWORKS.spo_location%TYPE IS
             
             site_location AMD_SPARE_NETWORKS.spo_location%TYPE ;
             result NUMBER ;
    BEGIN
        SELECT spo_location INTO site_location 
        FROM AMD_SPARE_NETWORKS
        WHERE loc_sid = getSiteLocation.loc_sid ;
        
        RETURN site_location ;
    EXCEPTION WHEN OTHERS THEN
        result := ErrorMsg(pSqlFunction => 'select',
        pTableName => 'amd_reqs',
        pErrorLocation => 10 , 
        pReturn_code => FAILURE,
        pKey_1 => TO_CHAR(getSiteLocation.loc_sid)) ;
        RAISE ;
    END getSiteLocation ;
                                                                             
    
    /* amd_reqs diff function */
    FUNCTION InsertRow(
                        req_id                 IN VARCHAR2,
                       part_no                IN VARCHAR2,
                       loc_sid                IN NUMBER,
                       quantity_due            IN NUMBER) RETURN NUMBER IS
                       
                       result  NUMBER ;
                       
    BEGIN
         <<insertAmdReqs>>
         DECLARE
                 PROCEDURE doUpdate IS
                BEGIN
                     <<getActionCode>>
                     DECLARE
                             action_code AMD_REQS.action_code%TYPE;
                            badInsert EXCEPTION ;
                       BEGIN
                            SELECT action_code INTO action_code
                           FROM AMD_REQS
                           WHERE req_id = insertRow.req_id
                           AND part_no = InsertRow.part_no;
                           IF action_code != Amd_Defaults.DELETE_ACTION THEN
                                               RAISE badInsert ;
                           END IF;
                    EXCEPTION WHEN OTHERS THEN
                                                result:= ErrorMsg(pSqlFunction=>'select',
                                                                               pTableName =>'amd_reqs',
                                                                            pErrorLocation => 20,
                                                                            pReturn_code => FAILURE,
                                                                            pKey_1 => req_id,
                                                                            pKey_2 => part_no,
                                                                            pKey_3 => loc_sid,
                                                                            pkey_4 => quantity_due);
                    END getActionCode;
                    
                    UPDATE AMD_REQS
                    SET loc_sid = InsertRow.loc_sid,
                                quantity_due = InsertRow.quantity_due,
                                action_code = Amd_Defaults.INSERT_ACTION,
                                last_update_dt = SYSDATE
                    WHERE req_id = InsertRow.req_id
                                    AND part_no = InsertRow.part_no;
            END doUpdate;
                                                                            
    BEGIN
         <<insertAmdReqs>>
         BEGIN
            INSERT INTO AMD_REQS
            (
                req_id,
              part_no,
              loc_sid,
              quantity_due,
              action_code,
              last_update_dt
             )
             VALUES
             (
                req_id,
              part_no,
              loc_sid,
              quantity_due,
              Amd_Defaults.INSERT_ACTION,
              SYSDATE
            ); 
            
            EXCEPTION
                    WHEN standard.DUP_VAL_ON_INDEX THEN
                         doUpdate ;
                   WHEN OTHERS THEN
                           RETURN ErrorMsg(pSqlFunction => 'insert',
                                           pTableName => 'amd_reqs1',
                                         pErrorLocation => 30,
                                         pReturn_code => FAILURE,
                                         pKey_1 => req_id,
                                         pKey_2 => part_no,
                                         pKey_3 => loc_sid,
                                         pKey_4 => quantity_due);                            
            END  insertAmdReqs ;                                                                                                                                      
            RETURN SUCCESS;                 
                    
    END insertRow;
END;
                                 
    FUNCTION UpdateRow(
                            REQ_ID            IN VARCHAR2,
                        PART_NO            IN VARCHAR2,
                        LOC_SID            IN NUMBER,
                        QUANTITY_DUE    IN NUMBER) RETURN NUMBER IS
    BEGIN
         <<updateAmdReqs>>
         BEGIN
             UPDATE AMD_REQS SET
                    quantity_due = UpdateRow.quantity_due,
                    action_code = Amd_Defaults.UPDATE_ACTION,
                    last_update_dt = SYSDATE
            WHERE
                    req_id = UpdateRow.req_id
                    AND loc_sid = UpdateRow.loc_sid
                    AND part_no = UpdateRow.part_no ;
            EXCEPTION 
                WHEN OTHERS THEN 
                   RETURN ErrorMsg(pSqlFunction => 'update',
                                pTableName => 'amd_reqs',
                                pErrorlocation => 40,
                                pReturn_code => FAILURE,
                                pKey_1 => req_id,
                                pKey_2 => part_no,
                                pKey_3 => loc_sid);
        END updateAmdReqs;     
         RETURN SUCCESS ;
         
    END UpdateRow ;
    
    FUNCTION DeleteRow(
                            REQ_ID                   IN VARCHAR2,
                        PART_NO                IN VARCHAR2,
                        LOC_SID                IN NUMBER) RETURN NUMBER IS
    BEGIN
         <<updateAmdReqs>>
         BEGIN
                   UPDATE AMD_REQS SET
                    req_id = DeleteRow.req_id,
                    part_no =  DeleteRow.part_no,
                    loc_sid = DeleteRow.loc_sid,
                    action_code    = Amd_Defaults.DELETE_ACTION,
                    last_update_dt  =  SYSDATE
                WHERE req_id = DeleteRow.req_id
                AND  part_no  = DeleteRow.part_no
                AND loc_sid = DeleteRow.loc_sid ;
                            
                EXCEPTION WHEN OTHERS THEN
                RETURN ErrorMsg(pSqlFunction => 'update',
                            pTableName => 'amd_reqs',
                            pErrorLocation => 50,
                            pReturn_code => FAILURE,
                            pKey_1 => req_id,
                            pKey_2 => part_no,
                            pKey_3 => loc_sid);
        END updateAmdReqs;
        RETURN SUCCESS ;
        
    END DeleteRow;
      
      
        
      FUNCTION InsertRowBackorder(
                              spo_prime_part_no IN VARCHAR2,
                         spo_location    IN varchar2,
                         qty        IN NUMBER) RETURN NUMBER IS
            
            result NUMBER ;
        FUNCTION doUpdate RETURN NUMBER IS
                 action_code AMD_BACKORDER_SUM.action_code%TYPE;
               badInsert EXCEPTION;
        BEGIN
            
            UPDATE AMD_BACKORDER_SUM
            SET qty = InsertRowBackorder.qty,
            action_code = Amd_Defaults.INSERT_ACTION,
            last_update_dt = SYSDATE
            WHERE spo_prime_part_no = InsertRowBackorder.spo_prime_part_no AND spo_location = InsertRowBackorder.spo_location;
            
            RETURN SUCCESS ;
            
        EXCEPTION WHEN OTHERS THEN
            result := ErrorMsg(pSqlFunction => 'update',
                pTableName => 'amd_backorder_sum',
                pErrorLocation => 60 , 
                pReturn_code => FAILURE,
                pKey_1 => spo_prime_part_no,
                pKey_2 => spo_location,
                pKey_3 => TO_CHAR(qty)) ;
            RAISE ;
        END doUpdate ;
            
        
      BEGIN
             writeMsg(pTableName => 'amd_backorder_sum', 
                         pError_location => 999, 
                        pKey1 => 'spo_prime_part_no=' || spo_prime_part_no, 
                        pKey2 => 'loc_sid=' || spo_location,
                        pKey3 => 'qty=' || to_char(qty)) ;
          commit ;
            
        <<validateData>>  
        DECLARE
                      line_no NUMBER := 0 ;
                    rec AMD_BACKORDER_SUM%ROWTYPE ;
        BEGIN
            line_no := line_no + 1; rec.spo_prime_part_no := spo_prime_part_no ;
            line_no := line_no + 1; rec.spo_location := insertRowBackorder.spo_location ;
            line_no := line_no + 1; rec.qty := qty ;
        EXCEPTION WHEN OTHERS THEN
          
            result := ErrorMsg(pSqlFunction => 'insert',
                pTableName => 'amd_backorder_sum',
                pErrorLocation => 70 , 
                pReturn_code => FAILURE,
                pKey_1 => spo_prime_part_no,
                pKey_2 => spo_location,
                pKey_3 => TO_CHAR(qty),
                pKey_4 => TO_CHAR(line_no)) ;
            RAISE ;
        END validateDate ;
        
        IF (qty > 0) and spo_prime_part_no is not null THEN  
            BEGIN            
                INSERT INTO AMD_BACKORDER_SUM
                    (
                    spo_prime_part_no,
                    spo_location,
                    qty,
                    action_code,
                    last_update_dt
                    )
                    VALUES
                    (
                    InsertRowBackorder.spo_prime_part_no,
                    InsertRowBackorder.spo_location,
                    InsertRowBackorder.qty,
                    Amd_Defaults.INSERT_ACTION,
                    SYSDATE
                    );
              
            EXCEPTION
                WHEN standard.DUP_VAL_ON_INDEX THEN
                     result := doUpdate ; 
                WHEN OTHERS THEN
            
                result := ErrorMsg(pSqlFunction => 'insert',
                    pTableName => 'amd_backorder_sum',
                    pErrorLocation => 80 , 
                    pReturn_code => FAILURE,
                    pKey_1 => spo_prime_part_no,
                    pKey_2 => spo_location,
                    pKey_3 => TO_CHAR(qty) ) ;
                RAISE ;
            END insertAmdBackorderSum;
                  
            
            RETURN SUCCESS ;
        END IF ;
    END InsertRowBackorder;
        
        
    FUNCTION  UpdateRowBackorder(
                          spo_prime_part_no    IN VARCHAR2,
                        spo_location          IN varchar2,
                        qty              IN NUMBER) RETURN NUMBER IS
            result NUMBER;
            
    BEGIN
      <<updateAmdBackorderSum>>
      BEGIN
             UPDATE AMD_BACKORDER_SUM SET
                qty = UpdateRowBackorder.qty,
             action_code = Amd_Defaults.UPDATE_ACTION,
             last_update_dt = SYSDATE
           WHERE spo_prime_part_no = UpdateRowBackorder.spo_prime_part_no
           AND spo_location = UpdateRowBackorder.spo_location;
    
      
       END updateAmdBackorderSum;
       
       RETURN SUCCESS;
       
    END UpdateRowBackorder;
    
     
     FUNCTION DeleteRowBackorder(
                           spo_prime_part_no    IN VARCHAR2,
                        spo_location             IN varchar2) RETURN NUMBER IS
    
     BEGIN
         <<updateAmdBackorderSum>>
        BEGIN
        
              UPDATE AMD_BACKORDER_SUM SET
                action_code = Amd_Defaults.DELETE_ACTION,
                last_update_dt = SYSDATE
              WHERE spo_prime_part_no = DeleteRowBackorder.spo_prime_part_no
              AND spo_location = DeleteRowBackorder.spo_location ;
        
            
            
                RETURN SUCCESS ;
                
        exception when others then
                 writeMsg(pTableName => 'updateAmdBackorderSum', 
                         pError_location => 100, 
                        pKey1 => 'spo_prime_part_no=' || spo_prime_part_no, 
                        pKey2 => 'loc_sid=' || spo_location) ;
                return success ;
        END updateAmdBackorderSum;
        
    END DeleteRowBackorder;
                         
    FUNCTION InsertRowSpoSum(
                              spo_prime_part_no    IN AMD_BACKORDER_SPO_SUM.SPO_PRIME_PART_NO%TYPE,
                         qty        IN AMD_BACKORDER_SPO_SUM.QTY%TYPE) RETURN NUMBER IS
            
            result NUMBER ;
            
            PROCEDURE doUpdate IS
                      action_code AMD_BACKORDER_SPO_SUM.action_code%TYPE ;
            BEGIN
                 <<getActionCode>>
                 BEGIN
                       SELECT action_code INTO doUpdate.action_code
                      FROM AMD_BACKORDER_SPO_SUM
                      WHERE spo_prime_part_no = InsertRowSpoSum.spo_prime_part_no
                      AND action_code = Amd_Defaults.DELETE_ACTION ;
                 EXCEPTION WHEN standard.NO_DATA_FOUND THEN
                       RAISE_APPLICATION_ERROR(-20000, spo_prime_part_no || ' does not have a ' || Amd_Defaults.DELETE_ACTION || ' action_code.');
                 END getActionCode ;
                 
                UPDATE AMD_BACKORDER_SPO_SUM
                SET qty = InsertRowSpoSum.qty,
                action_code = Amd_Defaults.INSERT_ACTION,
                last_update_dt = SYSDATE
                WHERE spo_prime_part_no = InsertRowSpoSum.spo_prime_part_no ;
            END doUpdate ;
            
        
    BEGIN
            
        <<validateData>>  
        DECLARE
                      line_no NUMBER := 0 ;
                    rec AMD_BACKORDER_SPO_SUM%ROWTYPE ;
        BEGIN
            line_no := line_no + 1; rec.spo_prime_part_no := spo_prime_part_no ;
            line_no := line_no + 1; rec.qty := qty ;
        EXCEPTION WHEN OTHERS THEN
          
            result := ErrorMsg(pSqlFunction => 'insert',
                pTableName => 'amd_backorder_spo_sum',
                pErrorLocation => 90 , 
                pReturn_code => FAILURE,
                pKey_1 => spo_prime_part_no,
                pKey_2 => TO_CHAR(qty),
                pKey_3 => TO_CHAR(line_no)) ;
            RAISE ;
        END validateDate ;
        
        IF (qty > 0) THEN  
            <<insertAmdBackorderSpoSum>>
            BEGIN            
                INSERT INTO AMD_BACKORDER_SPO_SUM
                    (
                    spo_prime_part_no,
                    qty,
                    action_code,
                    last_update_dt
                    )
                    VALUES
                    (
                    spo_prime_part_no,
                    qty,
                    Amd_Defaults.INSERT_ACTION,
                    SYSDATE
                    );
              
            EXCEPTION
                WHEN standard.DUP_VAL_ON_INDEX THEN
                     doUpdate ;
                WHEN OTHERS THEN
            
                result := ErrorMsg(pSqlFunction => 'insert',
                    pTableName => 'amd_backorder_spo_sum',
                    pErrorLocation => 100 , 
                    pReturn_code => FAILURE,
                    pKey_1 => spo_prime_part_no,
                    pKey_2 => TO_CHAR(qty) ) ;
                RAISE ;
            END insertAmdBackorderSpoSum;
                      
            
            RETURN SUCCESS ;
        END IF ;
    END InsertRowSpoSum ;
    
    FUNCTION UpdateRowSpoSum(
                              spo_prime_part_no    IN AMD_BACKORDER_SPO_SUM.SPO_PRIME_PART_NO%TYPE,
                         qty        IN AMD_BACKORDER_SPO_SUM.QTY%TYPE) RETURN NUMBER IS
            
            result NUMBER ;
            
        
      BEGIN
            
        <<validateData>>  
        DECLARE
                      line_no NUMBER := 0 ;
                    rec AMD_BACKORDER_SPO_SUM%ROWTYPE ;
        BEGIN
            line_no := line_no + 1; rec.spo_prime_part_no := spo_prime_part_no ;
            line_no := line_no + 1; rec.qty := qty ;
        EXCEPTION WHEN OTHERS THEN
          
            result := ErrorMsg(pSqlFunction => 'update',
                pTableName => 'amd_backorder_spo_sum',
                pErrorLocation => 110 , 
                pReturn_code => FAILURE,
                pKey_1 => spo_prime_part_no,
                pKey_2 => TO_CHAR(qty),
                pKey_3 => TO_CHAR(line_no)) ;
            RAISE ;
        END validateDate ;
        
        IF (qty > 0) THEN
            <<updateAmdBackorderSpoSum>>  
            BEGIN            
                UPDATE AMD_BACKORDER_SPO_SUM
                SET qty = UpdateRowSpoSum.qty,
                action_code = Amd_Defaults.UPDATE_ACTION,
                last_update_dt = SYSDATE
                WHERE spo_prime_part_no = UpdateRowSpoSum.spo_prime_part_no ;
            EXCEPTION
                WHEN OTHERS THEN
            
                result := ErrorMsg(pSqlFunction => 'update',
                    pTableName => 'amd_backorder_spo_sum',
                    pErrorLocation => 120 , 
                    pReturn_code => FAILURE,
                    pKey_1 => spo_prime_part_no,
                    pKey_2 => TO_CHAR(qty) ) ;
                RAISE ;
            END updateAmdBackorderSpoSum;
                      
            
            RETURN SUCCESS ;
            
        END IF ;
    END UpdateRowSpoSum ;
    
    FUNCTION DeleteRowSpoSum(
                              spo_prime_part_no    IN AMD_BACKORDER_SPO_SUM.SPO_PRIME_PART_NO%TYPE) RETURN NUMBER IS
            
            result NUMBER ;
            
        
      BEGIN
            
        
            UPDATE AMD_BACKORDER_SPO_SUM
            SET action_code = Amd_Defaults.DELETE_ACTION,
            last_update_dt = SYSDATE
            WHERE spo_prime_part_no = DeleteRowSpoSum.spo_prime_part_no ;
            
            RETURN SUCCESS ;

     EXCEPTION
        WHEN OTHERS THEN
    
        result := ErrorMsg(pSqlFunction => 'update',
            pTableName => 'amd_backorder_spo_sum',
            pErrorLocation => 130 , 
            pReturn_code => FAILURE,
            pKey_1 => spo_prime_part_no) ;
        RAISE ;
            
    END DeleteRowSpoSum ;
    
    PROCEDURE version IS
    BEGIN
         writeMsg(pTableName => 'amd_reqs_pkg', 
                 pError_location => 110, pKey1 => 'amd_reqs_pkg', pKey2 => '$Revision:   1.23  $') ;
    END version ;
              
     
END Amd_Reqs_Pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_RMADS_SOURCE_TMP_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER."AMD_RMADS_SOURCE_TMP_PKG"   as
/*
      $Author:   zf297a  $
    $Revision:   1.1  $
     $Date:   Dec 01 2005 09:46:34  $
    $Workfile:   amd_rmads_source_tmp_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_rmads_source_tmp_pkg.pkb-arc  $
/*
/*      Rev 1.1   Dec 01 2005 09:46:34   zf297a
/*   Add pvcs keywords
*/

	procedure LoadRmadsIntoAnsi is
	begin
		update amd_national_stock_items set
			mtbdr =
				(select mtbdr
				from amd_rmads_source_tmp
				where part_no = amd_national_stock_items.prime_part_no),
			qpei_weighted =
				(select qpei_weighted
				from amd_rmads_source_tmp
				where part_no = amd_national_stock_items.prime_part_no);
	end LoadRmadsIntoAnsi;

end amd_rmads_source_tmp_pkg;
/


DROP PACKAGE BODY AMD_OWNER.AMD_SPARE_NETWORKS_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Spare_Networks_Pkg AS
/*
      $Author:   zf297a  $
    $Revision:   1.7  $
        $Date:   Aug 23 2015
    $Workfile:   amd_spare_networks_pkg.pkb  $
    
/*      Rev 1.7   Aug 23 2015 fixed GROUP BY clause - used sran
/*      Rev 1.6   Jun 12 2015 use ramp.sran and item.loc_id

/*      Rev 1.5   fEB 23 2015 use amd_defaults.getStartLocId whereever substr(sc,8 was used
/*      Rev 1.4   Jun 09 2006 12:21:34   zf297a
/*   implemented version
/*   
/*      Rev 1.3   Mar 20 2006 11:38:58   c402417
/*   Removed the SUM going to AMD_SPARE_NETWORKS.
/*   
/*      Rev 1.2   Dec 01 2005 10:08:32   zf297a
/*   added errorMsg and better exception handling.
/*   
/*      Rev 1.1   Nov 30 2005 09:28:58   zf297a
/*   Comments:  Changed the default values 'Virtual UAB' to 'VIRTUAL UAB', and 'Virtual COD' to 'VIRTUAL COD'. 
*/

    procedure writeMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 in varchar2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'amd_spare_networks_pkg',    
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
    end writeMsg ;
    
 PROCEDURE ErrorMsg(
     pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE,
     pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
     pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
     pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE,
      pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
     pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
     pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
     pKey_5 IN AMD_LOAD_DETAILS.KEY_5%TYPE := '',
     pKeywordValuePairs IN VARCHAR2 := '') IS
  result NUMBER ;
 BEGIN
  Amd_Utils.InsertErrorMsg (
    pLoad_no => Amd_Utils.GetLoadNo(
      pSourceName => SUBSTR(pSqlfunction,1,20),
      pTableName  => SUBSTR(pTableName,1,20)),
    pData_line_no => pError_location,
    pData_line    => 'amd_spare_networkds_pkg',
    pKey_1 => SUBSTR(pKey_1,1,50),
    pKey_2 => SUBSTR(pKey_2,1,50),
    pKey_3 => SUBSTR(pKey_3,1,50),
    pKey_4 => SUBSTR(pKey_4,1,50),
    pKey_5 => SUBSTR(TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MM:SS') ||
         ' ' || pkey_5,1,50),
    pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
  COMMIT;
 EXCEPTION WHEN OTHERS THEN
     COMMIT ;
 END ErrorMsg;

  PROCEDURE auto_load_spare_networks IS

  --    This program will automatically get new sites from the RAMP and ITEM
  --      table within gold and load them into the AMD_SPARE_NETWORKS table.
  --
  --    Condition for RAMP table data to be selected and then inserted into 
  --      AMD_SPARE_NETORKS:
  --    position 1-3 of SC (field in RAMP) = 'C17' AND
  --      position 8-9 of SC = 'FB' AND
  --    position 14 of SC = 'G' AND
  --      sum of (serviceable_balance + difm_balance + hpmsk_balance + 
  --             spram_balance + wrm_balance > 0)
  --
  --    Condition for ITEM able data to be selected and then inserted into 
  --      AMD_SPARE_NETORKS:
  --      position 1-3 of SC = 'C17' AND
  --      position 8-10 of SC = 'CTL' or 'COD' AND
  --      position 8-13 of SC != 'CODLGB' AND
  --      position 14 of SC = 'G'
  
  lv_gold_table            VARCHAR2(15);
  lv_action            VARCHAR2(1) := Amd_Defaults.INSERT_ACTION;
    
  BEGIN
  lv_gold_table := 'RAMP';
  -- From RAMP gold table
    <<ramp_gold_table>>
      BEGIN 
        INSERT INTO AMD_SPARE_NETWORKS
          (loc_id,location_name,loc_type,action_code, spo_location, last_update_dt)
        SELECT DISTINCT(sran),sran,'UAB',lv_action,'VIRTUAL UAB', SYSDATE
          FROM RAMP a
         WHERE SUBSTR(sc,1,3) = 'C17'
           AND SUBSTR(sran,1,2) = 'FB'
           AND SUBSTR(sc,14,1) = 'G'
           AND NOT EXISTS (SELECT 'x'
                             FROM AMD_SPARE_NETWORKS b
                            WHERE b.loc_id = a.sran)
          GROUP BY sran ; 
        --HAVING SUM(NVL(serviceable_balance,0)+NVL(difm_balance,0)+NVL(hpmsk_balance,0)+
          --     NVL(spram_balance,0)+NVL(wrm_balance,0)) > 0;  /* Removed per spec provided by Laurie C. - 03/02/06 ThuyP. */
    EXCEPTION
        WHEN standard.NO_DATA_FOUND THEN
             NULL ; -- ignore because all locations are already in AMD_SPARE_NETWORKS!!!
        WHEN OTHERS THEN
            errormsg( psqlfunction => 'insert', ptablename => 'amd_spare_networks', perror_location => 10,
                pkey_1 =>'VIRTUAL UAB') ;
            RAISE ;             
    END ramp_gold_table ;

  lv_gold_table := 'ITEM';
  -- From ITEM gold table
  <<item_gold_table>>
  BEGIN 
    INSERT INTO AMD_SPARE_NETWORKS 
      (loc_id,location_name, loc_type,action_code,spo_location, last_update_dt)
    SELECT DISTINCT(loc_id),loc_id,
           DECODE(SUBSTR(loc_id,1,3),'CTL','CWH',SUBSTR(loc_id,1,3)),lv_action,
           DECODE(SUBSTR(loc_id,1,3),'CTL','FD2090','VIRTUAL COD'), SYSDATE
      FROM ITEM a
     WHERE SUBSTR(sc,1,3) = 'C17'
       AND (SUBSTR(loc_id,1,3) = 'CTL' OR SUBSTR(loc_id,1,3) = 'COD')
       AND loc_id != 'CODLGB'
       AND SUBSTR(sc,14,1) = 'G'
       AND NOT EXISTS (SELECT 'x'
                         FROM AMD_SPARE_NETWORKS b
                        WHERE b.loc_id = a.loc_id);
                                               
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      NULL; -- just ignore because all locations are already in AMD_SPARE_NETWORKS!!!
    WHEN OTHERS THEN
            errormsg( psqlfunction => 'insert', ptablename => 'amd_spare_networks', perror_location => 20,
                pkey_1 => 'VIRTUAL COD') ;
            RAISE ;             
   END item_gold_table ;
  END auto_load_spare_networks;

    procedure version is
    begin
         writeMsg(pTableName => 'amd_spare_networks_pkg', 
                 pError_location => 30, pKey1 => 'amd_spare_networks_pkg', pKey2 => '$Revision:   1.7  $') ;
    end version ;

END Amd_Spare_Networks_Pkg;
/


DROP PACKAGE BODY AMD_OWNER.AMD_SPARE_PARTS_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_spare_parts_pkg
AS
   /*
      $Author:   Douglas S. Elder
    $Revision:   1.125
        $Date:   14 Jul 2016
    $Workfile:   amd_spare_parts_pkg.pkb  $
    
     Rev 1.125 17 May 2017 added dbms_output to loadCurrentBackOrder and reformatted code
     Rev 1.124 14 Jul 2016 add writeMsg to insertRow when there is a non-zero return code
     Rev 1.123 11 Jul 2016 removed setting mDebug to true for insertRow
     Rev 1.122 17 Jun 2016 reformatted code

     Rev 1.121 21 Sep 2015 added getProgramId

     Rev 1.120.4 18 Jun 2015 use tmp1.to_loc_id and req1.select_from_loc_id

     Rev 1.120.3 23 Feb 2015 added amd_defaults.getStartLocId

     Rev 1.120.2 20 Feb 2015 added new value for last_update_dt and updated_by when amd_bssm_rvt needs
                   to be updated to be in sync on nsn's with amd_national_stock_items

     Rev 1.120.1 2/19/2015 added exception handlers to doUpdate and deleteAnyRblPairs

     Rev 1.120 2/19/2015 merged in patch 1.118.1  of UpdateRow's doupdate procedure and address the amd_bssm_rvt.amd_bssm_rvt_fk01 2292 constraint error that was
     occuring when the nsn was being changed for amd_national_stock_items.  The data that was causing the error was captured, deleted, and then
     restored with the new nsn to amd_bssm_rvt using a local declare .. begin / end block of code.

     Rev 1.119 2/4/2015 added amd_defaults.getSourceCode, getNonStockageList

     Rev 1.118 for hasPartMoved make sure subquery return one row by using "distinct' keyword

     Rev 1.117 - use consumables_pkg instead of a2a_consumables_pkg

     Rev 1.115   07 Aug 2009 11:11:30   zf297a
  Use the common sleep procedure

     Rev 1.114   15 Jul 2009 10:52:16   zf297a
  Removed a2a code

     Rev 1.111   24 Oct 2008 14:08:22   zf297a
  Made updateNsiPrimePartData, insertAmdNsn, updateAmdNsn,  prepareDataForUpdate, updateAmdSparePartRow, updatePrimeInd, insertNewNsn,  and checkNsnAndPrimeInd into procedures that throw exceptions when there are errors to simplify coding.

     Rev 1.110   24 Oct 2008 13:29:12   zf297a
  Made updatePrimePartNo into a procedure that throws exceptions for errors to simplify coding.

     Rev 1.109   24 Oct 2008 13:22:18   zf297a
  Made unassignPrimePart into a procedure that throws exceptions for errors to simplify coding.

     Rev 1.108   24 Oct 2008 13:09:20   zf297a
  Made makeNsnSameFoeAllParts into a procedure that throw exceptions for errors to simplify coding.

     Rev 1.107   24 Oct 2008 13:01:36   zf297a
  made doPhysicalInsert into a procedure that throws exceptions when there are errors to simplify coding.

     Rev 1.106   24 Oct 2008 12:45:38   zf297a
  Made doLogincalInsert into a procedure that throws exceptions for errors.

     Rev 1.105   24 Oct 2008 12:40:00   zf297a
  made updateNatStkItem a procedure which throws exception when there is an error to simplify coding.

     Rev 1.104   24 Oct 2008 12:17:28   zf297a
  Make insertSparePart and updatePrimePartData into procedures that through exceptions when there is an error.  This simplifies the code.

     Rev 1.103   24 Oct 2008 11:56:06   zf297a
  Made createNationalStockItem, makePrimeAnEquivalentPart, and prepareDataForInsert into  procedures to simplity code.  Rely on exception to exit routines when there are errors.

     Rev 1.102   24 Oct 2008 11:36:16   zf297a
  Made insertNsiParts into a procedure.  The exception will stop any routine that invokes it.

     Rev 1.101   24 Oct 2008 10:46:02   zf297a
  Implemented interfaces setDebug and getDebugYorN.  Replaced  writeMsg's that depend on mDebug with debugMsg.
  Changed debugMsg's 2nd param to pError_location so it can be resquenced with the awk resequence utility.

     Rev 1.100   23 Oct 2008 21:30:10   zf297a
  Added variable is_spo_part to deleteRow.

     Rev 1.99   23 Oct 2008 21:21:34   zf297a
  Added autonomous transaction pragma to ErrorMsg and debugMsg.

  Added an out parameter to updateFlags so that invoking routines can determine if the part is a spo part.

  After updating the flags and the part is no longer a spo part, but it had been one then execute a2a_pkg.deletePartInfo.

  Don't execute A2A code if the part is not a spo part.


     Rev 1.98   23 Oct 2008 15:17:56   zf297a
  For updateRow check is_spo_part before invoking a2a routines.

     Rev 1.97   13 Oct 2008 09:10:44   zf297a
  do updateFlags before any A2A processing is done since the package now uses the flags.

     Rev 1.96   22 Sep 2008 13:30:18   zf297a
  update flags is_repairable, is_consumable, and is_spo_part.

     Rev 1.95   09 Jul 2008 14:50:26   zf297a
  started using amd_defaults.CONSUMABLE_PLANNER_CODE and amd_defaults.REPAIRABLE_PLANNER_CODE.

     Rev 1.94   27 Jun 2008 11:59:22   zf297a
  Added some debug code.

     Rev 1.93   06 Jun 2008 22:08:10   zf297a
  Make sure that the part was sent to the spo via the amd_sent_to_a2a table before invoking the a2a_pkg.deletePartPricing function.

     Rev 1.92   16 May 2008 12:10:52   zf297a
  Fixed setting of debug flag for the a2a_pkg and added getVersion function

     Rev 1.91   27 Mar 2008 12:08:40   zf297a
  Made constant unable_to_get_prime_part unique for Oracle 10g

     Rev 1.90   20 Nov 2007 10:39:24   zf297a
  Fixed typo - partNoTab

     Rev 1.89   20 Nov 2007 10:20:12   zf297a
  Use bulk update for function makeNsnSameForAllParts and use bulk collect and bulk update for loadCurrentBackOrder.

     Rev 1.88   Nov 14 2007 18:55:44   c402417
  Added procedures insert, update, and delete for repair to table tmp_a2a_part_lead_time.

     Rev 1.87   11 Sep 2007 16:47:10   zf297a
  Added wesm_indicator and removed commits from for/loop's.

     Rev 1.86   24 May 2007 14:15:38   zf297a
  Used the simplified a2a_pkg.insertPartInfo procedure to create the A2A PartInfo data.

     Rev 1.85   05 Apr 2007 09:28:56   zf297a
  Added isDiff routines to replace complex conditions.  Added lineNumber to updateRow to help in debugging.

     Rev 1.84   05 Mar 2007 11:27:48   zf297a
  For updateRow update amd_spare_parts.order_lead_time_defaulted.

     Rev 1.83   14 Feb 2007 13:58:18   zf297a
  Implemented new version of insertRow and updateRow using amcDemand and amcDemandCleaned.

     Rev 1.82   Oct 06 2006 08:48:42   zf297a
  When insert of amd_spare_parts gets a dup_val_on_index change it to an update.

     Rev 1.81   Oct 05 2006 13:38:26   zf297a
  return SUCCESS when there is the part_already_exists exception for the insertRow function.

     Rev 1.80   Oct 05 2006 13:33:28   zf297a
  ignore duplicates for insertRow

     Rev 1.79   Oct 03 2006 11:54:48   zf297a
  Fixed query for getQtyDue of loadCurrentBackOrder.  Added dbms_output to version.

     Rev 1.78   Sep 14 2006 00:42:34   zf297a
  Added procedure deleteAnyRblPairs which is used when the nsn gets updated in amd_national_stock_items - this will delete any dependent child from amd_rbl_pairs if necessary.

     Rev 1.77   Jun 21 2006 11:36:44   zf297a
  Fixed loadCurrentBackOrder - needed to trim the part_no in the where clause of the update statements, otherwise the update did not find any matches per the criteria and it does not generate an exception.

     Rev 1.76   Jun 09 2006 12:29:48   zf297a
  implemented version

     Rev 1.75   Mar 23 2006 14:15:38   zf297a
  Changed code to use amd_defaults.nsn_planner_code or nsl_planner_code where either the cleaned planner code or the original planner_code do not exist in amd_planners.

     Rev 1.74   Mar 08 2006 09:25:46   zf297a
  Added mtbdr_computed

     Rev 1.73   Oct 10 2005 09:36:26   zf297a
  added price to insertPartInfo and updatePartInfo parameter list

     Rev 1.72   Sep 27 2005 08:53:46   zf297a
  Fixed updatePartLeadtime and updatePartPricing by adding a parts.part_no to both where clauses.  Aslo, added comprehensive checks of the data changing from null to not null or not null to null.

     Rev 1.72   Aug 19 2005 12:48:26   zf297a
  Since the amd_load package is converting ime_to_repair_off_base_cleand and order_lead_time_cleaned from months to calendar days and Converting order_lead_time from business days to calendar days remove all conversions from this package.

     Rev 1.71   Aug 17 2005 15:01:24   zf297a
  Enhanced loadCurrentBackOrder with periodic commits and display of update counters.

     Rev 1.70   Aug 16 2005 12:51:22   zf297a
  made same change as made to version 1.39.1.7

     Rev 1.69   Aug 10 2005 10:02:06   zf297a
  converted cleaned order_lead_time and order_lead_time to calandar days for a2a transactions.

     Rev 1.68   Aug 09 2005 07:23:32   zf297a
  Applied the same update for getQtyDue and cursor curDue - same patch will be applied to current prod (1.7.1)

     Rev 1.67   Jul 29 2005 14:59:40   zf297a
  Allow Nsn to change on the Prime or the Equivalent part.

     Rev 1.66   Jul 28 2005 10:36:20   zf297a
  Make sure that when a prime_part_no becomes unassigned that its associated national_stock_item gets logically deleted (set the last_update_dt too).  Whenever a new prime_part_no gets assigned to an exisiting national_stock_item update the action_code (U) and the last_update_dt.

     Rev 1.65   Jun 27 2005 13:55:24   c970183
  Moved a2a code for part_lead_time and part_pricing to be after partInfo

     Rev 1.64   Jun 27 2005 11:37:26   c970183
  Added the display of pPart_no and pNsn for the errorMsg when doing updatePartLeadTime

     Rev 1.63   Jun 17 2005 09:03:08   c970183
  Removed exception handler for insertLoadDetail, added raise_application for dup keys, and updated deleteRow's exception handler.

     Rev 1.62   Jun 16 2005 15:53:14   c970183
  Changed errorMsg to be the same as the errorMsg in the a2a_pkg: this uses a unique pError_location number to pinpoint the block of code that has the exception.  Also, added some user defined exception instead of return codes.

     Rev 1.61   Jun 03 2005 12:50:08   c970183
  Added the procedure loadCurrentBackOrder for amd_national_stock_items.current_backorder

     Rev 1.60   May 18 2005 08:59:04   c970183
  Started using a2a_pkg.getIndenture.

     Rev 1.59   May 18 2005 07:29:44   c970183
  Modified how mArgs is used.  Added function name for args list and prefixed package name.

     Rev 1.58   May 16 2005 11:59:50   c970183
  Moved time_to_repair_off_base and cost_to_repair_off_base from amd_part_locs to amd_national_stock_items.  Created "changed indicators" for both of these fields.

     Rev 1.57   May 13 2005 14:44:06   c970183
  Started using a2a_pkg.THIRD_PARTY_FLAG and a2a_pkg.INDENTURE constants

     Rev 1.56   May 06 2005 08:23:46   c970183
  changed dla_warehouse_stock, dla_warehouse_stock_cleaned, and getDlaWarehouseStock to current_backorder, current_backorder_cleaned, and getCurrentBackorder.

     Rev 1.55   May 02 2005 12:54:42   c970183
  Added some error handling for deleteRow.

     Rev 1.53   Apr 26 2005 14:04:02   c970183
  Fixed return value of getCriticalityChangedInd, getNrtsAvgChangedInd, getRtsAvgChangedInd, and getCondemiAvgChanged.

     Rev 1.52   Apr 26 2005 11:36:48   c970183
  Added criticality_changed, nrts_avg_changed, rts_avg_changed, and condemn_avg_changed indicators to amd_national_stock_items.

     Rev 1.51   Apr 25 2005 12:46:34   c970183
  Fixed the update of amd_spare_parts by adding in mfgr.  Enhanced debugging by adding a global mArgs string that contains all the data that was used to invoke insertRow, updateRow, or deleteRow.

     Rev 1.50   Apr 22 2005 08:33:34   c970183
  Fixed InsertRow so that it only invokes a2a_pkg.insertPartInfo when it does a physical insert to amd_national_stock_items, otherwise it will do an update function.

     Rev 1.49   Apr 22 2005 08:08:46   c970183
  added additional debug code

     Rev 1.48   Apr 18 2005 10:54:42   c970183
  Added new parameters to insertRow and updateRow.  Leveraged the old routines by just defining the new parameters as global member variables and invoking the old insertRow and updateRow methods.   Change the insert and update of amd_national_stock_items to use the new global member variables.

     Rev 1.47   Mar 24 2005 14:37:06   c970183
  added ver 1.40 - 1.45 changes.  Plus fixed a2a trans

     Rev 1.46  Mar 24 2005 09:36:22   c970183
  Added qpei_weighted, order_lead_time_cleaned, unit_cost_cleaned, planner_code_cleaned, smr_code_cleaned, cost_to_repair_off_base_cleand to InsertRow and UpdateRow

     Rev 1.39.1.0   06 Jan 2005 10:26:24   c970183
  Added mmac and unit_of_issue

  Copied the following changes from the SCCS version:
        Rev 1.6   13 Jun 2003 09:52:24   c970408
     Modified updateAmdSparePartRow() to use it's own nsn and removed call to updateNsnFromPrimeRec(). Modifed nsnChanged() to look at an.nsn instead of asp.nsn. Added call to makeNsnSameForAllParts() to checkNsnAndPrimeInd().

        Rev 1.5   18 Mar 2003 11:07:44   c970408
     Modified the code to correctly move a part from one nsn to another if both nsns exist concurrently in CAT1.

        Rev 1.4   05 Mar 2003 13:23:42   c970408
     fixed the movement of temp nsns to cat1 and the unassociation that results.

        Rev 1.3   26 Nov 2002 17:04:22   c970408
     Added getFedcCost().

        Rev 1.2   04 Nov 2002 16:20:06   c970408
     Mod'ed updating of the ansi.action_code = 'D' query in UpdateRow method to be more efficient.

        Rev 1.1   14 Oct 2002 16:03:44   c970408
     Added query at end of UpdateRow to update ansi.action_code = 'D' if no active amd_nsi_parts recs are linked to and ansi.nsi_sid.

        Rev 1.0   07 Oct 2002 06:26:18   c372701
     Initial revision.



     Rev 1.39   02 Oct 2002 12:30:06   c970408
  Added updateNsnFromPrimeRec() to resolve issue with amd_spare_parts.nsn not updating correctly on non-primes. Removed the nsi_sid qualification in UnassignPrimePart() to resolve issue when a part moves from one nsi_sid to another AND changes from a prime to a non-prime.

     Rev 1.38   30 Aug 2002 11:46:26   c970183
  Fixed updating of the prime_part_no.   When a prime_part_no and its equivalent parts got deleted and reinserted,  the logic caused the amd_national_stock_items.prime_part_no column to get set to a null value.  To accomodate this condition code has been added to the equivalent part section that checks for an existing amd_nsi_parts.part_no with its prime_ind set to 'Y'.  If found it makes sure that the same part_no appears in amd_national_stock_items.prime_part_no.

     Rev 1.37   28 Aug 2002 09:56:04   c970183
  Added the latest_config column for amd_national_stock_items with a value of 'Y'

     Rev 1.35   23 Aug 2002 12:10:54   c970183
  Stripped out ErrorMsg as a nested procedure and made it global to eliminate some redundant code.  Stripped out the updating of amd_national_stock_items to eliminate some redundant code.  Stripped out the routine for making all the equivalent parts have the same nsn as the prime part to eliminate some redundant code.
  Added the invocation of the routine to make nsn's same for equivalent parts for a part that was equivalent, but is now prime.

     Rev 1.34   08 Aug 2002 13:58:58   c970183
  Fixed InsertNewNsn's no_data_found exception: made sure it returned a value.

     Rev 1.33   08 Aug 2002 13:49:14   c970183
  Made the InsertNatStkItem function global to the package.  Wrap all the code needed to create the amd_national_stock_items and amd_nsns rows in a global procedure called CreateNationalStockItem.
  Changed the UpdateRow.InsertNewNsn to accomodate not finding a nsi_sid via the part_no (after having attempted to get it by the Nsn) to create a new Amd_National_Stock_Item/Amd_Nsns pair.

     Rev 1.32   07 Aug 2002 08:58:22   c970183
  Set unassignment_date to sysdate for deleted parts.

                29 July 2002 fixed code so that a part that will be used a prime
                     is unassigned no matter what nsn it is currently assigned and
                   regardless of its current prime_ind


                   22 July 2002 fixed code so that only one current 'C', nsn_type will
                exist in amd_nsns for a given nsi_sid

     Rev 1.30   22 May 2002 06:41:16   c970183
  Added routines to create an NsiGroup for new Nsn's and to create NsiEffects for new Nsn's using the amd_default_effectivity_pkg

     Rev 1.29   16 May 2002 09:59:28   c970183
  Qualifed two updates of amd_nsns with the nsn so that only one will be CURRENT.

     Rev 1.28   11 Apr 2002 10:02:08   c970183
  Added 2nd SUCCESS return code for the exception handler of insertNsiPart when it recovers without a problem.

     Rev 1.27   11 Apr 2002 09:51:08   c970183
  Added SUCCESS return code to insertNsiParts

     Rev 1.26   11 Apr 2002 08:32:22   c970183
  Added ONE routine that inserts the amd_nsi_parts row and handles the dup key problem by sleeping one second and then doing the insert again.

     Rev 1.25   11 Apr 2002 08:09:20   c970183
  Added $Log$ keyword

     10/02/01 Douglas Elder   Initial implementation
     03/28/02 Douglas Elder   Made application sleep when a duplicate insert
                                      occurs and then retry the insert.
     04/04/02 Douglas Elder    Added Mic Code to insert and update
     04/05/02 Douglas Elder    Added code to update the nsn_type for
                                       a given nsi_sid to
                                       the amd_spare_parts_pkg.TEMPORARY_NSN
                               whenever the nsn_type is
                               amd_spare_parts_pkg.CURRENT_NSN
      04/11/02 Douglas Elder   Added ONE routine that inserts the
                                  amd_nsi_parts row and handles the dup key
                               problem by sleeping one second and then doing
                               the insert again.
      04/11/12 Douglas Elder   Added SUCCESS return code to insertNsiParts
    */



   PROGRAM_ID          CONSTANT VARCHAR2 (30) := amd_defaults.getProgramId;
   PROGRAM_ID_LL       CONSTANT NUMBER := LENGTH (PROGRAM_ID);

   UNIT_COST_CLEANED_VIA_NSN    EXCEPTION;
   CANNOT_FIND_PART             EXCEPTION;
   ADD_UOM_CODE_EXCEPTION       EXCEPTION;
   ADD_PLANNER_CODE_EXCEPTION   EXCEPTION;
   UNABLE_TO_GET_NSI_SID_EXP    EXCEPTION;

   -- package member variables
   mDebug                       BOOLEAN := FALSE;
   mRc                          NUMBER := FAILURE;
   mArgs                        VARCHAR2 (2000);
   mMtbdr                       amd_national_stock_items.mtbdr%TYPE;
   mMtbdr_computed              amd_national_stock_items.mtbdr_computed%TYPE;
   mQpeiWeighted                amd_national_stock_items.qpei_weighted%TYPE;
   mCondemnAvgCleaned           amd_national_stock_items.condemn_avg_cleaned%TYPE;
   mCriticalityCleaned          amd_national_stock_items.criticality%TYPE;
   mMtbdrCleaned                amd_national_stock_items.mtbdr_cleaned%TYPE;
   mNrtsAvgCleaned              amd_national_stock_items.nrts_avg_cleaned%TYPE;
   mCostToRepairOffBaseCleand   amd_national_stock_items.cost_to_repair_off_base_cleand%TYPE;
   mTimeToRepairOffBaseCleand   amd_national_stock_items.time_to_repair_off_base_cleand%TYPE;
   mOrderLeadTimeCleaned        amd_national_stock_items.order_lead_time_cleaned%TYPE;
   mPlannerCodeCleaned          amd_national_stock_items.planner_code_cleaned%TYPE;
   mRtsAvgCleaned               amd_national_stock_items.rts_avg_cleaned%TYPE;
   mSmrCodeCleaned              amd_national_stock_items.smr_code_cleaned%TYPE;
   mUnitCostCleaned             amd_national_stock_items.unit_cost_cleaned%TYPE;
   mCondemnAvg                  amd_national_stock_items.condemn_avg%TYPE;
   mCriticality                 amd_national_stock_items.criticality%TYPE;
   mNrtsAvg                     amd_national_stock_items.nrts_avg%TYPE;
   mRtsAvg                      amd_national_stock_items.rts_avg%TYPE;
   mCostToRepairOffBase         amd_national_stock_items.cost_to_repair_off_base%TYPE;
   mTimeToRepairOffBase         amd_national_stock_items.time_to_repair_off_base%TYPE;
   mAmcDemand                   amd_national_stock_items.amc_demand%TYPE;
   mAmcDemandCleaned            amd_national_stock_items.amc_demand_cleaned%TYPE;
   mWesmIndicator               amd_national_stock_items.WESM_INDICATOR%TYPE;


   ---------------------------------------------------------------
   -- Private declarations
   --

   FUNCTION getFedcCost (pPartNo VARCHAR2)
      RETURN NUMBER;

   FUNCTION hasPartMoved (pPartNo VARCHAR2, pNsn VARCHAR2)
      RETURN BOOLEAN;

   PROCEDURE unassignPart (pPartNo VARCHAR2);

   FUNCTION ErrorMsg (
      pSourceName          IN amd_load_status.SOURCE%TYPE,
      pTableName           IN amd_load_status.TABLE_NAME%TYPE,
      pError_location      IN amd_load_details.DATA_LINE_NO%TYPE,
      pReturn_code         IN NUMBER,
      pPart_no             IN VARCHAR2 := '',
      pNsi_sid             IN VARCHAR2 := '',
      pKeywordValuePairs   IN VARCHAR2 := '',
      pComments            IN VARCHAR2 := '')
      RETURN NUMBER;

   --
   -- End Private declarations
   ---------------------------------------------------------------

   debugThreshold               NUMBER := 1000;
   debugCnt                     NUMBER := 0;

   PROCEDURE writeMsg (
      pTableName        IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
      pError_location   IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
      pKey1             IN VARCHAR2 := '',
      pKey2             IN VARCHAR2 := '',
      pKey3             IN VARCHAR2 := '',
      pKey4             IN VARCHAR2 := '',
      pData             IN VARCHAR2 := '',
      pComments         IN VARCHAR2 := '')
   IS
   BEGIN
      Amd_Utils.writeMsg (pSourceName       => 'amd_spare_parts_pkg',
                          pTableName        => pTableName,
                          pError_location   => pError_location,
                          pKey1             => pKey1,
                          pKey2             => pKey2,
                          pKey3             => pKey3,
                          pKey4             => pKey4,
                          pData             => pData,
                          pComments         => pComments);
   END writeMsg;

   FUNCTION ErrorMsg (
      pSqlfunction         IN amd_load_status.SOURCE%TYPE,
      pTableName           IN amd_load_status.TABLE_NAME%TYPE,
      pError_location         amd_load_details.DATA_LINE_NO%TYPE,
      pReturn_code         IN NUMBER,
      pKey_1               IN amd_load_details.KEY_1%TYPE,
      pKey_2               IN amd_load_details.KEY_2%TYPE := '',
      pKey_3               IN amd_load_details.KEY_3%TYPE := '',
      pKey_4               IN amd_load_details.KEY_4%TYPE := '',
      pKeywordValuePairs   IN VARCHAR2 := '')
      RETURN NUMBER
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;

      key5   amd_load_details.KEY_5%TYPE := pKeywordValuePairs;
   BEGIN
      IF key5 = ''
      THEN
         key5 := pSqlFunction || '/' || pTableName;
      ELSE
         key5 := key5 || ' ' || pSqlFunction || '/' || pTableName;
      END IF;

      -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
      -- do not exceed the length of the column's that the data gets inserted into
      -- This is for debugging and logging, so efforts to make it not be the source of more
      -- errors is VERY important
      Amd_Utils.InsertErrorMsg (
         pLoad_no        => Amd_Utils.GetLoadNo (
                              pSourceName   => SUBSTR (pSqlfunction, 1, 20),
                              pTableName    => SUBSTR (pTableName, 1, 20)),
         pData_line_no   => pError_location,
         pData_line      => 'amd_spare_parts_pkg.' || mArgs,
         pKey_1          => SUBSTR (pKey_1, 1, 50),
         pKey_2          => SUBSTR (pKey_2, 1, 50),
         pKey_3          => SUBSTR (pKey_3, 1, 50),
         pKey_4          => SUBSTR (pKey_4, 1, 50),
         pKey_5          => SUBSTR (
                                 'rc='
                              || TO_CHAR (pReturn_code)
                              || ' '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM')
                              || ' '
                              || key5,
                              1,
                              50),
         pComments       => SUBSTR (
                                 'sqlcode('
                              || SQLCODE
                              || ') sqlerrm('
                              || SQLERRM
                              || ')',
                              1,
                              2000));
      COMMIT;
      RETURN pReturn_code;
   EXCEPTION
      WHEN OTHERS
      THEN
         COMMIT;
   END ErrorMsg;

   PROCEDURE ErrorMsg (
      pSqlfunction         IN amd_load_status.SOURCE%TYPE,
      pTableName           IN amd_load_status.TABLE_NAME%TYPE := '',
      pError_location         amd_load_details.DATA_LINE_NO%TYPE,
      pKey_1               IN amd_load_details.KEY_1%TYPE := '',
      pKey_2               IN amd_load_details.KEY_2%TYPE := '',
      pKey_3               IN amd_load_details.KEY_3%TYPE := '',
      pKey_4               IN amd_load_details.KEY_4%TYPE := '',
      pKeywordValuePairs   IN VARCHAR2 := '')
   IS
      result   NUMBER;
   BEGIN
      result :=
         ErrorMsg (pSqlfunction         => pSqlfunction,
                   pTableName           => pTableName,
                   pError_location      => pError_location,
                   pReturn_code         => FAILURE,
                   pKey_1               => pKey_1,
                   pKey_2               => pKey_2,
                   pKey_3               => pKey_3,
                   pKey_4               => pKey_4,
                   pKeywordValuePairs   => pKeywordValuePairs);
   EXCEPTION
      WHEN OTHERS
      THEN
         COMMIT;
   END ErrorMsg;


   -- add wrapper for amd_utils.debugMsg
   PROCEDURE debugMsg (pMsg IN VARCHAR2, pError_Location IN NUMBER)
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      -- is debugging turned on for this package?
      IF mDebug
      THEN
         amd_utils.debugMsg (pMsg        => pMsg,
                             pPackage    => 'amd_spare_parts',
                             pLocation   => pError_Location);
         COMMIT;                                -- make sure the trace is kept
      END IF;
   END;

   PROCEDURE updateFlags (
      pPart_no      IN     amd_spare_parts.part_no%TYPE,
      is_spo_part      OUT amd_spare_parts.is_spo_part%TYPE)
   IS
      isSpoPart      amd_spare_parts.is_spo_part%TYPE;
      isRepairable   amd_spare_parts.is_repairable%TYPE;
      isConsumable   amd_spare_parts.is_consumable%TYPE;
   BEGIN
      isSpoPart := 'N';
      isConsumable := 'N';
      isRepairable := 'N';

      IF amd_utils.isPartRepairable (pPart_no)
      THEN
         isRepairable := 'Y';

         IF isValidRepairablePart (pPart_no)
         THEN
            isSpoPart := 'Y';
         END IF;
      END IF;

      IF amd_utils.isPartConsumable (pPart_no)
      THEN
         isConsumable := 'Y';

         IF isValidConsumablePart (pPart_no)
         THEN
            isSpoPart := 'Y';
         END IF;
      END IF;

      UPDATE amd_spare_parts
         SET is_repairable = isRepairable,
             is_consumable = isConsumable,
             is_spo_part = isSpoPart
       WHERE part_no = pPart_no;

      is_spo_part := isSpoPart;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction => 'updateFlags', pError_location => 10);
   END updateFlags;

   FUNCTION getCriticalityChangedInd (
      nsi_sid   IN amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.criticality_changed%TYPE
   IS
      oldCriticality          amd_national_stock_items.CRITICALITY%TYPE;
      oldCriticalityCleaned   amd_national_stock_items.CRITICALITY_CLEANED%TYPE;
   BEGIN
     <<getOldValues>>
      BEGIN
         SELECT criticality, criticality_cleaned
           INTO oldCriticality, oldCriticalityCleaned
           FROM amd_national_stock_items
          WHERE nsi_sid = getCriticalityChangedInd.nsi_sid;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            oldCriticality := NULL;
            oldCriticalityCleaned := NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (
               pSqlfunction      => 'select',
               pTableName        => 'amd_national_stock_items',
               pError_location   => 20,
               pKey_1            => TO_CHAR (getCriticalityChangedInd.nsi_sid));
            RAISE;
      END getOldValues;

      IF amd_preferred_pkg.GetPreferredValue (mCriticalityCleaned,
                                              mCriticality) !=
            amd_preferred_pkg.GetPreferredValue (oldCriticalityCleaned,
                                                 oldCriticality)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getCriticalityChangedInd;

   FUNCTION getNrtsAvgChangedInd (
      nsi_sid   IN amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.nrts_avg_changed%TYPE
   IS
      oldNrtsAvg          amd_national_stock_items.Nrts_Avg%TYPE;
      oldNrtsAvgCleaned   amd_national_stock_items.Nrts_Avg_CLEANED%TYPE;
   BEGIN
     <<getOldValues>>
      BEGIN
         SELECT Nrts_Avg, Nrts_Avg_cleaned
           INTO oldNrtsAvg, oldNrtsAvgCleaned
           FROM amd_national_stock_items
          WHERE nsi_sid = getNrtsAvgChangedInd.nsi_sid;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            oldNrtsAvg := NULL;
            oldNrtsAvgCleaned := NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (
               pSqlfunction      => 'select',
               pTableName        => 'amd_national_stock_items',
               pError_location   => 30,
               pKey_1            => TO_CHAR (getNrtsAvgChangedInd.nsi_sid));
            RAISE;
      END getOldValues;

      IF amd_preferred_pkg.GetPreferredValue (mNrtsAvgCleaned, mNrtsAvg) !=
            amd_preferred_pkg.GetPreferredValue (oldNrtsAvgCleaned,
                                                 oldNrtsAvg)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getNrtsAvgChangedInd;

   FUNCTION getRtsAvgChangedInd (
      nsi_sid   IN amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.rts_avg_changed%TYPE
   IS
      oldRtsAvg          amd_national_stock_items.Rts_Avg%TYPE;
      oldRtsAvgCleaned   amd_national_stock_items.Rts_Avg_CLEANED%TYPE;
   BEGIN
     <<getOldValues>>
      BEGIN
         SELECT Rts_Avg, Rts_Avg_cleaned
           INTO oldRtsAvg, oldRtsAvgCleaned
           FROM amd_national_stock_items
          WHERE nsi_sid = getRtsAvgChangedInd.nsi_sid;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            oldRtsAvg := NULL;
            oldRtsAvgCleaned := NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (
               pSqlfunction      => 'select',
               pTableName        => 'amd_national_stock_items',
               pError_location   => 40,
               pKey_1            => TO_CHAR (getRtsAvgChangedInd.nsi_sid));
            RAISE;
      END getOldValues;

      IF amd_preferred_pkg.GetPreferredValue (mRtsAvgCleaned, mRtsAvg) !=
            amd_preferred_pkg.GetPreferredValue (oldRtsAvgCleaned, oldRtsAvg)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getRtsAvgChangedInd;

   FUNCTION getCondemnAvgChangedInd (
      nsi_sid   IN amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.condemn_avg_changed%TYPE
   IS
      oldCondemnAvg          amd_national_stock_items.Condemn_Avg%TYPE;
      oldCondemnAvgCleaned   amd_national_stock_items.Condemn_Avg_CLEANED%TYPE;
   BEGIN
     <<getOldValues>>
      BEGIN
         SELECT Condemn_Avg, Condemn_Avg_cleaned
           INTO oldCondemnAvg, oldCondemnAvgCleaned
           FROM amd_national_stock_items
          WHERE nsi_sid = getCondemnAvgChangedInd.nsi_sid;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            oldCondemnAvg := NULL;
            oldCondemnAvgCleaned := NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (
               pSqlfunction      => 'select',
               pTableName        => 'amd_national_stock_items',
               pError_location   => 50,
               pKey_1            => TO_CHAR (getCondemnAvgChangedInd.nsi_sid));
            RAISE;
      END getOldValues;

      IF amd_preferred_pkg.GetPreferredValue (mCondemnAvgCleaned,
                                              mCondemnAvg) !=
            amd_preferred_pkg.GetPreferredValue (oldCondemnAvgCleaned,
                                                 oldCondemnAvg)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getCondemnAvgChangedInd;

   FUNCTION getCostToRepairOffBaseChgedInd (
      nsi_sid   IN amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.cost_to_repair_off_base_chged%TYPE
   IS
      oldCostToRepairOffBase         amd_national_stock_items.cost_to_repair_off_base%TYPE;
      oldCostToRepairOffBaseCleand   amd_national_stock_items.cost_to_repair_off_base_cleand%TYPE;
   BEGIN
     <<getOldValues>>
      BEGIN
         SELECT cost_to_repair_off_base, cost_to_repair_off_base_cleand
           INTO oldCostToRepairOffBase, oldCostToRepairOffBaseCleand
           FROM amd_national_stock_items
          WHERE nsi_sid = getCostToRepairOffBaseChgedInd.nsi_sid;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            oldCostToRepairOffBase := NULL;
            oldCostToRepairOffBaseCleand := NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (
               pSqlfunction      => 'select',
               pTableName        => 'amd_national_stock_items',
               pError_location   => 60,
               pKey_1            => TO_CHAR (
                                      getCostToRepairOffBaseChgedInd.nsi_sid));
            RAISE;
      END getOldValues;

      IF amd_preferred_pkg.GetPreferredValue (mCostToRepairOffBaseCleand,
                                              mCostToRepairOffBase) !=
            amd_preferred_pkg.GetPreferredValue (
               oldCostToRepairOffBaseCleand,
               oldCostToRepairOffBase)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getCostToRepairOffBaseChgedInd;

   FUNCTION getTimeToRepairOffBaseChgedInd (
      nsi_sid   IN amd_national_stock_items.nsi_sid%TYPE)
      RETURN amd_national_stock_items.time_to_repair_off_base_chged%TYPE
   IS
      oldTimeToRepairOffBase         amd_national_stock_items.time_to_repair_off_base%TYPE;
      oldTimeToRepairOffBaseCleand   amd_national_stock_items.time_to_repair_off_base_cleand%TYPE;
   BEGIN
     <<getOldValues>>
      BEGIN
         SELECT time_to_repair_off_base, time_to_repair_off_base_cleand
           INTO oldTimeToRepairOffBase, oldTimeToRepairOffBaseCleand
           FROM amd_national_stock_items
          WHERE nsi_sid = getTimeToRepairOffBaseChgedInd.nsi_sid;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            oldTimeToRepairOffBase := NULL;
            oldTimeToRepairOffBaseCleand := NULL;
         WHEN OTHERS
         THEN
            ErrorMsg (
               pSqlfunction      => 'select',
               pTableName        => 'amd_national_stock_items',
               pError_location   => 70,
               pKey_1            => TO_CHAR (
                                      getTimeToRepairOffBaseChgedInd.nsi_sid));
            RAISE;
      END getOldValues;

      IF amd_preferred_pkg.GetPreferredValue (mTimeToRepairOffBaseCleand,
                                              mTimeToRepairOffBase) !=
            amd_preferred_pkg.GetPreferredValue (
               oldTimeToRepairOffBaseCleand,
               oldTimeToRepairOffBase)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getTimeToRepairOffBaseChgedInd;

   PROCEDURE insertLoadDetail (pPartNo      VARCHAR2,
                               pNsn         VARCHAR2,
                               pPrimeInd    VARCHAR2,
                               pAction      VARCHAR2)
   IS
      aspNsn       amd_spare_parts.nsn%TYPE;
      aspAction    amd_spare_parts.action_code%TYPE;
      anpNsiSid    amd_nsi_parts.nsi_sid%TYPE;
      anNsiSid     amd_nsns.nsi_sid%TYPE;
      anNsn        amd_nsns.nsn%TYPE;
      anNsn2       amd_nsns.nsn%TYPE;
      anNsnType    amd_nsns.nsn_type%TYPE;
      anNsnType2   amd_nsns.nsn_type%TYPE;
      anpPrime     amd_nsi_parts.prime_ind%TYPE;
   BEGIN
      BEGIN
         SELECT anp.prime_ind,
                an.nsn,
                an.nsn_type,
                anp.nsi_sid,
                asp.action_code,
                asp.nsn
           INTO anpPrime,
                anNsn,
                anNsnType,
                anpNsiSid,
                aspAction,
                aspNsn
           FROM amd_spare_parts asp, amd_nsi_parts anp, amd_nsns an
          WHERE     asp.part_no = pPartNo
                AND asp.part_no = anp.part_no
                AND anp.nsi_sid = an.nsi_sid
                AND anp.unassignment_date IS NULL
                AND an.nsn_type = 'C';
      EXCEPTION
         WHEN OTHERS
         THEN
            NULL;
      END;

      BEGIN
         SELECT nsi_sid, nsn, nsn_type
           INTO anNsiSid, anNsn2, anNsnType2
           FROM amd_nsns
          WHERE nsn = pNsn;
      EXCEPTION
         WHEN OTHERS
         THEN
            NULL;
      END;

      amd_utils.InsertErrorMsg (
         pLoad_no        => amd_utils.GetLoadNo (
                              pSourceName   => 'amd_spare_parts_pkg',
                              pTableName    => 'amd_spare_parts'),
         pData_line_no   => 1,
         pData_line      => SUBSTR (
                                 'D: '
                              || pAction
                              || '- Curr View - pPartNo('
                              || pPartNo
                              || ') pNsn('
                              || pNsn
                              || ') pPrimeInd('
                              || pPrimeInd
                              || ') - anNsn('
                              || anNsn
                              || ') anNsnType('
                              || anNsnType
                              || ') aspAction('
                              || aspAction
                              || ') anpPrime('
                              || anpPrime
                              || ') anpNsiSid('
                              || anpNsiSid
                              || ')',
                              1,
                              2000),
         pKey_1          => 'anNsn2(' || anNsiSid || ')',
         pKey_2          => 'anNsnType2(' || anNsnType2 || ')',
         pKey_3          => 'aspNsn(' || aspNsn || ')',
         pKey_4          => 'anNsiSid(' || anNsiSid || ')',
         pKey_5          => '',
         pComments       => TO_CHAR (SYSDATE, 'yyyymmdd hh:mi:ss am'));

      COMMIT;
   END insertLoadDetail;


   PROCEDURE unassociateTmpNsn (pNsn VARCHAR2)
   IS
   BEGIN
      debugMsg ('unassociateTmpNsn(' || pNsn || ')', pError_location => 80);

      -- We do this when a temp nsn now appears in CAT1. This will remove
      -- the association to the current nsn and will set up the process
      -- to create a new nsi_sid for this formerly temp nsn.
      --
      DELETE FROM amd_nsns
            WHERE nsn = pNsn AND nsn_type = 'T';
   END;


   FUNCTION hasPartMoved (pPartNo VARCHAR2, pNsn VARCHAR2)
      RETURN BOOLEAN
   IS
      nsn   amd_nsns.nsn%TYPE;
   BEGIN
      debugMsg ('hasPartMoved(' || pPartNo || ')', pError_location => 90);

      -- A part has moved from one nsn to another if the new and old nsns
      -- appear in tmp_amd_spare_parts at the same time.
      --
      SELECT DISTINCT 'Part has moved.'
        INTO nsn
        FROM tmp_amd_spare_parts
       WHERE nsn =
                (SELECT DISTINCT an.nsn
                   FROM amd_nsi_parts anp, amd_nsns an
                  WHERE     anp.part_no = pPartNo
                        AND anp.nsi_sid = an.nsi_sid
                        AND anp.unassignment_date IS NULL
                        AND an.nsn_type = 'C'
                        AND an.nsn != pNsn)
      UNION
      SELECT 'Part has moved.'
        FROM amd_nsns an, amd_nsi_parts anp
       WHERE     anp.part_no = pPartNo
             AND an.nsi_sid != anp.nsi_sid
             AND anp.unassignment_date IS NULL
             AND an.nsn_type = 'C'
             AND an.nsn = pNsn;

      RETURN TRUE;
   EXCEPTION
      WHEN NO_DATA_FOUND
      THEN
         RETURN FALSE;
   END;


   FUNCTION getFedcCost (pPartNo VARCHAR2)
      RETURN NUMBER
   IS
      CURSOR costCur
      IS
           SELECT gfp_price
             FROM prc1
            WHERE part = pPartNo AND gfp_price IS NOT NULL
         ORDER BY sc DESC;

      fedcCost   NUMBER;
   BEGIN
      debugMsg ('getFedcCost(' || pPartNo || ')', pError_location => 100);

      FOR rec IN costCur
      LOOP
         fedcCost := rec.gfp_price;
         EXIT;
      END LOOP;

      RETURN fedcCost;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'select',
                   pTableName        => 'prcl',
                   pError_location   => 110,
                   pKey_1            => pPartNo);
         RAISE;
   END getFedcCost;



   PROCEDURE unassignPart (pPartNo VARCHAR2)
   IS
   BEGIN
      debugMsg ('unassignPart(' || pPartNo || ')', pError_location => 120);

      UPDATE amd_nsi_parts
         SET unassignment_date = SYSDATE
       WHERE part_no = pPartNo AND unassignment_date IS NULL;
   END unassignPart;


   FUNCTION IsPrimePart (pPrime_ind IN amd_nsi_parts.prime_ind%TYPE)
      RETURN BOOLEAN
   IS
   BEGIN
      debugMsg ('isPrimePart(' || pPrime_ind || ')', pError_location => 130);
      RETURN (UPPER (pPrime_ind) = amd_defaults.PRIME_PART);
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'isPrimeInd',
                   pTableName        => '',
                   pError_location   => 140,
                   pKey_1            => pPrime_ind);
         RAISE;
   END IsPrimePart;



   /* 8/23/02 DSE added ErrorMsg to eliminate some redundant code
    * and to give the error messages a std structure.
    */
   -- 9/3/04 DSE add stronger typing for Source and Table_name + add substr's to make
   -- certain that the key_1 to key_5 never exceed 50 characters
   FUNCTION ErrorMsg (
      pSourceName          IN amd_load_status.SOURCE%TYPE,
      pTableName           IN amd_load_status.TABLE_NAME%TYPE,
      pError_location      IN amd_load_details.DATA_LINE_NO%TYPE,
      pReturn_code         IN NUMBER,
      pPart_no             IN VARCHAR2 := '',
      pNsi_sid             IN VARCHAR2 := '',
      pKeywordValuePairs   IN VARCHAR2 := '',
      pComments            IN VARCHAR2 := '')
      RETURN NUMBER
   IS
      PRAGMA AUTONOMOUS_TRANSACTION;
   BEGIN
      amd_utils.InsertErrorMsg (
         pLoad_no        => amd_utils.GetLoadNo (pSourceName   => pSourceName,
                                                 pTableName    => pTableName),
         pData_line_no   => pError_location,
         pData_line      => 'amd_spare_parts_pkg.' || mArgs,
         pKey_1          => SUBSTR (pPart_no, 1, 50),
         pKey_2          => SUBSTR (pNsi_sid, 1, 50),
         pKey_3          => pKeywordValuePairs,
         pKey_4          => TO_CHAR (pReturn_code),
         pKey_5          => SYSDATE,
         pComments       =>    'sqlcode('
                            || SQLCODE
                            || ') sqlerrm('
                            || SQLERRM
                            || ') '
                            || pComments);

      COMMIT;
      RETURN pReturn_code;
   END;


   PROCEDURE insertNsiParts (
      pNsi_sid             IN amd_nsi_parts.nsi_sid%TYPE,
      pPart_no             IN amd_nsi_parts.part_no%TYPE,
      pPrime_ind           IN amd_nsi_parts.prime_ind%TYPE,
      pPrime_ind_cleaned   IN amd_nsi_parts.prime_ind_cleaned%TYPE,
      pBadRc               IN NUMBER)
   IS
      currDate   DATE := SYSDATE;
   BEGIN
      debugMsg (
            'insertNsiParts('
         || pNsi_sid
         || ','
         || pPart_no
         || ','
         || pPrime_ind
         || ','
         || pPrime_ind_cleaned
         || ','
         || pBadRc
         || ')',
         pError_location   => 150);

      INSERT INTO amd_nsi_parts (nsi_sid,
                                 assignment_date,
                                 part_no,
                                 prime_ind)
           VALUES (pNsi_sid,
                   currDate,
                   pPart_no,
                   pPrime_ind);

      -- This is a safeguard to ensure all other records are unassigned
      UPDATE amd_nsi_parts
         SET unassignment_date = SYSDATE
       WHERE     part_no = pPart_no
             AND unassignment_date IS NULL
             AND assignment_date < currDate;
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
        <<InsertAgainAfterOneSecond>>
         BEGIN
            sleep (1);

            INSERT INTO amd_nsi_parts (nsi_sid,
                                       assignment_date,
                                       part_no,
                                       prime_ind)
                 VALUES (pNsi_sid,
                         SYSDATE,
                         pPart_no,
                         pPrime_ind);
         EXCEPTION
            WHEN OTHERS
            THEN
               mRc := amd_spare_parts_pkg.INSERTAGAIN_ERR + pBadRC;
               ErrorMsg (pSqlfunction      => 'insert',
                         pTableName        => 'amd_nsi_parts',
                         pError_location   => 160,
                         pKey_1            => pPart_no,
                         pKey_2            => TO_CHAR (pNsi_sid),
                         pKey_3            => 'prime_ind=' || pPrime_ind);
               RAISE;
         END InsertAgainAfterOneSecond;
      WHEN OTHERS
      THEN
         mRC := pBadRc;
         ErrorMsg (pSqlfunction      => 'update',
                   pTableName        => 'amd_nsi_parts',
                   pError_location   => 170,
                   pKey_1            => pPart_no);
         RAISE;
   END insertNsiParts;


   /* 8/22/02 DSE added MakeNsnSameForAllParts to eliminate some
    * redundant code.\
    */
   PROCEDURE MakeNsnSameForAllParts (
      pNsi_sid   IN amd_nsi_parts.nsi_sid%TYPE,
      pNsn       IN amd_national_stock_items.nsn%TYPE)
   IS
      TYPE partNoTab IS TABLE OF amd_nsi_parts.PART_NO%TYPE;

      partNos   PartNoTab;

      TYPE nsnTab IS TABLE OF amd_national_stock_items.nsn%TYPE;

      nsns      NsnTab;

      CURSOR partList
      IS
         SELECT part_no, pNsn
           FROM amd_nsi_parts
          WHERE nsi_sid = pNsi_sid AND unassignment_date IS NULL;
   BEGIN
      OPEN partList;

      FETCH partList BULK COLLECT INTO partNos, nsns;

      CLOSE partList;

      IF partNos.FIRST IS NOT NULL
      THEN
         FORALL indx IN partNos.FIRST .. partNos.LAST
            UPDATE amd_spare_parts parts
               SET nsn = nsns (indx)
             WHERE part_no = partNos (indx);
      END IF;

      COMMIT;
   EXCEPTION
      WHEN OTHERS
      THEN
         mRC := amd_spare_parts_pkg.UPD_NSN_SPARE_PARTS_ERR;
         ErrorMsg (pSqlfunction      => 'select',
                   pTableName        => 'amd_nsi_parts',
                   pError_location   => 180,
                   pKey_1            => TO_CHAR (pNsi_sid));
         RAISE;
   END MakeNsnSameForAllParts;


   /*
       For a given nsn if all related parts are marked
       as deleted, then its associated nsn in the
       amd_national_stock_items should be marked as DELETED.
       For a given nsn if any related part is not marked
       DELETED and its associated nsn is marked DELETED,
       then mark the nsn as either INSERTED or UPDATED depending
       on the current action
     */
   PROCEDURE UpdateNatStkItem (pNsn      IN amd_spare_parts.nsn%TYPE,
                               pAction   IN VARCHAR2,
                               pPartNo      VARCHAR2 DEFAULT NULL)
   IS
      nsi_sid   amd_nsi_parts.nsi_sid%TYPE := NULL;

      FUNCTION NumberOfActiveParts
         RETURN NUMBER
      IS
         cnt   NUMBER := 0;
      BEGIN
         SELECT COUNT (*)
           INTO cnt
           FROM amd_nsi_parts nsi, amd_spare_parts parts
          WHERE     nsi.nsi_sid = UpdateNatStkItem.nsi_sid
                AND nsi.part_no = parts.part_no
                AND nsi.unassignment_date IS NULL
                AND parts.action_code != amd_defaults.DELETE_ACTION;

         RETURN cnt;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            NULL;                                                -- do nothing
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'select',
                      pTableName        => 'amd_nsi_parts',
                      pError_location   => 190,
                      pKey_1            => TO_CHAR (UpdateNatStkItem.nsi_sid));
            RAISE;
      END NumberOfActiveParts;


      FUNCTION IsNsnMarkedDeleted
         RETURN BOOLEAN
      IS
         action_code   amd_national_stock_items.action_code%TYPE := NULL;
         result        NUMBER;
      BEGIN
         SELECT action_code
           INTO action_code
           FROM amd_national_stock_items items
          WHERE items.nsi_sid = UpdateNatStkItem.nsi_sid;

         RETURN (action_code = amd_defaults.DELETE_ACTION);
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'select',
                      pTableName        => 'amd_national_stock_items',
                      pError_location   => 200,
                      pKey_1            => TO_CHAR (UpdateNatStkItem.nsi_sid));
            RAISE;
      END IsNsnMarkedDeleted;
   BEGIN                                                   -- UpdateNatStkItem
      debugMsg (
            'UpdateNatStkItem('
         || pNsn
         || ', '
         || pAction
         || ', '
         || pPartNo
         || ')',
         pError_location   => 210);

     <<GetNsiSid>>
      BEGIN
         /*
             use the nsi_sid to get a row from the
             amd_national_stock_items since it is always
             better than the Nsn - even though this Nsn
             should be the current Nsn for the prime part
             and its equivalent parts.
         */
         nsi_sid := amd_utils.GetNsiSid (pNsn => pNsn);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RAISE UNABLE_TO_GET_NSI_SID_EXP;
      END GetNsiSid;

      IF pAction = amd_defaults.DELETE_ACTION
      THEN
        <<numberOfActivePartsGt0>>
         BEGIN
            IF NumberOfActiveParts () = 0
            THEN
               UPDATE amd_national_stock_items
                  SET action_code = amd_defaults.DELETE_ACTION,
                      last_update_dt = SYSDATE
                WHERE nsi_sid = UpdateNatStkItem.nsi_sid;
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (
                  pSqlfunction      => 'update',
                  pTableName        => 'amd_national_stock_items',
                  pError_location   => 220,
                  pKey_1            => TO_CHAR (UpdateNatStkItem.nsi_sid));
               RAISE;
         END numberOfActivePartsGt0;
      ELSE
        /* must be an INSERT_ACTION or an UPDATE_ACTION */
        <<processInsertOrDelete>>
         BEGIN
            IF (NumberOfActiveParts () > 0 AND IsNsnMarkedDeleted ())
            THEN
               UPDATE amd_national_stock_items
                  SET action_code = pAction, last_update_dt = SYSDATE
                WHERE nsi_sid = UpdateNatStkItem.nsi_sid;
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (
                  pSqlfunction      => 'update',
                  pTableName        => 'amd_national_stock_items',
                  pError_location   => 230,
                  pKey_1            => TO_CHAR (UpdateNatStkItem.nsi_sid));
               RAISE;
         END processInsertOrDelete;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         mRC := amd_spare_parts_pkg.UPDT_NATSTKITEM_ERR;
         ErrorMsg (pSqlfunction      => 'updateNatStkItem',
                   pTableName        => 'amd_national_stock_items',
                   pError_location   => 240);
         RAISE;
   END UpdateNatStkItem;


   /* 8/22/02 DSE added UpdtNsiPrimePartData to eliminate some
    * redundant code.
    */
   PROCEDURE UpdtNsiPrimePartData (
      pPrime_ind         IN amd_nsi_parts.prime_ind%TYPE,
      pNsi_sid           IN amd_national_stock_items.nsi_sid%TYPE,
      pPartNo            IN amd_national_stock_items.prime_part_no%TYPE,
      pNsn               IN amd_national_stock_items.nsn%TYPE,
      pItem_type         IN amd_national_stock_items.item_type%TYPE,
      pOrder_quantity    IN amd_national_stock_items.order_quantity%TYPE,
      pPlannerCode       IN amd_national_stock_items.planner_code%TYPE,
      pSmr_code          IN amd_national_stock_items.smr_code%TYPE,
      pMic_code_lowest   IN amd_national_stock_items.mic_code_lowest%TYPE,
      pAction_code       IN amd_national_stock_items.action_code%TYPE,
      pReturn_code       IN NUMBER,
      pMmac              IN amd_national_stock_items.mmac%TYPE)
   IS
      fedcCost   NUMBER;

      PROCEDURE verifyData
      IS
         rec   amd_national_stock_items%ROWTYPE;
         x     NUMBER := 0;
      BEGIN
         debugMsg ('verifyData', pError_location => 250);
         x := x + 1;
         rec.prime_part_no := pPartNo;
         x := x + 1;
         rec.fedc_cost := fedcCost;
         x := x + 1;
         rec.nsn := pNsn;
         x := x + 1;
         rec.item_type := pItem_type;
         x := x + 1;
         rec.order_quantity := pOrder_quantity;
         x := x + 1;
         rec.planner_code := pPlannerCode;
         x := x + 1;
         rec.smr_code := pSmr_Code;
         x := x + 1;
         rec.mic_code_lowest := pMic_code_lowest;
         x := x + 1;
         rec.last_update_dt := SYSDATE;
         x := x + 1;
         rec.mmac := pMmac;
         x := x + 1;
         rec.mtbdr := mMtbdr;
         x := x + 1;
         rec.mtbdr_computed := mMtbdr_computed;
         x := x + 1;
         rec.qpei_weighted := mQpeiWeighted;

         x := x + 1;
         rec.condemn_avg_cleaned := mCondemnAvgCleaned;
         x := x + 1;
         rec.criticality_cleaned := mCriticalityCleaned;
         x := x + 1;
         rec.mtbdr_cleaned := mMtbdrCleaned;
         x := x + 1;
         rec.nrts_avg_cleaned := mNrtsAvgCleaned;
         x := x + 1;
         rec.cost_to_repair_off_base_cleand := mCostToRepairOffBaseCleand;
         x := x + 1;
         rec.time_to_repair_off_base_cleand := mTimeToRepairOffBaseCleand;
         x := x + 1;
         rec.amc_demand := mAmcDemand;
         x := x + 1;
         rec.amc_demand_cleaned := mAmcDemandCleaned;
         x := x + 1;
         rec.wesm_indicator := mWesmIndicator;
         x := x + 1;
         rec.order_lead_time_cleaned := mOrderLeadTimeCleaned;
         x := x + 1;
         rec.planner_code_cleaned := mPlannerCodeCleaned;
         x := x + 1;
         rec.rts_avg_cleaned := mRtsAvgCleaned;
         x := x + 1;
         rec.smr_code_cleaned := mSmrCodeCleaned;
         x := x + 1;
         rec.unit_cost_cleaned := mUnitCostCleaned;
         x := x + 1;
         rec.condemn_avg := mCondemnAvg;
         x := x + 1;
         rec.criticality := mCriticality;
         x := x + 1;
         rec.nrts_avg := mNrtsAvg;
         x := x + 1;
         rec.rts_avg := mRtsAvg;
         x := x + 1;
         rec.cost_to_repair_off_base := mCostToRepairOffBase;
         x := x + 1;
         rec.time_to_repair_off_base := mTimeToRepairOffBase;
         x := x + 1;
         rec.action_code := pAction_code;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'verifyData',
                      pTableName        => 'amd_national_stock_items',
                      pError_location   => 260);
            RAISE;
      END verifyData;

      PROCEDURE doUpdate (planner_code_cleaned   IN VARCHAR2,
                          planner_code           IN VARCHAR2)
      IS
         criticality_changed             amd_national_stock_items.CRITICALITY_CHANGED%TYPE
            := getCriticalityChangedInd (pNsi_sid);
         nrts_avg_changed                amd_national_stock_items.NRTS_AVG_CHANGED%TYPE
                                            := getNrtsAvgChangedInd (pNsi_sid);
         rts_avg_changed                 amd_national_stock_items.RTS_AVG_CHANGED%TYPE
                                            := getRtsAvgChangedInd (pNsi_sid);
         condemn_avg_changed             amd_national_stock_items.CONDEMN_AVG_CHANGED%TYPE
            := getCondemnAvgChangedInd (pNsi_sid);
         cost_to_repair_off_base_chged   amd_national_stock_items.COST_TO_REPAIR_OFF_BASE_CHGED%TYPE
            := getCostToRepairOffBaseChgedInd (pNsi_sid);
         time_to_repair_off_base_chged   amd_national_stock_items.time_to_repair_off_base_chged%TYPE
            := getTimeToRepairOffBaseChgedInd (PNsi_sid);

         PROCEDURE deleteAnyRblPairs
         IS
         BEGIN
            DELETE FROM amd_rbl_pairs
                  WHERE    (    old_nsn IN (SELECT nsn
                                              FROM amd_national_stock_items
                                             WHERE nsi_sid = pNsi_sid)
                            AND old_nsn <> pNsn)
                        OR (    new_nsn IN (SELECT nsn
                                              FROM amd_national_stock_items
                                             WHERE nsi_sid = pNsi_sid)
                            AND new_nsn <> pNsn);
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (pSqlfunction      => 'deleteAnyRblPairs',
                         pTableName        => 'amd_rbl_pairs',
                         pError_location   => 267,
                         pKey_1            => planner_code_cleaned,
                         pKey_2            => planner_code,
                         pKey_3            => TO_CHAR (pNsi_sid));
               RAISE;
         END deleteAnyRblPairs;
      BEGIN
         debugMsg ('doUpdate', pError_location => 270);

         deleteAnyRblPairs;

         UPDATE amd_national_stock_items
            SET criticality_changed = doUpdate.criticality_changed,
                nrts_avg_changed = doUpdate.nrts_avg_changed,
                rts_avg_changed = doUpdate.rts_avg_changed,
                condemn_avg_changed = doUpdate.condemn_avg_changed,
                cost_to_repair_off_base_chged =
                   doUpdate.cost_to_repair_off_base_chged,
                time_to_repair_off_base_chged =
                   doUpdate.time_to_repair_off_base_chged,
                prime_part_no = pPartNo,
                fedc_cost = fedcCost,
                nsn = pNsn,
                item_type = pItem_type,
                order_quantity = pOrder_quantity,
                planner_code = doUpdate.planner_code,
                smr_code = pSmr_code,
                mic_code_lowest = pMic_code_lowest,
                last_update_dt = SYSDATE,
                mmac = pMmac,
                mtbdr = mMtbdr,
                mtbdr_computed = mMtbdr_computed,
                qpei_weighted = mQpeiWeighted,
                condemn_avg_cleaned = mCondemnAvgCleaned,
                criticality_cleaned = mCriticalityCleaned,
                mtbdr_cleaned = mMtbdrCleaned,
                nrts_avg_cleaned = mNrtsAvgCleaned,
                cost_to_repair_off_base_cleand = mCostToRepairOffBaseCleand,
                time_to_repair_off_base_cleand = mTimeToRepairOffBaseCleand,
                amc_demand = mAmcDemand,
                amc_demand_cleaned = mAmcDemandCleaned,
                wesm_indicator = mWesmIndicator,
                order_lead_time_cleaned = mOrderLeadTimeCleaned,
                planner_code_cleaned = doUpdate.planner_code_cleaned,
                rts_avg_cleaned = mRtsAvgCleaned,
                smr_code_cleaned = mSmrCodeCleaned,
                unit_cost_cleaned = mUnitCostCleaned,
                condemn_avg = mCondemnAvg,
                criticality = mCriticality,
                nrts_avg = mNrtsAvg,
                rts_avg = mRtsAvg,
                cost_to_repair_off_base = mCostToRepairOffBase,
                time_to_repair_off_base = mTimeToRepairOffBase,
                action_code = pAction_code
          WHERE nsi_sid = pNsi_sid;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'doUpdate',
                      pTableName        => 'amd_national_stock_items',
                      pError_location   => 275,
                      pKey_1            => planner_code_cleaned,
                      pKey_2            => planner_code,
                      pKey_3            => TO_CHAR (pNsi_sid));
            RAISE;
      END doUpdate;
   BEGIN
      debugMsg ('UpdtNsiPrimePartData', pError_location => 280);

      IF (IsPrimePart (pPrime_ind))
      THEN
         fedcCost := getFedcCost (pPartNo);

         verifyData;


         BEGIN
            doUpdate (planner_code_cleaned   => mPlannerCodeCleaned,
                      planner_code           => pPlannerCode);
         EXCEPTION
            WHEN OTHERS
            THEN
               IF SQLCODE = -2291
               THEN
                 <<constraintError>>
                  DECLARE
                     msg            VARCHAR2 (50);
                     planner_code   amd_planners.planner_code%TYPE;
                  BEGIN
                     -- figurr out which foreign key does not have a parent
                     IF INSTR (SQLERRM, 'FK04') > 0
                     THEN
                        IF amd_utils.isPartConsumable (pPartNo)
                        THEN
                           mPlannerCodeCleaned :=
                              amd_defaults.CONSUMABLE_PLANNER_CODE;
                        ELSIF amd_utils.isPartRepairable (pPartNo)
                        THEN
                           mPlannerCodeCleaned :=
                              amd_defaults.REPAIRABLE_PLANNER_CODE;
                        ELSE
                           mPlannerCodeCleaned := NULL;
                        END IF;

                        doUpdate (
                           planner_code_cleaned   => mPlannerCodeCleaned,
                           planner_code           => pPlannerCode);
                        RETURN;
                     ELSIF INSTR (SQLERRM, 'FK03') > 0
                     THEN
                        IF amd_utils.isPartConsumable (pPartNo)
                        THEN
                           planner_code :=
                              amd_defaults.CONSUMABLE_PLANNER_CODE;
                        ELSIF amd_utils.isPartRepairable (pPartNo)
                        THEN
                           planner_code :=
                              amd_defaults.REPAIRABLE_PLANNER_CODE;
                        ELSE
                           planner_code := NULL;
                        END IF;

                        doUpdate (
                           planner_code_cleaned   => mPlannerCodeCleaned,
                           planner_code           => planner_code);
                        RETURN;
                     ELSIF INSTR (SQLERRM, 'FK02') > 0
                     THEN
                        msg := 'no parent for partNo=' || pPartNo;
                     ELSIF INSTR (SQLERRM, 'FK01') > 0
                     THEN
                        msg := 'no parent for nsn=' || pNsn;
                     ELSE
                        msg := 'Unknown';
                     END IF;

                     mRC := pReturn_code;
                     ErrorMsg (pSqlfunction      => 'UpdtNsiPrimePartData',
                               pTableName        => 'amd_national_stock_items',
                               pError_location   => 290,
                               pKey_1            => pPartNo,
                               pKey_2            => TO_CHAR (pNsi_sid),
                               pKey_3            => msg);
                     RAISE;
                  END constraintError;
               ELSIF SQLCODE = -2292
               THEN
                  DECLARE
                     TYPE bssmrvt_recs_type IS TABLE OF amd_bssm_rvt%ROWTYPE;

                     bssmrvt_recs   bssmrvt_recs_type;
                     cur_nsn        amd_bssm_rvt.nsn%TYPE;

                     CURSOR bssmRvts
                     IS
                        SELECT *
                          FROM amd_bssm_rvt
                         WHERE nsn = cur_nsn;
                  BEGIN
                     SELECT nsn
                       INTO cur_nsn
                       FROM amd_national_stock_items
                      WHERE nsi_sid = pNsi_Sid;

                     OPEN bssmRvts;

                     FETCH bssmRvts BULK COLLECT INTO bssmrvt_recs;

                     CLOSE bssmRvts;

                     IF bssmrvt_recs.COUNT > 0
                     THEN
                        BEGIN
                           FOR indx IN bssmrvt_recs.FIRST ..
                                       bssmrvt_recs.LAST
                           LOOP
                              DELETE amd_bssm_rvt
                               WHERE nsn = bssmrvt_recs (indx).nsn;

                              bssmrvt_recs (indx).nsn := pNsn;
                              bssmrvt_recs (indx).last_update_dt := SYSDATE;
                              bssmrvt_recs (indx).updated_by := USER;
                           END LOOP;
                        EXCEPTION
                           WHEN OTHERS
                           THEN
                              ErrorMsg (
                                 pSqlfunction      => 'fix_amd_bssm_rvt',
                                 pTableName        => 'amd_bssm_rvt',
                                 pError_location   => 292,
                                 pKey_1            => pPartNo,
                                 pKey_2            => TO_CHAR (pNsi_sid),
                                 pKey_3            => 'nsn ' || pNsn);
                              RAISE;
                        END;
                     END IF;

                     BEGIN
                        doUpdate (
                           planner_code_cleaned   => mPlannerCodeCleaned,
                           planner_code           => pPlannerCode);
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           ErrorMsg (
                              pSqlfunction      => 'fix_amd_bssm_rvt',
                              pTableName        => 'amd_bssm_rvt',
                              pError_location   => 294,
                              pKey_1            => pPartNo,
                              pKey_2            => 'nsn ' || pNsn,
                              pKey_3            =>    'plannerCodeCleaned='
                                                   || mPlannerCodeCleaned);
                           RAISE;
                     END;

                     IF bssmrvt_recs.COUNT > 0
                     THEN
                        BEGIN
                           FORALL indx
                               IN bssmrvt_recs.FIRST .. bssmrvt_recs.LAST
                              INSERT INTO amd_bssm_rvt
                                   VALUES bssmrvt_recs (indx);
                        EXCEPTION
                           WHEN OTHERS
                           THEN
                              ErrorMsg (
                                 pSqlfunction      => 'fix_amd_bssm_rvt',
                                 pTableName        => 'amd_bssm_rvt',
                                 pError_location   => 296,
                                 pKey_1            => pPartNo,
                                 pKey_2            => 'nsn ' || pNsn,
                                 pKey_3            =>    'plannerCodeCleaned='
                                                      || mPlannerCodeCleaned);
                              RAISE;
                        END;
                     END IF;
                  EXCEPTION
                     WHEN OTHERS
                     THEN
                        ErrorMsg (
                           pSqlfunction      => 'fix_amd_bssm_rvt',
                           pTableName        => 'amd_bssm_rvt',
                           pError_location   => 298,
                           pKey_1            => pPartNo,
                           pKey_2            => TO_CHAR (pNsi_sid),
                           pKey_3            =>    'plannerCodeCleaned='
                                                || mPlannerCodeCleaned);
                        RAISE;
                  END fix_amd_bssm_rvt;
               ELSE
                  mRC := pReturn_code;
                  ErrorMsg (
                     pSqlfunction      => 'UpdtNsiPrimePartData',
                     pTableName        => 'amd_national_stock_items',
                     pError_location   => 300,
                     pKey_1            => pPartNo,
                     pKey_2            => TO_CHAR (pNsi_sid),
                     pKey_3            =>    'plannerCodeCleaned='
                                          || mPlannerCodeCleaned);
                  RAISE;
               END IF;
         END;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         mRC := pReturn_code;
         ErrorMsg (pSqlfunction      => 'UpdtNsiPrimePartData',
                   pTableName        => 'amd_national_stock_items',
                   pError_location   => 310,
                   pKey_1            => pPartNo,
                   pKey_2            => TO_CHAR (pNsi_sid),
                   pKey_3            => 'nsn=' || pNsn);
         RAISE;
   END UpdtNsiPrimePartData;


   PROCEDURE InsertNatStkItem (
      pNsi_sid              OUT amd_national_stock_items.nsi_sid%TYPE,
      pNsn               IN     amd_spare_parts.nsn%TYPE,
      pItem_type         IN     amd_national_stock_items.item_type%TYPE,
      pOrder_quantity    IN     amd_national_stock_items.order_quantity%TYPE,
      pPlanner_code      IN     amd_national_stock_items.planner_code%TYPE,
      pSmr_code          IN     amd_national_stock_items.smr_code%TYPE,
      pTactical          IN     amd_national_stock_items.tactical%TYPE,
      pMic_code_lowest   IN     amd_national_stock_items.mic_code_lowest%TYPE,
      pMmac              IN     amd_national_stock_items.mmac%TYPE)
   IS
      nsiGroupSid   NUMBER;

      FUNCTION GetNsiSid
         RETURN amd_national_stock_items.nsi_sid%TYPE
      IS
         nsi_sid   amd_national_stock_items.nsi_sid%TYPE := NULL;
      BEGIN
         SELECT amd_nsi_sid_seq.CURRVAL INTO nsi_sid FROM DUAL;

         RETURN nsi_sid;
      END GetNsiSid;
   BEGIN                                                   -- InsertNatStkItem
      debugMsg ('InsertNatStkItem', pError_location => 320);
      nsiGroupSid := amd_default_effectivity_pkg.NewGroup;

      BEGIN
         INSERT
           INTO AMD_NATIONAL_STOCK_ITEMS (nsn,
                                          add_increment_cleaned,
                                          amc_base_stock_cleaned,
                                          amc_days_experience_cleaned,
                                          amc_demand,
                                          amc_demand_cleaned,
                                          capability_requirement_cleaned,
                                          criticality_cleaned,
                                          distrib_uom_defaulted,
                                          dla_demand_cleaned,
                                          current_backorder_cleaned,
                                          fedc_cost_cleaned,
                                          item_type,
                                          item_type_cleaned,
                                          mic_code_lowest_cleaned,
                                          mtbdr_cleaned,
                                          nomenclature_cleaned,
                                          order_lead_time_cleaned,
                                          order_quantity,
                                          order_quantity_defaulted,
                                          order_uom_cleaned,
                                          planner_code,
                                          planner_code_cleaned,
                                          prime_part_no,
                                          qpei_weighted_defaulted,
                                          ru_ind_cleaned,
                                          smr_code,
                                          smr_code_cleaned,
                                          unit_cost_cleaned,
                                          condemn_avg_defaulted,
                                          condemn_avg_cleaned,
                                          nrts_avg_defaulted,
                                          nrts_avg_cleaned,
                                          rts_avg_defaulted,
                                          rts_avg_cleaned,
                                          cost_to_repair_off_base_cleand,
                                          time_to_repair_off_base_cleand,
                                          time_to_repair_on_base_avg_df,
                                          time_to_repair_on_base_avg_cl,
                                          tactical,
                                          action_code,
                                          last_update_dt,
                                          mic_code_lowest,
                                          nsi_group_sid,
                                          latest_config,
                                          effect_by,
                                          mmac,
                                          mtbdr,
                                          mtbdr_computed,
                                          qpei_weighted,
                                          criticality,
                                          nrts_avg,
                                          rts_avg,
                                          cost_to_repair_off_base,
                                          time_to_repair_off_base,
                                          wesm_indicator)
         VALUES (NULL,                                                  -- nsn
                 Amd_Clean_Data.GetAddIncrement (pNsn),
                 Amd_Clean_Data.GetAmcBaseStock (pNsn),
                 Amd_Clean_Data.GetAmcDaysExperience (pNsn),
                 mAmcDemand,
                 mAmcDemandCleaned,
                 Amd_Clean_Data.GetCapabilityRequirement (pNsn),
                 mCriticalityCleaned,
                 Amd_Defaults.DISTRIB_UOM,
                 Amd_Clean_Data.GetDlaDemand (pNsn),
                 Amd_Clean_Data.GetCurrentBackorder (pNsn),
                 Amd_Clean_Data.GetFedcCost (pNsn),
                 pItem_type,
                 Amd_Clean_Data.GetItemType (pNsn),
                 Amd_Clean_Data.GetMicCodeLowest (pNsn),
                 mMtbdrCleaned,
                 Amd_Clean_Data.GetNomenclature (pNsn),
                 mOrderLeadTimeCleaned,
                 pOrder_Quantity,
                 Amd_Defaults.ORDER_QUANTITY,
                 Amd_Clean_Data.GetOrderUom (pNsn),
                 pPlanner_code,
                 mPlannerCodeCleaned,
                 NULL,                                        -- prime_part_no
                 Amd_Defaults.QPEI_WEIGHTED,
                 Amd_Clean_Data.GetRuInd (pNsn),
                 pSmr_code,
                 mSmrCodeCleaned,
                 mUnitCostCleaned,
                 mCondemnAvg,
                 mCondemnAvgCleaned,
                 Amd_Defaults.NRTS_AVG,
                 mNrtsAvgCleaned,
                 Amd_Defaults.RTS_AVG,
                 mRtsAvgCleaned,
                 mCostToRepairOffBaseCleand,
                 mTimeToRepairOffBaseCleand,
                 Amd_Defaults.TIME_TO_REPAIR_ONBASE,
                 Amd_Clean_Data.GetTimeToRepairOnBaseAvg (pNsn),
                 pTactical,
                 Amd_Defaults.INSERT_ACTION,
                 SYSDATE,
                 pMic_code_lowest,
                 nsiGroupSid,
                 'Y',
                 'S',
                 pMmac,
                 mMtbdr,
                 mMtbdr_computed,
                 mQpeiWeighted,
                 mCriticality,
                 mNrtsAvg,
                 mRtsAvg,
                 mCostToRepairOffBase,
                 mTimeToRepairOffBase,
                 mWesmIndicator);
      EXCEPTION
         WHEN OTHERS
         THEN
            mRC := amd_spare_parts_pkg.CREATE_NATSTKITEM_ERR;
            ErrorMsg (pSqlfunction      => 'insert',
                      pTableName        => 'amd_national_stock_items',
                      pError_location   => 330);
            RAISE;
      END InsertNsi;

      pNsi_sid := GetNsiSid ();
   EXCEPTION
      WHEN OTHERS
      THEN
         mRC := amd_spare_parts_pkg.CREATE_NATSTKITEM_ERR;
         ErrorMsg (pSqlfunction      => 'insert',
                   pTableName        => 'amd_nsi_groups',
                   pError_location   => 340);
         RAISE;
   END InsertNatStkItem;


   PROCEDURE ChgCurNsn2TempNsn (pNsiSid IN amd_nsns.nsi_sid%TYPE)
   IS
   BEGIN
      debugMsg ('ChgCurNsn2TempNsn(' || pNsiSid || ')',
                pError_location   => 350);

      UPDATE amd_nsns
         SET nsn_type = amd_spare_parts_pkg.TEMPORARY_NSN
       WHERE nsi_sid = pNsiSid AND nsn_type = amd_spare_parts_pkg.CURRENT_NSN;
   EXCEPTION
      WHEN OTHERS
      THEN
         mRC := amd_spare_parts_pkg.UNABLE_TO_CHG_NSN_TYPE;
         ErrorMsg (pSqlfunction      => 'update',
                   pTableName        => 'amd_nsns',
                   pError_location   => 360,
                   pKey_1            => TO_CHAR (pNsiSid));
         RAISE;
   END ChgCurNsn2TempNsn;


   PROCEDURE InsertAmdNsn (pNsi_sid    IN amd_nsns.nsi_sid%TYPE,
                           pNsn        IN amd_nsns.nsn%TYPE,
                           pNsn_type   IN amd_nsns.nsn_type%TYPE)
   IS
   BEGIN
      debugMsg (
         'InsertAmdNsn(' || pNsi_sid || ', ' || pNsn || ', ' || pNsn_type,
         pError_location   => 370);

      IF pNsn_type = amd_spare_parts_pkg.CURRENT_NSN
      THEN
         ChgCurNsn2TempNsn (pNsiSid => pNsi_sid);
      END IF;

      INSERT INTO amd_nsns (nsn,
                            nsn_type,
                            nsi_sid,
                            creation_date)
           VALUES (pNsn,
                   pNsn_type,
                   pNsi_sid,
                   SYSDATE);
   EXCEPTION
      WHEN OTHERS
      THEN
         mRC := amd_spare_parts_pkg.UNABLE_TO_INSERT_AMD_NSNS;
         ErrorMsg (pSqlfunction      => 'insert',
                   pTableName        => 'amd_nsns',
                   pError_location   => 380,
                   pKey_1            => TO_CHAR (pNsi_Sid),
                   pKey_2            => pNsn,
                   pKey_3            => pNsn_type);
         RAISE;
   END InsertAmdNsn;


   PROCEDURE UpdateAmdNsn (pNsi_sid    IN amd_nsns.nsi_sid%TYPE,
                           pNsn        IN amd_nsns.nsn%TYPE,
                           pNsn_type   IN amd_nsns.nsn_type%TYPE)
   IS
   BEGIN
      debugMsg (
            'UpdateAmdNsn('
         || pNsi_sid
         || ', '
         || pNsn
         || ', '
         || pNsn_type
         || ')',
         pError_location   => 390);

      IF pNsn_type = amd_spare_parts_pkg.CURRENT_NSN
      THEN
         ChgCurNsn2TempNsn (pNsiSid => pNsi_sid);
      END IF;

      UPDATE amd_nsns
         SET nsn_type = pNsn_type
       WHERE nsi_sid = pNsi_sid AND nsn = pNsn;
   EXCEPTION
      WHEN OTHERS
      THEN
         mRC := amd_spare_parts_pkg.UNABLE_TO_INSERT_AMD_NSNS;
         ErrorMsg (pSqlfunction      => 'update',
                   pTableName        => 'amd_nsns',
                   pError_location   => 400,
                   pKey_1            => TO_CHAR (pNsi_Sid),
                   pKey_2            => pNsn);
         RAISE;
   END UpdateAmdNsn;


   PROCEDURE CreateNationalStockItem (
      pNsi_sid              OUT amd_national_stock_items.nsi_sid%TYPE,
      pNsn               IN     amd_spare_parts.nsn%TYPE,
      pItem_type         IN     amd_national_stock_items.item_type%TYPE,
      pOrder_quantity    IN     amd_national_stock_items.order_quantity%TYPE,
      pPlanner_code      IN     amd_national_stock_items.planner_code%TYPE,
      pSmr_code          IN     amd_national_stock_items.smr_code%TYPE,
      pTactical          IN     amd_national_stock_items.tactical%TYPE,
      pMic_code_lowest   IN     amd_national_stock_items.mic_code_lowest%TYPE,
      pNsn_type          IN     amd_nsns.nsn_type%TYPE,
      pMmac              IN     amd_national_stock_items.mmac%TYPE)
   IS
      result   NUMBER := SUCCESS;
   BEGIN
      InsertNatStkItem (pNsi_sid           => pNsi_sid,
                        pNsn               => pNsn,
                        pItem_type         => pItem_type,
                        pOrder_quantity    => pOrder_quantity,
                        pPlanner_code      => pPlanner_code,
                        pSmr_code          => pSmr_code,
                        pTactical          => pTactical,
                        pMic_code_lowest   => pMic_code_lowest,
                        pMmac              => pMmac);

      amd_default_effectivity_pkg.SetNsiEffects (pNsi_sid);

      IF pNsn_type = amd_spare_parts_pkg.CURRENT_NSN
      THEN
         amd_spare_parts_pkg.ChgCurNsn2TempNsn (pNsiSid => pNsi_sid);
      END IF;

      InsertAmdNsn (pNsi_sid => pNsi_sid, pNsn => pNsn, pNsn_type => pNsn_type);
   END CreateNationalStockItem;

   -- forward declare the old insertRow method, which is now private, so it can be used in
   -- the new public insertRow method
   FUNCTION InsertRow (pPart_no                   IN VARCHAR2,
                       pMfgr                      IN VARCHAR2,
                       pDate_icp                  IN DATE,
                       pDisposal_cost             IN NUMBER,
                       pErc                       IN VARCHAR2,
                       pIcp_ind                   IN VARCHAR2,
                       pNomenclature              IN VARCHAR2,
                       pOrder_lead_time           IN NUMBER,
                       pOrder_quantity            IN NUMBER,
                       pOrder_uom                 IN VARCHAR2,
                       pPrime_ind                 IN VARCHAR2,
                       pScrap_value               IN NUMBER,
                       pSerial_flag               IN VARCHAR2,
                       pShelf_life                IN NUMBER,
                       pUnit_cost                 IN NUMBER,
                       pUnit_volume               IN NUMBER,
                       pNsn                       IN VARCHAR2,
                       pNsn_type                  IN VARCHAR2,
                       pItem_type                 IN VARCHAR2,
                       pSmr_code                  IN VARCHAR2,
                       pPlanner_code              IN VARCHAR2,
                       pMic_code_lowest           IN VARCHAR2,
                       pAcquisition_advice_code   IN VARCHAR2,
                       pMmac                      IN VARCHAR2,
                       pUnitOfIssue               IN VARCHAR2)
      RETURN NUMBER;

   FUNCTION InsertRow (
      pPart_no                     IN VARCHAR2,
      pMfgr                        IN VARCHAR2,
      pDate_icp                    IN DATE,
      pDisposal_cost               IN NUMBER,
      pErc                         IN VARCHAR2,
      pIcp_ind                     IN VARCHAR2,
      pNomenclature                IN VARCHAR2,
      pOrder_lead_time             IN NUMBER,
      pOrder_quantity              IN NUMBER,
      pOrder_uom                   IN VARCHAR2,
      pPrime_ind                   IN VARCHAR2,
      pScrap_value                 IN NUMBER,
      pSerial_flag                 IN VARCHAR2,
      pShelf_life                  IN NUMBER,
      pUnit_cost                   IN NUMBER,
      pUnit_volume                 IN NUMBER,
      pNsn                         IN VARCHAR2,
      pNsn_type                    IN VARCHAR2,
      pItem_type                   IN VARCHAR2,
      pSmr_code                    IN VARCHAR2,
      pPlanner_code                IN VARCHAR2,
      pMic_code_lowest             IN VARCHAR2,
      pAcquisition_advice_code     IN VARCHAR2,
      pMmac                        IN VARCHAR2,
      pUnitOfIssue                 IN VARCHAR2,
      pMtbdr                       IN NUMBER,
      pMtbdr_computed              IN NUMBER,
      pQpeiWeighted                IN NUMBER,
      pCondemnAvgCleaned           IN NUMBER,
      pCriticalityCleaned          IN NUMBER,
      pMtbdrCleaned                IN NUMBER,
      pNrtsAvgCleaned              IN NUMBER,
      pCosToRepairOffBaseCleand    IN NUMBER,
      pTimeToRepairOffBaseCleand   IN NUMBER,
      pOrderLeadTimeCleaned        IN NUMBER,
      pPlannerCodeCleaned          IN amd_national_stock_items.planner_code_cleaned%TYPE,
      pRtsAvgCleaned               IN NUMBER,
      pSmrCodeCleaned              IN amd_national_stock_items.smr_code_cleaned%TYPE,
      pUnitCostCleaned             IN NUMBER,
      pCondemnAvg                  IN NUMBER,
      pCriticality                 IN NUMBER,
      pNrtsAvg                     IN NUMBER,
      pRtsAvg                      IN NUMBER,
      pCostToRepairOffBase         IN NUMBER,
      pTimeToRepairOffBase         IN NUMBER,
      pAmcDemand                   IN NUMBER,
      pAmcDemandCleaned            IN NUMBER,
      pWesmIndicator               IN VARCHAR2)
      RETURN NUMBER
   IS
   BEGIN
      -- By overriding the insertRow and updateRow routines all that needs to be done
      -- is to set the member variables to the values passed in and then invoke
      -- the old insertRow method, which is now private, That way I don't have to pass parameters just get the data
      -- from these global member variables.
      mArgs :=
            'insertRow('
         || pPart_no
         || ', '
         || pMfgr
         || ', '
         || pDate_icp
         || ', '
         || pDisposal_cost
         || ', '
         || pErc
         || ', '
         || pIcp_ind
         || ', '
         || pNomenclature
         || ', '
         || pOrder_lead_time
         || ', '
         || pOrder_quantity
         || ', '
         || pOrder_uom
         || ', '
         || pPrime_ind
         || ', '
         || pScrap_value
         || ', '
         || pSerial_flag
         || ', '
         || pShelf_life
         || ', '
         || pUnit_cost
         || ', '
         || pUnit_volume
         || ', '
         || pNsn
         || ', '
         || pNsn_type
         || ', '
         || pItem_type
         || ', '
         || pSmr_code
         || ', '
         || pPlanner_code
         || ', '
         || pMic_code_lowest
         || ', '
         || pAcquisition_advice_code
         || ', '
         || pMmac
         || ', '
         || pUnitOfIssue
         || ', '
         || pMtbdr
         || ', '
         || pMtbdr_computed
         || ', '
         || pQpeiWeighted
         || ', '
         || pCondemnAvgCleaned
         || ', '
         || pCriticalityCleaned
         || ', '
         || pMtbdrCleaned
         || ', '
         || pNrtsAvgCleaned
         || ', '
         || pCosToRepairOffBaseCleand
         || ', '
         || pTimeToRepairOffBaseCleand
         || ', '
         || pOrderLeadTimeCleaned
         || ', '
         || pPlannerCodeCleaned
         || ', '
         || pRtsAvgCleaned
         || ', '
         || pSmrCodeCleaned
         || ', '
         || pUnitCostCleaned
         || ', '
         || pCondemnAvg
         || ', '
         || pCriticality
         || ', '
         || pNrtsAvg
         || ', '
         || pRtsAvg
         || ', '
         || pAmcDemand
         || ', '
         || pAmcDemandCleaned
         || ','
         || pWesmIndicator
         || ')';
      mMtbdr := pMtbdr;
      mMtbdr_computed := pMtbdr_computed;
      mQpeiWeighted := pQpeiWeighted;
      mCondemnAvgCleaned := pCondemnAvgCleaned;
      mCriticalityCleaned := pCriticalityCleaned;
      mMtbdrCleaned := pMtbdrCleaned;
      mNrtsAvgCleaned := pNrtsAvgCleaned;
      mCostToRepairOffBaseCleand := pCosToRepairOffBaseCleand;
      mTimeToRepairOffBaseCleand := pTimeToRepairOffBaseCleand;
      mAmcDemand := pAmcDemand;
      mAmcDemandCleaned := pAmcDemandCleaned;
      mWesmIndicator := pWesmIndicator;
      mOrderLeadTimeCleaned := pOrderLeadTimeCleaned;
      mPlannerCodeCleaned := pPlannerCodeCleaned;
      mRtsAvgCleaned := pRtsAvgCleaned;
      mSmrCodeCleaned := pSmrCodeCleaned;
      mUnitCostCleaned := pUnitCostCleaned;
      mCondemnAvg := pCondemnAvg;
      mCriticality := pCriticality;
      mNrtsAvg := pNrtsAvg;
      mRtsAvg := pRtsAvg;
      mCostToRepairOffBase := pCostToRepairOffBase;
      mTimeToRepairOffBase := pTimeToRepairOffBase;

      RETURN InsertRow (pPart_no,
                        pMfgr,
                        pDate_icp,
                        pDisposal_cost,
                        pErc,
                        pIcp_ind,
                        pNomenclature,
                        pOrder_lead_time,
                        pOrder_quantity,
                        pOrder_uom,
                        pPrime_ind,
                        pScrap_value,
                        pSerial_flag,
                        pShelf_life,
                        pUnit_cost,
                        pUnit_volume,
                        pNsn,
                        pNsn_type,
                        pItem_type,
                        pSmr_code,
                        pPlanner_code,
                        pMic_code_lowest,
                        pAcquisition_advice_code,
                        pMmac,
                        pUnitOfIssue);
   END InsertRow;

   -- forward declare the old updateRow method, which is now private, so it can be used in
   -- the new public updateRow method
   FUNCTION UpdateRow (pPart_no                   IN VARCHAR2,
                       pMfgr                      IN VARCHAR2,
                       pDate_icp                  IN DATE,
                       pDisposal_cost             IN NUMBER,
                       pErc                       IN VARCHAR2,
                       pIcp_ind                   IN VARCHAR2,
                       pNomenclature              IN VARCHAR2,
                       pOrder_lead_time           IN NUMBER,
                       pOrder_quantity            IN NUMBER,
                       pOrder_uom                 IN VARCHAR2,
                       pPrime_ind                 IN VARCHAR2,
                       pScrap_value               IN NUMBER,
                       pSerial_flag               IN VARCHAR2,
                       pShelf_life                IN NUMBER,
                       pUnit_cost                 IN NUMBER,
                       pUnit_volume               IN NUMBER,
                       pNsn                       IN VARCHAR2,
                       pNsn_type                  IN VARCHAR2,
                       pItem_type                 IN VARCHAR2,
                       pSmr_code                  IN VARCHAR2,
                       pPlanner_code              IN VARCHAR2,
                       pMic_code_lowest           IN VARCHAR2,
                       pAcquisition_advice_code   IN VARCHAR2,
                       pMmac                      IN VARCHAR2,
                       pUnitOfIssue               IN VARCHAR2)
      RETURN NUMBER;

   FUNCTION UpdateRow (
      pPart_no                     IN VARCHAR2,
      pMfgr                        IN VARCHAR2,
      pDate_icp                    IN DATE,
      pDisposal_cost               IN NUMBER,
      pErc                         IN VARCHAR2,
      pIcp_ind                     IN VARCHAR2,
      pNomenclature                IN VARCHAR2,
      pOrder_lead_time             IN NUMBER,
      pOrder_quantity              IN NUMBER,
      pOrder_uom                   IN VARCHAR2,
      pPrime_ind                   IN VARCHAR2,
      pScrap_value                 IN NUMBER,
      pSerial_flag                 IN VARCHAR2,
      pShelf_life                  IN NUMBER,
      pUnit_cost                   IN NUMBER,
      pUnit_volume                 IN NUMBER,
      pNsn                         IN VARCHAR2,
      pNsn_type                    IN VARCHAR2,
      pItem_type                   IN VARCHAR2,
      pSmr_code                    IN VARCHAR2,
      pPlanner_code                IN VARCHAR2,
      pMic_code_lowest             IN VARCHAR2,
      pAcquisition_advice_code     IN VARCHAR2,
      pMmac                        IN VARCHAR2,
      pUnitOfIssue                 IN VARCHAR2,
      pMtbdr                       IN NUMBER,
      pMtbdr_computed              IN NUMBER,
      pQpeiWeighted                IN NUMBER,
      pCondemnAvgCleaned           IN NUMBER,
      pCriticalityCleaned          IN NUMBER,
      pMtbdrCleaned                IN NUMBER,
      pNrtsAvgCleaned              IN NUMBER,
      pCosToRepairOffBaseCleand    IN NUMBER,
      pTimeToRepairOffBaseCleand   IN NUMBER,
      pOrderLeadTimeCleaned        IN NUMBER,
      pPlannerCodeCleaned          IN amd_national_stock_items.planner_code_cleaned%TYPE,
      pRtsAvgCleaned               IN NUMBER,
      pSmrCodeCleaned              IN amd_national_stock_items.smr_code_cleaned%TYPE,
      pUnitCostCleaned             IN NUMBER,
      pCondemnAvg                  IN NUMBER,
      pCriticality                 IN NUMBER,
      pNrtsAvg                     IN NUMBER,
      pRtsAvg                      IN NUMBER,
      pCostToRepairOffBase         IN NUMBER,
      pTimeToRepairOffBase         IN NUMBER,
      pAmcDemand                   IN NUMBER,
      pAmcDemandCleaned            IN NUMBER,
      pWesmIndicator               IN VARCHAR2)
      RETURN NUMBER
   IS
      lineNo   NUMBER := 0;
      result   NUMBER;
   BEGIN
      -- By overriding the updateRow andinsertRow routines all that needs to be done
      -- is to set the member variables to the values passed in and then invoke
      -- the old updateRow method, which is now private, That way I don't have to pass parameters just get the data
      -- from these global member variables.
      mArgs :=
            'UpdateRow('
         || pPart_no
         || ', '
         || pMfgr
         || ', '
         || pDate_icp
         || ', '
         || pDisposal_cost
         || ', '
         || pErc
         || ', '
         || pIcp_ind
         || ', '
         || pNomenclature
         || ', '
         || pOrder_lead_time
         || ', '
         || pOrder_quantity
         || ', '
         || pOrder_uom
         || ', '
         || pPrime_ind
         || ', '
         || pScrap_value
         || ', '
         || pSerial_flag
         || ', '
         || pShelf_life
         || ', '
         || pUnit_cost
         || ', '
         || pUnit_volume
         || ', '
         || pNsn
         || ', '
         || pNsn_type
         || ', '
         || pItem_type
         || ', '
         || pSmr_code
         || ', '
         || pPlanner_code
         || ', '
         || pMic_code_lowest
         || ', '
         || pAcquisition_advice_code
         || ', '
         || pMmac
         || ', '
         || pUnitOfIssue
         || ', '
         || pMtbdr
         || ', '
         || pMtbdr_computed
         || ', '
         || pQpeiWeighted
         || ', '
         || pCondemnAvgCleaned
         || ', '
         || pCriticalityCleaned
         || ', '
         || pMtbdrCleaned
         || ', '
         || pNrtsAvgCleaned
         || ', '
         || pCosToRepairOffBaseCleand
         || ', '
         || pTimeToRepairOffBaseCleand
         || ', '
         || pOrderLeadTimeCleaned
         || ', '
         || pPlannerCodeCleaned
         || ', '
         || pRtsAvgCleaned
         || ', '
         || pSmrCodeCleaned
         || ', '
         || pUnitCostCleaned
         || ', '
         || pCondemnAvg
         || ', '
         || pCriticality
         || ', '
         || pNrtsAvg
         || ', '
         || pRtsAvg
         || ', '
         || pCostToRepairOffBase
         || ', '
         || pTimeToRepairOffBase
         || ', '
         || pAmcDemand
         || ', '
         || pAmcDemandCleaned
         || ')';
      lineNo := lineNo + 1;
      mMtbdr := pMtbdr;
      lineNo := lineNo + 1;
      mMtbdr_computed := pMtbdr_computed;
      lineNo := lineNo + 1;
      mQpeiWeighted := pQpeiWeighted;
      lineNo := lineNo + 1;
      mCondemnAvgCleaned := pCondemnAvgCleaned;
      lineNo := lineNo + 1;
      mCriticalityCleaned := pCriticalityCleaned;
      lineNo := lineNo + 1;
      mMtbdrCleaned := pMtbdrCleaned;
      lineNo := lineNo + 1;
      mNrtsAvgCleaned := pNrtsAvgCleaned;
      lineNo := lineNo + 1;
      mCostToRepairOffBaseCleand := pCosToRepairOffBaseCleand;
      lineNo := lineNo + 1;
      mTimeToRepairOffBaseCleand := pTimeToRepairOffBaseCleand;
      lineNo := lineNo + 1;
      mAmcDemand := pAmcDemand;
      lineNo := lineNo + 1;
      mAmcDemandCleaned := pAmcDemandCleaned;
      lineNo := lineNo + 1;
      mWesmIndicator := pWesmIndicator;
      lineNo := lineNo + 1;
      mOrderLeadTimeCleaned := pOrderLeadTimeCleaned;
      lineNo := lineNo + 1;
      mPlannerCodeCleaned := pPlannerCodeCleaned;
      lineNo := lineNo + 1;
      mRtsAvgCleaned := pRtsAvgCleaned;
      lineNo := lineNo + 1;
      mSmrCodeCleaned := pSmrCodeCleaned;
      lineNo := lineNo + 1;
      mUnitCostCleaned := pUnitCostCleaned;
      lineNo := lineNo + 1;
      mCondemnAvg := pCondemnAvg;
      lineNo := lineNo + 1;
      mCriticality := pCriticality;
      lineNo := lineNo + 1;
      mNrtsAvg := pNrtsAvg;
      lineNo := lineNo + 1;
      mRtsAvg := pRtsAvg;
      lineNo := lineNo + 1;
      mCostToRepairOffBase := pCostToRepairOffBase;
      lineNo := lineNo + 1;
      mTimeToRepairOffBase := pTimeToRepairOffBase;

      RETURN UpdateRow (pPart_no,
                        pMfgr,
                        pDate_icp,
                        pDisposal_cost,
                        pErc,
                        pIcp_ind,
                        pNomenclature,
                        pOrder_lead_time,
                        pOrder_quantity,
                        pOrder_uom,
                        pPrime_ind,
                        pScrap_value,
                        pSerial_flag,
                        pShelf_life,
                        pUnit_cost,
                        pUnit_volume,
                        pNsn,
                        pNsn_type,
                        pItem_type,
                        pSmr_code,
                        pPlanner_code,
                        pMic_code_lowest,
                        pAcquisition_advice_code,
                        pMmac,
                        pUnitOfIssue);
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'updateRow',
                   pTableName        => '',
                   pError_location   => 410);
         RETURN UPDT_ERRX;
   END UpdateRow;

   FUNCTION InsertRow (pPart_no                   IN VARCHAR2,
                       pMfgr                      IN VARCHAR2,
                       pDate_icp                  IN DATE,
                       pDisposal_cost             IN NUMBER,
                       pErc                       IN VARCHAR2,
                       pIcp_ind                   IN VARCHAR2,
                       pNomenclature              IN VARCHAR2,
                       pOrder_lead_time           IN NUMBER,
                       pOrder_quantity            IN NUMBER,
                       pOrder_uom                 IN VARCHAR2,
                       pPrime_ind                 IN VARCHAR2,
                       pScrap_value               IN NUMBER,
                       pSerial_flag               IN VARCHAR2,
                       pShelf_life                IN NUMBER,
                       pUnit_cost                 IN NUMBER,
                       pUnit_volume               IN NUMBER,
                       pNsn                       IN VARCHAR2,
                       pNsn_type                  IN VARCHAR2,
                       pItem_type                 IN VARCHAR2,
                       pSmr_code                  IN VARCHAR2,
                       pPlanner_code              IN VARCHAR2,
                       pMic_code_lowest           IN VARCHAR2,
                       pAcquisition_advice_code   IN VARCHAR2,
                       pMmac                      IN VARCHAR2,
                       pUnitOfIssue               IN VARCHAR2)
      RETURN NUMBER
   IS
      /* Although the following variables are local to the InsertRow
        procedure, you will see them referenced as InsertRow.variable_name.
        This was done to improve readability.  A similar approach is used
        for package constants: package_name.constant_name.
       */
      prime_ind_cleaned     amd_nsi_parts.prime_ind_cleaned%TYPE := NULL;
      result                NUMBER := SUCCESS;
      tactical              amd_spare_parts.tactical%TYPE := 'N';
      unit_cost_defaulted   amd_spare_parts.unit_cost_defaulted%TYPE := NULL;
      part_already_exists   EXCEPTION;
      is_spo_part           amd_spare_parts.is_spo_part%TYPE;


      /* Put a wrapper on the amd_utils.InsertErrorMsg procedure, so it is
          more specific to the InsertRow function.  Output gets stored
          into amd_load_details and amd_load_status.
      */

      PROCEDURE InsertAmdNsiParts (pNsi_sid IN amd_nsi_parts.nsi_sid%TYPE)
      IS
      BEGIN
         insertNsiParts (
            pNsi_sid             => pNsi_sid,
            pPart_no             => pPart_no,
            pPrime_ind           => pPrime_ind,
            pPrime_ind_cleaned   => prime_ind_cleaned,
            pBadRc               => amd_spare_parts_pkg.UNABLE_TO_INSERT_AMD_NSI_PARTS);
      EXCEPTION
         WHEN OTHERS
         THEN
            mRC := INS_AMD_NSI_PARTS_ERR;
            ErrorMsg (pSqlfunction      => 'insert',
                      pTableName        => 'amd_nsi_parts',
                      pError_location   => 420,
                      pKey_1            => TO_CHAR (pNsi_sid));
            RAISE;
      END InsertAmdNsiParts;


      PROCEDURE InsertEquivalentPartData (
         pNsi_sid   IN amd_nsi_parts.nsi_sid%TYPE)
      IS
      BEGIN
         InsertAmdNsiParts (pNsi_sid);
      EXCEPTION
         WHEN OTHERS
         THEN
            mRC := INS_AMD_NSI_PARTS_ERR;
            ErrorMsg (pSqlfunction      => 'insert',
                      pTableName        => 'amd_nsi_parts',
                      pError_location   => 430,
                      pKey_1            => TO_CHAR (pNsi_sid));
            RAISE;
      END InsertEquivalentPartData;


      PROCEDURE DoPhysicalInsert
      IS
         nsi_sid   amd_national_stock_items.nsi_sid%TYPE := NULL;

         FUNCTION IsPrimeReplacingExistingOne (
            pNsi_sid                 IN     amd_nsi_parts.nsi_sid%TYPE,
            pCurrent_prime_part_no      OUT amd_nsi_parts.part_no%TYPE)
            RETURN BOOLEAN
         IS
            prime_ind   amd_nsi_parts.prime_ind%TYPE := NULL;
         BEGIN
            BEGIN
               SELECT part_no, prime_ind
                 INTO pCurrent_prime_part_no, prime_ind
                 FROM amd_nsi_parts
                WHERE     nsi_sid = pNsi_sid
                      AND prime_ind = amd_defaults.PRIME_PART
                      AND unassignment_date IS NULL;

               RETURN TRUE;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  RETURN FALSE;
            END;
         END IsPrimeReplacingExistingOne;


         PROCEDURE PrepareDataForInsert
         IS
         BEGIN
           -- todo prime_ind_cleaned will be set in a separate routine since it is
           -- so complicated
           -- InsertRow.prime_ind_cleaned := amd_clean_data.prime_ind(nsn);

           <<getTacticalInd>>
            BEGIN
               InsertRow.tactical :=
                  amd_validation_pkg.GetTacticalInd (
                     amd_preferred_pkg.GetPreferredValue (
                        mUnitCostCleaned,
                        pUnit_cost,
                        InsertRow.unit_cost_defaulted),
                     amd_preferred_pkg.GetPreferredValue (mSmrCodeCleaned,
                                                          pSmr_code));
            EXCEPTION
               WHEN OTHERS
               THEN
                  ErrorMsg (pSqlfunction      => 'getTacticalInd',
                            pError_location   => 440);
                  RAISE;
            END getTacticalInd;

            IF pPlanner_code IS NOT NULL
            THEN
               IF NOT amd_validation_pkg.IsValidPlannerCode (pPlanner_code)
               THEN
                  IF amd_validation_pkg.AddPlannerCode (pPlanner_code) !=
                        amd_validation_pkg.SUCCESS
                  THEN
                     RAISE ADD_PLANNER_CODE_EXCEPTION;
                  END IF;
               END IF;
            END IF;

            IF pOrder_uom IS NOT NULL
            THEN
               IF NOT amd_validation_pkg.IsValidUomCode (pOrder_uom)
               THEN
                  IF amd_validation_pkg.AddUomCode (pOrder_uom) !=
                        amd_validation_pkg.SUCCESS
                  THEN
                     RAISE ADD_UOM_CODE_EXCEPTION;
                  END IF;
               END IF;
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               mRC := amd_spare_parts_pkg.UNABLE_TO_PREP_DATA;
               ErrorMsg (pSqlfunction      => 'prepareDataForInsert',
                         pError_location   => 450);
               RAISE;
         END prepareDataForInsert;


         FUNCTION NatStkItemExists (pNsn       IN     amd_spare_parts.nsn%TYPE,
                                    pNsi_sid      OUT amd_nsns.nsi_sid%TYPE)
            RETURN BOOLEAN
         IS
         BEGIN
            SELECT nsi_sid
              INTO pNsi_sid
              FROM amd_nsns
             WHERE nsn = pNsn AND nsi_sid IS NOT NULL;

            RETURN TRUE;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN FALSE;
         END NatStkItemExists;


         PROCEDURE InsertSparePart
         IS
         BEGIN
            INSERT INTO amd_spare_parts (part_no,
                                         mfgr,
                                         date_icp,
                                         disposal_cost,
                                         disposal_cost_defaulted,
                                         erc,
                                         icp_ind,
                                         nomenclature,
                                         order_lead_time,
                                         order_lead_time_defaulted,
                                         order_uom,
                                         order_uom_defaulted,
                                         scrap_value,
                                         scrap_value_defaulted,
                                         serial_flag,
                                         shelf_life,
                                         shelf_life_defaulted,
                                         unit_cost,
                                         unit_cost_defaulted,
                                         unit_volume,
                                         unit_volume_defaulted,
                                         nsn,
                                         tactical,
                                         action_code,
                                         last_update_dt,
                                         acquisition_advice_code,
                                         unit_of_issue)
                 VALUES (pPart_no,
                         pMfgr,
                         pDate_icp,
                         pDisposal_cost,
                         amd_defaults.DISPOSAL_COST,
                         pErc,
                         pIcp_ind,
                         pNomenclature,
                         pOrder_lead_time,
                         amd_defaults.GetOrderLeadTime (pItem_type),
                         pOrder_uom,
                         amd_defaults.ORDER_UOM,
                         pScrap_value,
                         amd_defaults.SCRAP_VALUE,
                         pSerial_flag,
                         pShelf_life,
                         amd_defaults.SHELF_LIFE,
                         pUnit_cost,
                         InsertRow.unit_cost_defaulted,
                         pUnit_volume,
                         amd_defaults.UNIT_VOLUME,
                         pNsn,
                         InsertRow.tactical,
                         amd_defaults.INSERT_ACTION,
                         SYSDATE,
                         pAcquisition_advice_code,
                         pUnitOfIssue);
         EXCEPTION
            WHEN DUP_VAL_ON_INDEX
            THEN
               writeMsg (
                  pTableName        => 'amd_spare_parts',
                  pError_location   => 460,
                  pKey1             => 'pPart_no=' || pPart_no,
                  pKey2             => 'tried to insert a part that was already there');
               result :=
                  UpdateRow (pPart_no,
                             pMfgr,
                             pDate_icp,
                             pDisposal_cost,
                             pErc,
                             pIcp_ind,
                             pNomenclature,
                             pOrder_lead_time,
                             pOrder_quantity,
                             pOrder_uom,
                             pPrime_ind,
                             pScrap_value,
                             pSerial_flag,
                             pShelf_life,
                             pUnit_cost,
                             pUnit_volume,
                             pNsn,
                             pNsn_type,
                             pItem_type,
                             pSmr_code,
                             pPlanner_code,
                             pMic_code_lowest,
                             pAcquisition_advice_code,
                             pMmac,
                             pUnitOfIssue);
            WHEN OTHERS
            THEN
               ErrorMsg (pSqlfunction      => 'insert',
                         pTableName        => 'amd_spare_parts',
                         pError_location   => 470,
                         pKey_1            => pPart_no);
               RAISE;
         END InsertSparePart;


         PROCEDURE UpdatePrimePartData (
            pNsi_sid   IN amd_national_stock_items.nsi_sid%TYPE)
         IS
            result   NUMBER := SUCCESS;
         BEGIN                                          -- UpdatePrimePartData
            InsertAmdNsiParts (pNsi_sid);

            UpdtNsiPrimePartData (
               pPrime_ind         => pPrime_ind,
               pNsi_sid           => pNsi_sid,
               pPartNo            => pPart_no,
               pNsn               => pNsn,
               pItem_type         => pItem_type,
               pOrder_quantity    => pOrder_quantity,
               pPlannerCode       => pPlanner_code,
               pSmr_code          => pSmr_code,
               pMic_code_lowest   => pMic_code_lowest,
               pAction_code       => amd_defaults.INSERT_ACTION,
               pReturn_code       => amd_spare_parts_pkg.UNABLE_TO_PRIME_INFO,
               pMmac              => pMmac);
         EXCEPTION
            WHEN OTHERS
            THEN
               mRC := INSERT_PRIMEPART_ERR;
               ErrorMsg (pSqlfunction      => 'updatePrimePartData',
                         pError_location   => 480);
               RAISE;
         END UpdatePrimePartData;


         PROCEDURE UpdatePrimePartData (
            pNsn                     IN amd_national_stock_items.nsn%TYPE,
            pNsi_sid                 IN amd_nsns.nsi_sid%TYPE,
            pCurrent_prime_part_no   IN amd_nsi_parts.part_no%TYPE)
         IS
            result   NUMBER := SUCCESS;

            PROCEDURE MakePrimeAnEquivalentPart
            IS
               curPrime   amd_nsi_parts.PART_NO%TYPE;
            BEGIN
               -- first make sure the prime_part is flagged as logically deleted
               UPDATE amd_national_stock_items
                  SET action_code = amd_defaults.DELETE_ACTION,
                      last_update_dt = SYSDATE
                WHERE     nsi_sid = pNsi_sid
                      AND prime_part_no =
                             (SELECT part_no
                                FROM amd_nsi_parts
                               WHERE     nsi_sid = pNsi_sid
                                     AND (   prime_ind =
                                                amd_defaults.PRIME_PART
                                          OR prime_ind_cleaned =
                                                amd_defaults.PRIME_PART)
                                     AND unassignment_date IS NULL);


               UPDATE amd_nsi_parts
                  SET unassignment_date = SYSDATE
                WHERE     nsi_sid = pNsi_sid
                      AND (   prime_ind = amd_defaults.PRIME_PART
                           OR prime_ind_cleaned = amd_defaults.PRIME_PART)
                      AND unassignment_date IS NULL;

               insertNsiParts (
                  pNsi_sid             => pNsi_sid,
                  pPart_no             => pCurrent_prime_part_no,
                  pPrime_ind           => amd_defaults.NOT_PRIME_PART,
                  pPrime_ind_cleaned   => NULL,
                  pBadRc               => amd_spare_parts_pkg.UNASSIGN_OLD_PRIME_PART_ERR);
            EXCEPTION
               WHEN OTHERS
               THEN
                  ErrorMsg (pSqlfunction      => 'makePrimeAnEquivalentPart',
                            pError_location   => 490);
                  RAISE;
            END MakePrimeAnEquivalentPart;
         BEGIN                                          -- UpdatePrimePartData
            UpdtNsiPrimePartData (
               pPrime_ind         => pPrime_ind,
               pNsi_sid           => pNsi_sid,
               pPartNo            => pPart_no,
               pNsn               => pNsn,
               pItem_type         => pItem_type,
               pOrder_quantity    => pOrder_quantity,
               pPlannerCode       => pPlanner_code,
               pSmr_code          => pSmr_code,
               pMic_code_lowest   => pMic_code_lowest,
               pAction_code       => amd_defaults.UPDATE_ACTION,
               pReturn_code       => amd_spare_parts_pkg.CANNOT_UPADATE_NAT_STCK_ITEMS,
               pMmac              => pMmac);


            IF pNsn_type = amd_spare_parts_pkg.CURRENT_NSN
            THEN
               amd_spare_parts_pkg.ChgCurNsn2TempNsn (pNsiSid => pNsi_sid);
            END IF;

            BEGIN
               amd_spare_parts_pkg.UpdateAmdNsn (pNsn_Type   => pNsn_Type,
                                                 pNsi_Sid    => pNsi_sid,
                                                 pNsn        => pNsn);
            EXCEPTION
               WHEN OTHERS
               THEN
                  mRC := CANNOT_UPDATE_AMD_NSNS;
                  ErrorMsg (pSqlfunction      => 'updateAmdNsn',
                            pError_location   => 500,
                            pKey_1            => pNsn_Type,
                            pKey_2            => TO_CHAR (pNsi_sid),
                            pKey_3            => pNsn);
                  RAISE;
            END update_amd_nsns;

            MakePrimeAnEquivalentPart ();
            insertNsiParts (
               pNsi_sid             => pNsi_sid,
               pPart_no             => pPart_no,
               pPrime_ind           => pPrime_ind,
               pPrime_ind_cleaned   => NULL,
               pBadRc               => amd_spare_parts_pkg.MAKE_NEW_PRIME_PART_ERR);
            MakeNsnSameForAllParts (pNsi_sid => pNsi_sid, pNsn => pNsn);
         EXCEPTION
            WHEN OTHERS
            THEN
               mRC := CANNOT_UPDATE_AMD_NSNS;
               ErrorMsg (pSqlfunction      => 'updatePrimePartData',
                         pError_location   => 510,
                         pKey_1            => pNsn_Type,
                         pKey_2            => TO_CHAR (pNsi_sid),
                         pKey_3            => pNsn);
               RAISE;
         END UpdatePrimePartData;
      BEGIN                                                -- DoPhysicalInsert
         debugMsg ('DoPhysicalInsert', pError_location => 520);

         PrepareDataForInsert;

         IF NatStkItemExists (pNsn       => pNsn,
                              pNsi_sid   => DoPhysicalInsert.nsi_sid)
         THEN
            NULL;                                             -- OK do nothing
         ELSE                                                    -- create one
            CreateNationalStockItem (
               pNsi_sid           => DoPhysicalInsert.nsi_sid,
               pNsn               => pNsn,
               pItem_type         => pItem_type,
               pOrder_quantity    => pOrder_quantity,
               pPlanner_code      => pPlanner_code,
               pSmr_code          => pSmr_code,
               pTactical          => InsertRow.tactical,
               pMic_code_lowest   => InsertRow.pMic_code_lowest,
               pNsn_type          => pNsn_type,
               pMmac              => pMmac);
         END IF;

         InsertSparePart ();

         IF IsPrimePart (pPrime_ind)
         THEN
            DECLARE
               current_prime_part_no   amd_nsi_parts.part_no%TYPE := NULL;
            BEGIN
               IF IsPrimeReplacingExistingOne (
                     pNsi_sid                 => DoPhysicalInsert.nsi_sid,
                     pCurrent_prime_part_no   => current_prime_part_no)
               THEN
                  UpdatePrimePartData (
                     pNsn                     => pNsn,
                     pNsi_sid                 => DoPhysicalInsert.nsi_sid,
                     pCurrent_prime_part_no   => current_prime_part_no);
               ELSE
                  UpdatePrimePartData (pNsi_sid => DoPhysicalInsert.nsi_sid);
               END IF;
            END CheckForExistingPrime;
         ELSE
            InsertEquivalentPartData (pNsi_sid => DoPhysicalInsert.nsi_sid);
         END IF;

         IF pNsn IS NOT NULL
         THEN
            UpdateNatStkItem (pNsn, amd_defaults.INSERT_ACTION, pPart_no);
         END IF;
      END DoPhysicalInsert;


      PROCEDURE DoLogicalInsert
      IS
      BEGIN
         result :=
            UpdateRow (pPart_no,
                       pMfgr,
                       pDate_icp,
                       pDisposal_cost,
                       pErc,
                       pIcp_ind,
                       pNomenclature,
                       pOrder_lead_time,
                       pOrder_quantity,
                       pOrder_uom,
                       pPrime_ind,
                       pScrap_value,
                       pSerial_flag,
                       pShelf_life,
                       pUnit_cost,
                       pUnit_volume,
                       pNsn,
                       pNsn_type,
                       pItem_type,
                       pSmr_code,
                       pPlanner_code,
                       pMic_code_lowest,
                       pAcquisition_advice_code,
                       pMmac,
                       pUnitOfIssue);

         IF result = SUCCESS
         THEN
            BEGIN
               -- Make it look like an insert was just
               -- done.
               UPDATE amd_spare_parts
                  SET action_code = amd_defaults.INSERT_ACTION
                WHERE part_no = pPart_no;
            EXCEPTION
               WHEN OTHERS
               THEN
                  mRC := LOGICAL_INSERT_FAILED;
                  ErrorMsg (pSqlfunction      => 'update',
                            pTablename        => 'amd_spare_parts',
                            pError_location   => 530,
                            pKey_1            => pPart_no);
                  RAISE;
            END LogicalInsert;
         END IF;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'update',
                      pTablename        => 'amd_spare_parts',
                      pError_location   => 540,
                      pKey_1            => pPart_no);
            RAISE;
      END DoLogicalInsert;


      FUNCTION IsPartMarkedAsDeleted
         RETURN BOOLEAN
      IS
         FUNCTION GetActionCode
            RETURN VARCHAR2
         IS
            action_code   VARCHAR2 (1);
         BEGIN
            SELECT action_code
              INTO action_code
              FROM amd_spare_parts
             WHERE part_no = pPart_no;

            RETURN action_code;
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN NULL;
         END GetActionCode;
      BEGIN
         RETURN (GetActionCode () = amd_defaults.DELETE_ACTION);
      END IsPartMarkedAsDeleted;
   BEGIN                                                  -- <<<---- InsertRow
      amd_utils.mDebugThreshold := 100000;
      debugMsg (mArgs, pError_location => 550);

      --        insertLoadDetail(pPart_No,pNsn,pPrime_Ind,'Insert');

      IF IsPartMarkedAsDeleted ()
      THEN
         DoLogicalInsert ();
      ELSE
         unassociateTmpNsn (pNsn);

         DoPhysicalInsert ();
      END IF;

      updateFlags (pPart_no, is_spo_part);

      IF result <> 0
      THEN
         mDebug := TRUE;
         debugMsg (mArgs, pError_location => 553);
         writeMsg (pTableName        => 'tmp_amd_spare_parts',
                   pError_location   => 555,
                   pKey1             => 'insertRow',
                   pKey2             => 'result ' || result,
                   pKey3             => 'part ' || pPart_No);
      END IF;

      mDebug := FALSE;
      RETURN result;
   EXCEPTION
      WHEN part_already_exists
      THEN
         RETURN SUCCESS;                                  -- ignore this error
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction => 'insertRow', pError_location => 560);
         RETURN mRC;
   END InsertRow;


   FUNCTION UpdateRow (pPart_no                   IN VARCHAR2,
                       pMfgr                      IN VARCHAR2,
                       pDate_icp                  IN DATE,
                       pDisposal_cost             IN NUMBER,
                       pErc                       IN VARCHAR2,
                       pIcp_ind                   IN VARCHAR2,
                       pNomenclature              IN VARCHAR2,
                       pOrder_lead_time           IN NUMBER,
                       pOrder_quantity            IN NUMBER,
                       pOrder_uom                 IN VARCHAR2,
                       pPrime_ind                 IN VARCHAR2,
                       pScrap_value               IN NUMBER,
                       pSerial_flag               IN VARCHAR2,
                       pShelf_life                IN NUMBER,
                       pUnit_cost                 IN NUMBER,
                       pUnit_volume               IN NUMBER,
                       pNsn                       IN VARCHAR2,
                       pNsn_type                  IN VARCHAR2,
                       pItem_type                 IN VARCHAR2,
                       pSmr_code                  IN VARCHAR2,
                       pPlanner_code              IN VARCHAR2,
                       pMic_code_lowest           IN VARCHAR2,
                       pAcquisition_advice_code   IN VARCHAR2,
                       pMmac                      IN VARCHAR2,
                       pUnitOfIssue               IN VARCHAR2)
      RETURN NUMBER
   IS
      /* Although the following variables are local to the UpdateRow
        procedure, you will see them referenced as UpdateRow.variable_name.
        This was done to improve readability.  A similar approach is used
        for package constants: package_name.constant_name.
       */
      nsiSid        amd_national_stock_items.nsi_sid%TYPE := NULL;
      result        NUMBER := SUCCESS;
      tactical      amd_spare_parts.tactical%TYPE := 'N';
      lineNumber    NUMBER := 0;
      is_spo_part   amd_spare_parts.is_spo_part%TYPE;


      /* Put a wrapper on the amd_utils.InsertErrorMsg procedure, so it is
          more specific to the UpdateRow function.  Output gets stored
          into amd_load_details and amd_load_status.
      */


      PROCEDURE PrepareDataForUpdate
      IS
         FUNCTION GetSmrCode
            RETURN amd_national_stock_items.smr_code%TYPE
         IS
            smr_code_cleaned   amd_national_stock_items.smr_code_cleaned%TYPE;
         BEGIN
            SELECT smr_code_cleaned
              INTO smr_code_cleaned
              FROM amd_national_stock_items items
             WHERE nsi_sid = nsiSid;

            RETURN amd_preferred_pkg.GetPreferredValue (smr_code_cleaned,
                                                        pSmr_code);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RETURN NULL;
         END GetSmrCode;


         FUNCTION GetUnitCost
            RETURN amd_spare_parts.unit_cost%TYPE
         IS
            unit_cost_cleaned     amd_national_stock_items.unit_cost_cleaned%TYPE;
            unit_cost_defaulted   amd_spare_parts.unit_cost_defaulted%TYPE;
         BEGIN
            BEGIN
               SELECT unit_cost_cleaned, unit_cost_defaulted
                 INTO unit_cost_cleaned, unit_cost_defaulted
                 FROM amd_national_stock_items
                WHERE nsn = pNsn;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  unit_cost_cleaned := NULL;
               WHEN OTHERS
               THEN
                  RAISE amd_spare_parts_pkg.UNIT_COST_CLEANED_VIA_NSN;
            END get_unit_cost_cleaned;

            RETURN amd_preferred_pkg.GetPreferredValue (unit_cost_cleaned,
                                                        pUnit_cost,
                                                        unit_cost_defaulted);
         END GetUnitCost;
      BEGIN                                            -- PrepareDataForUpdate
         BEGIN
            UpdateRow.tactical :=
               amd_validation_pkg.GetTacticalInd (GetUnitCost (),
                                                  GetSmrCode ());
         EXCEPTION
            WHEN amd_spare_parts_pkg.UNIT_COST_CLEANED_VIA_NSN
            THEN
               mRC := amd_spare_parts_pkg.CANNOT_GET_UNIT_COST_CLEANED;
               ErrorMsg (pSqlfunction      => 'getTacticalInd',
                         pError_location   => 570);
               RAISE;
         END setTactical;

         IF pPlanner_code IS NOT NULL
         THEN
            IF NOT amd_validation_pkg.IsValidPlannerCode (pPlanner_code)
            THEN
               IF amd_validation_pkg.AddPlannerCode (pPlanner_code) !=
                     amd_validation_pkg.SUCCESS
               THEN
                  RAISE ADD_PLANNER_CODE_EXCEPTION;
               END IF;
            END IF;
         END IF;

         IF pOrder_uom IS NOT NULL
         THEN
            IF NOT amd_validation_pkg.IsValidUomCode (pOrder_uom)
            THEN
               IF amd_validation_pkg.AddUomCode (pOrder_uom) !=
                     amd_validation_pkg.SUCCESS
               THEN
                  RAISE ADD_UOM_CODE_EXCEPTION;
               END IF;
            END IF;
         END IF;
      EXCEPTION
         WHEN OTHERS
         THEN
            mRC := amd_spare_parts_pkg.PREP_DATA_FOR_UPDT_ERR;
            ErrorMsg (pSqlfunction      => 'prepareDataForUpdate',
                      pError_location   => 580);
            RAISE;
      END PrepareDataForUpdate;


      PROCEDURE UpdateAmdSparePartRow (
         pPartNo    amd_spare_parts.part_no%TYPE,
         pNsn       amd_spare_parts.nsn%TYPE)
      IS
      BEGIN
         debugMsg ('updateAmdSparePartRow(' || pPartNo || ',' || pNsn || ')',
                   pError_location   => 590);

         UPDATE amd_spare_parts
            SET mfgr = pMfgr,
                date_icp = pDate_icp,
                disposal_cost = pDisposal_cost,
                erc = pErc,
                icp_ind = pIcp_ind,
                nomenclature = pNomenclature,
                order_lead_time = pOrder_lead_time,
                order_lead_time_defaulted =
                   amd_defaults.GETORDERLEADTIME (pItem_type),
                order_uom = pOrder_uom,
                scrap_value = pScrap_value,
                serial_flag = pSerial_flag,
                shelf_life = pShelf_life,
                unit_cost = pUnit_cost,
                unit_volume = pUnit_volume,
                tactical = UpdateRow.tactical,
                action_code = amd_defaults.UPDATE_ACTION,
                last_update_dt = SYSDATE,
                nsn = pNsn,
                acquisition_advice_code = pAcquisition_advice_code,
                unit_of_issue = pUnitOfIssue
          WHERE part_no = pPartNo;
      EXCEPTION
         WHEN OTHERS
         THEN
            mRC := amd_spare_parts_pkg.UPDT_SPAREPART_ERR;
            ErrorMsg (pSqlfunction      => 'updateAmdSparePartRow',
                      pError_location   => 600);
            RAISE;
      END UpdateAmdSparePartRow;


      PROCEDURE UpdatePrimePartData
      IS
      BEGIN
        <<update_amd_nsns>>
         BEGIN
            amd_spare_parts_pkg.UpdateAmdNsn (pNsn_type   => pNsn_type,
                                              pNsi_sid    => nsiSid,
                                              pNsn        => pNsn);
         EXCEPTION
            WHEN OTHERS
            THEN
               mRC := amd_spare_parts_pkg.CANNOT_UPDATE_AMD_NSNS;
               ErrorMsg (pSqlfunction      => 'updateAmdNsn',
                         pError_location   => 610);
               RAISE;
         END update_amd_nsns;
      EXCEPTION
         WHEN OTHERS
         THEN
            mRC := amd_spare_parts_pkg.UPDT_PRIMEPART_ERR;
            ErrorMsg (pSqlfunction      => 'updatePrimePartData',
                      pError_location   => 620);
            RAISE;
      END UpdatePrimePartData;


      FUNCTION NsnChanged (pPartNo VARCHAR2, pNsn VARCHAR2)
         RETURN BOOLEAN
      IS
         nsn   amd_nsns.nsn%TYPE;
      BEGIN
         debugMsg ('nsnChanged(' || pPartNo || ',' || pNsn || ')',
                   pError_location   => 630);

         SELECT an.nsn
           INTO nsn
           FROM amd_nsi_parts anp, amd_nsns an
          WHERE     anp.nsi_sid = an.nsi_sid
                AND anp.part_no = pPartNo
                AND anp.unassignment_date IS NULL
                AND an.nsn_type = 'C';

         IF nsn != pNsn
         THEN
            RETURN TRUE;
         ELSE
            RETURN FALSE;
         END IF;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN TRUE;
      END NsnChanged;


      FUNCTION PrimeIndChanged
         RETURN BOOLEAN
      IS
         prime_ind   amd_nsi_parts.prime_ind%TYPE := NULL;
      BEGIN
         debugMsg ('primeIndChanged(' || prime_ind || ')',
                   pError_location   => 640);

         SELECT prime_ind
           INTO prime_ind
           FROM amd_nsi_parts
          WHERE     nsi_sid = nsiSid
                AND part_no = pPart_no
                AND unassignment_date IS NULL;

         RETURN (prime_ind != pPrime_ind);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RETURN TRUE;
      END;


      FUNCTION UpdateNsnForPrimePart
         RETURN NUMBER
      IS
         /*
         IMPORTANT:  The prime part controls the value of
         the nsn column in amd_spare_parts. Whenever the value
         of the amd_spare_parts nsn column changes for a prime part, the
         following will happen:
                 1.    Update the nsn column of amd_national_stock_items.
                 2.    Using the amd_nsi_parts linked via nsi_sid update the
                     nsn column of amd_spare_parts with the new value -
                     i.e. update the prime part and its equivalent parts.
         */
         result   NUMBER := SUCCESS;

         PROCEDURE UpdtNsnOfNationalStockItems (pNsiSid NUMBER)
         IS
         BEGIN
            debugMsg (
                  'updtNsnOfNationalStockItems('
               || pNsn
               || ','
               || pNsiSid
               || ')',
               pError_location   => 650);

            UPDATE amd_national_stock_items
               SET nsn = pNsn
             WHERE nsi_sid = pNsiSid;
         EXCEPTION
            WHEN OTHERS
            THEN
               mRC := amd_spare_parts_pkg.CANNOT_UPDT_NSN_NAT_STCK_ITEMS;
               ErrorMsg (pSqlfunction      => 'update',
                         pTableName        => 'amd_national_stock_items',
                         pError_location   => 660);
               RAISE;
         END UpdtNsnOfNationalStockItems;
      BEGIN                                           -- UpdateNsnForPrimePart
         UpdtNsnOfNationalStockItems (nsiSid);

         MakeNsnSameForAllParts (pNsi_sid => nsiSid, pNsn => pNsn);
         RETURN result;
      EXCEPTION
         WHEN OTHERS
         THEN
            mRC := amd_spare_parts_pkg.UPDT_NSN_PRIME_ERR;
            ErrorMsg (pSqlfunction      => 'updateNsnForPrimePart',
                      pError_location   => 670);
            RAISE;
      END UpdateNsnForPrimePart;


      PROCEDURE UpdatePrimeInd
      IS
         PROCEDURE UnassignPrimePart (pPart_no IN amd_nsi_parts.part_no%TYPE)
         IS
         BEGIN
            debugMsg ('unassignPrimePart(' || pPart_no || ')',
                      pError_location   => 680);

            UPDATE amd_nsi_parts
               SET unassignment_date = SYSDATE
             WHERE     part_no = pPart_no
                   AND (   prime_ind = amd_defaults.PRIME_PART
                        OR prime_ind_cleaned = amd_defaults.PRIME_PART)
                   AND unassignment_date IS NULL;

            -- Since this prime_part is unassigned logically delete the
            -- national_stock_item
            UPDATE amd_national_stock_items
               SET action_code = amd_defaults.DELETE_ACTION,
                   last_update_dt = SYSDATE
             WHERE prime_part_no = pPart_no;
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (pSqlfunction      => 'unassignPrimePart',
                         pError_location   => 690,
                         pKey_1            => pPart_no);
               RAISE;
         END UnassignPrimePart;

         PROCEDURE MakeCurrentPrimeIntoEquiv
         IS
            part_no   amd_nsi_parts.part_no%TYPE := NULL;
         BEGIN
            BEGIN
               -- get the current Prime Part
               SELECT part_no
                 INTO part_no
                 FROM amd_nsi_parts
                WHERE     nsi_sid = nsiSid
                      AND (   prime_ind = amd_defaults.PRIME_PART
                           OR prime_ind_cleaned = amd_defaults.PRIME_PART)
                      AND unassignment_date IS NULL;
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  /* This can occur when a prime has alreay become an
                      equivalent part, before the NEW prime is processed.
                      */
                  RETURN;                                        -- do nothing
               WHEN OTHERS
               THEN
                  mRC := amd_spare_parts_pkg.UNABLE_TO_GET_PRIME_PART_X;
                  ErrorMsg (pSqlfunction      => 'select',
                            pTableName        => 'amd_nsi_parts',
                            pError_location   => 700,
                            pKey_1            => TO_CHAR (nsiSid));
                  RAISE;
            END GetCurrentPrimePart;

            UnassignPrimePart (pPart_no => part_no);

            insertNsiParts (
               pNsi_sid             => nsiSid,
               pPart_no             => part_no,
               pPrime_ind           => amd_defaults.NOT_PRIME_PART,
               pPrime_ind_cleaned   => NULL,
               pBadRc               => amd_spare_parts_pkg.ASSIGN_PRIME_TO_EQUIV_ERR);
         EXCEPTION
            WHEN OTHERS
            THEN
               ErrorMsg (pSqlfunction      => 'MakeCurrentPrimeIntoEquiv',
                         pError_location   => 710,
                         pKey_1            => pPart_no);
               RAISE;
         END MakeCurrentPrimeIntoEquiv;


         PROCEDURE UpdatePrimePartNo
         IS
            temp_prime_part_no   amd_national_stock_items.prime_part_no%TYPE
                                    := NULL;
         BEGIN
           <<getPrimePart>>
            BEGIN
               -- check if the prime part has been set yet
               SELECT part_no
                 INTO temp_prime_part_no
                 FROM amd_nsi_parts
                WHERE     nsi_sid = nsiSid
                      AND unassignment_date IS NULL
                      AND (   prime_ind = amd_defaults.PRIME_PART
                           OR prime_ind_cleaned = amd_defaults.PRIME_PART);
            EXCEPTION
               WHEN NO_DATA_FOUND
               THEN
                  NULL;           -- OK the prime_part_no has not been set yet
               WHEN OTHERS
               THEN
                  mRC := amd_spare_parts_pkg.UNABLE_TO_GET_PRIME_PART;
                  ErrorMsg (pSqlfunction      => 'select',
                            pTableName        => 'amd_nsi_parts',
                            pError_location   => 720,
                            pKey_1            => TO_CHAR (nsiSid));
                  RAISE;
            END getPrimePart;

            IF temp_prime_part_no != NULL
            THEN
               BEGIN
                  SELECT prime_part_no
                    INTO temp_prime_part_no
                    FROM amd_national_stock_items
                   WHERE     nsi_sid = nsiSid
                         AND prime_part_no = temp_prime_part_no;
               EXCEPTION
                  WHEN NO_DATA_FOUND
                  THEN
                     BEGIN
                        /* This should not happen, but just in
                         * case this will gaurantee that the
                         * prime_part_no = part_no in
                         * amd_nsi_parts with prime_ind = 'Y'
                         */
                        UPDATE amd_national_stock_items
                           SET prime_part_no = temp_prime_part_no,
                               last_update_dt = SYSDATE,
                               action_code = amd_defaults.UPDATE_ACTION
                         WHERE nsi_sid = nsiSid;
                     EXCEPTION
                        WHEN OTHERS
                        THEN
                           mRC := amd_spare_parts_pkg.UPDT_NULL_PRIME_COLS_ERR;
                           ErrorMsg (
                              pSqlfunction      => 'update',
                              pTableName        => 'amd_national_stock_items',
                              pError_location   => 730,
                              pKey_1            => TO_CHAR (nsiSid));
                           RAISE;
                     END UpdateNationalStockItems;
                  WHEN OTHERS
                  THEN
                     mRC := amd_spare_parts_pkg.UNABLE_TO_GET_PRIME_PART;
                     ErrorMsg (pSqlfunction      => 'updatePrimePartNo',
                               pError_location   => 740);
                     RAISE;
               END;
            ELSE
               -- the prime part is null, but it should get
               -- set with subsequent data
               BEGIN
                  UPDATE amd_national_stock_items
                     SET prime_part_no = temp_prime_part_no,
                         last_update_dt = SYSDATE,
                         action_code = amd_defaults.UPDATE_ACTION
                   WHERE nsi_sid = nsiSid;
               EXCEPTION
                  WHEN OTHERS
                  THEN
                     mRC := amd_spare_parts_pkg.UPDT_NULL_PRIME_COLS_ERR2;
                     ErrorMsg (pSqlfunction      => 'update',
                               pTableName        => 'amd_national_stock_items',
                               pError_location   => 750,
                               pKey_1            => TO_CHAR (nsiSid));
                     RAISE;
               END UpdateNationalStockItems;
            END IF;
         EXCEPTION
            WHEN OTHERS
            THEN
               mRC := amd_spare_parts_pkg.UPDT_NULL_PRIME_COLS_ERR2;
               ErrorMsg (pSqlfunction      => 'update',
                         pTableName        => 'amd_national_stock_items',
                         pError_location   => 760,
                         pKey_1            => TO_CHAR (nsiSid));
               RAISE;
         END UpdatePrimePartNo;
      BEGIN                                                 --  UpdatePrimeInd
         debugMsg ('updatePrimeInd()', pError_location => 770);

         IF IsPrimePart (pPrime_ind)
         THEN
            MakeCurrentPrimeIntoEquiv ();

            unassignPart (pPart_no);

            BEGIN
               insertNsiParts (
                  pNsi_sid             => nsiSid,
                  pPart_no             => pPart_no,
                  pPrime_ind           => pPrime_ind,
                  pPrime_ind_cleaned   => NULL,
                  pBadRc               => amd_spare_parts_pkg.ASSIGN_NEW_PRIME_PART_ERR);
            END AssignNewPrimePart;

            BEGIN
               -- make sure action_code and last_update_dt get set too
               UPDATE amd_national_stock_items
                  SET prime_part_no = pPart_no,
                      nsn = pNsn,
                      last_update_dt = SYSDATE,
                      action_code = amd_defaults.UPDATE_ACTION
                WHERE nsi_sid = nsiSid;
            EXCEPTION
               WHEN OTHERS
               THEN
                  mRC := amd_spare_parts_pkg.UPDT_ERR_NATIONAL_STK_ITEMS;
                  ErrorMsg (pSqlfunction      => 'update',
                            pTableName        => 'amd_national_stock_items',
                            pError_location   => 780,
                            pKey_1            => TO_CHAR (nsiSid));
                  RAISE;
            END UpdateNationalStockItems;

            /* added invocation of MakeNsnSameForAllParts to
             * to fix bug where equiv parts did not have the same
             * nsn as the prime part.
             */
            MakeNsnSameForAllParts (pNsi_sid => nsiSid, pNsn => pNsn);
         ELSE
            UnassignPrimePart (pPart_no => pPart_no);
            insertNsiParts (
               pNsi_sid             => nsiSid,
               pPart_no             => pPart_no,
               pPrime_ind           => pPrime_ind,
               pPrime_ind_cleaned   => NULL,
               pBadRc               => amd_spare_parts_pkg.ASSIGN_NEW_EQUIV_PART_ERR);

            UpdatePrimePartNo;
         END IF;
      EXCEPTION
         WHEN OTHERS
         THEN
            mRC := amd_spare_parts_pkg.UPD_NSI_PARTS_ERR;
            ErrorMsg (pSqlfunction => 'updatePrimeInd', pError_location => 790);
            RAISE;
      END UpdatePrimeInd;


      PROCEDURE InsertNewNsn (pNsi_sid OUT amd_nsns.nsi_sid%TYPE)
      IS
         /* Get the nsi_sid using the part_no */
         PROCEDURE GetNsiSid
         IS
         BEGIN
            pNsi_sid := amd_utils.GetNsiSid (pPart_no => pPart_no);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               RAISE;
            WHEN OTHERS
            THEN
               pNsi_sid := NULL;
               mRC := amd_spare_parts_pkg.GET_NSISID_BY_PART_ERR;
               ErrorMsg (pSqlfunction => 'getNsiSid', pError_location => 800);
               RAISE;
         END GetNsiSid;
      BEGIN                                                    -- InsertNewNsn
         GetNsiSid ();

         InsertAmdNsn (pNsi_sid    => pNsi_sid,
                       pNsn        => pNsn,
                       pNsn_type   => pNsn_type);
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            CreateNationalStockItem (pNsi_sid           => pNsi_sid,
                                     pNsn               => pNsn,
                                     pItem_type         => pItem_type,
                                     pOrder_quantity    => pOrder_quantity,
                                     pPlanner_code      => pPlanner_code,
                                     pSmr_code          => pSmr_code,
                                     pTactical          => UpdateRow.tactical,
                                     pMic_code_lowest   => pMic_code_lowest,
                                     pNsn_type          => pNsn_type,
                                     pMmac              => pMmac);
         WHEN OTHERS
         THEN
            pNsi_sid := NULL;
            mRC := amd_spare_parts_pkg.NEW_NSN_ERROR;
            ErrorMsg (pSqlfunction => 'insertNewNsn', pError_location => 810);
            RAISE;
      END InsertNewNsn;


      FUNCTION GetNsiSid
         RETURN amd_nsns.nsi_sid%TYPE
      IS
         nsi_sid   amd_nsns.nsi_sid%TYPE;
      BEGIN
         debugMsg ('getNsiSid()', pError_location => 820);
         nsi_sid := amd_utils.GetNsiSid (pNsn => pNsn);
         debugMsg ('Nsi_sid=' || Nsi_sid, pError_location => 830);
         RETURN nsi_sid;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            RAISE;                                        -- must be a new nsn
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction => 'getNsiSid', pError_location => 840);
            RAISE;
      END GetNsiSid;


      PROCEDURE CheckNsnAndPrimeInd
      IS
         result   NUMBER := SUCCESS;
      BEGIN
         debugMsg ('checkNsnAndPrimeInd()', pError_location => 850);

         IF NsnChanged (pPart_no, pNsn)
         THEN
            IF IsPrimePart (pPrime_ind)
            THEN
               IF PrimeIndChanged ()
               THEN
                  UpdatePrimeInd ();
                  result := UpdateNsnForPrimePart ();
               ELSE
                  result := UpdateNsnForPrimePart ();
               END IF;

               MakeNsnSameForAllParts (nsiSid, pNsn);
            ELSE
               unassignPart (pPart_no);

               insertNsiParts (
                  pNsi_sid             => nsiSid,
                  pPart_no             => pPart_no,
                  pPrime_ind           => pPrime_ind,
                  pPrime_ind_cleaned   => NULL,
                  pBadRc               => amd_spare_parts_pkg.ASSIGN_NEW_PRIME_PART_ERR);

               IF PrimeIndChanged ()
               THEN
                  UpdatePrimeInd ();
               END IF;
            END IF;
         ELSE
            IF PrimeIndChanged ()
            THEN
               UpdatePrimeInd ();
            END IF;
         END IF;
      EXCEPTION
         WHEN amd_spare_parts_pkg.CANNOT_FIND_PART
         THEN
            ErrorMsg (pSqlfunction      => 'CheckNsnAndPrimeInd',
                      pError_location   => 860);
            RAISE;
         WHEN OTHERS
         THEN
            mRC := amd_spare_parts_pkg.CHK_NSN_AND_PRIME_ERR2;
            ErrorMsg (pSqlfunction      => 'CheckNsnAndPrimeInd',
                      pError_location   => 870);
            RAISE;
      END CheckNsnAndPrimeInd;

      FUNCTION updatePartLeadTime
         RETURN NUMBER
      IS
         result                           NUMBER := SUCCESS;
         order_lead_time                  amd_spare_parts.order_lead_time%TYPE;
         order_lead_time_cleaned          amd_national_stock_items.order_lead_time_cleaned%TYPE;
         time_to_repair_off_base          amd_national_stock_items.TIME_TO_REPAIR_OFF_BASE%TYPE;
         time_to_repair_off_base_cleand   amd_national_stock_items.TIME_TO_REPAIR_OFF_BASE_CLEAND%TYPE;
      BEGIN
         SELECT parts.order_lead_time,
                items.order_lead_time_cleaned,
                items.TIME_TO_REPAIR_OFF_BASE,
                items.TIME_TO_REPAIR_OFF_BASE_CLEAND
           INTO order_lead_time,
                order_lead_time_cleaned,
                time_to_repair_off_base,
                time_to_repair_off_base_cleand
           FROM amd_spare_parts parts, amd_national_stock_items items
          WHERE parts.part_no = pPart_no AND parts.nsn = items.nsn;



         RETURN result;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            RETURN result;
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'updatePartLeadTime',
                      pError_location   => 880,
                      pKey_1            => pPart_no,
                      pKey_2            => pNsn);
            RAISE;
      END updatePartLeadTime;

      FUNCTION updatePartPricing
         RETURN NUMBER
      IS
         unit_cost           amd_spare_parts.unit_cost%TYPE;
         unit_cost_cleaned   amd_national_stock_items.unit_cost_cleaned%TYPE;
      BEGIN
         SELECT unit_cost, unit_cost_cleaned
           INTO unit_cost, unit_cost_cleaned
           FROM amd_spare_parts parts, amd_national_stock_items items
          WHERE parts.part_no = pPart_no AND parts.nsn = items.nsn;

         RETURN result;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            RETURN result;
         WHEN OTHERS
         THEN
            mRC := amd_spare_parts_pkg.CANNOT_UPDATE_PART_PRICING;
            ErrorMsg (pSqlfunction      => 'updatePartPricing',
                      pError_location   => 890);
            RAISE;
      END updatePartPricing;

      PROCEDURE validateInput
      IS
         part_no                          amd_spare_parts.part_no%TYPE;
         mfgr                             amd_spare_parts.mfgr%TYPE;
         date_icp                         amd_spare_parts.DATE_ICP%TYPE;
         disposal_cost                    amd_spare_parts.DISPOSAL_COST%TYPE;
         erc                              amd_spare_parts.ERC%TYPE;
         icp_ind                          amd_spare_parts.ICP_IND%TYPE;
         nomenclature                     amd_spare_parts.NOMENCLATURE%TYPE;
         order_lead_time                  amd_spare_parts.ORDER_LEAD_TIME%TYPE;
         order_quantity                   amd_national_stock_items.ORDER_QUANTITY%TYPE;
         order_uom                        amd_spare_parts.ORDER_UOM%TYPE;
         prime_ind                        amd_nsi_parts.PRIME_IND%TYPE;
         scrap_value                      amd_spare_parts.SCRAP_VALUE%TYPE;
         serial_flag                      amd_spare_parts.SERIAL_FLAG%TYPE;
         shelf_life                       amd_spare_parts.SHELF_LIFE%TYPE;
         unit_cost                        amd_spare_parts.UNIT_COST%TYPE;
         unit_volume                      amd_spare_parts.UNIT_VOLUME%TYPE;
         nsn                              amd_spare_parts.NSN%TYPE;
         nsn_type                         amd_nsns.NSN_TYPE%TYPE;
         item_type                        amd_national_stock_items.ITEM_TYPE%TYPE;
         smr_code                         amd_national_stock_items.SMR_CODE%TYPE;
         planner_code                     amd_national_stock_items.PLANNER_CODE%TYPE;
         mic_code_lowest                  amd_national_stock_items.MIC_CODE_LOWEST%TYPE;
         acquisition_advice_code          amd_spare_parts.ACQUISITION_ADVICE_CODE%TYPE;
         mmac                             amd_national_stock_items.MMAC%TYPE;
         unit_Of_Issue                    amd_spare_parts.UNIT_OF_ISSUE%TYPE;
         mtbdr                            amd_national_stock_items.MTBDR%TYPE;
         mtbdr_computed                   amd_national_stock_items.mtbdr_computed%TYPE;
         qpei_weighted                    amd_national_stock_items.QPEI_WEIGHTED%TYPE;
         condemn_avg_cleaned              amd_national_stock_items.CONDEMN_AVG_CLEANED%TYPE;
         criticality_cleaned              amd_national_stock_items.CRITICALITY_CLEANED%TYPE;
         mtbdr_cleaned                    amd_national_stock_items.MTBDR_CLEANED%TYPE;
         nrts_avg_cleaned                 amd_national_stock_items.NRTS_AVG_CLEANED%TYPE;
         cost_to_repair_off_base_cleand   amd_national_stock_items.COST_TO_REPAIR_OFF_BASE_CLEAND%TYPE;
         time_to_repair_off_base_cleand   amd_national_stock_items.TIME_TO_REPAIR_OFF_BASE_CLEAND%TYPE;
         order_Lead_Time_cleaned          amd_national_stock_items.ORDER_LEAD_TIME_CLEANED%TYPE;
         planner_code_cleaned             amd_national_stock_items.planner_code_cleaned%TYPE;
         rts_avg_cleaned                  amd_national_stock_items.RTS_AVG_CLEANED%TYPE;
         smr_code_cleaned                 amd_national_stock_items.smr_code_cleaned%TYPE;
         unit_cost_cleaned                amd_national_stock_items.UNIT_COST_CLEANED%TYPE;
         condemn_avg                      amd_national_stock_items.CONDEMN_AVG%TYPE;
         criticality                      amd_national_stock_items.CRITICALITY%TYPE;
         nrts_avg                         amd_national_stock_items.NRTS_AVG%TYPE;
         rts_avg                          amd_national_stock_items.RTS_AVG%TYPE;
         lineNo                           NUMBER := 0;
         result                           NUMBER;
      BEGIN
         lineNo := lineNo + 1;
         part_no := pPart_no;
         lineNo := lineNo + 1;
         mfgr := pMfgr;
         lineNo := lineNo + 1;
         date_icp := pDate_icp;
         lineNo := lineNo + 1;
         disposal_cost := pDisposal_cost;
         lineNo := lineNo + 1;
         erc := pErc;
         lineNo := lineNo + 1;
         icp_ind := pIcp_ind;
         lineNo := lineNo + 1;
         nomenclature := pNomenclature;
         lineNo := lineNo + 1;
         order_lead_time := pOrder_lead_time;
         lineNo := lineNo + 1;
         order_quantity := pOrder_quantity;
         lineNo := lineNo + 1;
         order_uom := pOrder_uom;
         lineNo := lineNo + 1;
         prime_ind := pPrime_ind;
         lineNo := lineNo + 1;
         scrap_value := pScrap_value;
         lineNo := lineNo + 1;
         serial_flag := pSerial_flag;
         lineNo := lineNo + 1;
         shelf_life := pShelf_life;
         lineNo := lineNo + 1;
         unit_volume := pUnit_volume;
         lineNo := lineNo + 1;
         nsn := pNsn;
         lineNo := lineNo + 1;
         nsn_type := pNsn_type;
         lineNo := lineNo + 1;
         item_type := pItem_type;
         lineNo := lineNo + 1;
         smr_code := pSmr_code;
         lineNo := lineNo + 1;
         planner_code := pPlanner_code;
         lineNo := lineNo + 1;
         mic_code_lowest := pMic_code_lowest;
         lineNo := lineNo + 1;
         acquisition_advice_code := pAcquisition_advice_code;
         lineNo := lineNo + 1;
         mmac := pMmac;
         lineNo := lineNo + 1;
         unit_of_issue := pUnitOfIssue;
      /*
      lineNo := lineNo + 1;mtbdr := pMtbdr ;
        lineNo := lineNo + 1;qpei_weighted := pQpeiWeighted ;
        lineNo := lineNo + 1;condemn_avg_cleaned := pCondemnAvgCleaned ;
        lineNo := lineNo + 1;criticality_cleaned := pCriticalityCleaned ;
        lineNo := lineNo + 1;mtbdr_cleaned := pMtbdrCleaned ;
        lineNo := lineNo + 1;nrts_avg_cleaned := pNrtsAvgCleaned ;
        lineNo := lineNo + 1;cost_to_repair_off_base_cleand := pCostOfRepairOffBaseCleand ;
        lineNo := lineNo + 1;time_to_repair_off_base_cleand := pTimeToRepairOffBaseCleand ;
        lineNo := lineNo + 1;order_Lead_Time_cleaned := pOrderLeadTimeCleaned ;
        lineNo := lineNo + 1;planner_code_cleaned := pPlannerCodeCleaned ;
        lineNo := lineNo + 1;rts_avg_cleaned := pRtsAvgCleaned ;
        lineNo := lineNo + 1;smr_code_cleaned := pSmrCodeCleaned ;
        lineNo := lineNo + 1;unit_cost_cleaned := pUnitCostCleaned ;
        lineNo := lineNo + 1;condemn_avg := pCondemnAvg ;
        lineNo := lineNo + 1;criticality := pCriticality ;
        lineNo := lineNo + 1;nrts_avg := pNrtsAvg ;
        lineNo := lineNo + 1;rts_avg := pRtsAvg ;
      */
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction => 'validateInput', pError_location => 900);
            RAISE;
      END validateInput;
   BEGIN                                                  -- <<<---- UpdateRow
      validateInput;
      debugMsg (mArgs || ')', pError_location => 910);
      --        insertLoadDetail(pPart_No,pNsn,pPrime_Ind,'Update');

      -- if part has moved to a different nsn then unassign existing part to
      -- break it's relation to old nsn so it can get associated with a
      -- different sid(new nsn). Also break any current/temp nsn relation of
      -- old nsn(current) with incoming(new) nsn(temp).
      --
      -- "moved" means old nsn and new nsn appear in CAT1 at the same time or
      -- both nsns are already in AMD on different sids,
      -- therefore, they are no longer related regardless of what amd_nsns says.
      -- that's why the part needs to be unassigned from the old nsn.
      --
      lineNumber := 10;

      IF (hasPartMoved (pPart_no, pNsn))
      THEN
         unassociateTmpNsn (pNsn);
         unassignPart (pPart_no);
      END IF;

      -- retrieve the nsi_sid right away, since it will be make
      -- retrieving data from the amd_national_stock_items,
      -- amd_nsns, and amd_nsi_parts easier
      lineNumber := 20;

      BEGIN
         nsiSid := GetNsiSid ();
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            /* This must be a new nsn - add it to amd_nsns
                using part_no to get the current nsi_sid
            */
            InsertNewNsn (pNsi_sid => nsiSid);
      END;

      /* The nsi_sid should not be null, but just leave this code in
          as a backup parachute!
          */
      lineNumber := 30;

      IF nsiSid IS NULL
      THEN
         ErrorMsg (pSqlfunction => 'getNsiSid', pError_location => 920);
         RAISE cannotGetNsiSid;
      END IF;

      lineNumber := 40;
      CheckNsnAndPrimeInd ();

      lineNumber := 50;
      PrepareDataForUpdate ();

      lineNumber := 60;
      UpdateAmdSparePartRow (pPart_no, pNsn);

      lineNumber := 70;
      UpdtNsiPrimePartData (
         pPrime_ind         => pPrime_ind,
         pNsi_sid           => nsiSid,
         pPartNo            => pPart_no,
         pNsn               => pNsn,
         pItem_type         => pItem_type,
         pOrder_quantity    => pOrder_quantity,
         pPlannerCode       => pPlanner_code,
         pSmr_code          => pSmr_code,
         pMic_code_lowest   => pMic_code_lowest,
         pAction_code       => amd_defaults.UPDATE_ACTION,
         pReturn_code       => amd_spare_parts_pkg.UPDATE_NATSTK_ERR,
         pMmac              => pMmac);

      lineNumber := 80;
      amd_spare_parts_pkg.UpdateAmdNsn (pNsn_type   => pNsn_type,
                                        pNsi_sid    => nsiSid,
                                        pNsn        => pNsn);

      lineNumber := 90;

      IF pNsn IS NOT NULL
      THEN
         UpdateNatStkItem (pNsn, amd_defaults.UPDATE_ACTION, pPart_no);
      END IF;

      -- Update amd_national_stock_items.action_code = 'D' for any other
      -- nsi_sid this part came off of that has no parts assigned to it.
      -- An nsi_sid w/o assigned parts is a "deleted" nsi_sid.
      --
      lineNumber := 100;
      debugMsg ('updating action code to D', pError_location => 930);

      UPDATE amd_national_stock_items
         SET action_code = 'D', last_update_dt = SYSDATE
       WHERE     action_code != 'D'
             AND nsi_sid IN
                    (SELECT nsi_sid
                       FROM amd_nsi_parts
                      WHERE part_no = pPart_no AND nsi_sid != nsiSid
                     MINUS
                     SELECT nsi_sid
                       FROM amd_nsi_parts
                      WHERE     nsi_sid IN (SELECT nsi_sid
                                              FROM amd_nsi_parts
                                             WHERE part_no = pPart_no)
                            AND unassignment_date IS NULL);

      updateFlags (pPart_no, is_spo_part);


      lineNumber := 110;
      RETURN result;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'updateRow',
                   pError_location   => 940,
                   pKey_1            => lineNumber);
         RETURN mRC;
   END UpdateRow;


   FUNCTION DeleteRow (pPart_no        IN VARCHAR2,
                       pNomenclature   IN VARCHAR2,
                       pMfgr           IN VARCHAR2)
      RETURN NUMBER
   IS
      result        NUMBER := SUCCESS;
      nsn           amd_spare_parts.nsn%TYPE := NULL;
      is_spo_part   amd_spare_parts.is_spo_part%TYPE;

      /* Put a wrapper on the amd_utils.InsertErrorMsg procedure, so it is
          more specific to the DeleteRow function.  Output gets stored
          into amd_load_details and amd_load_status.
      */

      FUNCTION GetNsn
         RETURN amd_spare_parts.nsn%TYPE
      IS
         nsn   amd_spare_parts.nsn%TYPE := NULL;
      BEGIN
         SELECT nsn
           INTO nsn
           FROM amd_spare_parts
          WHERE part_no = pPart_no;

         RETURN nsn;
      END GetNsn;
   BEGIN
      debugMsg ('amd_spare_parts.deleteRow: ' || pPart_no,
                pError_location   => 950);

      mArgs :=
            'DeleteRow('
         || pPart_no
         || ', '
         || pMfgr
         || ', '
         || pNomenclature
         || ')';


      insertLoadDetail (pPart_No,
                        'nsn',
                        'pPrimeInd',
                        'Delete');
      nsn := GetNsn ();

     -- nsn is NULLed to facilitate temp nsns turning into current nsns. When a
     -- temp nsn becomes current the nsn/nsi_sid association needs to be broken
     -- and this helps facilitate that when it may happen at a later time.
     --
     <<updateAmdSpareParts>>
      BEGIN
         UPDATE amd_spare_parts
            SET action_code = amd_defaults.DELETE_ACTION,
                nsn = NULL,
                last_update_dt = SYSDATE
          WHERE part_no = pPart_no;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'update',
                      pTableName        => 'amd_spare_parts',
                      pError_location   => 960,
                      pKey_1            => pPart_no);
            RAISE;
      END updateAmdSpareParts;

      unassignPart (pPart_no);

      IF nsn IS NOT NULL
      THEN
         UpdateNatStkItem (nsn, amd_defaults.DELETE_ACTION);
      ELSE
         result := SUCCESS;
      END IF;

      updateFlags (pPart_no, is_spo_part);

      debugMsg ('amd_spare_parts.deleteRow: ' || pPart_no,
                pError_location   => 970);
      RETURN result;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction => 'deleteRow', pError_location => 980);
         RETURN mRC;
   END DeleteRow;

   FUNCTION getQtyDue (primePartNo IN VARCHAR2)
      RETURN NUMBER
   IS
      qtyDue     NUMBER;
      thePrime   cat1.PRIME%TYPE;
   BEGIN
        SELECT SUM (qty_due) qty_due, prime_part_no
          INTO qtyDue, thePrime
          FROM tmp1, amd_national_stock_items, amd_spare_parts
         WHERE     returned_voucher IS NULL
               AND status = 'O'
               AND tcn = 'LBR'
               AND UPPER (SUBSTR (to_sc, 1, PROGRAM_ID_LL)) = PROGRAM_ID
               AND UPPER (SUBSTR (to_loc_id, 1, 3)) NOT IN
                      ('MRC', 'SUP', 'TST')
               AND to_loc_id NOT IN ('CODLGB', 'ROTLGB')
               AND tmp1.from_part = amd_spare_parts.part_no
               AND amd_spare_parts.action_code IN ('A', 'C')
               AND amd_spare_parts.nsn = amd_national_stock_items.nsn
               AND amd_national_stock_items.action_code IN ('A', 'C')
      GROUP BY prime_part_no
        HAVING prime_part_no = primePartNo;

      RETURN qtyDue;
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN 0;
   END getQtyDue;


   PROCEDURE loadCurrentBackOrder (debug IN BOOLEAN := FALSE)
   IS
      TYPE qtyDueRec IS RECORD
      (
         primePartNo   cat1.prime%TYPE,
         qtyDue        NUMBER
      );

      TYPE primePartNoTab IS TABLE OF cat1.prime%TYPE;

      primePartNos    primePartNoTab;

      TYPE qtyDueTab IS TABLE OF NUMBER;

      quantitiesDue   qtyDueTab;

      TB     CONSTANT VARCHAR2 (1) := CHR (9);                -- tab character

      curDueCnt       NUMBER := 0;
      curTmpCnt       NUMBER := 0;


      CURSOR curDue
      IS
           SELECT cat1.prime primePartNo,
                    SUM (NVL (req1.qty_due, 0) + NVL (req1.qty_reserved, 0))
                  + getQtyDue (cat1.prime)
                     DUE
             FROM req1, cat1
            WHERE     req1.select_from_part = cat1.part
                  AND req1.request_id NOT LIKE 'KIT%'
                  AND req1.mils_source_dic IS NOT NULL
                  AND req1.select_from_sc LIKE PROGRAM_ID || '%'
                  AND req1.status IN ('U',
                                      'H',
                                      'O',
                                      'R')
                  AND req1.request_priority <= 5
                  AND req1.select_from_loc_id NOT IN ('CODLGB', 'ROTLGB')
                  AND SUBSTR (req1.select_from_loc_id, 1, 3) NOT IN
                         ('MRC', 'SUP', 'TST')
                  AND cat1.SOURCE_CODE = amd_defaults.getSourceCode
         GROUP BY cat1.prime;

      CURSOR curTmp1QtyDue
      IS
         SELECT prime_part_no primePartNo, qty_due qtyDue
           FROM (  SELECT SUM (qty_due) qty_due, prime prime_part_no
                     FROM tmp1,
                          cat1,
                          amd_national_stock_items,
                          amd_spare_parts
                    WHERE     from_part = cat1.PART
                          AND returned_voucher IS NULL
                          AND status = 'O'
                          AND tcn = 'LBR'
                          AND SUBSTR (to_sc, 1, PROGRAM_ID_LL) = PROGRAM_ID
                          AND SUBSTR (to_loc_id, 1, 3) NOT IN
                                 ('MRC', 'SUP', 'TST')
                          AND to_loc_id NOT IN ('CODLGB', 'ROTLGB')
                          AND from_part = amd_spare_parts.part_no
                          AND amd_spare_parts.action_code IN ('A', 'C')
                          AND amd_spare_parts.nsn =
                                 amd_national_stock_items.nsn
                 GROUP BY prime)
          WHERE prime_part_no NOT IN
                   (SELECT DISTINCT cat1.prime primePartNo
                      FROM req1, cat1
                     WHERE     req1.select_from_part = cat1.part
                           AND req1.request_id NOT LIKE 'KIT%'
                           AND req1.mils_source_dic IS NOT NULL
                           AND req1.select_from_sc LIKE PROGRAM_ID || '%'
                           AND req1.status IN ('U',
                                               'H',
                                               'O',
                                               'R')
                           AND req1.request_priority <= 5
                           AND cat1.SOURCE_CODE = amd_defaults.getSourceCode);
   BEGIN
      writeMsg (
         pTableName        => 'amd_spare_parts',
         pError_location   => 990,
         pKey1             => 'loadCurrentBackorder',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      UPDATE amd_national_stock_items
         SET current_backorder = NULL;

      writeMsg (
         pTableName        => 'amd_spare_parts',
         pError_location   => 1000,
         pKey1             => 'curDue',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      COMMIT;

      OPEN curDue;

      FETCH curDue BULK COLLECT INTO primePartNos, quantitiesDue;

      CLOSE curDue;

      IF primePartNos.FIRST IS NOT NULL
      THEN
         FORALL indx IN primePartNos.FIRST .. primePartNos.LAST
            UPDATE amd_national_stock_items
               SET current_backorder = quantitiesDue (indx)
             WHERE prime_part_no = primePartNos (indx);
      END IF;

      curDueCnt := SQL%ROWCOUNT;
      DBMS_OUTPUT.put_line (
            'loadCurrentBackOrder: '
         || curDueCnt
         || ' rows updated for amd_national_stock_items');
      writeMsg (
         pTableName        => 'amd_spare_parts',
         pError_location   => 1010,
         pKey1             => 'curDue',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => 'curDueCnt=' || TO_CHAR (curDueCnt));
      COMMIT;

      writeMsg (
         pTableName        => 'amd_spare_parts',
         pError_location   => 1020,
         pKey1             => 'curTmp1QtyDue',
         pKey2             =>    'started at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'));

      OPEN curTmp1QtyDue;

      FETCH curTmp1QtyDue BULK COLLECT INTO primePartNos, quantitiesDue;

      CLOSE curTmp1QtyDue;

      IF primePartNos.FIRST IS NOT NULL
      THEN
         FORALL indx IN primePartNos.FIRST .. primePartNos.LAST
            UPDATE amd_national_stock_items
               SET current_backorder = quantitiesDue (indx)
             WHERE prime_part_no = primePartNos (indx);
      END IF;

      curTmpCnt := SQL%ROWCOUNT;

      writeMsg (
         pTableName        => 'amd_spare_parts',
         pError_location   => 1030,
         pKey1             => 'curTmp1QtyDue',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => 'curTmpCnt=' || TO_CHAR (curTmpCnt));

      writeMsg (
         pTableName        => 'amd_spare_parts',
         pError_location   => 1040,
         pKey1             => 'loadCurrentBackorder',
         pKey2             =>    'ended at '
                              || TO_CHAR (SYSDATE, 'MM/DD/YYYY HH:MI:SS AM'),
         pKey3             => 'curDueCnt=' || TO_CHAR (curDueCnt),
         pKey4             => 'curTmpCnt=' || TO_CHAR (curTmpCnt));

      COMMIT;
   END loadCurrentBackOrder;



   PROCEDURE version
   IS
   BEGIN
      writeMsg (pTableName        => 'amd_spare_parts_pkg',
                pError_location   => 1050,
                pKey1             => 'amd_spare_parts_pkg',
                pKey2             => '$Revision:   1.125  $');
      DBMS_OUTPUT.put_line ('amd_spare_parts_pkg: $Revision:   1.125  $');
   END version;

   FUNCTION getVersion
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN '$Revision:   1.125  $';
   END getVersion;

   PROCEDURE setDebug (switch IN VARCHAR2)
   IS
   BEGIN
      mDebug :=
         UPPER (switch) IN ('Y',
                            'T',
                            'YES',
                            'TRUE');

      IF mDebug
      THEN
         DBMS_OUTPUT.ENABLE (100000);
      ELSE
         DBMS_OUTPUT.DISABLE;
      END IF;
   END setDebug;

   FUNCTION getDebugYorN
      RETURN VARCHAR2
   IS
   BEGIN
      IF mDebug
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END getDebugYorN;

   -- used to be a2a code

   FUNCTION isNsnInIsgPairs (nsn          IN amd_spare_parts.nsn%TYPE,
                             showReason   IN BOOLEAN := FALSE)
      RETURN BOOLEAN
   IS
      result   BOOLEAN := FALSE;
   BEGIN
     <<tryOldNsn>>
      DECLARE
         CURSOR old_nsns
         IS
            SELECT old_nsn
              FROM bssm_isg_pairs
             WHERE old_nsn = isNsnInIsgPairs.nsn AND lock_sid = 0;
      BEGIN
         FOR rec IN old_nsns
         LOOP
            result := TRUE;
            EXIT WHEN TRUE;
         END LOOP;

         IF NOT result
         THEN
           <<tryNewNsn>>
            DECLARE
               CURSOR new_nsns
               IS
                  SELECT new_nsn
                    FROM bssm_isg_pairs
                   WHERE new_nsn = isnsninisgpairs.nsn AND lock_sid = 0;
            BEGIN
               FOR rec IN new_nsns
               LOOP
                  result := TRUE;
                  EXIT WHEN TRUE;
               END LOOP;
            EXCEPTION
               WHEN OTHERS
               THEN
                  ErrorMsg (pSqlfunction      => 'select',
                            pTableName        => 'bssm_isg_pairs',
                            pError_location   => 1060,
                            pKey_1            => isNsnInIsgPairs.nsn);
                  RAISE;
            END tryNewNsn;
         END IF;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'select',
                      pTableName        => 'bssm_isg_pairs',
                      pError_location   => 1070,
                      pKey_1            => isNsnInIsgPairs.nsn);
            RAISE;
      END tryOldNsn;

      IF result
      THEN
         NULL;                                                   -- do nothing
      ELSE
         debugMsg ('Nsn is NOT in ISG Pairs', 50);

         IF showReason
         THEN
            DBMS_OUTPUT.put_line ('Nsn is NOT in ISG Pairs');
         END IF;
      END IF;

      RETURN result;
   END isNsnInIsgPairs;

   FUNCTION isNsnInIsgPairsYorN (nsn          IN amd_spare_parts.nsn%TYPE,
                                 showReason   IN BOOLEAN := FALSE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF isNsnInIsgPairs (nsn, showReason)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isNsnInIsgPairsYorN;


   FUNCTION isNsnInRblPairs (nsn          IN amd_spare_parts.nsn%TYPE,
                             showReason   IN BOOLEAN := FALSE)
      RETURN BOOLEAN
   IS
      result   BOOLEAN := FALSE;
   BEGIN
     <<tryOldNsn>>
      DECLARE
         CURSOR old_nsns
         IS
            SELECT old_nsn
              FROM amd_rbl_pairs
             WHERE old_nsn = isNsnInRblPairs.nsn;
      BEGIN
         FOR rec IN old_nsns
         LOOP
            result := TRUE;
            EXIT WHEN TRUE;
         END LOOP;

         IF NOT result
         THEN
           <<tryNewNsn>>
            DECLARE
               CURSOR new_nsns
               IS
                  SELECT new_nsn
                    FROM amd_rbl_pairs
                   WHERE new_nsn = isNsnInRblPairs.nsn;
            BEGIN
               FOR rec IN new_nsns
               LOOP
                  result := TRUE;
                  EXIT WHEN TRUE;
               END LOOP;
            EXCEPTION
               WHEN OTHERS
               THEN
                  ErrorMsg (pSqlfunction      => 'select',
                            pTableName        => 'amd_rbl_pairs',
                            pError_location   => 1080,
                            pKey_1            => isNsnInRblPairs.nsn);
                  RAISE;
            END tryNewNsn;
         END IF;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'select',
                      pTableName        => 'amd_rbl_pairs',
                      pError_location   => 1090,
                      pKey_1            => isNsnInRblPairs.nsn);
            RAISE;
      END tryOldNsn;

      IF result
      THEN
         NULL;                                                   -- do nothing
      ELSE
         debugMsg (isNsnInRblPairs.nsn || ' Nsn is NOT valid', 40);

         IF showReason
         THEN
            DBMS_OUTPUT.put_line (
               isNsnInRblPairs.nsn || ' Nsn is NOT in Rbl Pairs');
         END IF;
      END IF;

      RETURN result;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'isNsnInRblPairs',
                   pTableName        => 'amd_rbl_pairs',
                   pError_location   => 1100,
                   pKey_1            => isNsnInRblPairs.nsn);

         RAISE;
   END isNsnInRblPairs;

   FUNCTION isNsnInRblPairsYorN (nsn          IN amd_spare_parts.nsn%TYPE,
                                 showReason   IN BOOLEAN := FALSE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF isNsnInRblPairs (nsn, showReason)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isNsnInRblPairsYorN;

   FUNCTION inventoryExists (part_no      IN amd_spare_parts.part_no%TYPE,
                             showReason   IN BOOLEAN := FALSE)
      RETURN BOOLEAN
   IS
      result        NUMBER := 0;
      primePartNo   AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE;
   BEGIN
     <<getPrimePartNo>>
      BEGIN
         SELECT items.prime_part_no
           INTO primePartNo
           FROM amd_national_stock_items items, amd_spare_parts parts
          WHERE     inventoryExists.part_no = parts.part_no
                AND parts.nsn = items.nsn;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'select',
                      pTableName        => 'amd_spare_parts',
                      pError_location   => 1110,
                      pKey_1            => inventoryExists.part_no);
            RAISE;
      END getPrimePartNo;

     <<doesDataExist>>
      BEGIN
         SELECT 1
           INTO result
           FROM DUAL
          WHERE    EXISTS
                      (SELECT *
                         FROM amd_on_hand_invs oh
                        WHERE     primepartno = oh.part_no
                              AND oh.action_code !=
                                     amd_defaults.delete_action
                              AND oh.inv_qty > 0)
                OR EXISTS
                      (SELECT *
                         FROM amd_in_repair ir
                        WHERE     primepartno = ir.part_no
                              AND ir.action_code !=
                                     amd_defaults.delete_action
                              AND ir.repair_qty > 0)
                OR EXISTS
                      (SELECT *
                         FROM amd_on_order oo
                        WHERE     primepartno = oo.part_no
                              AND oo.action_code !=
                                     amd_defaults.delete_action
                              AND oo.order_qty > 0)
                OR EXISTS
                      (SELECT *
                         FROM amd_in_transits it
                        WHERE     primepartno = it.part_no
                              AND it.action_code !=
                                     amd_defaults.delete_action
                              AND it.quantity > 0);
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            NULL;
         WHEN OTHERS
         THEN
            IF SQLCODE = -4091
            THEN
               raise_application_error (
                  -20050,
                  SUBSTR (1, 2000, '29 ' || inventoryExists.part_No));
            ELSE
               ErrorMsg (pSqlfunction      => 'select',
                         pTableName        => 'exist',
                         pError_location   => 1120,
                         pKey_1            => inventoryExists.part_No);
            END IF;

            RAISE;
      END doesDataExist;

      IF result > 0
      THEN
         NULL;                                                   -- do nothing
      ELSE
         debugMsg (
            'Inventory does NOT exist for ' || inventoryExists.part_No,
            20);

         IF showReason
         THEN
            DBMS_OUTPUT.put_line (
               'Inventory does NOT exist for ' || inventoryExists.part_No);
         END IF;
      END IF;

      RETURN (result > 0);
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'selects',
                   pTableName        => 'inventoryExists',
                   pError_location   => 1130,
                   pKey_1            => part_no);

         RAISE;
   END inventoryExists;

   FUNCTION inventoryExistsYorN (part_no      IN amd_spare_parts.part_no%TYPE,
                                 showReason   IN BOOLEAN := FALSE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF inventoryExists (part_no, showReason)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'selects',
                   pTableName        => 'inventoryExistsYorN',
                   pError_location   => 1140,
                   pKey_1            => part_no);

         RAISE;
   END inventoryExistsYorN;

   FUNCTION isNsnValid (part_no      IN amd_spare_parts.part_no%TYPE,
                        showReason   IN BOOLEAN := FALSE)
      RETURN BOOLEAN
   IS
      nsn   amd_spare_parts.nsn%TYPE;
   BEGIN
     <<getNsn>>
      BEGIN
         SELECT parts.nsn
           INTO isNsnValid.nsn
           FROM amd_spare_parts parts
          WHERE isNsnValid.part_no = parts.part_no;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'select',
                      pTableName        => 'amd_spare_parts',
                      pError_location   => 1150,
                      pKey_1            => isNsnValid.part_no,
                      pKey_2            => nsn);
            RAISE;
      END getNsn;

      RETURN    isNsnInRblPairs (nsn, showReason)
             OR isNsnInIsgPairs (nsn, showReason);
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN FALSE;
   END isNsnValid;

   FUNCTION isNsnValidYorN (part_no      IN amd_spare_parts.part_no%TYPE,
                            showReason   IN BOOLEAN := FALSE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF isNsnValid (part_no, showReason)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isNsnValidYorN;


   FUNCTION demandExists (part_no      IN amd_spare_parts.part_no%TYPE,
                          showReason   IN BOOLEAN := FALSE)
      RETURN BOOLEAN
   IS
      result   NUMBER := 0;
   BEGIN
      SELECT 1
        INTO result
        FROM DUAL
       WHERE EXISTS
                (SELECT *
                   FROM amd_demands demands,
                        amd_national_stock_items items,
                        amd_spare_parts parts
                  WHERE     demandexists.part_no = parts.part_no
                        AND parts.action_code != amd_defaults.delete_action
                        AND parts.nsn = items.nsn
                        AND items.action_code != amd_defaults.delete_action
                        AND items.nsi_sid = demands.nsi_sid
                        AND demands.quantity > 0
                        AND demands.action_code != amd_defaults.delete_action);

      IF result > 0
      THEN
         NULL;                                                  -- do  nothing
      ELSE
         debugMsg ('Demand does NOT exist for ' || demandExists.part_no, 10);

         IF showReason
         THEN
            DBMS_OUTPUT.put_line (
               'Demand does NOT exist for ' || demandExists.part_no);
         END IF;
      END IF;

      RETURN (result > 0);
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN FALSE;
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'select',
                   pTableName        => 'demands / items',
                   pError_location   => 1160,
                   pKey_1            => demandExists.part_no);
         RAISE;
   END demandExists;

   FUNCTION demandExistsYorN (part_no      IN amd_spare_parts.part_no%TYPE,
                              showReason   IN BOOLEAN := FALSE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF demandExists (part_no, showReason)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END demandExistsYorN;

   FUNCTION isNsl (partNo IN AMD_SPARE_PARTS.part_no%TYPE)
      RETURN BOOLEAN
   IS
      nsn   AMD_SPARE_PARTS.nsn%TYPE;
   BEGIN
     <<getNsn>>
      BEGIN
         SELECT nsn
           INTO isNsl.nsn
           FROM AMD_SPARE_PARTS
          WHERE partNo = part_no;
      EXCEPTION
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'select',
                      pTableName        => 'amd_spare_parts',
                      pError_location   => 1170,
                      pKey_1            => partNo);
            RAISE;
      END getNsn;

      RETURN UPPER (SUBSTR (nsn, 1, 3)) = amd_defaults.getNonStockageList;
   END isNsl;

   FUNCTION isNslYorN (partNo IN AMD_SPARE_PARTS.part_no%TYPE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF isNsl (partNo)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isNslYorN;

   FUNCTION isPlannerCodeValid (
      plannerCode   IN amd_national_stock_items.planner_code%TYPE,
      showReason    IN BOOLEAN := FALSE)
      RETURN BOOLEAN
   IS
      isValid   BOOLEAN := FALSE;
   BEGIN
      IF plannerCode IS NOT NULL
      THEN
         IF LENGTH (plannerCode) >= 2
         THEN
            isValid :=
                   UPPER (SUBSTR (plannerCode, 1, 2)) != 'KE'
               AND UPPER (SUBSTR (plannerCode, 1, 2)) != 'SE';

            IF isValid
            THEN
               IF LENGTH (plannerCode) >= 3
               THEN
                  isValid := UPPER (SUBSTR (plannerCode, 1, 3)) != 'AFD';
               ELSE
                  isValid := TRUE;
               END IF;
            END IF;
         ELSE
            isValid := TRUE;
         END IF;
      END IF;

      IF isValid
      THEN
         NULL;                                                   -- do nothing
      ELSE
         debugMsg (plannerCode || ' Planner code is NOT valid', 10);

         IF showReason
         THEN
            DBMS_OUTPUT.put_line (
               plannerCode || ' Planner code is NOT valid');
         END IF;
      END IF;

      RETURN isValid;
   END isPlannerCodeValid;

   FUNCTION isPlannerCodeValidYorN (
      plannerCode   IN amd_national_stock_items.planner_code%TYPE,
      showReason    IN BOOLEAN := FALSE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF isPlannerCodeValid (plannerCode, showReason)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isPlannerCodeValidYorN;

   FUNCTION getAcquisitionAdviceCode (
      part_no   IN amd_spare_parts.part_no%TYPE)
      RETURN VARCHAR2
   IS
      theCode   AMD_SPARE_PARTS.ACQUISITION_ADVICE_CODE%TYPE;
   BEGIN
      mArgs := 'getAcquisitionAdviceCode(' || part_no || ')';

      SELECT acquisition_advice_code
        INTO theCode
        FROM AMD_SPARE_PARTS
       WHERE part_no = getAcquisitionAdviceCode.part_No;

      mArgs := 'theCode=' || theCode;
      RETURN UPPER (theCode);
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         mArgs := 'getAcquisitionAdviceCode: no data found for ' || part_no;
         RETURN NULL;
      WHEN OTHERS
      THEN
         ErrorMsg (pSqlfunction      => 'select',
                   pTableName        => 'amd_spare_parts',
                   pError_location   => 1180,
                   pKey_1            => part_no);
         RAISE;
   END getAcquisitionAdviceCode;


   FUNCTION isValidRepairablePart (partNo       IN AMD_SPARE_PARTS.part_no%TYPE,
                                   showReason   IN BOOLEAN := FALSE)
      RETURN BOOLEAN
   IS
      result               BOOLEAN := FALSE;
      nsn                  amd_national_stock_items.nsn%TYPE;
      smrCode              AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE;
      smrCodeCleaned       AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE;
      mtbdr                AMD_NATIONAL_STOCK_ITEMS.mtbdr%TYPE;
      mtbdr_cleaned        AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE;
      mtbdr_computed       AMD_NATIONAL_STOCK_ITEMS.mtbdr_computed%TYPE;
      plannerCode          AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE;
      part_no              AMD_SPARE_PARTS.part_no%TYPE;
      plannerCodeCleaned   AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE;
   BEGIN
     <<doesPartExist>>
      BEGIN
         SELECT part_no
           INTO isValidRepairablePart.part_no
           FROM AMD_SPARE_PARTS
          WHERE     partNo = part_no
                AND action_code != Amd_Defaults.DELETE_ACTION;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            RETURN FALSE;
      END doesPartExist;

      IF amd_utils.isPartConsumable (partNo)
      THEN
         RETURN CONSUMABLES_PKG.ISPARTVALID (partNo);
      END IF;

     <<getPrimePartData>>
      BEGIN
         SELECT nsn,
                smr_code,
                smr_code_cleaned,
                mtbdr,
                mtbdr_cleaned,
                mtbdr_computed,
                planner_code,
                planner_code_cleaned
           INTO nsn,
                smrCode,
                smrCodeCleaned,
                mtbdr,
                mtbdr_cleaned,
                mtbdr_computed,
                plannerCode,
                plannerCodeCleaned
           FROM AMD_NATIONAL_STOCK_ITEMS items, AMD_NSI_PARTS parts
          WHERE     isValidRepairablePart.partNo = parts.part_no
                AND parts.UNASSIGNMENT_DATE IS NULL
                AND parts.nsi_sid = items.nsi_sid;
      EXCEPTION
         WHEN STANDARD.NO_DATA_FOUND
         THEN
            RETURN FALSE;
         WHEN OTHERS
         THEN
            ErrorMsg (pSqlfunction      => 'select',
                      pTableName        => 'items / parts',
                      pError_location   => 1190,
                      pKey_1            => isValidRepairablePart.partNo);
            RAISE;
      END getPrimePartData;

      RETURN isValidRepairablePart (
                partNo                 => partNo,
                preferredSmrCode       => Amd_Preferred_Pkg.getPreferredValue (
                                            smrCodeCleaned,
                                            smrCode),
                preferredMtbdr         => Amd_Preferred_Pkg.getPreferredValue (
                                            mtbdr_cleaned,
                                            mtbdr_computed,
                                            mtbdr),
                preferredPlannerCode   => Amd_Preferred_Pkg.GetPreferredValue (
                                            plannerCodeCleaned,
                                            plannerCode,
                                            amd_defaults.getPlannerCode (nsn)),
                showReason             => showReason);
   END isValidRepairablePart;

   FUNCTION isValidRepairablePartYorN (
      partNo                 IN VARCHAR2,
      preferredSmrCode       IN VARCHAR2,
      preferredMtbdr         IN NUMBER,
      preferredPlannerCode   IN VARCHAR2,
      showReason             IN VARCHAR2 := 'F')
      RETURN VARCHAR2
   IS
   BEGIN
      IF isValidRepairablePart (partNo,
                                preferredSmrCode,
                                preferredMtbdr,
                                preferredPlannerCode,
                                UPPER (showReason) IN ('T',
                                                       'Y',
                                                       'YES',
                                                       'TRUE'))
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isValidRepairablePartYorN;

   FUNCTION isValidRepairablePart (
      partNo                 IN VARCHAR2,
      preferredSmrCode       IN VARCHAR2,
      preferredMtbdr         IN NUMBER,
      preferredPlannerCode   IN VARCHAR2,
      showReason             IN BOOLEAN := FALSE)
      RETURN BOOLEAN
   IS
      result   BOOLEAN := FALSE;
      nsn      amd_spare_parts.nsn%TYPE;
      lineNo   NUMBER := 0;
   BEGIN
      lineNo := 10;

      IF NOT amd_utils.isPartActive (partno)
      THEN
         IF showReason
         THEN
            DBMS_OUTPUT.put_line (partNo || ' is not active');
         END IF;

         RETURN FALSE;
      END IF;

      lineNo := 20;

      IF    UPPER (partNo) = 'F117-PW-100'
         OR INSTR (UPPER (partNo), '17L8D') > 0
         OR INSTR (UPPER (partNo), '17R9Y') > 0
         OR INSTR (UPPER (preferredSmrCode), 'PE') > 0
      THEN
         IF showReason
         THEN
            DBMS_OUTPUT.put_line (
                  partNo
               || ' fails test: UPPER(partNo) = F117-PW-100 OR INSTR(UPPER(partNo),17L8D) > 0 OR INSTR(UPPER(partNo),17R9Y) > 0 OR INSTR(UPPER(preferredSmrCode),PE) > 0');
         END IF;

         RETURN FALSE;
      END IF;

      lineNo := 30;

      IF getAcquisitionAdviceCode (partNo) = 'Y'
      THEN
         IF showReason
         THEN
            DBMS_OUTPUT.put_line (
               partNo || ' has an acquisition advice code of Y');
         END IF;

         RETURN FALSE;
      END IF;

      lineNo := 40;
      result := amd_utils.isRepairableSmrCode (preferredSmrCode);

      IF NOT result
      THEN
         debugmsg (preferredSmrCode || ' is NOT a repairable smr code', 70);

         IF showreason
         THEN
            DBMS_OUTPUT.put_line (
               preferredSmrCode || ' is NOT a repairable smr code');
         END IF;
      END IF;

      lineNo := 50;
      result := result AND isPlannerCodeValid (preferredPlannerCode);

      IF NOT result AND showReason
      THEN
         DBMS_OUTPUT.put_line (
               partNo
            || ' does not have a valid planner code: '
            || preferredPlannerCode);
      END IF;

      IF result AND isNsl (partNo)
      THEN
         IF     showReason
            AND (preferredMtbdr IS NOT NULL AND preferredMtbdr > 0)
         THEN
            DBMS_OUTPUT.put_line ('mtbdr > 0 for part ' || partNo);
         END IF;

         lineNo := 60;
         result :=
                result
            AND (   demandExists (partNo, showReason)
                 OR inventoryExists (partNo, showReason)
                 OR (preferredMtbdr IS NOT NULL AND preferredMtbdr > 0)
                 OR isNsnValid (partNo, showReason));
      END IF;

      IF result
      THEN
         NULL;                                                   -- do nothing
      ELSE
         debugMsg ('part ' || partNo || ' is NOT valid.', 80);

         IF showReason
         THEN
            DBMS_OUTPUT.put_line ('part ' || partNo || ' is NOT valid.');
         END IF;
      END IF;

      lineNo := 70;
      RETURN result;
   EXCEPTION
      WHEN OTHERS
      THEN
         IF SQLCODE = -20000
         THEN
            DBMS_OUTPUT.disable;                   -- buffer overflow, disable
            RETURN isValidRepairablePart (partno);     -- try validation again
         END IF;

         ErrorMsg (pSqlfunction      => 'selects',
                   pTableName        => 'isValidRepairablePart',
                   pError_location   => 1200,
                   pKey_1            => lineNo);

         RAISE;
   END isValidRepairablePart;


   FUNCTION isValidConsumablePart (
      part_no        IN VARCHAR2,
      smr_code       IN amd_national_stock_items.smr_code%TYPE,
      nsn            IN amd_spare_parts.nsn%TYPE,
      planner_code   IN amd_national_stock_items.planner_code%TYPE,
      mtbdr          IN amd_national_stock_items.MTBDR%TYPE)
      RETURN BOOLEAN
   IS
      result   BOOLEAN := FALSE;

      lineNo   NUMBER := 0;
   BEGIN
      -- ToDo: change all literals and tests to be specifically for consumables

      lineNo := 20;

      IF NOT amd_utils.isPartActive (part_no)
      THEN
         RETURN FALSE;
      END IF;

      IF    UPPER (part_No) = 'F117-PW-100'
         OR INSTR (UPPER (part_no), '17L8D') > 0
         OR INSTR (UPPER (part_no), '17R9Y') > 0
         OR INSTR (UPPER (smr_code), 'PE') > 0
      THEN
         RETURN FALSE;
      END IF;


      lineNo := 30;

      IF getAcquisitionAdviceCode (part_no) = 'Y'
      THEN
         RETURN FALSE;
      END IF;

      lineNo := 40;
      result :=
         amd_utils.isPartConsumable (preferred_smr_code       => smr_code,
                                     preferred_planner_code   => planner_code,
                                     nsn                      => nsn);

      IF NOT result
      THEN
         IF mDebug
         THEN
            DBMS_OUTPUT.put_line (smr_code || ' is NOT a valid smr code');
         END IF;
      END IF;

      lineNo := 50;
      result := result AND isPlannerCodeValid (planner_Code);

      IF result AND isNsl (part_no)
      THEN
         IF mdebug AND (mtbdr IS NOT NULL AND mtbdr > 0)
         THEN
            DBMS_OUTPUT.put_line ('mtbdr > 0 for part ' || part_no);
         END IF;

         lineNo := 60;
         result :=
                result
            AND (   demandExists (part_no, mdebug)
                 OR inventoryExists (part_no, mdebug)
                 OR (mtbdr IS NOT NULL AND mtbdr > 0)
                 OR isNsnValid (part_no, mdebug));
      END IF;

      IF NOT result
      THEN
         IF mdebug
         THEN
            DBMS_OUTPUT.put_line ('part ' || part_no || ' is NOT valid.');
         END IF;
      END IF;

      RETURN result;
   EXCEPTION
      WHEN OTHERS
      THEN
         IF SQLCODE = -20000
         THEN
            DBMS_OUTPUT.disable;                   -- buffer overflow, disable
            RETURN isValidConsumablePart (part_no);    -- try validation again
         ELSE
            errorMsg (pSqlfunction      => 'select',
                      pTableName        => 'isValidConsumablePart',
                      pError_location   => 1210,
                      pKey_1            => part_no,
                      pKey_2            => lineNo);
            RAISE;
         END IF;
   END isValidConsumablePart;

   FUNCTION isValidConsumablePartYorN (
      part_no        IN VARCHAR2,
      smr_code       IN amd_national_stock_items.smr_code%TYPE,
      nsn            IN amd_spare_parts.nsn%TYPE,
      planner_code   IN amd_national_stock_items.planner_code%TYPE,
      mtbdr          IN amd_national_stock_items.MTBDR%TYPE)
      RETURN VARCHAR2
   IS
   BEGIN
      IF isValidConsumablePart (part_no,
                                smr_code,
                                nsn,
                                planner_code,
                                mtbdr)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isValidConsumablePartYorN;

   PROCEDURE getPartInfoData (
      part_no        IN     amd_spare_parts.part_no%TYPE,
      smr_code          OUT amd_national_stock_items.smr_code%TYPE,
      nsn               OUT amd_spare_parts.nsn%TYPE,
      planner_code      OUT amd_national_stock_items.planner_code%TYPE,
      mtbdr             OUT amd_national_stock_items.MTBDR%TYPE)
   IS
      nsi_sid   amd_national_stock_items.nsi_sid%TYPE;
   BEGIN
      debugMsg ('getPartInfoData: ' || part_no, pError_location => 1220);

      SELECT items.smr_code,
             items.nsn,
             items.mtbdr,
             items.nsi_sid
        INTO smr_code,
             nsn,
             mtbdr,
             nsi_sid
        FROM amd_spare_parts parts, amd_national_stock_items items
       WHERE     getPartInfoData.part_no = parts.part_no
             AND parts.nsn = items.nsn;

      planner_code := amd_preferred_pkg.getPlannerCode (nsi_sid);
   EXCEPTION
      WHEN STANDARD.NO_DATA_FOUND
      THEN
         RETURN;
      WHEN OTHERS
      THEN
         errorMsg (
            pSqlfunction      => 'select',
            pTableName        => 'amd_spare_parts/amd_national_stock_items',
            pError_location   => 1230,
            pKey_1            => part_no);
         RAISE;
   END getPartInfoData;

   FUNCTION isValidConsumablePart (part_no IN VARCHAR2)
      RETURN BOOLEAN
   IS
      smr_code       amd_national_stock_items.smr_code%TYPE;
      nsn            amd_spare_parts.nsn%TYPE;
      planner_code   amd_national_stock_items.planner_code%TYPE;
      mtbdr          amd_national_stock_items.MTBDR%TYPE;
   BEGIN
      getPartInfoData (part_no,
                       smr_code,
                       nsn,
                       planner_code,
                       mtbdr);

      debugMsg (
            'isPartVaid: '
         || part_no
         || ' '
         || smr_code
         || ' '
         || nsn
         || ' '
         || planner_code
         || ' '
         || mtbdr,
         pError_location   => 1240);

      RETURN isValidConsumablePart (part_no,
                                    smr_code,
                                    nsn,
                                    planner_code,
                                    mtbdr);
   END isValidConsumablePart;

   FUNCTION isValidConsumablePartYorN (part_no IN VARCHAR2)
      RETURN VARCHAR2
   IS
   BEGIN
      IF isValidConsumablePart (part_no)
      THEN
         RETURN 'Y';
      ELSE
         RETURN 'N';
      END IF;
   END isValidConsumablePartYorN;
END amd_spare_parts_pkg;
/


DROP PACKAGE BODY AMD_OWNER.AMD_TEST_DATA;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Test_Data  AS
    /*
        PVCS Keywords

       $Author:   zf297a  $
     $Revision:   1.15  $
         $Date:   Dec 06 2005 10:43:00  $
     $Workfile:   AMD_TEST_DATA.pkb  $
          $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_test_data.pkb-arc  $
   
      Rev 1.15   Dec 06 2005 10:43:00   zf297a
   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS
   
      Rev 1.14   Nov 22 2005 11:05:30   c402417
   Revomed obsolete codes.

*/
    SUBTYPE data_source  IS NUMBER  ;
    
    theSequence number := 0 ;
    prevKey varchar2(256) := '' ;

    NSI_PARTS        CONSTANT data_source := 1 ;
    TMP_SPARE_PARTS CONSTANT data_source := 2 ;

    testProperty NUMBER ;
    xmlFile UTL_FILE.FILE_TYPE ;

    PROCEDURE setTestProperty(value IN NUMBER) IS
    BEGIN
         testProperty := value ;
    END setTestProperty ;

    PROCEDURE setTestProperty(value IN NUMBER, value2 IN NUMBER) IS
    BEGIN
         NULL ;
    END setTestProperty ;

    FUNCTION getTestProperty RETURN NUMBER IS
    BEGIN
         RETURN testProperty ;
    END getTestProperty ;

    FUNCTION DeleteParameters RETURN BOOLEAN IS
    BEGIN
        BEGIN
            DELETE FROM AMD_PARAM_CHANGES ;
        EXCEPTION WHEN OTHERS THEN
            NULL ; -- ignore
        END ;
        DELETE FROM AMD_PARAMS ;
        COMMIT ;
        RETURN TRUE ;
    END DeleteParameters ;
    FUNCTION CreateParameters RETURN BOOLEAN IS

        init_error EXCEPTION ;

        PROCEDURE InsertAmdParam(pParam_key IN AMD_PARAMS.param_key%TYPE,
            pParam_description IN AMD_PARAMS.param_description%TYPE,
            pParam_value IN AMD_PARAM_CHANGES.param_value%TYPE,
            pUser_id IN AMD_PARAM_CHANGES.user_id%TYPE DEFAULT 'c970183')  IS
            PROCEDURE ErrorMsg(pTableName IN VARCHAR2, pMsg IN VARCHAR2) IS
            BEGIN
                ROLLBACK ;
                Amd_Utils.InsertErrorMsg(
                    Amd_Utils.GetLoadNo(pSourceName => 'amd_test_data', pTableName => pTableName),
                    pParam_key, pParam_description, pParam_value, pUser_id, NULL, pMsg);
                COMMIT ;
            END ErrorMsg ;

        BEGIN
            BEGIN
                INSERT INTO AMD_PARAMS
                (param_key, param_description)
                VALUES (pParam_key, pParam_description) ;
            EXCEPTION WHEN OTHERS THEN
                ErrorMsg('amd_params', 'Could not insert') ;
                RAISE init_error ;
            END ;

            BEGIN
                INSERT INTO AMD_PARAM_CHANGES
                (param_key, effective_date, param_value, user_id)
                VALUES (pParam_key, SYSDATE, pParam_value, pUser_id) ;
            EXCEPTION WHEN OTHERS THEN
                ErrorMsg('amd_param_changes', 'Could not insert') ;
                RAISE init_error ;
            END ;
        END ;
    BEGIN
        InsertAmdParam(pParam_key => 'use_bssm_to_get_nsls',
            pParam_description => 'The amd_spare_parts_pkg uses this. If the value is Y it will retrieve NSN''s with keys like NSL#nnnnnn from the BSSM tables, when the value gets set to N it will generate its own sequence number for NSL''s.',
            pParam_value => 'Y') ;
        InsertAmdParam(pParam_key => 'consumable_reduction_factor',
            pParam_description => 'The amd_defaults package uses this.  It is applied to the gfp_price returned from FEDC when the item is QuasiRepairable (smr6=P) or Consumable (smr6=N).',
            pParam_value => '0.60') ;
        InsertAmdParam(pParam_key => 'engine_part_reduction_factor',
            pParam_description => 'The amd_defaults package uses this.  It is applied to the gfp_price returned from FEDC when the item is an Engine Part (planner_code = PSA or PSB).',
            pParam_value => '0.92') ;
        InsertAmdParam(pParam_key => 'non_engine_part_reductn_factor',
            pParam_description => 'The amd_defaults package uses this.  It is applied to the gfp_price returned from FEDC when the item is a Non-Engine Part (planner_code is not = PSA and planner_code is not = PSB).',
            pParam_value => '0.79') ;
        InsertAmdParam(pParam_key => 'order_lead_time_consumable',
            pParam_description => 'This is used by the amd_defaults package, which is used by amd_spare_parts_pkg.',
            pParam_value => '270') ;
        InsertAmdParam(pParam_key => 'order_lead_time_repairable',
            pParam_description => 'This is used by the amd_defaults package, which is used by amd_spare_parts_pkg.',
            pParam_value => '540') ;
        InsertAmdParam(pParam_key => 'order_quantity',
            pParam_description => 'This is used by the amd_defaults package, which is used by the amd_spare_parts_pkg.',
            pParam_value => '1') ;
        InsertAmdParam(pParam_key => 'order_uom',
            pParam_description => 'This is used by the amd_defaults package, which is used by the amd_spare_parts_pkg.',
            pParam_value => 'PC') ;
        InsertAmdParam(pParam_key => 'shelf_life',
            pParam_description => 'This is used by the amd_defaults package, which is used by the amd_spare_parts_pkg.',
            pParam_value => '999998') ;
        InsertAmdParam(pParam_key => 'condemn_avg',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'distrib_uom',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'nrts_avg',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'disposal_cost',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'off_base_turn_around',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'qpei_weighted',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'rts_avg',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'scrap_value',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'time_to_repair_on_base_avg',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        InsertAmdParam(pParam_key => 'unit_volume',
            pParam_description => 'todo - needs to be set to a valid value.',
            pParam_value => '0') ;
        COMMIT ;
        RETURN TRUE ;
    EXCEPTION WHEN init_error THEN
        RETURN FALSE ;
    END ;

    FUNCTION TestInsertNewPrimePart RETURN BOOLEAN IS
        RetVal1 NUMBER ;
    BEGIN
        --RetVal1 := AMD_OWNER.AMD_SPARE_PARTS_PKG.INSERTROW ( '17P1A7006-502', '88277', NULL, NULL, NULL,  'F77', 'Test the insertion of a new Prime Part', NULL, NULL, NULL, 'Y', NULL, NULL, NULL, NULL, 191.809780092593, '1560013353279', 'C', 'R', 'PAODDT', 'AFA', '','', '', '' );
        COMMIT ;
        dbms_output.put_line('RetVal1 = ' || RetVal1) ;
        IF RetVal1 = Amd_Spare_Parts_Pkg.SUCCESS THEN
            RETURN TRUE ;
        ELSE
            RETURN FALSE ;
        END IF ;
    END TestInsertNewPrimePart ;

    FUNCTION TestUpdEquivToPrime RETURN BOOLEAN IS
        RetVal2 NUMBER ;
    BEGIN
        --RetVal2 := AMD_OWNER.AMD_SPARE_PARTS_PKG.UPDATEROW ( '17P1A7006-501', '88277', NULL, NULL, NULL,  'F77', 'Test Change from Equiv to Prime', NULL, NULL, NULL, 'Y', NULL, NULL, NULL, NULL, 191.809780092593, '1560013353279', 'C', 'R', 'PAODDT', 'AFA', '', '', '', '' );
        COMMIT ;
        dbms_output.put_line('RetVal2 = ' || RetVal2) ;
        IF RetVal2 = Amd_Spare_Parts_Pkg.SUCCESS THEN
            RETURN TRUE ;
        ELSE
            RETURN FALSE ;
        END IF ;
    END TestUpdEquivToPrime ;

    PROCEDURE sleep(secs IN NUMBER) IS
        ss VARCHAR2(2) ;
    BEGIN
        ss := TO_CHAR(SYSDATE,'ss') ;
        WHILE TO_NUMBER(ss) + secs > TO_NUMBER(TO_CHAR(SYSDATE,'ss'))
        LOOP
            NULL ;
        END LOOP ;
    END ;
    FUNCTION test_amd_spare_parts_pkg RETURN BOOLEAN IS
        result BOOLEAN ;
        RetVal2 NUMBER ;
    BEGIN
        IF TestInsertNewPrimePart() THEN
            dbms_output.put_line('TestInsertNewPrimePart OK') ;
            -- must sleep for a couple of sec's otherwise
            -- the generated key with the timestamp
            -- might match a previous one - this acutally
            -- happened that is why I, DSE, put this here
            sleep(5) ;
            IF TestUpdEquivToPrime() THEN
                dbms_output.put_line('TestUpdEquivToPrime OK') ;
            ELSE
                RETURN FALSE ;
            END IF ;
        ELSE
            RETURN FALSE ;
        END IF ;
        RETURN TRUE ;
    END test_amd_spare_parts_pkg ;

    FUNCTION DeleteAmdSparePart(pNsi_sid IN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE) RETURN BOOLEAN IS
    BEGIN
        BEGIN
            DELETE FROM AMD_DEMANDS WHERE nsi_sid = pNsi_sid ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_demands: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        BEGIN
            DELETE FROM AMD_MAINT_TASK_DISTRIBS WHERE nsi_sid = pNsi_sid ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_maint_task_distribs: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        BEGIN
            DELETE FROM AMD_PART_LOCS WHERE nsi_sid = pNsi_sid ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_part_locs: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        BEGIN
            DELETE FROM AMD_NATIONAL_STOCK_ITEMS WHERE nsi_sid = pNsi_sid ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_national_stock_items: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        BEGIN
            DELETE FROM AMD_ON_HAND_INVS
            WHERE part_no IN
                (SELECT part_no FROM AMD_SPARE_PARTS
                 WHERE nsn IN
                 (SELECT nsn FROM AMD_NSNS
                 WHERE nsi_sid = pNsi_sid)) ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_spare_invs: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        BEGIN
            DELETE FROM AMD_IN_REPAIR
            WHERE part_no IN
                (SELECT part_no FROM AMD_SPARE_PARTS
                 WHERE nsn IN
                 (SELECT nsn FROM AMD_NSNS
                 WHERE nsi_sid = pNsi_sid)) ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_spare_invs: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        BEGIN
            DELETE FROM AMD_ON_ORDER
            WHERE part_no IN
                (SELECT part_no FROM AMD_SPARE_PARTS
                 WHERE nsn IN
                 (SELECT nsn FROM AMD_NSNS
                 WHERE nsi_sid = pNsi_sid)) ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_spare_invs: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        BEGIN
            DELETE FROM AMD_SPARE_PARTS WHERE nsn IN (SELECT nsn FROM AMD_NSNS WHERE nsi_sid = pNsi_sid) ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_spare_parts: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        BEGIN
            DELETE AMD_NSNS WHERE nsi_sid = pNsi_sid ;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL ; -- do nothing
            WHEN OTHERS THEN
                dbms_output.put_line('amd_nsns: sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM) ;
                RETURN FALSE ;
        END ;

        COMMIT ;

        RETURN TRUE ;
    END DeleteAmdSparePart ;

    FUNCTION DeleteAmdSpareParts RETURN BOOLEAN IS
    BEGIN
        DELETE FROM AMD_DEMANDS ;
        DELETE FROM AMD_MAINT_TASK_DISTRIBS ;
        DELETE FROM AMD_PART_LOCS ;
        DELETE FROM AMD_NATIONAL_STOCK_ITEMS ;
        DELETE FROM AMD_ON_HAND_INVS ;
        DELETE FROM AMD_IN_REPAIR ;
        DELETE FROM AMD_ON_ORDER ;
        DELETE FROM AMD_SPARE_PARTS ;
        DELETE FROM AMD_NSNS ;
        DELETE FROM AMD_NSI_PARTS ;
        COMMIT ;
        RETURN TRUE ;
    EXCEPTION WHEN OTHERS THEN
        dbms_output.put_line('SQLCODE = ' || SQLCODE || ' SQLERRM = ' || SQLERRM ) ;
        RETURN FALSE ;
    END DeleteAmdSpareParts ;

    /* This function can be used in place of the Java diff routine.
      However, it is less generic tham the Java diff routine, but
      it could be adapted to other data that require this functionality.
      */
    FUNCTION Diff RETURN NUMBER IS

        /* Return codes */
        SUCCESS                        CONSTANT NUMBER := 0 ;
        FAILURE                        CONSTANT NUMBER := 4 ;
        CANNOT_GET_NSI_SID            CONSTANT NUMBER := 8 ;
        CANNOT_GET_ITEM_DATA        CONSTANT NUMBER := 12 ;
        CANNOT_GET_NSI_PARTS_DATA    CONSTANT NUMBER := 16 ;
        GET_PART_DATA_ERROR            CONSTANT NUMBER := 20 ;
        GET_CURRENT_DATA_ERROR        CONSTANT NUMBER := 24 ;
        CURRENT_DATA_NOT_FOUND        CONSTANT NUMBER := 30 ;

        rows_read                    NUMBER := 0 ;
        rows_inserted                NUMBER := 0 ;
        rows_updated                NUMBER := 0 ;
        rows_deleted                NUMBER := 0 ;

        CURSOR newData IS
            SELECT *
            FROM TMP_AMD_SPARE_PARTS
            ORDER BY nsn ASC, prime_ind DESC ;

        oldParts    AMD_SPARE_PARTS%ROWTYPE := NULL ;

        result             NUMBER := NULL ;
        nsi_sid            AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE := NULL ;
        nsn_type        AMD_NSNS.nsn_type%TYPE := NULL ;
        item_type         AMD_NATIONAL_STOCK_ITEMS.item_type%TYPE := NULL ;
        order_quantity     AMD_NATIONAL_STOCK_ITEMS.order_quantity%TYPE := NULL ;
        planner_code     AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE := NULL ;
        smr_code         AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE := NULL ;
        prime_ind        AMD_NSI_PARTS.prime_ind%TYPE := NULL ;

        FUNCTION ErrorMsg(pMsg IN VARCHAR2, pTableName IN VARCHAR2, pData_line_no IN AMD_LOAD_DETAILS.data_line_no%TYPE, pPart_no IN AMD_SPARE_PARTS.part_no%TYPE, pMfgr IN AMD_SPARE_PARTS.mfgr%TYPE, pNsn IN AMD_SPARE_PARTS.nsn%TYPE, pReturnCode IN NUMBER) RETURN NUMBER IS
        BEGIN
            ROLLBACK ;
            dbms_output.put_line(pMsg) ;
            dbms_output.put_line('TableName=' || pTableName) ;
            dbms_output.put_line('Data_line_no=' || pData_line_no) ;
            dbms_output.put_line('part_no=' || pPart_no || ' mfgr=' || pMfgr || ' nsn=' || pNsn || ' ReturnCode=' || pReturnCode) ;
            Amd_Utils.InsertErrorMsg (
                pLoad_no => Amd_Utils.GetLoadNo(pSourceName => 'Diff', pTableName => pTableName),
                pData_line_no => pData_line_no,
                pData_line => 'amd_test_data',
                pKey_1 => pPart_no,
                pKey_2 => pMfgr,
                pKey_3 => pNsn,
                pKey_4 => pReturnCode,
                pKey_5 => to_char(sysdate,'MM/DD/YYYY HH:MM:SS'),
                pComments => pMsg) ;
            COMMIT ;
            RETURN  pReturnCode ;
        END ;

        FUNCTION InsertRow(newRec IN TMP_AMD_SPARE_PARTS%ROWTYPE) RETURN NUMBER IS
        BEGIN
             /*
            return amd_spare_parts_pkg.InsertRow(newRec.part_no,
                newRec.mfgr,
                newRec.date_icp,
                newRec.disposal_cost,
                newRec.erc,
                newRec.icp_ind,
                newRec.nomenclature,
                newRec.order_lead_time,
                newRec.order_quantity,
                newRec.order_uom,
                newRec.prime_ind,
                newRec.scrap_value,
                newRec.serial_flag,
                newRec.shelf_life,
                newRec.unit_cost,
                newRec.unit_volume,
                newRec.nsn,
                newRec.nsn_type,
                newRec.item_type,
                newRec.smr_code,
                newRec.planner_code, '', '', '', '') ;
                */
                NULL ;
        END InsertRow ;

        FUNCTION UpdateRow(newRec IN TMP_AMD_SPARE_PARTS%ROWTYPE) RETURN NUMBER IS
        BEGIN
             NULL ;
             /*
            return amd_spare_parts_pkg.UpdateRow
                 (newRec.part_no,
                newRec.mfgr,
                newRec.date_icp,
                newRec.disposal_cost,
                newRec.erc,
                newRec.icp_ind,
                newRec.nomenclature,
                newRec.order_lead_time,
                newRec.order_quantity,
                newRec.order_uom,
                newRec.prime_ind,
                newRec.scrap_value,
                newRec.serial_flag,
                newRec.shelf_life,
                newRec.unit_cost,
                newRec.unit_volume,
                newRec.nsn,
                newRec.nsn_type,
                newRec.item_type,
                newRec.smr_code,
                newRec.planner_code, '', '', '', '') ;
                */
        END UpdateRow ;

        FUNCTION IsDifferent(pOldParts IN AMD_SPARE_PARTS%ROWTYPE,
            pItem_type IN AMD_NATIONAL_STOCK_ITEMS.item_type%TYPE,
            pOrder_quantity IN AMD_NATIONAL_STOCK_ITEMS.order_quantity%TYPE,
            pPlanner_code IN AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE,
            pSmr_code IN AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE,
            pNsn_type IN AMD_NSNS.nsn_type%TYPE,
            pPrime_ind IN AMD_NSI_PARTS.prime_ind%TYPE,
            pNewRec IN TMP_AMD_SPARE_PARTS%ROWTYPE) RETURN BOOLEAN IS
            result BOOLEAN := FALSE ;
        BEGIN
                result := (pNewRec.date_icp = pOldParts.date_icp) ;
                result := (result AND (pNewRec.disposal_cost = pOldParts.disposal_cost)) ;
                result := (result AND (pNewRec.erc = pOldParts.erc)) ;
                result := (result AND (pNewRec.icp_ind = pOldParts.icp_ind)) ;
                result := (result AND (pNewRec.nomenclature = pOldParts.nomenclature)) ;
                result := (result AND (pNewRec.order_lead_time = pOldParts.order_lead_time)) ;
                result := (result AND (pNewRec.order_uom = pOldParts.order_uom)) ;
                result := (result AND (pNewRec.prime_ind = pPrime_ind)) ;
                result := (result AND (pNewRec.scrap_value = pOldParts.scrap_value)) ;
                result := (result AND (pNewRec.serial_flag = pOldParts.serial_flag)) ;
                result := (result AND (pNewRec.shelf_life = pOldParts.shelf_life)) ;
                result := (result AND (pNewRec.unit_cost = pOldParts.unit_cost)) ;
                result := (result AND (pNewRec.unit_volume = pOldParts.unit_volume)) ;
                IF result AND pNewRec.prime_ind = 'Y' THEN
                    result := (result AND (pNewRec.nsn = pOldParts.nsn)) ;
                    result := (result AND (pNewRec.order_quantity = pOrder_quantity)) ;
                    result := (result AND (pNewRec.nsn_type = pNsn_type)) ;
                    result := (result AND (pNewRec.item_type = pItem_type)) ;
                    result := (result AND (pNewRec.smr_code = pSmr_code)) ;
                    result := (result AND (pNewRec.planner_code = pPlanner_code)) ;
                END IF ;
                RETURN result ;
        END IsDifferent ;

        FUNCTION DeleteRows RETURN NUMBER IS
            CURSOR deleteData IS
                SELECT part_no, mfgr, nomenclature
                FROM AMD_SPARE_PARTS
                WHERE action_code != Amd_Defaults.DELETE_ACTION
                MINUS
                SELECT part_no, mfgr, nomenclature
                FROM TMP_AMD_SPARE_PARTS parts ;
        BEGIN
            FOR oldRec IN deleteData LOOP
                result := Amd_Spare_Parts_Pkg.DeleteRow(oldRec.part_no, oldRec.mfgr, oldRec.nomenclature) ;
                IF result != Amd_Spare_Parts_Pkg.SUCCESS THEN
                    RETURN result ;
                END IF ;
                rows_deleted := rows_deleted + 1 ;
                COMMIT ;
            END LOOP ;
            RETURN Diff.SUCCESS ;
        END DeleteRows ;

        FUNCTION GetCurrentData(pNewRec IN TMP_AMD_SPARE_PARTS%ROWTYPE) RETURN NUMBER IS

            FUNCTION GetPartData(pNewRec IN TMP_AMD_SPARE_PARTS%ROWTYPE) RETURN NUMBER IS

                FUNCTION GetDataFromOtherTables RETURN NUMBER IS
                    result NUMBER := NULL ;

                    FUNCTION GetNsiSid(pNsn IN AMD_NSNS.nsn%TYPE) RETURN NUMBER IS
                    BEGIN
                        SELECT nsi_sid, nsn_type
                        INTO nsi_sid, nsn_type
                        FROM AMD_NSNS
                        WHERE nsn = pNsn ;
                        RETURN Diff.SUCCESS ;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            nsi_sid := NULL ;
                            nsn_type := NULL ;
                            RETURN Diff.SUCCESS ;
                        WHEN OTHERS THEN
                            RETURN ErrorMsg(pMsg => 'sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM ,
                                pTableName => 'amd_nsns',
                                pData_line_no => 1,
                                pPart_no => NULL,
                                pMfgr => NULL, pNsn => pNsn,
                                pReturnCode => Diff.CANNOT_GET_NSI_SID)  ;
                    END GetNsiSid ;

                    FUNCTION GetItemData RETURN NUMBER IS
                    BEGIN
                        SELECT item_type, order_quantity, planner_code, smr_code
                        INTO item_type, order_quantity, planner_code, smr_code
                        FROM AMD_NATIONAL_STOCK_ITEMS
                        WHERE nsi_sid = Diff.nsi_sid ;
                        RETURN Diff.SUCCESS ;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            item_type := NULL ;
                            order_quantity := NULL ;
                            planner_code := NULL ;
                            smr_code := NULL ;
                            RETURN Diff.SUCCESS ;
                        WHEN OTHERS THEN
                            RETURN ErrorMsg(pMsg => 'sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM ,
                                pTableName => 'amd_nsns',
                                pData_line_no => 2,
                                pPart_no => NULL,
                                pMfgr => NULL,
                                pNsn =>  NULL,
                                pReturnCode => Diff.CANNOT_GET_ITEM_DATA)  ;
                    END GetItemData;

                    FUNCTION GetNsiPartsData(pPart_no IN AMD_NSI_PARTS.part_no%TYPE) RETURN NUMBER IS
                    BEGIN
                        SELECT prime_ind INTO prime_ind
                        FROM AMD_NSI_PARTS
                        WHERE nsi_sid = Diff.nsi_sid
                        AND part_no = pPart_no
                        AND unassignment_date IS NULL ;
                        RETURN Diff.SUCCESS ;
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            prime_ind := NULL ;
                            RETURN Diff.SUCCESS ;
                        WHEN OTHERS THEN
                            RETURN ErrorMsg(pMsg => 'sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM ,
                                pTableName => 'amd_nsns',
                                pData_line_no => 3,
                                pPart_no => pPart_no,
                                pMfgr => NULL,
                                pNsn => TO_CHAR(nsi_sid),
                                pReturnCode => Diff.CANNOT_GET_NSI_PARTS_DATA)  ;
                    END GetNsiPartsData;

                BEGIN
                    result := GetNsiSid(pNewRec.nsn) ;
                    IF result = Diff.SUCCESS THEN
                        result := GetItemData() ;
                    END IF ;
                    IF result = Diff.SUCCESS THEN
                        result := GetNsiPartsData(pPart_no => pNewRec.part_no ) ;
                    END IF ;
                    RETURN result ;
                END GetDataFromOtherTables ;

            BEGIN
                SELECT * INTO oldParts
                FROM AMD_SPARE_PARTS
                WHERE part_no = pNewRec.part_no
                AND mfgr = pNewRec.mfgr ;
                RETURN GetDataFromOtherTables() ;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    RETURN Diff.CURRENT_DATA_NOT_FOUND ;
                WHEN OTHERS THEN
                    RETURN ErrorMsg(pMsg => 'sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM ,
                        pTableName => 'amd_nsns',
                        pData_line_no => 4,
                        pPart_no => pNewRec.part_no,
                        pMfgr => pNewRec.mfgr,
                        pNsn => pNewRec.nsn,
                        pReturnCode => Diff.GET_PART_DATA_ERROR)  ;
            END GetPartData ;

        BEGIN
            RETURN GetPartData(pNewRec => pNewRec) ;
        EXCEPTION WHEN OTHERS THEN
            RETURN ErrorMsg(pMsg => 'sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM ,
                pTableName => 'amd_nsns',
                pData_line_no => 5,
                pPart_no => pNewRec.part_no,
                pMfgr => pNewRec.mfgr,
                pNsn => pNewRec.nsn,
                pReturnCode => Diff.GET_CURRENT_DATA_ERROR)  ;
        END GetCurrentData;

    BEGIN --<<<-- Diff
        FOR newRec IN newData LOOP
            rows_read := rows_read + 1 ;
            result := GetCurrentData(pNewRec => newRec) ;
            IF result = Diff.CURRENT_DATA_NOT_FOUND THEN
                result := InsertRow(newRec) ;
                IF result = Amd_Spare_Parts_Pkg.SUCCESS THEN
                    rows_inserted := rows_inserted + 1 ;
                    COMMIT ;
                    result := Diff.SUCCESS ;
                END IF ;
            ELSIF result = Diff.SUCCESS THEN
                IF IsDifferent(oldParts, item_type, order_quantity,
                    planner_code, smr_code, nsn_type, prime_ind,
                    newRec ) THEN
                    result := UpdateRow(newRec) ;
                    IF result = Amd_Spare_Parts_Pkg.SUCCESS THEN
                        rows_updated := rows_updated + 1 ;
                        COMMIT ;
                        result := Diff.SUCCESS ;
                    END IF ;
                END IF ;
            END IF ;
            EXIT WHEN result != Diff.SUCCESS ;
        END LOOP ;
        dbms_output.put_line('rows_read=' || rows_read || ' rows_inserted=' || rows_inserted || ' rows_updated=' || rows_updated) ;
        IF result = Diff.SUCCESS THEN
            result := DeleteRows() ;
        END IF ;
        dbms_output.put_line('rows_deleted=' || rows_deleted) ;
        Amd_Utils.InsertErrorMsg (
            pLoad_no => Amd_Utils.GetLoadNo(pSourceName => 'Diff',
            pTableName => 'Diff'),
            pData_line_no => 6,
            pData_line => 'amd_test_data',
            pKey_1 => rows_read,
            pKey_2 => rows_inserted,
            pKey_3 => rows_updated,
            pKey_4 => rows_deleted,
            pKey_5 => SYSDATE,
            pComments => 'rows_read=' || rows_read ||' rows_inserted=' || rows_inserted || ' rows_updated=' || rows_updated || ' rows_deleted=' || rows_deleted) ;
        COMMIT ;
        RETURN result ;
    EXCEPTION WHEN OTHERS THEN
        IF result IS NULL THEN
            result := Diff.FAILURE ;
        END IF ;
        RETURN ErrorMsg(pMsg => 'sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM ,
            pTableName => 'amd_spare_parts',
            pData_line_no => 7,
            pPart_no => NULL,
            pMfgr => NULL,
            pNsn => NULL,
            pReturnCode => result)  ;
    END Diff ;

    FUNCTION PrimeExistForEachNsn(pDataSource IN data_source) RETURN BOOLEAN IS


        result BOOLEAN := TRUE ;

        FUNCTION IsGoodPartList RETURN BOOLEAN IS
            result BOOLEAN := TRUE ;

            nsi_sid AMD_NSI_PARTS.nsi_sid%TYPE := NULL ;
            prime_cnt NUMBER := 0 ;
            tactical_cnt NUMBER := 0 ;
            error_cnt NUMBER := 0 ;

            CURSOR partList IS
                SELECT
                    nsi_sid,
                    part_no,
                    prime_ind
                FROM AMD_NSI_PARTS
                WHERE unassignment_date IS NULL
                ORDER BY nsi_sid ;
            PROCEDURE reportError(pNsi_sid IN AMD_NSI_PARTS.nsi_sid%TYPE, pPrime_cnt IN NUMBER) IS
                CURSOR nsns IS
                    SELECT nsn
                    FROM AMD_NSNS
                    WHERE nsi_sid = pNsi_sid ;

                nsn AMD_NSNS.nsn%TYPE := NULL ;
                tactical AMD_NATIONAL_STOCK_ITEMS.tactical%TYPE ;
                CURSOR sourceData IS
                    SELECT
                        nsn,
                        part_no,
                        mfgr,
                        prime_ind,
                        unit_cost,
                        smr_code
                    FROM TMP_AMD_SPARE_PARTS
                    WHERE nsn = reportError.nsn ;
            BEGIN
                IF pPrime_cnt = 0 THEN
                    dbms_output.put('No prime for nsi_sid=' || pNsi_sid) ;
                ELSE
                    dbms_output.put('Multiple primes for nsi_sid=' || pNsi_sid) ;
                END IF ;
                FOR nsnRec IN nsns LOOP
                    reportError.nsn := nsnRec.nsn ;
                    FOR rec IN sourceData LOOP
                        SELECT tactical
                        INTO reportError.tactical
                        FROM AMD_NATIONAL_STOCK_ITEMS
                        WHERE nsi_sid = pNsi_sid ;
                        IF reportError.tactical = 'Y' THEN
                            tactical_cnt := tactical_cnt + 1 ;
                        END IF ;
                        dbms_output.put_line(' part_no=' || rec.part_no || ' mfgr=' || rec.mfgr || ' nsn=' || rec.nsn ) ;
                    END LOOP ;
                END LOOP ;
            END reportError ;
        BEGIN
            FOR partList_rec IN partList LOOP
                IF nsi_sid IS NULL THEN
                    nsi_sid := partList_rec.nsi_sid ;
                END IF ;
                IF nsi_sid != partList_rec.nsi_sid THEN
                    IF prime_cnt = 1 THEN
                        NULL ;
                    ELSE
                        result := FALSE ;
                        error_cnt := error_cnt + 1 ;
                        reportError(pNsi_sid => nsi_sid, pPrime_cnt => prime_cnt) ;
                    END IF ;
                    nsi_sid := partList_rec.nsi_sid ;
                    prime_cnt := 0 ;
                END IF ;
                IF partList_rec.prime_ind = Amd_Defaults.PRIME_PART THEN
                    prime_cnt := prime_cnt + 1 ;
                END IF ;
            END LOOP ;
            IF error_cnt > 0 THEN
                dbms_output.put_line('There were ' || error_cnt || ' errors. ' || tactical_cnt || ' were marked as tactical.') ;
            END IF ;
            RETURN result ;
        END IsGoodPartList ;

        FUNCTION IsGoodSourceData RETURN BOOLEAN IS
            result BOOLEAN := TRUE ;
            prime_cnt NUMBER := 0 ;
            error_cnt NUMBER := 0 ;

            CURSOR sourceData IS
                SELECT *
                FROM TMP_AMD_SPARE_PARTS
                ORDER BY nsn, part_no, mfgr ;
            nsn TMP_AMD_SPARE_PARTS.nsn%TYPE := NULL ;

            PROCEDURE reportError(pNsn TMP_AMD_SPARE_PARTS.nsn%TYPE, pPrime_cnt IN NUMBER) IS
            BEGIN
                IF pPrime_cnt = 0 THEN
                    dbms_output.put_line('No prime for nsn=' || pNsn) ;
                ELSE
                    dbms_output.put_line(prime_cnt || ' primes for nsn=' || pNsn) ;
                END IF ;
            END reportError ;
        BEGIN
            FOR rec IN sourceData LOOP
                IF nsn IS NULL THEN
                    nsn := rec.nsn ;
                END IF ;
                IF nsn != rec.nsn THEN
                    IF prime_cnt = 1 THEN
                        NULL ;
                    ELSE
                        result := FALSE ;
                        error_cnt := error_cnt + 1 ;
                        reportError(pNsn => nsn,pPrime_cnt => prime_cnt) ;
                    END IF ;
                    nsn := rec.nsn ;
                    prime_cnt := 0 ;
                END IF ;
                IF rec.prime_ind = Amd_Defaults.PRIME_PART THEN
                    prime_cnt := prime_cnt + 1 ;
                END IF ;
            END LOOP ;
             IF error_cnt > 0 THEN
                dbms_output.put_line('There were ' || error_cnt || ' errors.') ;
            END IF ;
             RETURN result ;
        END IsGoodSourceData ;
    BEGIN
        IF pDataSource = NSI_PARTS THEN
            result := IsGoodPartList() ;
        ELSE
            result := IsGoodSourceData() ;
        END IF ;
        IF result THEN
            dbms_output.put_line('Only 1 prime/nsi_sid in amd_nsi_parts - the system is correct.') ;
        END IF ;
        RETURN result ;
    END PrimeExistForEachNsn ;

    FUNCTION PrimeCheckForTmpAmdSpareParts RETURN BOOLEAN IS
    BEGIN
        RETURN PrimeExistForEachNsn(pDataSource => TMP_SPARE_PARTS ) ;
    END PrimeCheckForTmpAmdSpareParts ;

    FUNCTION PrimeCheckForAmdNsiParts RETURN BOOLEAN IS
    BEGIN
        RETURN PrimeExistForEachNsn(pDataSource => NSI_PARTS ) ;
    END PrimeCheckForAmdNsiParts ;

    FUNCTION TestDefaults RETURN BOOLEAN IS
    BEGIN
        dbms_output.put_line('CONDEMN_AVG=' || Amd_Defaults.CONDEMN_AVG) ;
        dbms_output.put_line('CONSUMABLE=' || Amd_Defaults.CONSUMABLE) ;
        dbms_output.put_line('DELETE_ACTION=' || Amd_Defaults.DELETE_ACTION) ;
        dbms_output.put_line('DISPOSAL_COST=' || Amd_Defaults.DISPOSAL_COST) ;
        dbms_output.put_line('DISTRIB_UOM=' || Amd_Defaults.DISTRIB_UOM) ;
        dbms_output.put_line('INSERT_ACTION=' || Amd_Defaults.INSERT_ACTION) ;
        dbms_output.put_line('NOT_PRIME_PART=' || Amd_Defaults.NOT_PRIME_PART) ;
        dbms_output.put_line('NRTS_AVG=' || Amd_Defaults.NRTS_AVG) ;
        dbms_output.put_line('OFF_BASE_TURN_AROUND=' || Amd_Defaults.OFF_BASE_TURN_AROUND) ;
        dbms_output.put_line('ORDER_LEAD_TIME (repairable)=' || Amd_Defaults.GetOrderLeadTime(Amd_Defaults.REPAIRABLE)) ;
        dbms_output.put_line('ORDER_LEAD_TIME (consumable)=' || Amd_Defaults.GetOrderLeadTime(Amd_Defaults.CONSUMABLE)) ;
        dbms_output.put_line('ORDER_QUANTITY=' || Amd_Defaults.ORDER_QUANTITY) ;
        dbms_output.put_line('ORDER_UOM=' || Amd_Defaults.ORDER_UOM) ;
        dbms_output.put_line('PRIME_PART=' || Amd_Defaults.PRIME_PART ) ;
        dbms_output.put_line('QPEI_WEIGHTED=' || Amd_Defaults.QPEI_WEIGHTED) ;
        dbms_output.put_line('REPAIRABLE=' || Amd_Defaults.REPAIRABLE) ;
        dbms_output.put_line('RTS_AVG=' || Amd_Defaults.RTS_AVG ) ;
        dbms_output.put_line('SCRAP_VALUE=' || Amd_Defaults.SCRAP_VALUE) ;
        dbms_output.put_line('SHELF_LIFE=' || Amd_Defaults.SHELF_LIFE) ;
        dbms_output.put_line('TIME_TO_REPAIR_ON_BASE_AVG=' || Amd_Defaults.TIME_TO_REPAIR_ON_BASE_AVG) ;
        dbms_output.put_line('UNIT_COST=' || Amd_Defaults.GetUnitCost(
            pNsn => '1660014172839',
            pPart_no => '174081-13',
            pMfgr => '49315',
            pSmr_code => 'P2345N',
            pPlanner_code => 'PSA')) ;

        dbms_output.put_line('UNIT_VOLUME=' || Amd_Defaults.UNIT_VOLUME) ;
        dbms_output.put_line('UPDATE_ACTION=' || Amd_Defaults.UPDATE_ACTION) ;
        dbms_output.put_line('USE_BSSM_TO_GET_NSLs=' || Amd_Defaults.USE_BSSM_TO_GET_NSLs) ;
        dbms_output.put_line('COST_TO_REPAIR_ONBASE=' || Amd_Defaults.COST_TO_REPAIR_ONBASE) ;
        dbms_output.put_line('TIME_TO_REPAIR_ONBASE=' || Amd_Defaults.TIME_TO_REPAIR_ONBASE) ;
        dbms_output.put_line('TIME_TO_REPAIR_OFFBASE=' || Amd_Defaults.TIME_TO_REPAIR_OFFBASE) ;
        dbms_output.put_line('UNIT_COST_FACTOR_OFFBASE=' || Amd_Defaults.UNIT_COST_FACTOR_OFFBASE) ;
        RETURN TRUE ;
    END TestDefaults ;

    FUNCTION TestGetNsiSid RETURN BOOLEAN IS
        nsn AMD_NSNS.nsn%TYPE := '12424242' ;
        nsi_sid AMD_NSNS.nsi_sid%TYPE ;
        part_no AMD_NSI_PARTS.part_no%TYPE := '123434' ;
    BEGIN
        BEGIN
            nsi_sid := Amd_Utils.GetNsiSid(pNsn => nsn) ;
        EXCEPTION WHEN NO_DATA_FOUND THEN
            dbms_output.put_line('no data found') ;
        END ;
        BEGIN
            nsi_sid := Amd_Utils.GetNsiSid(pPart_no => part_no) ;
        EXCEPTION WHEN NO_DATA_FOUND THEN
            dbms_output.put_line('no data found') ;
        END ;
        RETURN TRUE ;
    END TestGetNsiSid ;

    FUNCTION revision RETURN VARCHAR2 IS
    BEGIN
         RETURN '$Revision:   1.15  $' ;
    END revision ;

    PROCEDURE helloWorld IS
    BEGIN
         dbms_output.put_line('Hello World') ;
    END helloWorld ;

    PROCEDURE show_message(pmv_msg_in IN CLOB) IS
    BEGIN
      IF LENGTH(pmv_msg_in)  > 255 THEN
         dbms_output.put_line(SUBSTR(pmv_msg_in,1,255));
         show_message(SUBSTR(pmv_msg_in,256,LENGTH(pmv_msg_in)));
      ELSE
         dbms_output.put_line(pmv_msg_in);
      END IF;
    END show_message ;


    PROCEDURE printclobout(result IN OUT NOCOPY CLOB) IS
    xmlstr VARCHAR2(32767);
    line VARCHAR2(2000);
    BEGIN
      xmlstr := dbms_lob.SUBSTR(result,32767);
      LOOP
        EXIT WHEN xmlstr IS NULL;
        line := SUBSTR(xmlstr,1,INSTR(xmlstr,'>',1,2));
        dbms_output.put_line(line);
        xmlstr := SUBSTR(xmlstr,INSTR(xmlstr,'>',1,2)+1);
      END LOOP;
    END printclobout ;

    PROCEDURE genXml IS

              theXml XmlType ;

    BEGIN
        DECLARE
               theClob CLOB := theXml.getClobVal() ;
        BEGIN
              printClobOut(theClob ) ;
        END ;
    END genXml ;
/*
    PROCEDURE orderInfoXml IS
              theXml XmlType ;
        CURSOR orderInfo IS
        SELECT
            xmlelement("ORDER",
              xmlelement("TRANHEADER",
                xmlelement("SITE",'LBC17'),
                xmlelement("TRANSRC",'BATCH'),
                xmlelement("TRANPRI",DECODE(action_code,'A','002','C','002','007')),
                xmlelement("TRANTYPE",'ORDER_INFO'),
                xmlelement("TRANACT",DECODE(action_code, 'A', 'I', 'C', 'I', action_code)),
                xmlelement("TRANDTE",TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')),
                xmlelement("ERRORFLG",'N')
                ),
              xmlelement("PARTHEADER",
                xmlelement("SRCSYS",PH_SOURCE_SYSTEM),
                xmlelement("CAGE",PH_CAGE_CODE),
                xmlelement("PART",PH_PART_NO),
                xmlelement("PCAGE",PH_PRIME_CAGE),
                xmlelement("PRIME",PH_PRIME_PART),
                xmlelement("NOUN",PH_NOUN),
                xmlelement("RCMIND",PH_RCM_IND),
                xmlelement("COG",PH_COG),
                xmlelement("FSC",PH_FSC),
                xmlelement("NIIN",PH_NIIN),
                xmlelement("ASSETMGR",PH_RESP_ASSET_MGR),
                xmlelement("PLAN",PH_PLANNED_PART),
                xmlelement("LEADTIME",PH_LEAD_TIME),
                xmlelement("PRICETYPE",PH_PRICE_TYPE),
                xmlelement("PRICE",PH_PRICE),
                xmlelement("FISCAL",PH_PRICE_FISCAL_YEAR),
                xmlelement("INDENT",PH_INDENTURE)
               ),
            xmlelement("DATA",
              xmlelement("ORDERNO",ORDER_NO),
              xmlelement("SITE",SITE_LOCATION),
              xmlelement("CREATED",TO_CHAR(CREATED_DATE, 'YYYYMMDDHH24MISS')),
              xmlelement("STATUS",STATUS)
             )
         ) AS theData
        FROM TMP_A2A_ORDER_INFO, amd_part_header_v
        WHERE part_no = ph_part_no ;

        theClob CLOB ; 

    BEGIN
        FOR rec IN orderInfo LOOP
               theXml := rec.theData ;
               theClob := theXml.getClobVal() ;
              printClobOut(theClob ) ;
        END LOOP ;
    END orderInfoXml ; */
 /*
    PROCEDURE orderInfoLineXml IS
              theXml XmlType ;
        CURSOR orderInfoLine IS
        SELECT
            xmlelement("ORDERLINE",
              xmlelement("TRANHEADER",
                xmlelement("SITE",'LBC17'),
                xmlelement("TRANSRC",'BATCH'),
                xmlelement("TRANPRI",DECODE(action_code,'A','002','C','002','007')),
                xmlelement("TRANTYPE",'ORDER_INFO'),
                xmlelement("TRANACT",DECODE(action_code, 'A', 'I', 'C', 'I', action_code)),
                xmlelement("TRANDTE",TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')),
                xmlelement("ERRORFLG",'N')
                ),
              xmlelement("PARTHEADER",
                xmlelement("SRCSYS",PH_SOURCE_SYSTEM),
                xmlelement("CAGE",PH_CAGE_CODE),
                xmlelement("PART",PH_PART_NO),
                xmlelement("PCAGE",PH_PRIME_CAGE),
                xmlelement("PRIME",PH_PRIME_PART),
                xmlelement("NOUN",PH_NOUN),
                xmlelement("RCMIND",PH_RCM_IND),
                xmlelement("COG",PH_COG),
                xmlelement("FSC",PH_FSC),
                xmlelement("NIIN",PH_NIIN),
                xmlelement("ASSETMGR",PH_RESP_ASSET_MGR),
                xmlelement("PLAN",PH_PLANNED_PART),
                xmlelement("LEADTIME",PH_LEAD_TIME),
                xmlelement("PRICETYPE",PH_PRICE_TYPE),
                xmlelement("PRICE",PH_PRICE),
                xmlelement("FISCAL",PH_PRICE_FISCAL_YEAR),
                xmlelement("INDENT",PH_INDENTURE)
               ),
            xmlelement("DATA",
              xmlelement("ORDERNO",ORDER_NO),
              xmlelement("SITE",SITE_LOCATION),
              xmlelement("CREATED",TO_CHAR(CREATED_DATE, 'YYYYMMDDHH24MISS')),
              xmlelement("STATUS",STATUS),
              xmlelement("LINE",LINE),
              xmlelement("QTYORDERED",QTY_ORDERED),
              xmlelement("QTYREC",QTY_RECEIVED)
             )
         ) AS theData
        FROM TMP_A2A_ORDER_INFO_LINE, amd_part_header_v
        WHERE part_no = ph_part_no ;

        theClob CLOB ;

    BEGIN
        FOR rec IN orderInfoLine LOOP
               theXml := rec.theData ;
               theClob := theXml.getClobVal() ;
              printClobOut(theClob ) ;
        END LOOP ;
    END orderInfoLineXml ; */

    PROCEDURE fix_national_stock_items IS
              CURSOR tmp_parts IS
              SELECT part_no, nsn FROM TMP_AMD_SPARE_PARTS ;
              plannerCodeCleaned AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE ;

              CURSOR items IS
              SELECT prime_part_no, nsn FROM AMD_NATIONAL_STOCK_ITEMS ;
              tmpCnt NUMBER := 0 ;
              itemCnt NUMBER := 0 ;
              threshold CONSTANT NUMBER := 500 ;
              updateCnt NUMBER := 0 ;
              recCnt NUMBER := 0 ;

              FUNCTION isValidPlannerCode(planner_code IN VARCHAR2) RETURN BOOLEAN IS
                         plannerCode AMD_PLANNERS.planner_code%TYPE ;
              BEGIN
                     SELECT planner_code INTO plannerCode FROM AMD_PLANNERS WHERE planner_code = isValidPlannerCode.planner_code ;
                   RETURN TRUE ;
              EXCEPTION WHEN standard.NO_DATA_FOUND THEN
                     RETURN FALSE ;
              END isValidPlannerCode ;
    BEGIN
         FOR rec IN tmp_parts LOOP
              recCnt := recCnt + 1 ;
              plannerCodeCleaned := Amd_Clean_Data.getPlannerCode(rec.nsn, rec.part_no) ;
             IF isValidPlannerCode(plannerCodeCleaned) THEN
                 IF plannerCodeCleaned IS NOT NULL
                 AND plannerCodeCleaned > '' THEN
                      tmpCnt := tmpCnt + 1 ;
                 END IF ;
                  UPDATE TMP_AMD_SPARE_PARTS
                 SET planner_code_cleaned = plannerCodeCleaned
                 WHERE part_no = rec.part_no
                 AND nsn = rec.nsn ;
                  updateCnt := updateCnt + 1 ;
                 IF MOD(updateCnt,threshold) = 0 THEN
                     COMMIT ;
                 END IF ;
             END IF ;
         END LOOP ;

         dbms_output.put_line('Processed ' || recCnt || ' parts.  Loaded ' || tmpCnt || ' tmp parts with planner_code_cleaned.'  || 'Updated ' || updateCnt || ' rows.') ;
         recCnt := 0 ;
         updateCnt := 0 ;

         FOR rec IN items LOOP
              recCnt := recCnt + 1 ;
              plannerCodeCleaned := Amd_Clean_Data.getPlannerCode(rec.nsn, rec.prime_part_no) ;
             IF isValidPlannerCode(plannerCodeCleaned) THEN
                 IF plannerCodeCleaned IS NOT NULL
                 AND plannerCodeCleaned > '' THEN
                      itemCnt := itemCnt + 1 ;
                 END IF ;
                 UPDATE AMD_NATIONAL_STOCK_ITEMS
                 SET planner_code_cleaned = plannerCodeCleaned
                 WHERE prime_part_no = rec.prime_part_no
                 AND nsn = rec.nsn ;
                  updateCnt := updateCnt + 1 ;
                 IF MOD(updateCnt,threshold) = 0 THEN
                     COMMIT ;
                 END IF ;
             END IF ;
         END LOOP ;
         dbms_output.put_line('Processed ' || recCnt || ' items.  Loaded ' || itemCnt || ' items with planner_code_cleaned.'  || 'Updated ' || updateCnt || ' rows.') ;

    END ;
    
    procedure setSequence(value in number) is
    begin
        theSequence := value ;
    end setSequence ;
    
    function setSequence(value in number) return number is
    begin
        theSequence := value ;
        return theSequence ;
    end setSequence ;
    
    function nextSequence(key in varchar2 := '') return number is
    begin
        if key = prevKey then
            null ;
        else
            theSequence := 0 ;
            prevKey := key ;
        end if;
        theSequence := theSequence + 1 ;
        return theSequence ;
    end nextSequence ;
    
    function getSequence return number is
    begin
        return theSequence ;
    end getSequence ;        

END;
/


DROP PACKAGE BODY AMD_OWNER.AMD_TMAPI_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_tmapi_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.2  $
     $Date:   Dec 01 2005 09:48:18  $
    $Workfile:   amd_tmapi_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\AMD_TMAPI_PKG.PKB-arc  $

      Rev 1.2   Dec 01 2005 09:48:18   zf297a
   added pvcs keywords
*/
	   -- largeunitcost used when unit cost is null to force to lowest priority
	   -- smallunitcost used to ensure primary part has highest priority
	LARGEUNITCOST constant number := 999999999;
	SMALLUNITCOST constant number := -1;
	function GetPriority(pNsn amd_spare_parts.nsn%type, pPartNo amd_spare_parts.part_no%type) return number is
			priority number := null;
			cursor nsnPriority_cur is
				select nsn, part_no, rownum
				from
					(
				 		select
							asp.nsn,
				  			asp.part_no,
							decode(ansi.prime_part_no, asp.part_no, SMALLUNITCOST,
								nvl(decode(asp.unit_cost, null, asp.unit_cost_defaulted, asp.unit_cost), LARGEUNITCOST)) as unitCost
						from
							amd_spare_parts asp, amd_national_stock_items ansi
				 		where
							asp.nsn = pNsn and
							asp.nsn = ansi.nsn
						order by unitCost desc
	 				);
			nsnPrec nsnPriority_cur%rowtype;

	begin
			if (not nsnPriority_cur%isOpen) then
			   open nsnPriority_cur;
			end if;
			loop
		 		fetch nsnPriority_cur into nsnPrec;
				exit when not nsnPriority_cur%FOUND;
				if (nsnPrec.part_no = pPartNo) then
				   priority := nsnPrec.rownum;
				   exit;
				end if;
			end loop;
			close nsnPriority_cur;
	 		return priority;
	exception
		when no_data_found then
			return null;
	end GetPriority;
end amd_tmapi_pkg;
/


DROP PACKAGE BODY AMD_OWNER.AMD_UTILS;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.Amd_Utils AS
/*
       $Author:   zf297a  $
     $Revision:   1.66  $
         $Date:   19 Oct 2015
     $Workfile:   amd_utils.pkb  $
     $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_utils.pkb-arc  $

      Rev 1.66   25 Jul 2011 15:33:33  Douglas Elder
     commented out dbms_output for rank 

      Rev 1.65   25 Jul 2011 15:33:33   zf297a
     Fixed rank's and convertToBase alphabet to include the letter K which had been inccorrectly coded as an I 

   
      Rev 1.64   24 Jun 2009 09:32:36   zf297a
   Modified rank to use 36 characters 0 to 9 and A to Z.  Implemented interfaces convertToBase and groupPriority.
   
      Rev 1.63   24 Mar 2009 15:39:06   zf297a
   Implemented inferfaces getDebug, setDebug, getDebugCnt, setDebugCnt, getDebugThreshold, setDebugThreshold, getSpoPrimePartNo, isSpoPartYorN, getLastLoadDetail, and emptyTraceTables.
   
      Rev 1.62   20 Mar 2009 09:17:32   zf297a
   Redefined isPartConsumable to be NOT isPartRepairable
   
      Rev 1.61   09 Sep 2008 15:24:04   zf297a
   Implemented  interfaces:    
   function isDiffYorN(oldText in varchar2, newText in varchar2) return varchar2 ; 
   function isDiffYorN(oldNum in number, newNum in number) return varchar2 ;
   function isDiffYorN(oldDate in date, newDate in Date) return varchar2 ;
   
   
      Rev 1.60   02 Jul 2008 09:04:40   zf297a
   Removed date for k5 since the last_update_dt was added to the table.
   
      Rev 1.59   23 May 2008 13:12:58   zf297a
   Implemented function validatePlannerCode.
   
      Rev 1.58   22 May 2008 16:44:50   zf297a
   Implemented interface for getVersion.
   
      Rev 1.57   22 May 2008 11:06:48   zf297a
   Added code to use the FMS segment codes from the amd_param_changes table or to get them all from amd_defaults.fmsSegCodes.
   
      Rev 1.56   22 May 2008 09:04:02   zf297a
   Implemented interfaces for isForeignMilitarySale and isForeignMilitarySaleYorN
      
      Rev 1.55   22 Oct 2007 08:48:02   zf297a
   Fixed date/time formating: use MI for minutes and added AM for non-military time format.
   
      Rev 1.54   19 Oct 2007 10:48:46   zf297a
   Removed planner_code filter from isPartConsumable
   
      Rev 1.53   19 Sep 2007 16:59:36   zf297a
   Implementednew interfaces for isPartConsumable and isPartConsumablesYorN so that the determination can be made without retrieving any additional data.. Implemented new interfaces IsRepairableSmrCode and isRepairSmrCodeYorNm, so that a part's smr_code can be used to determine if it is repairable or not.
   
      Rev 1.52   21 Aug 2007 12:03:40   zf297a
   Fixed isNsnActive and isPartActive to return false for all NO_DATA_FOUND exceptions.
   
      Rev 1.51   19 Jul 2007 13:30:40   zf297a
   Implemented isWesmPart, isWesmPartYorN, getPrimePartNo and modified isPartConsumable - checked planner_code_cleaned and exclude nsn's beginning with NSL
   
      Rev 1.50   25 May 2007 14:22:16   zf297a
   Implemented transformNsn
   
      Rev 1.49   24 May 2007 14:45:36   zf297a
   Implemented isPartConsumable and isPartConsumableYorN.
   
      Rev 1.48   14 Apr 2007 00:36:52   zf297a
   fixed cleanTraceTables - added trim to dayOfWeek
   
      Rev 1.47   03 Apr 2007 14:37:28   zf297a
   Implement interface cleanTraceTables.
   
      Rev 1.46   22 Mar 2007 10:15:26   zf297a
   Implemented functions isSpoPrimePart and isSpoPrimePartYorN
   
      Rev 1.45   21 Mar 2007 11:40:36   zf297a
   Implemented functions:
   isPartActiveYorN
   isPartActive
   isNsnActiveYorN
   isNsnActive
   
   
      Rev 1.44   14 Mar 2007 13:52:38   zf297a
   Fixed errorMsg to use raise_application_error when it encounters an exception.
   
      Rev 1.43   14 Mar 2007 13:44:00   zf297a
   Mix multiplier for months2Calendar days - was supposed to be 30
   
      Rev 1.42   10 Mar 2007 18:25:24   zf297a
   Fixed isPrimePart - check for null for amd_nsi_parts.unassigned_date
   
      Rev 1.41   20 Feb 2007 11:36:54   zf297a
   Changed function months2CalendarDays to a simple multiplication by 30
   
      Rev 1.40   Nov 09 2006 08:46:08   zf297a
   Implemented interface rank
   
      Rev 1.38   Oct 04 2006 15:42:40   zf297a
   Fixed isPartRepariable to use the preferred smr_code - ie smr_code_cleaned if it is not null and then smr_code.  Used amd_utils.isPartRepairable in a2a_pkg.isPartValid so they use common code.
   
      Rev 1.37   Sep 25 2006 15:16:30   zf297a
   implemented interface isDiff with date parameters
   
      Rev 1.36   Sep 18 2006 13:14:40   zf297a
   implemented overloaded boolean functions isDiff
   
      Rev 1.35   Sep 12 2006 10:57:00   zf297a
   implemented interface isNumber and isNumberYorN
   
      Rev 1.34   Sep 05 2006 10:32:58   zf297a
   Added dbms_output to version
   
      Rev 1.33   Aug 29 2006 08:43:30   zf297a
   For boolean function isPartRepairable, relaxed the select criteria so that it determines if the part is repairable even if it is deleted.  Also, added an exception handler for the NO_DATA_FOUND exception and had it return false: i.e. the function was not able to clearly determine if the part was repairable based on the smr_code alone.
   
      Rev 1.32   Aug 23 2006 09:45:12   zf297a
   implemented interface isPartRepairable and isPartRepairYorN
   
      Rev 1.31   Jul 13 2006 12:13:08   zf297a
   added implementation for  getSpoPrimePartNo.

      Rev 1.30   Jun 09 2006 11:27:40   zf297a
   implemented version

      Rev 1.29   Jun 01 2006 10:55:56   zf297a
   Added writeMsg

      Rev 1.28   Mar 05 2006 19:14:12   zf297a
   Fixed debugMsg bug: substr's were wrong for pMsg3, and pMsg4

      Rev 1.26   Dec 06 2005 09:21:56   zf297a
   Fixed date so it display MM/DD/YYYY HH:MM:SS for the debugMsg

      Rev 1.24   Nov 09 2005 11:26:02   zf297a
   Implemented interface for isPrimePartYorN.

      Rev 1.23   Oct 21 2005 10:54:26   zf297a
   Removed dbms_output.put_line from debugMsg because it was filling up the output buffer.

      Rev 1.22   Sep 09 2005 14:04:22   zf297a
   Make sure there are words to join for the joinString function

      Rev 1.21   Sep 09 2005 00:20:38   zf297a
   Changed splitString and joinString to use a single character delimiter.

      Rev 1.20   Sep 07 2005 10:13:52   zf297a
   Implemented interfaces splitString and joinString (lesson learned - varray type variables must always be initialized and extended before adding an element using the extend method)

      Rev 1.19   Sep 02 2005 15:06:28   zf297a
   Missing versions after 1.18 because of PVCS server change. Implemented interfaces for getLocType,  isPrimePart, getPrimePart, getEquivalentParts, equivalentParts

      Rev 1.20   Aug 19 2005 12:41:06   zf297a
   Added functions bizDays2CalendarDays, months2CalendarDays, and getSiteLocation.

      Rev 1.19   Aug 19 2005 11:35:16   c378632
   add GetNsiSidFromPartNo

      Rev 1.18   07 Jun 2005 22:13:02   c378632
   add GetLocationInfo, GetSpoLocation, GetPartNo

      Rev 1.17   May 17 2005 10:03:56   c970183
   Removed redundant version of InsertErrorMessage

      Rev 1.16   May 13 2005 14:18:58   c970183
   For the insertErrorMsg procedure all parameters are now optional.  The load_no will still get set, the key5 variable will get set if it is null to the sysdate, and the comments column will get set to sqlcode and sqlerrm.

      Rev 1.15   May 02 2005 13:40:22   c970183
   Removed global debugging.  Used exact types related to amd_load_details for paramater args to debugMsg

      Rev 1.14   Apr 21 2005 08:17:06   c970183
   Created debugMsg which can be controlled via mDebug and mDebugThreshold.  Both params can be controlled by the package user or the amd_param_changes table.  The data from amd_param_changes is loaded at package initialization, therefore the settings given by the package user have a higher priority since they can be overriden at any time during the session.

      Rev 1.13   03 Dec 2004 07:29:14   c970183
   Made sure sourceName and tableName do not exceed the column size for the getLoadNo function

      Rev 1.12   02 Dec 2004 14:32:44   c970183
   Made sure the error logging routines never try to insert a column that is longer than the maximum field.

      Rev 1.10   05 Sep 2002 10:16:34   c970183
   Added $Log$ keyword and changed variable name from sendorAddress to senderAddress
    -- 09/05/02 dse        added sendMail procedure

    --06/07/05 KS        added GetSpoLocation, GetLocationInfo, GetPartNo
*/

    debugCnt NUMBER := 0 ;
    debug boolean := false ;
    type FmsSegCodeTab is table of amd_param_changes.PARAM_VALUE%type ;
    FmsSegCodes FmsSegCodeTab ;


    -- use this function  to make sure a field never exceeds its max length
    FUNCTION trimToMax(str IN VARCHAR2, maxLen IN NUMBER) RETURN VARCHAR2 IS
    BEGIN
         IF LENGTH(str) >maxLen THEN
             RETURN SUBSTR(str,1,maxLen) ;
         ELSE
              RETURN str ;
         END IF ;
    END trimToMax ;

    FUNCTION GetLoadNo(
                            pSourceName AMD_LOAD_STATUS.SOURCE%TYPE,
                            pTableName AMD_LOAD_STATUS.TABLE_NAME%TYPE) RETURN NUMBER IS
        loadNo   NUMBER;
        sourceName AMD_LOAD_STATUS.SOURCE%TYPE := trimToMax(pSourceName,20) ;
        tableName AMD_LOAD_STATUS.TABLE_NAME%TYPE := trimToMax(pTableName,30) ;
    BEGIN
        SELECT
            amd_load_status_seq.NEXTVAL
        INTO loadNo
        FROM dual;
        INSERT INTO AMD_LOAD_STATUS
        (
            load_no,
            source,
            load_date,
            table_name
        )
        VALUES
        (
            loadNo,
            sourceName,
            SYSDATE,
            tableName
        );
        RETURN loadNo;
    END GetLoadNo;
    FUNCTION FormatNsn(
                            pNsn VARCHAR2,
                            pType VARCHAR2 DEFAULT 'AMD') RETURN VARCHAR2 IS
        RetVal    VARCHAR2(50);
    BEGIN
        --
        -- AMD uses NSN w/o dashes. GOLD uses NSN w/dashes.
        --
        IF (pType = 'AMD') THEN
            RetVal := REPLACE(pNsn,'-');
        ELSE
            RetVal := SUBSTR(pNsn,1,4)||'-'||SUBSTR(pNsn,5,2)||'-'||
                            SUBSTR(pNsn,7,3)||'-'||SUBSTR(pNsn,10,4);
        END IF;
        RETURN RetVal;
    END;


    PROCEDURE InsertErrorMsg (
                            pLoad_no IN AMD_LOAD_DETAILS.load_no%TYPE := NULL,
                            pData_line_no IN AMD_LOAD_DETAILS.data_line_no%TYPE := NULL,
                            pData_line IN AMD_LOAD_DETAILS.data_line%TYPE := NULL,
                            pKey_1 IN AMD_LOAD_DETAILS.key_1%TYPE := NULL,
                            pKey_2 IN AMD_LOAD_DETAILS.key_2%TYPE := NULL,
                            pKey_3 IN AMD_LOAD_DETAILS.key_3%TYPE := NULL,
                            pKey_4 IN AMD_LOAD_DETAILS.key_4%TYPE := NULL,
                            pKey_5 IN AMD_LOAD_DETAILS.key_5%TYPE := NULL,
                            pComments IN AMD_LOAD_DETAILS.comments%TYPE := NULL ) IS

        loadNo NUMBER := pLoad_no ;
        dataLine AMD_LOAD_DETAILS.data_line%TYPE := trimToMax(pData_line,2000) ;
        k1 AMD_LOAD_DETAILS.KEY_1%TYPE := trimToMax(pKey_1,50) ;
        k2 AMD_LOAD_DETAILS.KEY_2%TYPE := trimToMax(pKey_2, 50) ;
        k3 AMD_LOAD_DETAILS.KEY_3%TYPE := trimToMax(pKey_3, 50) ;
        k4 AMD_LOAD_DETAILS.KEY_4%TYPE := trimToMax(pKey_4, 40) ;
        k5 AMD_LOAD_DETAILS.KEY_5%TYPE := trimToMax(pKey_5, 50) ;
        msg AMD_LOAD_DETAILS.COMMENTS%TYPE := trimToMax(pComments, 2000) ;

    BEGIN
         IF loadNo IS NULL THEN
             loadNo := getLoadNo('amd_utils','amd_load_details') ;
         END IF ;
         IF msg IS NULL THEN
             msg := SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000) ;
         END IF ;
        INSERT INTO AMD_LOAD_DETAILS
        (
            load_no,
            data_line_no,
            data_line,
            key_1,
            key_2,
            key_3,
            key_4,
            key_5,
            comments
        )
        VALUES
        (
            pLoad_no,
            pData_line_no,
            dataLine,
            k1,
            k2,
            k3,
            k4,
            k5,
            msg
        );
    exception when others then
          dbms_output.enable(100000) ;
          if not isNumber(to_char(pLoad_no)) then
               dbms_output.put_line('pLoad_no is not a number') ;
          end if ;
          if not isNumber(to_char(dataLine)) then
               dbms_output.put_line('dataLine is not a number') ;
          end if ;
          dbms_output.put_line('k1=' || k1) ;              
          dbms_output.put_line('k2=' || k2) ;
          dbms_output.put_line('k3=' || k3) ;
          dbms_output.put_line('k4=' || k4) ;
          dbms_output.put_line('k5=' || k5) ;
          dbms_output.put_line('msg=' || msg) ;
          
          raise_application_error(-20010,
                substr('amd_utils ' 
                    || sqlcode || ' '
                    || pLoad_no || ' ' 
                    || dataLine || ' ' 
                    || k1 || ' ' 
                    || k2 || ' ' 
                    || k3 || ' ' 
                    || k4 || ' '
                    || k5 || ' '
                    || msg, 1,2000)) ;
                    
    END InsertErrorMsg;

    FUNCTION GetNsiSid(pNsn IN AMD_NSNS.nsn%TYPE) RETURN AMD_NSNS.nsi_sid%TYPE IS
        nsi_sid AMD_NSNS.nsi_sid%TYPE := NULL ;
    BEGIN
        SELECT nsi_sid INTO nsi_sid
        FROM AMD_NSNS
        WHERE nsn = pNsn ;
        RETURN nsi_sid ;
    END GetNsiSid ;

    FUNCTION GetNsiSid(pPart_no IN AMD_NSI_PARTS.part_no%TYPE) RETURN AMD_NSI_PARTS.nsi_sid%TYPE IS
        nsi_sid AMD_NSI_PARTS.nsi_sid%TYPE := NULL ;
    BEGIN
        SELECT nsi_sid INTO nsi_sid
        FROM AMD_NSI_PARTS
        WHERE part_no = pPart_no
        AND unassignment_date IS NULL ;
        RETURN nsi_sid ;
    END GetNsiSid ;

    FUNCTION GetLocSid(pLocId AMD_SPARE_NETWORKS.loc_id%TYPE) RETURN AMD_SPARE_NETWORKS.loc_sid%TYPE IS
        locSid AMD_SPARE_NETWORKS.loc_sid%TYPE := NULL;
        -- locId amd_spare_networks.loc_id%type := null;
    BEGIN
         /* may not always be applicable, moved to amd_from_bssm_pkg
         if (pLocId = amd_from_bssm_pkg.BSSM_WAREHOUSE_SRAN) then
               locId := amd_from_bssm_pkg.AMD_WAREHOUSE_LOCID;
         else
                locId := pLocId;
         end if;
         */
         SELECT loc_sid
         INTO locSid
         FROM AMD_SPARE_NETWORKS
         WHERE loc_id = pLocId;
         RETURN locSid;
    EXCEPTION
         WHEN NO_DATA_FOUND THEN
               RETURN NULL;
    END GetLocSid;

    FUNCTION GetLocType(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_type%TYPE IS
        locType AMD_SPARE_NETWORKS.loc_type%TYPE := NULL;
    BEGIN
         SELECT loc_type
         INTO locType
         FROM AMD_SPARE_NETWORKS
         WHERE loc_sid = pLocSid;
         RETURN locType;
    EXCEPTION
         WHEN NO_DATA_FOUND THEN
               RETURN NULL;
    END GetLocType;

    FUNCTION GetLocId(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_id%TYPE IS
        locId AMD_SPARE_NETWORKS.loc_id%TYPE := NULL;
    BEGIN
         SELECT loc_id
         INTO locId
         FROM AMD_SPARE_NETWORKS
         WHERE loc_sid = pLocSid;
         RETURN locid;
    EXCEPTION
         WHEN NO_DATA_FOUND THEN
               RETURN NULL;
    END GetLocId;

    procedure writeMsg(
            pSourceName in varchar2,
            pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
            pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
            pKey1 IN VARCHAR2 := '',
            pKey2 IN VARCHAR2 := '',
            pKey3 IN VARCHAR2 := '',
            pKey4 in varchar2 := '',
            pData IN VARCHAR2 := '',
            pComments IN VARCHAR2 := '')  IS
    BEGIN
        Amd_Utils.InsertErrorMsg (
                pLoad_no => Amd_Utils.GetLoadNo(pSourceName => pSourceName,    pTableName  => pTableName),
                pData_line_no => pError_location,
                pData_line    => pData,
                pKey_1 => SUBSTR(pKey1,1,50),
                pKey_2 => SUBSTR(pKey2,1,50),
                pKey_3 => substr(pKey3,1,50),
                pKey_4 => substr(pKey4,1,50),
                pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pComments => 'sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||') ' || pComments);
    end writeMsg ;


    -- NOTE: this routine does not do any commit's that is left up to the user of the routine
    PROCEDURE debugMsg(pMsg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE,
              pPackage IN AMD_LOAD_DETAILS.KEY_1%TYPE := 'amd_utils',
              pLocation IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE := 999,
              pMsg2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
              pMsg3 IN AMD_LOAD_DETAILS.key_3%TYPE := '',
              pMsg4 IN AMD_LOAD_DETAILS.key_4%TYPE := '') IS
    BEGIN
        IF debugCnt  <= mDebugThreshold or debug THEN

           -- dbms_output.put_line(pMsg);

           InsertErrorMsg (
                    pLoad_no => Amd_Utils.GetLoadNo(
                            pSourceName => 'debugMsg',
                            pTableName  => 'amd_load_details'),
                    pData_line_no => pLocation,
                    pData_line    => SUBSTR(pMsg,1,2000),
                    pKey_1 => SUBSTR(pPackage,1,50),
                    pKey_2 => SUBSTR(pMsg2,1,50),
                    pKey_3 =>  SUBSTR(pMsg3,1,50),
                    pKey_4 => SUBSTR(pMsg4,1,50),
                    pKey_5 => SUBSTR(to_char(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') || ' debugThreshold=' || TO_CHAR(mDebugThreshold),1,50),
                    pComments => SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||') ' || SUBSTR(pMsg,201),1,2000));

           debugCnt := debugCnt + 1 ;
        END IF ;
    EXCEPTION WHEN OTHERS THEN
              dbms_output.put_line('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||') ') ;
    END;

    PROCEDURE sendMail(senderAddress   VARCHAR2, receiverAddress VARCHAR2, subject VARCHAR2, mesg VARCHAR2) IS
         EmailServer     VARCHAR2(30) := 'mail.boeing.com';
         Port NUMBER  := 25;
         conn UTL_SMTP.CONNECTION;
         mesg_body VARCHAR2(32767) ;
         crlf VARCHAR2( 2 ):= CHR( 13 ) || CHR( 10 );
    BEGIN
        conn:= utl_smtp.open_connection( EmailServer, Port );
        utl_smtp.helo( conn, EmailServer );
        utl_smtp.mail( conn, senderAddress);
        utl_smtp.rcpt( conn, receiverAddress );
        mesg_body := 'Date: ' || TO_CHAR( SYSDATE, 'dd Mon yy hh24:mi:ss' )|| crlf ||
               'From:'  || senderAddress || crlf ||
               'Subject: ' || subject  || crlf ||
               'To: '|| receiverAddress || crlf ||
               '' || crlf || mesg ;

        utl_smtp.data( conn, mesg_body );
        utl_smtp.quit( conn );

    END sendMail ;

     --- ks added 06/07/05 --

    FUNCTION GetSpoLocation(pLocSid AMD_SPARE_NETWORKS.loc_sid%TYPE)
        RETURN AMD_SPARE_NETWORKS.spo_location%TYPE IS
        retLocation AMD_SPARE_NETWORKS.spo_location%TYPE := NULL ;
    BEGIN
         SELECT spo_location INTO retLocation
                FROM AMD_SPARE_NETWORKS
               WHERE loc_sid = pLocSid ;
            RETURN retLocation ;
    EXCEPTION WHEN OTHERS THEN
         RETURN NULL ;
    END GetSpoLocation ;

    FUNCTION GetPartNo(pNsiSid AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE)
        RETURN AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE IS
        retPart AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE := NULL ;
    BEGIN
         SELECT prime_part_no INTO retPart
                FROM AMD_NATIONAL_STOCK_ITEMS
               WHERE nsi_sid = pNsiSid AND action_code != 'D';
         RETURN retPart ;
    EXCEPTION WHEN OTHERS THEN
        RETURN NULL ;
    END GetPartNo ;

    FUNCTION GetLocationInfo(pLocSid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN
        AMD_SPARE_NETWORKS%ROWTYPE IS
        retRow AMD_SPARE_NETWORKS%ROWTYPE := NULL ;
    BEGIN
        SELECT * INTO retRow
            FROM AMD_SPARE_NETWORKS
            WHERE loc_sid = pLocSid ;
        RETURN retRow ;
    EXCEPTION WHEN OTHERS THEN
        RETURN retRow ;
    END GetLocationInfo ;

    -- ks added 06/09/05 ---
    FUNCTION GetNsiSidFromPartNo(pPart AMD_NSI_PARTS.part_no%TYPE)
         RETURN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE IS
         retNsiSid AMD_NSI_PARTS.nsi_sid%TYPE  ;
    BEGIN
        SELECT nsi_sid INTO retNsiSid
            FROM AMD_NSI_PARTS
            WHERE part_no = pPart
            AND unassignment_date IS NULL ;
        RETURN retNsiSid ;
    EXCEPTION WHEN NO_DATA_FOUND THEN
        RETURN NULL ;
    END GetNsiSidFromPartNo ;

     --  added 08/19/05
     FUNCTION bizDays2CalendarDays(bizDays IN INTEGER) RETURN INTEGER IS
     BEGIN
           RETURN ROUND((bizDays / 5) * 7) ;
     END bizDays2CalendarDays ;


     --  added 08/19/05
     FUNCTION months2CalendarDays(months IN DECIMAL) RETURN NUMBER IS
     BEGIN
           RETURN ROUND(months * 30) ;
     END months2CalendarDays ;

     --  added 08/19/05
     FUNCTION getSiteLocation(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN
        AMD_SPARE_NETWORKS.loc_id%TYPE IS

        loc_id AMD_SPARE_NETWORKS.loc_id%TYPE ;
     BEGIN
      SELECT loc_id INTO loc_id
      FROM AMD_SPARE_NETWORKS
      WHERE loc_sid = getsitelocation.loc_sid ;

      RETURN loc_id ;
     END getSiteLocation ;

     FUNCTION getLocType(loc_sid IN AMD_SPARE_NETWORKS.loc_sid%TYPE) RETURN AMD_SPARE_NETWORKS.loc_type%TYPE IS
               loc_type AMD_SPARE_NETWORKS.loc_type%TYPE ;
     BEGIN
           SELECT loc_type INTO loc_type FROM AMD_SPARE_NETWORKS WHERE loc_sid = getLocType.loc_sid ;
          RETURN loc_type ;

     EXCEPTION
           WHEN standard.NO_DATA_FOUND THEN
                 RETURN NULL ;
     END getLocType ;

     FUNCTION isPrimePart(part_no IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN IS
               prime_part_no AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE ;
     BEGIN
           SELECT sp.part_no INTO prime_part_no
          FROM AMD_SPARE_PARTS sp,
          AMD_NSI_PARTS np
          WHERE action_code != 'D'
          AND sp.part_no = isPrimePart.part_no
          AND sp.part_no = np.part_no
          AND np.UNASSIGNMENT_DATE IS  NULL
          AND np.PRIME_IND = 'Y' ;
          RETURN TRUE ;
     EXCEPTION
         WHEN standard.NO_DATA_FOUND THEN
             RETURN FALSE ;
     END isPrimePart ;

     FUNCTION isPrimePartYorN(part_no AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 IS
     BEGIN
           IF isPrimePart(part_no) THEN
               RETURN 'Y' ;
          ELSE
             RETURN 'N' ;
          END IF ;
     END isPrimePartYorN ;

     FUNCTION getPrimePart(part_no AMD_NSI_PARTS.part_no%TYPE) RETURN AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE IS
               prime_part_no AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE ;
     BEGIN
           SELECT items.prime_part_no INTO prime_part_no
          FROM AMD_NATIONAL_STOCK_ITEMS items,
          AMD_NSI_PARTS parts
          WHERE items.nsi_sid = (SELECT nsi_sid FROM AMD_NSI_PARTS parts WHERE getPrimePart.part_no = parts.part_no AND parts.unassignment_date IS NULL)
          AND items.action_code != 'D'
          AND items.nsi_sid = parts.nsi_sid
          AND parts.prime_ind = 'Y'
          AND parts.UNASSIGNMENT_DATE IS NULL ;

          RETURN prime_part_no ;

     EXCEPTION
           WHEN standard.NO_DATA_FOUND THEN
                 RETURN NULL ;
     END getPrimePart ;
     
    function isSpoPrimePart(part_no in amd_spare_parts.part_no%type) return boolean is
        result number := 0 ;
    begin
        select 1 into result 
        from dual 
        where exists (select null 
                      from amd_sent_to_a2a
                      where spo_prime_part_no = isSpoPrimePart.part_no
                      and action_code <> amd_defaults.DELETE_ACTION
                      ) ;
        return true ;
    exception when standard.no_data_found then
        return false ;        
    end isSpoPrimePart ;
    
function isSpoPrimePartYorN(part_no in amd_spare_parts.part_no%type) return varchar2 is
begin
    if isSpoPrimePart(part_no) then
        return 'Y' ;
    end if ;
    return 'N' ;
end isSpoPrimePartYorN ;

    FUNCTION getEquivalentParts(part_no AMD_SPARE_PARTS.part_no%TYPE) RETURN equivalent_parts IS
             equivParts equivalent_parts ;
             rec AMD_SPARE_PARTS%ROWTYPE ;
     BEGIN
           OPEN equivParts FOR
          SELECT * FROM AMD_SPARE_PARTS parts
          WHERE parts.part_no IN
            (SELECT part_no FROM AMD_NSI_PARTS nsi
             WHERE nsi.nsi_sid = (
                                   SELECT nsi_sid
                               FROM AMD_NATIONAL_STOCK_ITEMS
                               WHERE prime_part_no = Amd_Utils.getPrimePart(getEquivalentParts.part_no)
                               AND action_code != 'D'
                                )
            AND nsi.unassignment_date IS NULL
            AND nsi.prime_ind != 'Y' );

           RETURN equivParts ;

     END getEquivalentParts ;

    FUNCTION equivalentParts(part_no AMD_SPARE_PARTS.part_no%TYPE) RETURN parts PIPELINED IS
             equivParts equivalent_parts ;
             rec AMD_SPARE_PARTS%ROWTYPE ;
     BEGIN
           OPEN equivParts FOR
          SELECT * FROM AMD_SPARE_PARTS parts
          WHERE parts.part_no IN
            (SELECT part_no FROM AMD_NSI_PARTS nsi
             WHERE nsi.nsi_sid = (
                                   SELECT nsi_sid
                               FROM AMD_NATIONAL_STOCK_ITEMS
                               WHERE prime_part_no = Amd_Utils.getPrimePart(equivalentParts.part_no)
                               AND action_code != 'D'
                                )
            AND nsi.unassignment_date IS NULL
            AND nsi.prime_ind != 'Y' );
          LOOP
                FETCH equivParts INTO rec ;
              EXIT WHEN equivParts%NOTFOUND ;
                 pipe ROW(rec) ;
          END LOOP ;
          RETURN ;
     END equivalentParts ;

    -- added 9/7/2005 dse
    FUNCTION splitString(text IN VARCHAR2, delim IN VARCHAR2 := ',') RETURN arrayOfWords IS
             word VARCHAR2(512) ;
             words arrayOfWords := arrayOfWords() ;
             x NUMBER := 0 ;


             PROCEDURE addWord IS
             BEGIN
                  x := x + 1 ;
                 words.extend ;
                 words(x) := word ;
                 word := NULL ;
             END addWord ;


    BEGIN
         IF LENGTH(text) > 0 THEN
             FOR i IN 1..LENGTH(text) LOOP
                  IF SUBSTR(text,i,1) != delim THEN
                     word := word || SUBSTR(text,i,1) ;
                 ELSE
                      addWord ;
                 END IF ;
                 IF LENGTH(text) > 0 AND i = LENGTH(text) THEN
                     addWord ;
                 END IF ;
             END LOOP ;
         END IF ;
         RETURN words ;
    END splitString ;

    FUNCTION joinString(words IN arrayOfWords, delim IN VARCHAR2 := ',') RETURN VARCHAR2 IS
             buf VARCHAR2(512) := '' ;
    BEGIN

         IF words.COUNT() > 0 THEN
             FOR i IN words.first..words.last LOOP
                  IF i != words.last THEN
                    buf := buf || words(i) || delim ;
                 ELSE
                     buf := buf || words(i) ;
                 END IF ;
             END LOOP ;
         END IF ;
         RETURN buf ;
    END joinString ;

    FUNCTION getCageCode(part_no IN VARCHAR2) RETURN VARCHAR2 IS
              cageCode AMD_SPARE_PARTS.mfgr%TYPE ;
    BEGIN
          SELECT mfgr INTO cageCode FROM AMD_SPARE_PARTS WHERE part_no = getCageCode.part_no ;
      RETURN cageCode ;
    EXCEPTION WHEN standard.NO_DATA_FOUND THEN
          RETURN NULL ;
    END getCageCode ;

    FUNCTION getUnitCostDefaulted(part_no IN VARCHAR2) RETURN AMD_SPARE_PARTS.unit_cost_defaulted%TYPE IS
             nsn AMD_SPARE_PARTS.nsn%TYPE ;
             mfgr AMD_SPARE_PARTS.mfgr%TYPE ;
             smr_code AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE ;
             planner_code AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE ;
    BEGIN
         SELECT nsn, mfgr INTO nsn, mfgr
         FROM AMD_SPARE_PARTS
         WHERE part_no = getUnitCostDefaulted.part_no
         AND action_code != Amd_Defaults.DELETE_ACTION ;

         SELECT smr_code, planner_code INTO smr_code, planner_code
         FROM AMD_NATIONAL_STOCK_ITEMS items,
         AMD_SPARE_PARTS parts
         WHERE parts.part_no = getUnitCostDefaulted.part_no
         AND parts.nsn = items.nsn
         AND items.action_code != Amd_Defaults.DELETE_ACTION ;
         RETURN Amd_Defaults.GetUnitCost(pNsn => nsn, pPart_no => part_no,pMfgr => mfgr, pSmr_code => smr_code, pPlanner_code => planner_code)  ;
    EXCEPTION WHEN standard.NO_DATA_FOUND THEN
              RETURN NULL ;
    END getUnitCostDefaulted ;

    function boolean2Varchar2(theValue in boolean, YorN in boolean := false) return varchar2 is
    begin
         if theValue then
             if YorN then
               return 'Y' ;
            else
                 return 'true' ;
            end if ;
         else
            if YorN then
               return 'N' ;
            else
                  return 'false' ;
            end if ;
         end if ;
    end boolean2Varchar2 ;

    procedure version is
    begin
         amd_utils.writeMsg(pSourceName => 'amd_utils', pTableName => 'amd_utils',
                 pError_location => 999, pKey1 => 'amd_utils', pKey2 => '$Revision:   1.66  $') ;
         dbms_output.put_line('amd_utils: $Revision:   1.66  $') ;
    end version ;

    function getVersion return varchar2 is
    begin
        return '$Revision:   1.66  $';
    end getVersion ;

   FUNCTION getSpoPrimePartNo(part_no AMD_spare_parts.part_no%TYPE) RETURN AMD_spare_parts.SPO_PRIME_PART_NO%TYPE IS
               spo_prime_part_no AMD_spare_parts.SPO_PRIME_PART_NO%TYPE ;
   BEGIN
           SELECT DISTINCT spo_prime_part_no INTO spo_prime_part_no 
        FROM amd_spare_parts
        WHERE part_no = getSpoPrimePartNo.part_no
        and is_spo_part = 'Y' ;           
        RETURN spo_prime_part_no ;
   exception when no_data_found then
        return null ;        
   END getSpoPrimePartNo ;
   
   -- this was written to be used by a trigger to avoid ora-04091 - table name is mutating
   function isPartConsumable(preferred_smr_code amd_national_stock_items.smr_code%type,
        preferred_planner_code amd_national_stock_items.planner_code%type,
        nsn amd_national_stock_items.nsn%type) return boolean is
             result boolean := false ;
   begin
    return not isRepairableSmrCode(preferred_smr_code) ;
   end isPartConsumable ;
   
   function isPartConsumableYorN(preferred_smr_code amd_national_stock_items.smr_code%type,
        preferred_planner_code amd_national_stock_items.planner_code%type,
        nsn amd_national_stock_items.nsn%type) return varchar2 is
   begin
        if isPartConsumable(preferred_smr_code => preferred_smr_code, preferred_planner_code => preferred_planner_code,
            nsn => nsn) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;                         
   end isPartConsumableYorN ;        
                
   function isPartConsumable(part_no amd_spare_parts.part_no%type) return boolean is
    
             preferred_smr_code amd_national_stock_items.smr_code%type ;
             preferred_planner_code amd_national_stock_items.planner_code%type;
             nsn amd_national_stock_items.nsn%type ;
    begin
        return not isPartRepairable(part_no) ;

    exception when standard.no_data_found then
              return false ;         
    end isPartConsumable ;

       function isPartConsumableYorN(part_no amd_spare_parts.part_no%type) return varchar2 is
    begin
        if isPartConsumable(part_no) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isPartConsumableYorN ;
    
    
    function isWesmPart(part_no in amd_national_stock_items.prime_part_no%type) return boolean is
        result number := 0;
    begin
        select 1 into result
        from dual
        where exists (select null
                      from l11 , amd_national_stock_items items, active_niins
                      where items.prime_part_no = isWesmPart.part_no
                      and l11.nsn = items.nsn and items.action_code <> amd_defaults.getDELETE_ACTION
                      and l11.niin = active_niins.niin) ;
    
        return true;

    exception when standard.no_data_found then
        return false;
    
    end isWesmPart;
    
    
    function isWesmPartYorN(part_no in amd_national_stock_items.prime_part_no%type) return varchar2 is
    begin
        if isWesmPart(part_no) then
            return 'Y';
        end if; 
            return 'N';
    end isWesmPartYorN ;

    
    -- this was written to be used by a trigger to avoid ora-04091 - table name is mutating
       function isRepairableSmrCode(preferred_smr_code amd_national_stock_items.smr_code%type) return boolean is
    begin
        return preferred_smr_code is not null and length(preferred_smr_code) >= 6 and upper(substr(preferred_smr_code,6,1)) = 'T' ;
    end isRepairableSmrCode ;             

       function isRepairableSmrCodeYorN(preferred_smr_code amd_national_stock_items.smr_code%type) return varchar2 is
    begin
        if isRepairableSmrCode(preferred_smr_code => preferred_smr_code) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;                        
    end isRepairableSmrCodeYorN ;

    
       function isPartRepairable(part_no amd_spare_parts.part_no%type) return boolean is
             preferred_smr_code amd_national_stock_items.smr_code%type ;
    begin
         select amd_preferred_pkg.getPreferredValue(smr_code_cleaned, smr_code) into preferred_smr_code 
         from amd_spare_parts parts, 
         amd_national_stock_items items
         where parts.part_no = isPartRepairable.part_no
         and parts.nsn = items.nsn ;
         
         return isRepairableSmrCode(preferred_smr_code => preferred_smr_code) ;
         
    exception when standard.no_data_found then
              return false ;         
    end isPartRepairable ;
    
    function isPartRepairableYorN(part_no amd_spare_parts.part_no%type) return varchar2 is
    begin
         if isPartRepairable(part_no) then
             return 'Y' ;
         else
             return 'N' ;
         end if ;
    end isPartRepairableYorN ;

    function isNumber( p_string in varchar2 ) return boolean
    is
       l_number number;
    begin
       l_number := P_string;
       return true;
    exception 
       when others then return false;
    end;
    
    function isNumberYorN( p_string in varchar2 ) return varchar2 is
    begin
         if isNumber(p_string) then
             return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isNumberYorN ;
           
    function isDiff(oldText in varchar2, newText in varchar2) return boolean is
    begin
         return oldText <> newText 
                 or (oldText is null and newText is not null) 
                or (oldText is not null and newText is null) ;
    end isDiff ;
    
    function isDiffYorN(oldText in varchar2, newText in varchar2) return varchar2 is
    begin
        if isDiff(oldText,newText) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;                        
    end isDiffYorN ;
    
    function isDiff(oldNum in number, newNum in number) return boolean is
    begin
         return (oldNum <> newNum)
                 or (oldNum is null and newNum is not null) 
                or (oldNum is not null and newNum is null) ;
    end isDiff ;
    
    function isDiffYorN(oldNum in number, newNum in number) return varchar2 is
    begin
        if isDiff(oldNum,newNum) then
            return 'Y' ;
        else
            return 'N' ;            
        end if ;                        
    end isDiffYorN ;

    function isDiff(oldDate in date, newDate in Date) return boolean is
    begin
         return (oldDate <> newDate)
                 or (oldDate is null and newDate is not null) 
                or (oldDate is not null and newDate is null) ;
    end isDiff ;
    
    function isDiffYorN(oldDate in date, newDate in Date) return varchar2 is
    begin
        if isDiff(oldDate,newDate) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;                        
    end isDiffYorN ;
    
    function getNsn(part_no in amd_spare_parts.part_no%type) return amd_spare_parts.nsn%type is
             theNsn amd_spare_parts.nsn%type ;
    begin
         select nsn into theNsn from amd_spare_parts where part_no = getNsn.part_no ;
         return theNsn ;
    exception when standard.no_data_found then
         return null ;
    end getNsn ;
    
    function rank(orderOfUsage in varchar2) return number is
             i number ;
             j number ;
             exp number := 0 ;
             cnt number := 0 ;
             countingChars varchar2(36) := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ;
 
    begin
         
         for i in reverse  1..length(orderOfUsage) loop
              --dbms_output.put_line('i=' || i) ;
             for j in 0..35 loop
                  if substr(countingChars,j+1,1) = substr(orderOfUsage,i,1) then
                     cnt := cnt + (j * 36 ** exp) ;
                    exit ;
                 end if ;
             end loop ;      
             exp := exp + 1 ; 
         end loop ;
         return cnt ;
    end rank ;

    function convertToBase(value in number, base in number) return varchar2 is
        countingChars varchar2(36) := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ;
    begin
        if value < base then
            return substr(countingChars,value+1,1) ;
        else
            return convertToBase(trunc(value/base),base) || substr(countingChars,mod(value,base)+1,1) ;
        end if ;            
    end convertToBase ;

    function groupPriority(rank in number) return varchar2 is
    begin
        return convertToBase(rank,36) ;            
    end groupPriority ;
    
    
    
    function isOneWay(orderOfUse in orderOfUsages) return boolean is
             secondLetter varchar2(1) ;
    begin
         secondLetter := substr(orderOfUse.FIRST,2,1) ;
         for oou in orderOfUse.NEXT(orderOfUse.FIRST)..orderOfUse.LAST loop
              if secondLetter  <> substr(oou,2,1) then
                 return true ;
             end if ;
         end loop ;
         return false ;
    end isOneWay ;
    
    function isOneWayYorN(orderOfUse in orderOfUsages) return varchar2 is
    begin
         if isOneWay(orderOfUse) then
             return 'Y' ;
         else
             return 'N' ;
         end if ;
    end isOneWayYorN ;
    
    -- raises standard.NO_DATA_FOUND
    function isPartActiveYorN(part_no in amd_spare_parts.PART_NO%type) return varchar2 is
    begin
        -- don't check for no data found condition let the caller hand that exception
        if isPartActive(part_no) then
            return 'Y' ;
        end if ;
        return 'N' ;
    end isPartActiveYorN ;
    
    -- raises standard.NO_DATA_FOUND for amd_spare_parts query
    function isPartActive(part_no in amd_spare_parts.part_no%type) return boolean is
        action_code amd_spare_parts.action_code%type ;
    begin
        select action_code into isPartActive.action_code 
        from amd_spare_parts 
        where part_no = isPartActive.part_no ;
        return action_code <> amd_defaults.DELETE_ACTION ;
    exception when standard.no_data_found then
        return false ;        
    end isPartActive ;
    
    function isNsnActiveYorN(nsn in amd_nsns.NSN%type) return varchar2 is
    begin
        -- don't check for no data found condition let the caller hand that exception
        if isNsnActive(nsn) then
            return 'Y' ;
        end if ;
        return 'N' ;
    end isNsnActiveYorN ;
    
    -- raises standard.NO_DATA_FOUND for amd_nsns query
    function isNsnActive(nsn in amd_nsns.NSN%type) return boolean is
        nsn_type amd_nsns.NSN_TYPE%type ;
        nsi_sid amd_nsns.NSI_SID%type ;
        action_code amd_national_stock_items.action_code%type ;
    begin
        select nsn_type, nsi_sid into isNsnActive.nsn_type, isNsnActive.nsi_sid from amd_nsns where nsn = isNsnActive.nsn ;
        if nsn_type = 'C' then -- current
            begin
                select action_code into isNsnActive.action_code 
                from amd_national_stock_items 
                where nsi_sid = isNsnActive.nsi_sid
                and action_code <> amd_defaults.DELETE_ACTION
                and exists (select null 
                            from amd_nsi_parts 
                            where nsi_sid = isNsnActive.nsi_sid 
                           and unassignment_date is null) ;
                return true ;   
            exception when standard.no_data_found then
                return false ;
            end ;
        end if ;
        
        return false ;

    exception when standard.no_data_found then
        return false ;            
    end isNsnActive ;

    procedure cleanTraceTables is
        dayOfWeek varchar2(10) ;
    begin
        select to_char(sysdate,'DAY') into dayOfWeek from dual ;
        if trim(dayOfWeek) = amd_defaults.CLEAN_DATA_DAY then
            mta_truncate_table('amd_load_details','reuse storage') ;
            mta_truncate_table('amd_load_status','reuse storage') ;
        end if ; 
    end cleanTraceTables ;
    
    function transformNsn(nsn in varchar2) return varchar2  is
        newNsn varchar2(65) := upper(nsn) ;
        part_no amd_spare_parts.part_no%type ;
    begin
        if substr(newNsn,1,3) = amd_defaults.getNonStockageList and substr(newNsn,4,1) in ('~','$','#') then
            part_no := substr(nsn,5) ;
            if isPartActive(part_no) then
                newNsn := getNsn(part_no) ;
            else
                newNsn := null ;
            end if ;
        end if ;
        
        return newNsn ;
        
    end transformNsn ;
    
    function getPrimePartNo(nsn in varchar2) return varchar2 is
        prime_part_no amd_national_stock_items.prime_PART_NO%type ;
    begin
        select prime_part_no into prime_part_no from amd_national_stock_items where nsn = getPrimePartNo.nsn ;
        return prime_part_no ;
    exception when standard.no_data_found then
        return null ;
    end getPrimePartNo ;
    
    function isForeignMilitarySale(segment_code in varchar2) return boolean is
    begin
        
        
        if fmsSegCodes.first is null then
            -- there was no data in amd_param_changes so use the default values
            -- by loading from the amd_defaults varray the code in this function
            -- does not have to know the exact number of segment codes for FMS
            for indx in amd_defaults.fmsSegCodes.first .. amd_defaults.fmsSegCodes.last loop
                fmsSegCodes.extend ;
                fmsSegCodes(fmsSegCodes.last) := amd_defaults.fmsSegCodes(indx) ;
            end loop ;
        end if ;            


        if fmsSegCodes.first is not null then
            for indx in fmsSegCodes.first .. fmsSegCodes.last loop
                if segment_code like fmsSegCodes(indx) then
                    return true ;
                end if ;
            end loop ;
        end if ;
  
       
        return false ;
        
    end isForeignMilitarySale ;

    function isForeignMilitarySaleYorN(segment_code in varchar2) return varchar2 is
    begin
        if isForeignMilitarySale(segment_code) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isForeignMilitarySaleYorN ;                    

    function validatePlannerCode(planner_code in amd_planners.planner_code%type) 
        return amd_planners.PLANNER_CODE%type is
        wk_planner_code amd_planners.planner_code%type ;
    begin
        select planner_code into wk_planner_code
        from amd_planners 
        where amd_planners.planner_code = validatePlannerCode.planner_code
        and action_code <> 'D' ;
        return planner_code ;
    exception when no_data_found then
        return null ;        
    end validatePlannerCode ;
    
    function getDebugYorN return varchar2 is
    begin
        if debug then 
            return 'Y' ;
        else
            return 'N' ;
        end if ;                        
    end getDebugYorN ;
    
    procedure setDebug(value in varchar2) is
    begin
        debug := upper(value) in ('TRUE','T','YES','Y') ;
    end setDebug ;
    
    function getDebugCnt return number is
    begin
        return debugCnt ;
    end getDebugCnt ;
    procedure setDebugCnt(value in number) is
    begin
        debugCnt := value ;
    end setDebugCnt ;
    
    function getDebugThreshold return number is
    begin
        return mDebugThreshold ;
    end getDebugThreshold ;
    procedure setDebugThreshold(value in number) is
    begin
        mDebugThreshold := value ;
    end setDebugThreshold ;
 
    function getLastLoadDetail return number is
        value number ;
    begin
        select max(load_no) into value from amd_load_details ;
        return value  ;
    exception when others then
        return 0 ;
    end getLastLoadDetail ;
    
    procedure emptyTraceTables is
    begin
        mta_truncate_table('amd_load_status','reuse storage') ;
        mta_truncate_table('amd_load_details','reuse storage') ;
    end emptyTraceTables ;
    
    function isSpoPartYorN(part_no in amd_spare_parts.part_no%type) return amd_spare_parts.is_spo_part%type is
        result varchar2(1) ;
    begin
        select is_spo_part into result from amd_spare_parts where part_no = isSpoPartYorN.part_no ; 
        return result ;
    exception when no_data_found then
        return 'N' ;
    end isSpoPartYorN ;                                           
    
BEGIN
     <<getDebugThresholdInit>>
     DECLARE
             param AMD_PARAM_CHANGES.PARAM_VALUE%TYPE ;
     BEGIN
             SELECT param_value INTO param FROM AMD_PARAM_CHANGES WHERE param_key = 'debugUtilsThreshold' ;
            --mDebugThreshold := to_number(param) ;
     EXCEPTION WHEN OTHERS THEN
                mDebugThreshold := 1000 ;
     END getDebugThresholdInit ;
    
    select param_value bulk collect into fmsSegCodes from amd_param_changes a
    where param_key like 'fms_%' 
    and effective_date = (select max(effective_date) from amd_param_changes where param_key = a.param_key) ; 
 
     
END Amd_Utils;
/


DROP PACKAGE BODY AMD_OWNER.AMD_VALIDATION_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER."AMD_VALIDATION_PKG"    AS
/*
      $Author:   zf297a  $
    $Revision:   1.4  $
     $Date:   Dec 06 2005 10:45:32  $
    $Workfile:   amd_validation_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_validation_pkg.pkb-arc  $

      Rev 1.4   Dec 06 2005 10:45:32   zf297a
   Fixed display of sysdate in errorMsg - changed to MM/DD/YYYY HH:MM:SS

      Rev 1.3   Dec 01 2005 09:50:48   zf297a
   added pvcs keywords
*/

		FUNCTION ErrorMsg(pTableName IN VARCHAR2, pMsg IN VARCHAR2, rc IN NUMBER, data IN VARCHAR2) RETURN NUMBER IS
		BEGIN
		ROLLBACK ;
		Amd_Utils.InsertErrorMsg(
			Amd_Utils.GetLoadNo(pSourceName => 'Validation', pTableName => pTableName),
			1,
			'amd_validation_pkg',
			data, NULL, NULL, TO_CHAR(rc),to_char(sysdate,'MM/DD/YYYY HH:MM:SS'), pMsg);
		COMMIT ;
		RETURN rc ;
		END ErrorMsg ;

	FUNCTION IsValidUomCode(pUom_code AMD_UOMS.uom_code%TYPE) RETURN BOOLEAN IS
		uom_code AMD_UOMS.uom_code%TYPE := NULL ;
	BEGIN
		SELECT uom_code INTO uom_code
		FROM AMD_UOMS
		WHERE uom_code = pUom_code ;
		RETURN TRUE ;
	EXCEPTION WHEN NO_DATA_FOUND THEN
		RETURN FALSE ;
	END IsValidUomCode ;

	FUNCTION IsValidPlannerCode(pPlanner_code AMD_PLANNERS.planner_code%TYPE) RETURN BOOLEAN IS
		planner_code AMD_PLANNERS.planner_code%TYPE := NULL ;
	BEGIN
		SELECT planner_code INTO planner_code
		FROM AMD_PLANNERS
		WHERE planner_code = pPlanner_code ;
		RETURN TRUE ;
	EXCEPTION WHEN NO_DATA_FOUND THEN
		RETURN FALSE ;
	END IsValidPlannerCode ;

    FUNCTION AddPlannerCode(pPlanner_code AMD_PLANNERS.planner_code%TYPE ) RETURN NUMBER IS
	BEGIN
		INSERT INTO AMD_PLANNERS
		(planner_code, action_code, last_update_dt)
		VALUES (pPlanner_code, Amd_Defaults.INSERT_ACTION, SYSDATE ) ;
		RETURN Amd_Validation_Pkg.SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		RETURN ErrorMsg('amd_planners', 'sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM,
			Amd_Validation_Pkg.INSERT_PLANNER_CODE_ERR, pPlanner_code ) ;
	END AddPlannerCode ;

    FUNCTION AddUomCode(pUom_code AMD_UOMS.uom_code%TYPE ) RETURN NUMBER IS
	BEGIN
		INSERT INTO AMD_UOMS
		(uom_code, uom_term)
		VALUES (pUom_code, pUom_code ) ;
		RETURN Amd_Validation_Pkg.SUCCESS ;
	EXCEPTION WHEN OTHERS THEN
		RETURN ErrorMsg('amd_uoms', 'sqlcode=' || SQLCODE || ' sqlerrm=' || SQLERRM,
			Amd_Validation_Pkg.INSERT_UOM_ERR, pUom_code ) ;
	END AddUomCode ;

	FUNCTION GetTacticalInd(pUnit_cost IN AMD_SPARE_PARTS.unit_cost%TYPE, pSmr_code IN AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE) RETURN AMD_SPARE_PARTS.tactical%TYPE IS
	BEGIN
		IF pUnit_cost IS NOT NULL AND pSmr_code IS NOT NULL THEN
			RETURN 'Y' ;
		ELSE
			RETURN 'N' ;
		END IF ;
	END GetTacticalInd ;

END Amd_Validation_Pkg ;
/


DROP PACKAGE BODY AMD_OWNER.AMD_WARNINGS_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.amd_warnings_pkg as
/*
      $Author:   zf297a  $
    $Revision:   1.5  $
     $Date:   30 Jan 2009 15:41:54  $
    $Workfile:   amd_warnings_pkg.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\amd_warnings_pkg.pkb.-arc  $
/*
/*      Rev 1.5   30 Jan 2009 15:41:54   zf297a
/*   Fixed the lv_str varchar2 size for the split function and made it 2000 ... which would be the max size of concatenated email addresses separated by semicolons
/*
/*      Rev 1.4   30 Jan 2009 09:14:20   zf297a
/*   Implemented split interface and created toArray function to convert between this package's t_array type to the email_handler_pkg.array type.  Modified sendWarnings to use the email_hander_pkg.send procedure when the to email address contains more than one email address delimitted by a semicolon.
/*
/*      Rev 1.3   29 Jan 2009 15:01:24   zf297a
/*   Added args to sendWarnings.  Implemented a sendWarnings function that returns the # of current warnings.
/*
/*
/*
/*      Rev 1.2   23 Jan 2009 17:57:44   zf297a
/*   Include key_1 to key_5 in the output email.
/*
/*      Rev 1.1   16 Jan 2009 23:26:06   zf297a
/*   AMD 3.7
/*
/*      Rev 1.0   16 Jan 2009 10:56:44   zf297a
/*   Initial revision.

*/

	CRLF constant varchar2(2)   := utl_tcp.CRLF ;

	FUNCTION toArray (arrayIn in t_array) RETURN email_handler_pkg.array
	is
		strings email_handler_pkg.array := email_handler_pkg.array() ;
	begin
		for i in arrayIn.first .. arrayIn.last loop
			strings.extend ;
			strings(i) := arrayIn(i) ;
		end loop ;
		return strings ;
	end toArray ;


	FUNCTION SPLIT (p_in_string VARCHAR2, p_delim VARCHAR2) RETURN t_array
	IS

		i       number :=0;
		pos     number :=0;
		lv_str  varchar2(2000) := p_in_string;

		strings t_array;

	BEGIN

		-- determine first chuck of string
		pos := instr(lv_str,p_delim,1,1);

		-- while there are chunks left, loop
		WHILE ( pos != 0) LOOP

			-- increment counter
			i := i + 1;

			-- create array element for chuck of string
			strings(i) := substr(lv_str,1,pos-1);

			-- remove chunk from string
			lv_str := substr(lv_str,pos+1,length(lv_str));

			-- determine next chunk
			pos := instr(lv_str,p_delim,1,1);

			-- no last chunk, add to array
			IF pos = 0 THEN

				strings(i+1) := lv_str;

			END IF;

		END LOOP;

		-- return array
		RETURN strings;

	END SPLIT;

    	-- use this function  to make sure a field never exceeds its max length
	function trimToMax(str IN VARCHAR2, maxLen IN NUMBER) RETURN VARCHAR2 IS
	begin
		 if length(str) >maxLen then
		 	return substr(str,1,maxLen) ;
		 else
		 	 return str ;
		 end if ;
	end TrimToMax ;

	procedure insertWarningMsg (
		pData_line_no IN amd_load_warnings.data_line_no%TYPE := NULL,
		pData_line IN amd_load_warnings.data_line%TYPE := NULL,
		pKey_1 IN amd_load_warnings.key_1%TYPE := NULL,
		pKey_2 IN amd_load_warnings.key_2%TYPE := NULL,
		pKey_3 IN amd_load_warnings.key_3%TYPE := NULL,
		pKey_4 IN amd_load_warnings.key_4%TYPE := NULL,
		pKey_5 IN amd_load_warnings.key_5%TYPE := NULL,
		pWarning IN amd_load_warnings.warning%TYPE := NULL ) IS

		dataLine amd_load_warnings.data_line%TYPE := trimToMax(pData_line,2000) ;
		k1 amd_load_warnings.KEY_1%TYPE := trimToMax(pKey_1,50) ;
		k2 amd_load_warnings.KEY_2%TYPE := trimToMax(pKey_2, 50) ;
		k3 amd_load_warnings.KEY_3%TYPE := trimToMax(pKey_3, 50) ;
		k4 amd_load_warnings.KEY_4%TYPE := trimToMax(pKey_4, 40) ;
		k5 amd_load_warnings.KEY_5%TYPE := trimToMax(pKey_5, 50) ;
		msg amd_load_warnings.warning%TYPE := trimToMax(pWarning, 2000) ;

	BEGIN

		 IF msg IS NULL THEN
		 	msg := SUBSTR('sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||')',1,2000) ;
		 END IF ;
		insert into amd_load_warnings
		(
			load_no,
			data_line_no,
			data_line,
			key_1,
			key_2,
			key_3,
			key_4,
			key_5,
			warning
		)
		VALUES
		(
		 	amd_load_warnings_seq.NEXTVAL,
			pData_line_no,
			dataLine,
			k1,
			k2,
			k3,
			k4,
			k5,
			msg
		);
	exception when others then
		  dbms_output.enable(100000) ;
		  if not amd_utils.isNumber(to_char(dataLine)) then
		  	 dbms_output.put_line('dataLine is not a number') ;
		  end if ;
		  dbms_output.put_line('k1=' || k1) ;
		  dbms_output.put_line('k2=' || k2) ;
		  dbms_output.put_line('k3=' || k3) ;
		  dbms_output.put_line('k4=' || k4) ;
		  dbms_output.put_line('k5=' || k5) ;
		  dbms_output.put_line('msg=' || msg) ;

          raise_application_error(-20010,
                substr('amd_warnings_pkg '
                    || sqlcode || ' '
                    || dataLine || ' '
                    || k1 || ' '
                    || k2 || ' '
                    || k3 || ' '
                    || k4 || ' '
                    || k5 || ' '
                    || msg, 1,2000)) ;

	END insertWarningMsg;

	procedure addWarnings(warning in varchar2) is
	begin
		insertWarningMsg(pWarning => warning ) ;
	end addWarnings ;

	function warningsExistForCurJob return boolean is
		cnt number ;
	begin
		select count(*) into cnt
		from amd_load_warnings
		where last_update_dt >= amd_batch_pkg.getLastStartTime ;
		if cnt > 0 then
			return true ;
		else
			return false ;
		end if ;
	end warningsExistForCurJob ;

	function warningsExistForCurJobYorN return varchar2 is
	begin
		if warningsExistForCurJob then
			return 'Y' ;
		else
			return 'N' ;
		end if ;
	end warningsExistForCurJobYorN ;

	function sendWarnings(toEmailAddr in varchar2, subject in varchar2 := 'AMD Load Warnings',
        fromEmailAddr in varchar2 := 'AMDLOAD') return number is
		cnt number ;
	begin
		sendWarnings(toEmailAddr, subject, fromEmailAddr) ;

		select count(*) into cnt
		from amd_load_warnings
		where last_update_dt >= amd_batch_pkg.getLastStartTime ;

		return cnt ;

	end sendWarnings ;

	procedure append(target in out varchar2, text in varchar2) is
	begin
		null ;
	end append ;

	function toLong(text in varchar2) return long is
		msg long := text ;
	begin
		return msg ;
	end toLong ;

   	procedure sendWarnings(toEmailAddr in varchar2, subject in varchar2 := 'AMD Load Warnings',
	        fromEmailAddr in varchar2 := 'AMDLOAD') is

		cursor currentWarnings is
		select distinct data_line,key_1,key_2,key_3,key_4,key_5,warning from amd_load_warnings
		where last_update_dt >= amd_batch_pkg.getLastStartTime ;

		msgBody varchar2(32000) := '<h2>This is a system generated message. DO NOT REPLY.</h2><br><ul>';
		cnt number := 0 ;
		global_name varchar2(30) ;

	begin
		for rec in currentWarnings loop
		    msgBody := msgBody || '<li>' ||  rec.data_line || ': ' ;
		    if rec.key_1 is not null then
			    msgBody := msgBody || rec.key_1 || ' ' ;
		    end if ;
		    if rec.key_2 is not null then
			    msgBody := msgBody || rec.key_2 || ' ' ;
		    end if ;
		    if rec.key_3 is not null then
			    msgBody := msgBody || rec.key_3 || ' ' ;
		    end if ;
		    if rec.key_4 is not null then
			    msgBody := msgBody || rec.key_4 || ' ' ;
		    end if ;
		    if rec.key_5 is not null then
			    msgBody := msgBody || rec.key_5 || ' ' ;
		    end if ;
		    msgBody := msgBody || '..' || rec.warning || '</li>' ;
		    cnt := cnt + 1 ;
		end loop ;

		if cnt > 0 then
			msgBody := msgBody || '</ul>' ;
			if instr(toEmailAddr,';') > 0 then
				select lower(global_name) into global_name from global_name ;
				email_handler_pkg.send
					( p_sender_email => 'amdload@' || global_name,
					p_from => 'AMD LOAD <amdload@' || global_name || '>',
					p_to => toArray( split(toEmailAddr,';')),
					p_cc => email_handler_pkg.array(),
					p_bcc => email_handler_pkg.array(),
					p_subject => sendWarnings.subject,
					p_body => toLong(msgBody) ) ;
			else
				email_handler_pkg.send_email(subject => sendWarnings.subject,
					to_userid => toEmailAddr,
					v_body => msgBody,
					from_name => fromEmailAddr) ;
			end if ;
		end if ;

	end sendWarnings ;


end amd_warnings_pkg ;
/


DROP PACKAGE BODY AMD_OWNER.CONSUMABLES_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.consumables_Pkg AS
    
/*
      $Author:   zf297a  $
    $Revision:   1.15  $
        $Date:   26 Jul 2013
    $Workfile:   consumables_PKG.pkb  $
    
         rev 1.15 removed a2a dependencies
/*   
         rev 1.14 renamed package from a2a_consumables_pkg to consumables_pkg
         
/*      Rev 1.13   15 Oct 2008 09:45:40   zf297a
/*   Fixed the literal used by debugMsg. Added lots of debugMsg's 
/*   
/*      Rev 1.12   13 Oct 2008 23:05:00   zf297a
/*   Added debug code + tweaked insert of tmp_a2a_part_info - it is hanging up for some reason.
/*   
/*      Rev 1.11   28 Aug 2008 15:34:02   zf297a
/*   Implemented getVersion
/*   
/*      Rev 1.10   13 Aug 2008 16:50:20   zf297a
/*   Made errorMsg act as autonomous transaction so that this routine may issue commits independent of the main transaction.
/*   
/*      Rev 1.9   12 Aug 2008 08:07:02   zf297a
/*   Implemented isPartValidYorN with additional arguments: part_no, smr_code, nsn, planner_code, and mtbdr.
/*   
/*      Rev 1.8   05 Aug 2008 18:25:20   zf297a
/*   Use the default planner_code when inserting or updating tmp_a2a_part_info and the planner_code passed in is null.
/*   
/*      Rev 1.7   31 Jul 2008 11:14:06   zf297a
/*   Used repairables_pkg.getAssignedPlannerCode to make sure all resp_asset_mgr of the tmp_a2a_part_info is set to a common value.
/*   
/*      Rev 1.6   09 Oct 2007 15:19:02   zf297a
/*   Removed planner code filter 
/*   
/*      Rev 1.5   19 Sep 2007 16:52:56   zf297a
/*   Fixed isPartValid to use the new amd_utils.isPartConsumable boolean function, which is a function that does not need to retrieve any data to make the determination if a part is consumable.
/*   
/*      Rev 1.4   20 Aug 2007 22:46:08   zf297a
/*   Added a doUpdate procedure to insertPartInfo to update any a2a record.
/*   
/*      Rev 1.3   16 Aug 2007 14:26:32   zf297a
/*   Implemented procedure version and added procedure writeMsg.
/*   
/*      Rev 1.2   Jul 19 2007 08:55:46   c402417
/*   Corrected typo PDS to PSD in
/*   function isPlannerCodeValid.
/*   
/*      Rev 1.1   Jul 18 2007 07:55:28   c402417
/*   Changed to get indenture from local instead of from repairables_pkg.pkg
/*   
/*      Rev 1.0   29 May 2007 12:54:04   zf297a
/*   Initial revision.
*/    
     mArgs VARCHAR2(2000) ;
     
     debug boolean := false ;
    
    procedure writemsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 IN VARCHAR2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'consumables_pkg',    
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
    exception when others then
        --  ignoretrying to rollback or commit from trigger
        if sqlcode <> -4092 then
            raise_application_error(-20010,
                substr('repairables_pkg ' 
                    || sqlcode || ' '
                    || pError_Location || ' ' 
                    || pTableName || ' ' 
                    || pKey1 || ' ' 
                    || pKey2 || ' ' 
                    || pKey3 || ' ' 
                    || pKey4 || ' '
                    || pData, 1,2000)) ;
        end if ;
    end writemsg ;
    
     PROCEDURE errorMsg(
         pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE := 'errorMsg',
         pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE := 'noname',
         pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE := -100,
         pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE := '',
          pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
         pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
         pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
         pKeywordValuePairs IN VARCHAR2 := '') IS
         
         pragma autonomous_transaction ;
         
         key5 AMD_LOAD_DETAILS.KEY_5%TYPE := pKeywordValuePairs ;
         saveSqlCode number := sqlcode ;
         
     BEGIN
          IF key5 = '' or key5 is null THEN
             key5 := pSqlFunction || '/' || pTableName ;
          ELSE
            if key5 is not null then
                if length(key5) + length('' || pSqlFunction || '/' || pTablename) < 50  then           
                    key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
                end if ;
            end if ;
          END IF ;
          -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
          -- do not exceed the length of the column's that the data gets inserted into
          -- This is for debugging and logging, so efforts to make it not be the source of more
          -- errors is VERY important
          
          dbms_output.put_line('insertError@' || pError_location) ;
          
          Amd_Utils.InsertErrorMsg (
            pLoad_no => Amd_Utils.GetLoadNo(
              pSourceName => SUBSTR(pSqlfunction,1,20),
              pTableName  => SUBSTR(pTableName,1,20)),
            pData_line_no => pError_location,
            pData_line    => 'consumables_pkg.' || mArgs,
            pKey_1 => SUBSTR(pKey_1,1,50),
            pKey_2 => SUBSTR(pKey_2,1,50),
            pKey_3 => SUBSTR(pKey_3,1,50),
            pKey_4 => SUBSTR(pKey_4,1,50),
            pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS') ||
                 ' ' || substr(key5,1,50),
            pComments => SUBSTR('sqlcode('||saveSQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
            
            if sqlcode <> -4092 then            
                COMMIT;
            end if ;
       
     EXCEPTION WHEN OTHERS THEN
       dbms_output.enable(10000) ;
       dbms_output.put_line('sql error=' || sqlcode || ' ' || sqlerrm) ;
       if pSqlFunction is not null then dbms_output.put_line('pSqlFunction=' || pSqlfunction) ; end if ;
       if pTableName is not null then dbms_output.put_line('pTableName=' || pTableName) ; end if ;
       if pError_location is not null then dbms_output.put_line('pError_location=' || pError_location) ; end if ;
       if pKey_1 is not null then dbms_output.put_line('key1=' || pKey_1) ; end if ;
       if pkey_2 is not null then dbms_output.put_line('key2=' || pKey_2) ; end if ;
       if pKey_3 is not null then dbms_output.put_line('key3=' || pKey_3) ; end if ;
       if pKey_4 is not null then dbms_output.put_line('key4=' || pKey_4) ; end if ;
       if pKeywordValuePairs is not null then dbms_output.put_line('pKeywordValuePairs=' || pKeywordValuePairs) ; end if ;
       if sqlcode <> -4092 then
           raise_application_error(-20030,
                substr('repairables_pkg ' 
                    || sqlcode || ' '
                    || pError_location || ' '
                    || pSqlFunction || ' ' 
                    || pTableName || ' ' 
                    || pKey_1 || ' ' 
                    || pKey_2 || ' ' 
                    || pKey_3 || ' ' 
                    || pKey_4 || ' '
                    || pKeywordValuePairs,1, 2000)) ;
        end if ;
     END errorMsg;

     PROCEDURE debugMsg(msg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE, pError_Location IN NUMBER) IS
        pragma autonomous_transaction ;
     BEGIN
       IF debug THEN
           Amd_Utils.debugMsg(pMsg => msg,pPackage => 'consumables_pkg', pLocation => pError_location) ;
           COMMIT ; -- make sure the trace is kept
       END IF ;
     EXCEPTION WHEN OTHERS THEN
                IF SQLCODE = -14551 OR SQLCODE = -14552 THEN
                     NULL ; -- cannot do a commit inside a query, so ignore the error
               ELSE
                      RAISE ;
               END IF ;
     END debugMsg ;

    procedure getPartInfoData(part_no in amd_spare_parts.part_no%type,
        smr_code     out    amd_national_stock_items.smr_code%type,
        nsn          out    amd_spare_parts.nsn%type,
        planner_code out    amd_national_stock_items.planner_code%type,
        mtbdr        out    amd_national_stock_items.MTBDR%type ) is
        
        nsi_sid amd_national_stock_items.nsi_sid%type ;
        
    begin
        debugMsg('getPartInfoData: ' || part_no, pError_location => 10) ;
        select items.smr_code, items.nsn,  items.mtbdr, items.nsi_sid
        into smr_code, nsn,  mtbdr, nsi_sid
        from amd_spare_parts parts, amd_national_stock_items items
        where getPartInfoData.part_no = parts.part_no
        and parts.nsn = items. nsn ;
        planner_code := amd_preferred_pkg.getPlannerCode(nsi_sid) ;
    exception
        when standard.no_data_found then
            return ;
        when others then
           errorMsg(pSqlfunction => 'select',pTableName => 'amd_spare_parts/amd_national_stock_items',
             pError_location => 20, pKey_1 => part_no ) ;
           raise ;
        
    end getPartInfoData ;
    
    procedure getPartInfoData(part_no in amd_spare_parts.part_no%type,
            nomenclature out     amd_spare_parts.NOMENCLATURE%type,
            mfgr         out    amd_spare_parts.MFGR%type,
            unit_issue   out    amd_spare_parts.UNIT_OF_ISSUE%type,
            smr_code     out    amd_national_stock_items.smr_code%type,
            nsn          out    amd_spare_parts.nsn%type,
            planner_code out    amd_national_stock_items.planner_code%type,
            mtbdr        out    amd_national_stock_items.MTBDR%type,
            price        out    amd_spare_parts.UNIT_COST%type ) 
         is
    begin        
        debugMsg('getPartInfoData(' || part_no || ')', pError_location => 30) ;            
        select nomenclature, mfgr, unit_of_issue, parts.nsn, 
            amd_preferred_pkg.GetPreferredValue(smr_code_cleaned, smr_code) smr_code,
            amd_preferred_pkg.getPreferredValue(mtbdr_cleaned, mtbdr_computed, mtbdr) mtbdr,            
            amd_preferred_pkg.getPreferredValue(planner_code_cleaned, planner_code) planner_code,
            amd_preferred_pkg.getPreferredValue(unit_cost_cleaned, unit_cost) price
        into nomenclature, mfgr, unit_issue, nsn, smr_code, mtbdr, planner_code, price             
        from amd_spare_parts parts, amd_national_stock_items items
        where part_no = getPartInfoData.part_no
        and parts.nsn = items.nsn ;
        
    exception when others then
       errorMsg(pSqlfunction => 'select',pTableName => 'amd_spare_parts/amd_national_stock_items',
         pError_location => 40, pKey_1 => part_no ) ;
       raise ;
        
    end getPartInfoData ;

     
    FUNCTION getIndenture(smr_code_preferred IN AMD_NATIONAL_STOCK_ITEMS.SMR_CODE%TYPE) RETURN varchar2 IS
     BEGIN
       IF SUBSTR(smr_code_preferred,6,1) IN ('N','P') THEN
            RETURN '3' ;
       END IF ;
       return null;       
     END getIndenture ; 

    function isPlannerCodeValid(plannerCode in amd_national_stock_items.planner_code%type) 
        return boolean is
        isValid BOOLEAN := TRUE ;
    begin
        return isValid ; 
    end isPlannerCodeValid ;
    
    function isPlannerCodeValidYorN(plannerCode in amd_national_stock_items.planner_code%type) return varchar2 is
    begin
        if isPlannerCodeValid(plannerCode) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isPlannerCodeValidYorN ;
           


    function isPartValid(part_no in varchar2,    
        smr_code     in    amd_national_stock_items.smr_code%type,
        nsn          in    amd_spare_parts.nsn%type,
        planner_code in    amd_national_stock_items.planner_code%type,
        mtbdr        in    amd_national_stock_items.MTBDR%type ) return boolean is
        
       result boolean := false ;
       
       lineNo           number := 0 ;
                  
    begin
        -- ToDo: change all literals and tests to be specifically for consumables               
    
        lineNo := 20 ;            
        if not amd_utils.isPartActive(part_no) then
             return false ;
        end if ;
        IF UPPER(part_No) = 'F117-PW-100' OR INSTR(UPPER(part_no),'17L8D') > 0 OR INSTR(UPPER(part_no),'17R9Y') > 0 OR INSTR(UPPER(smr_code),'PE') > 0 THEN
              RETURN FALSE ;
        END IF ;
       
       lineNo := 30 ;            
       if repairables_pkg.getAcquisitionAdviceCode(part_no) = 'Y' then
            return false ;
       end if ;
       
       lineNo := 40 ;            
       result := amd_utils.isPartConsumable(preferred_smr_code => smr_code,
                    preferred_planner_code => planner_code, nsn => nsn) ;
       
       if not result then
             if showreason then 
                dbms_output.put_line(smr_code || ' is NOT a valid smr code') ; 
            end if ;
       end if ;
       
       lineNo := 50 ;            
       result := result AND isPlannerCodeValid(planner_Code) ;
       IF result AND repairables_pkg.isNsl(part_no) THEN
       
         IF showReason AND (mtbdr IS NOT NULL AND mtbdr > 0) THEN
             dbms_output.put_line('mtbdr > 0 for part ' || part_no) ; 
         END IF ;
         
        lineNo := 60 ;            
        result := result AND (repairables_pkg.demandExists(part_no, showReason) 
                                    OR repairables_pkg.inventoryExists(part_no, showReason)
                                    OR (mtbdr IS NOT NULL AND mtbdr > 0)
                                    OR repairables_pkg.isNsnValid(part_no,showReason)
                             ) ;
      END IF ;
      
      if not result then
           if showreason then 
            dbms_output.put_line('part ' || part_no || ' is NOT valid.') ; 
           end if ;
      end if ;
      
      return result ;
      
     exception when others then
        if sqlcode = -20000 then
            dbms_output.disable ; -- buffer overflow, disable
            return isPartValid(part_no) ; -- try validation again
        else
            errorMsg(pSqlfunction => 'select',pTableName => 'isPartValid',
              pError_location => 50, pKey_1 => part_no, pKey_2 => lineNo ) ;
            raise ;
        end if ;
    
    end isPartValid ;
    
    function isPartValidYorN(part_no in varchar2,    
        smr_code     in    amd_national_stock_items.smr_code%type,
        nsn          in    amd_spare_parts.nsn%type,
        planner_code in    amd_national_stock_items.planner_code%type,
        mtbdr        in    amd_national_stock_items.MTBDR%type ) return varchar2 is
    begin
        if isPartValid(part_no,smr_code,nsn,planner_code,mtbdr) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;                        
    end isPartValidYorN ;        


    function isPartValid(part_no in varchar2) return boolean is
            smr_code        amd_national_stock_items.smr_code%type ;
            nsn             amd_spare_parts.nsn%type ;
            planner_code    amd_national_stock_items.planner_code%type ;
            mtbdr           amd_national_stock_items.MTBDR%type ;
    begin
        getPartInfoData(part_no, smr_code, nsn, planner_code, mtbdr) ;

        debugMsg('isPartVaid: ' || part_no 
        || ' ' || smr_code 
        || ' ' || nsn 
        || ' ' || planner_code
        || ' ' || mtbdr, pError_location => 55) ;          

        return isPartValid(part_no,  smr_code, nsn, planner_code, mtbdr) ;
        
    end isPartValid ;
     
    function isPartValidYorN(part_no in varchar2) return varchar2 is
    begin
        if isPartValid(part_no) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isPartValidYorN;

    procedure insertPartInfo(part_no in varchar2, action_code in varchar2) is
            nomenclature      amd_spare_parts.NOMENCLATURE%type ;
            mfgr             amd_spare_parts.MFGR%type ;
            unit_issue       amd_spare_parts.UNIT_OF_ISSUE%type ;
            smr_code         amd_national_stock_items.smr_code%type ;
            nsn              amd_spare_parts.nsn%type ;
            planner_code     amd_national_stock_items.planner_code%type ;
            mtbdr            amd_national_stock_items.MTBDR%type ;
            price            amd_spare_parts.UNIT_COST%type ; 
    begin
        debugMsg('insertPartInfoData: ' || part_no, pError_location => 60) ;
        getPartInfoData(part_no, nomenclature, mfgr, unit_issue, smr_code, nsn, planner_code, mtbdr, price) ;
        
        insertPartInfo(action_code, part_no, nomenclature, mfgr, unit_issue, smr_code, nsn, planner_code,
        repairables_pkg.THIRD_PARTY_FLAG, mtbdr, price) ;
        
    end insertPartInfo ;

    procedure insertPartInfo(action_code in varchar2, part_no in varchar2, nomenclature in varchar2,
           mfgr in varchar2,  unit_issue in varchar2, smr_code in varchar2, nsn in varchar2, planner_code in varchar2,
           third_party_flag in varchar2, mtbdr in number, price in number) is
          
        indenture      varchar2(7) ;
        rcm_ind         varchar2(1) ;        
        a2a_action_code varchar2(1) := action_code ;
        nsn_fsc        varchar2(4) := substr(nsn, 1, 4) ;
        nsn_niin        varchar2(9) := substr(nsn, 5, 9) ;
        thePlannerCode amd_national_stock_items.planner_code%type ;  
        is_spo_part amd_spare_parts.is_spo_part%type ;  
        
        procedure doUpdate(action_code in varchar2) is
        begin
        debugMsg('insertPartInfo.doUpdate: ' 
        || insertPartInfo.part_no, pError_location => 65) ;
        end doUpdate ;
        
        procedure insertTmpA2A(action_code in varchar2) is
        begin
            debugMsg('insertTmpA2A: ' 
        || action_code || ' ' 
        || part_no || ' ' 
        || nsn_fsc || ' '
        || nsn_niin, pError_location => 70) ;
/*
        insert into tmp_a2a_part_info
        (part_no,noun,action_code,last_update_dt)
        values(part_no, nomenclature,action_code,sysdate) ;
        doUpdate(action_code) ;
        */
        
        
        exception when standard.DUP_VAL_ON_INDEX then
            doUpdate(action_code) ;
        end insertTmpA2A ;
        
         
    begin
        debugMsg('insertPartInfo: ' || part_no || ' ' || action_code,
            pError_location => 80) ;

        if planner_code is null then
            thePlannerCode := amd_defaults.CONSUMABLE_PLANNER_CODE ;
        else
            thePlannerCode := planner_code ;
        end if ;                        
    
    select is_spo_part into insertPartInfo.is_spo_part 
    from amd_spare_parts 
    where part_no = insertPartInfo.part_no ;
        if is_spo_part = 'Y' then
                        
            indenture := getIndenture(smr_code) ;
            
            if length(smr_code) >= 6 then
                rcm_ind := repairables_pkg.getValidRcmInd(SUBSTR(smr_code,6,1)) ; -- ToDo: make sure this works for consumables
            end if ;
        debugMsg('insertPartInfo: ' || action_code,pError_location => 83) ;
            insertTmpA2A(action_code) ;
        else
            if repairables_pkg.isPartSent(part_no) then
        debugMsg('insertPartInfo: D',pError_location => 85) ;
                insertTmpA2A(amd_defaults.DELETE_ACTION ); -- make sure the part_no is deleted    
            else
                return ;    
            end if ;
        end if ;
        
    exception when others then
        errorMsg(pSqlfunction => 'select',pTableName => 'tmp_a2a_part_info',
            pError_location => 90, pKey_1 => part_no ) ;
        raise ;
    end insertPartInfo ;

    procedure version is
    begin
         writeMsg(pTableName => 'consumables_pkg', 
                 pError_location => 100, pKey1 => 'consumables_pkg', pKey2 => '$Revision:   1.15  $') ;
          dbms_output.put_line('consumables_pkg: $Revision:   1.15  $') ;
    end version ;
    
    function getVersion return varchar2 is
    begin
        return '$Revision:   1.15  $' ;
    end getVersion ;
     
    procedure setDebug(switch in varchar2) is
    begin
        debug := upper(switch) in ('Y','T','YES','TRUE') ;
        if debug then
            dbms_output.ENABLE(100000) ;
        else
            dbms_output.DISABLE ;
        end if ;                    
    end setDebug ;

end consumables_pkg ;
/


DROP PACKAGE BODY AMD_OWNER.EMAIL_HANDLER_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.email_handler_pkg  is

/*
      $Author:   zf297a  $
    $Revision:   1.1  $
        $Date:   10 Apr 2009 15:31:08  $
    $Workfile:   email_handler_pkg.sql  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\EMAIL_HANDLER_PKG.pkb.-arc  $
/*
/*      Rev 1.4   07 Apr 2009 23:58:22   zf297a
/*   Add time zone to Date: email sent.
/*
/*      Rev 1.3   18 Feb 2009 08:15:10   zf297a
/*   Change the content type to html for the send procedure.
/*
/*      Rev 1.2   30 Jan 2009 09:17:50   zf297a
/*   Fixed address_email function
/*
/*      Rev 1.1   23 Jan 2009 17:59:24   zf297a
/*   Implemented interface for a more flexible send procedure
/*
/*      Rev 1.0   16 Jan 2009 11:02:16   zf297a
/*   Initial revision.
*/


    g_crlf        char(2) default chr(13)||chr(10);
    g_mail_conn   utl_smtp.connection;
    g_mailhost    varchar2(255) := 'relay.boeing.com';
    debug_flag boolean := false ;

    procedure setDebug(flag in char) is
    begin
        if flag = 'Y' or flag = 'T' then
            debug_flag := true ;
        end if ;             
    end setDebug ;
    function address_email( p_string in varchar2,
        p_recipients in array ) return varchar2 is
        l_recipients long;
    begin
        for i in 1 .. p_recipients.count loop
            utl_smtp.rcpt(g_mail_conn, p_recipients(i) );
            if ( l_recipients is null ) then
                l_recipients := p_string || p_recipients(i) ;
            else
                l_recipients := l_recipients || ', ' || p_recipients(i);
            end if;
        end loop;
        return l_recipients;
    exception when others then
        dbms_output.put_line('sqlcode=' || sqlcode || ' sqlerrm=' || sqlerrm) ;
        return '' ;
    end address_email ;

    procedure send( p_sender_email in varchar2,
        p_from         in varchar2,
        p_to           in array default array(),
        p_cc           in array default array(),
        p_bcc          in array default array(),
        p_subject      in varchar2,
        p_body         in long )
    is
        l_to_list   long;
        l_cc_list   long;
        l_bcc_list  long;
        l_date      varchar2(255) default
        to_char(systimestamp,'dd Mon yy hh24:mi:ss tzr tzd') ;
                --to_char( SYSDATE, 'dd Mon yy hh24:mi:ss' );

        procedure writeData( p_text in varchar2 )
        as
        begin
            if ( p_text is not null )
            then
                utl_smtp.write_data( g_mail_conn, p_text || g_crlf );
                if debug_flag then
                    dbms_output.put_line(p_text || g_crlf);
                end if;
            end if;
        end writeData ;

    begin
        g_mail_conn := utl_smtp.open_connection(g_mailhost, 25);

        utl_smtp.helo(g_mail_conn, g_mailhost);
        utl_smtp.mail(g_mail_conn, p_sender_email);

        l_to_list  := address_email( 'To: ', p_to );
        l_cc_list  := address_email( 'Cc: ', p_cc );
        l_bcc_list := address_email( 'Bcc: ', p_bcc );

        utl_smtp.open_data(g_mail_conn );

        writeData( 'Date: ' || l_date );
        writeData( 'From: ' || nvl( p_from, p_sender_email ) );
        writeData( 'Subject: ' || nvl( p_subject, '(no subject)' ) );
        writeData('Content-Type: text/html');

        writeData( l_to_list );
        writeData( l_cc_list );

        utl_smtp.write_data( g_mail_conn, '' || g_crlf );
        utl_smtp.write_data(g_mail_conn, p_body );
        utl_smtp.close_data(g_mail_conn );
        utl_smtp.quit(g_mail_conn);

    end send ;


    procedure send_email(subject in varchar2,
        to_userid in varchar2 := NULL,
        v_body in varchar2 := NULL,
        from_name in varchar2 := NULL,
        to_name in varchar2 := NULL,
        content_type in varchar2 := NULL) IS

        c utl_smtp.connection;
        -- from_userid varchar2(40) := 'webmaster@boeing.com';
        from_userid varchar2(40) := 'amdload@relay.boeing.com';
        send_user varchar2(40);
        from_domain VARCHAR2(200) := SUBSTR(from_userid,INSTR(from_userid,'@')+1);
        smtp_server varchar2(50) := 'relay.boeing.com';
        my_body varchar2(32000);

        procedure header(name varchar2, value varchar2) is
        begin
            utl_smtp.write_data(c, name || ': ' || value || utl_tcp.CRLF);
        end header ;

    BEGIN

        if to_userid is null then
            send_user := user || '@boeing.com';
        else
            send_user := to_userid;
        end if;

        my_body := v_body;

        c := utl_smtp.open_connection(smtp_server);
        utl_smtp.helo(c, from_domain );
        utl_smtp.mail(c, from_userid );
        utl_smtp.rcpt(c, send_user );
        utl_smtp.open_data(c);

        header('From','"'|| NVL(from_name,from_userid)
            ||'" <'||from_userid||'>');  header('To','"'
            ||NVL(to_name,to_userid)||'" <'||to_userid||'>');

        header('Subject', subject );
        header('Content-Type', NVL(content_type,'text/html'));
        utl_smtp.write_data(c, utl_tcp.CRLF || my_body );
        utl_smtp.close_data(c);
        utl_smtp.quit(c);

    EXCEPTION WHEN utl_smtp.transient_error OR utl_smtp.permanent_error THEN
        utl_smtp.quit(c);

    end send_email;

end email_handler_pkg ;
/


DROP PACKAGE BODY AMD_OWNER.REPAIRABLES_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.repairables_Pkg AS
 --
 -- SCCSID:   %M%   %I%   Modified: %G%  %U%
 --
 /*
      $Author:   zf297a  $
    $Revision:   1.236 $
     $Date:   26 Jul 2013 
           rev 1.236 got rid of all a2a dependencies
           
           rev 1.235 got rid of references to tmp_a2a_backorder_info
           
          Rev 1.234 renamed package to repairables_pkg
/*      Rev 1.233 got riid of ampersands and removed amd_partPrime_pkg procedure that was no longer there
   
/*      Rev 1.232   24 Feb 2009 22:31:00   zf297a
/*   Commented out invocation of packages that have had a2a code removed.
/*   
/*      Rev 1.231   24 Feb 2009 11:50:00   zf297a
/*   Removed a2a for amd_location_part_override's
/*   
/*      Rev 1.230   15 Jan 2009 15:57:22   zf297a
/*   converted from loc_sid to spo_location for amd_backorder_sum
/*   
/*      Rev 1.229   23 Oct 2008 21:11:22   zf297a
/*   Make sure the part was sent before trying to insert a tmp_a2a_part_pricing row.
/*   
/*      Rev 1.228   23 Oct 2008 14:34:38   zf297a
/*   Fixed updatePartPricing by making sure that the part was sent before inserting .. ie a record exist in amd_sent_to_a2a for the given part_no.
/*   
/*      Rev 1.227   15 Oct 2008 09:46:22   zf297a
/*   Renumbered pError_location's.
/*   
/*      Rev 1.226   13 Aug 2008 17:19:28   zf297a
/*   get rid of setting the debug flag via a amd_param_changes flag.  get rid of excessive debugMsg's.   
/*   Only turn on the debug with the setDebug procedure.
/*   
/*      Rev 1.225   13 Aug 2008 16:48:42   zf297a
/*   Made errorMsg and debugMsg act as autonomous transactions so that these routines may issue commits independent of the main transaction.
/*   
/*      Rev 1.224   12 Aug 2008 08:16:04   zf297a
/*   Implemented interface isPartValidYorN with additional arguments: part_no, preferred smr_code, preferred mtbdr, and preferred planner_code.
/*   
/*      Rev 1.223   05 Aug 2008 18:25:06   zf297a
/*   Use the default planner_code when inserting or updating tmp_a2a_part_info and the planner_code passed in is null.
/*   
/*      Rev 1.222   05 Aug 2008 12:47:14   zf297a
/*   Fixed showReason message for function isNsnInRblPairs
/*   
/*      Rev 1.221   05 Aug 2008 09:55:10   zf297a
/*   Make sure all subroutines of isPartValid are using showReason so that they will display the reason the test failed when showReason is set to true.
/*   
/*   Use the default planner code when retrieving data for the isPartValid routine.
/*   
/*      Rev 1.220   31 Jul 2008 11:18:30   zf297a
/*   Make sure that planner_code gets set via getAssignedPlannerCode for all updates or insert of tmp_a2a_part_info
/*   
/*      Rev 1.219   09 Jul 2008 14:44:54   zf297a
/*   Eliminated cursor managersNoUser and started using amd_defaults.CONSUMABLE_PLANNER_CODE and amd_defaults.REPAIRABLE_PLANNER_CODE.
/*   
/*      Rev 1.218   27 Jun 2008 12:01:56   zf297a
/*   Added some debug to function deletePartInfo and deleteSentToA2AChildren plus added commit's to deleteSentToA2AChildren to try to figure out why function deletePartInfo is stalling in AMDD when it does an insert to tmp_a2a_part_info.
/*   
/*      Rev 1.217   15 May 2008 19:45:10   zf297a
/*   changed mDebug to debug which gets set via the setDebug procedure and retrived via the getDebugYorN.
/*   
/*      Rev 1.216   13 Mar 2008 11:48:02   zf297a
/*   Changed OVERRIDE_TYPE to TSL_OVERRIDE_TYPE
/*   
/*      Rev 1.215   22 Feb 2008 12:27:32   zf297a
/*   For all initA2A routines make sure the data is in order by key and last_update_dt so the most recent Add, Change, or Delete is sent.
/*   
/*      Rev 1.214   22 Feb 2008 11:58:24   zf297a
/*   for initA2ARepairInvInfo make sure the data is ordered by key and last_update_dt so that the last Add, Change, or Delete for a particular key is the most recent.
/*   
/*      Rev 1.213   22 Feb 2008 11:22:30   zf297a
/*   Made sure updateCnt gets saved correctly to amd_load_details
/*   
/*      Rev 1.212   22 Feb 2008 11:10:28   zf297a
/*   Added package counters for debugging: insertCnt, deleteCnt, updateCnt  andrejectCnt.
/*   Added debugging to processOnHandInvSum
/*   Added debugging to initA2AInvInfo
/*   Fixed processRepairInvInfo: removed rec variables, fixed invocation of insertRepairInvInfo - site_location was not being passed from the repairInvInfos array.
/*   Added debugging to initA2ARepairInvInfo
/*   Added execption handlers to all doUpdate routines
/*   Added nested procedure doUpdate to insertInvInfo
/*   Added debugging to insertInvInfo
/*   Added nested procedure doUpdate to insertRepairInvInfo
/*   Added debugging to insertRepairInvInfo
/*   
/*   
/*   
/*   
/*      Rev 1.211   04 Feb 2008 10:37:18   zf297a
/*   Modifed isPartValid to check whether the part is consumable.  If it is consumable it uses the consumables_pkg.isPartValid funtion to determine if the part is valid for SPO.
/*   
/*      Rev 1.210   30 Jan 2008 10:51:02   zf297a
/*   Added debug and debug threshold variables and their corresponding get/set methods.
/*   
/*      Rev 1.209   03 Dec 2007 13:20:48   zf297a
/*   Removed the rec variable from processOnHandInvSum and made sure to use the array onHandInvSums to get all data for the insertInvInfo procedure.
/*   
/*      Rev 1.208   30 Nov 2007 09:19:28   zf297a
/*   Fixed insertTimeToRepair to use data from amd_national_stock_items vs amd_part_locs.
/*   For the loadAll procedure using a more complete load of amd_location_part_override and amd_locpart_overid_consumables by using amd_location_part_override_pkg.loadInitial and amd_lp_override_consumabl_pkg.initialize ;
/*   
/*      Rev 1.207   16 Nov 2007 13:15:24   zf297a
/*   changed insertTimeToRepair to get the time_to_repair_off_base from amd_national_stock_items instead of amd_part_locs, since amd_part_locs does not get updated.
/*   
/*      Rev 1.206   08 Nov 2007 11:35:46   zf297a
/*   Removed erroneous close's of cursor that are being bulk collected, since the process routine closes the cursor.  Added check to see if .first is not null before trying to process any data in the bulk table.
/*   
/*      Rev 1.204   06 Nov 2007 15:07:00   zf297a
/*   Changed most of the cursors to use bulk collect.
/*   
/*      Rev 1.203   06 Nov 2007 12:14:08   zf297a
/*   Added BULK COLLECt to processParts
/*   
/*      Rev 1.202   01 Nov 2007 11:55:22   zf297a
/*   Fixed initA2APartAlt to load only alternate parts.    Allow all parts to be inserted into tmp_a2a_part_lead_time with their lead time
/*   
/*      Rev 1.201   27 Sep 2007 18:55:02   zf297a
/*   Implemented initA2APartAlt.  Changed loadAllA2A to have 16 steps, where the 16th step executes initA2APartAlt.
/*   
/*      Rev 1.200   19 Sep 2007 17:18:36   zf297a
/*   Implemented the interface for insertPartInfo.  This interface allows for all the data to be passed to the procedure versus it needing to retrieve it.
/*   Implemented the interface for isPartValid.  This interface allows for all the data to be passed to the function versus it needing to retrieve it.
/*   Implemented procedure insertTmpA2APartInfo.  This procedure allows for a row to be inserted into the tmp_a2a_part_info table after having been verified to be repairable or consumable and a valid part for the SPO.
/*   Used the new isPartValid and isRepairableSmr to determine these conditions without retrieving any data, but just using the passed in data.
/*   Replaced the SQL insert's of rows to tmp_a2a_part_info with the new procedure insertTmpA2APartInfo.
/*   
/*      Rev 1.199   17 Sep 2007 21:47:10   zf297a
/*   Fixed lpOverrideExists to use an existenial qualifier 'Exists' to determine if a row exists for the given part and site_location in view datasys_lp_override_v.  The other query return more than one row and caused ORA-01422 fetch errors.
/*   
/*      Rev 1.198   14 Sep 2007 13:23:12   zf297a
/*   For PartLeadTime A2A's only create them for spo_prime_part's.
/*   
/*      Rev 1.197   14 Sep 2007 13:06:06   zf297a
/*   Streamlined functions insertPartLeadTime, updatePartLeadTime, and deletePartLeadTime to use one common routine to create the A2A transaction.
/*   
/*      Rev 1.196   14 Sep 2007 11:52:48   zf297a
/*   Only send delete A2A PartLeadTime delete transactions for repairable or consumable parts.
/*   
/*      Rev 1.194   14 Sep 2007 11:01:30   zf297a
/*   Make sure a2a part lead time transactions are being created for both repairable and consumable parts.
/*   
/*      Rev 1.193   11 Sep 2007 16:03:26   zf297a
/*   Removed commits from all for/loops.
/*   
/*      Rev 1.192   07 Sep 2007 16:04:26   zf297a
/*   For procedure deleteInvalidParts fixed the cursor to retrieve consumables that are no longer valid as well as parts that are neither consumable nor repairable - all these parts need to be "excluded" from SPO.
/*   
/*      Rev 1.191   23 Aug 2007 09:22:32   zf297a
/*   initA2ADemands was running too long with the multiple invocations of functions, so I created a simple cursor and for loop to load the data.
/*   
/*      Rev 1.190   20 Aug 2007 09:36:08   zf297a
/*   Added invocation of amd_demand.loadAllA2A to load the ExtForecast consumables
/*   
/*      Rev 1.189   16 Aug 2007 12:34:34   zf297a
/*   added invocation of amd_lp_override_consumabl_pkg.loadAllA2A in the loadAllA2A procedure.
/*   
/*      Rev 1.188   27 Jul 2007 13:03:14   zf297a
/*   Added the check for isPartConsumable to the overloaded insertPartInfo routine that takes a complete list of arguments to make it like the insertPartInfo with one part_no argument.  The overloaded routine that takes the record does not need this test  since it is just a wrapper for the insertPartInfo with the list of part info arguments.
/*   
/*      Rev 1.187   25 Jun 2007 09:50:00   zf297a
/*   Fixed cursor invalidParts for procedure deleteInvalidParts
/*   
/*      Rev 1.186   25 Jun 2007 08:17:04   zf297a
/*   Use the new rcm constants.  Changed the deleteInvalidParts' cursor to be more specific: for repairable parts that are not valid.
/*   
/*      Rev 1.185   Jun 18 2007 15:05:30   c402417
/*   Modified the Consumable to function getValidRcmInd and isPartValid.
/*   
/*      Rev 1.183   25 May 2007 13:32:54   zf297a
/*   Implemented the following functions:
/*   getValidRcmInd
/*   isPlannerCodeValidlannerCode
/*   isPlannerCodeValidYorNlannerCode
/*   getAcquisitionAdviceCodeart_no
/*   isNsnInRblPairssn
/*   isNsnInRblPairsYorNsn
/*   isNsnInIsgPairssn
/*   isNsnInIsgPairsYorNsn
/*   isNsnValidart_no
/*   isNsnValidYorNart_no
/*   demandExistsart_no
/*   demandExistsYorNart_no
/*   inventoryExistsart_no
/*   inventoryExistsYorNart_no
/*   
/*   
/*      Rev 1.182   15 May 2007 09:43:00   zf297a
/*   Fixed names of variables used by the raise_application_error for the errorMsg procedure.
/*   
/*      Rev 1.181   15 May 2007 09:28:48   zf297a
/*   Added raise_application_error to errorMsg's exception routine.
/*   
/*      Rev 1.180   12 Apr 2007 14:52:38   zf297a
/*   Fixed isSpoPrimePartActive
/*   
/*      Rev 1.179   12 Apr 2007 11:54:46   zf297a
/*   Implemented interfaces for isSpoPrimePartActive, which returns true if the given spo_prime_part_no is in amd_sent_to_a2a as a part_no that has an action_code not equal to D.
/*   Implemented interface isSpoPrimePartYorN.
/*   
/*      Rev 1.178   12 Apr 2007 10:24:24   zf297a
/*   Implemented interface isPartActive, which returns true if the part does not have an action_code of D in amd_sent_to_a2a.  Implemented interfaces isPartActiveYorN and getSentToA2AActionCode.
/*   
/*      Rev 1.176   05 Apr 2007 11:16:56   zf297a
/*   Filter out commit / rollback errors when a routine is invoked via a trigger - however there was a mutating table, so creating the tmp_a2a_order_info_line via a trigger was abandoned.
/*   
/*      Rev 1.175   29 Mar 2007 12:43:02   zf297a
/*   Added interfaces for tmpA2ALocPartOverrideAddOk, tmpA2AInvInfoAddOk, tmpA2ARepairInvInfoAddOk, and tmpA2AInTransitsAddOk
/*   
/*      Rev 1.174   29 Mar 2007 09:12:40   zf297a
/*   Implemented tmpA2AOrderInfoLineAddOk
/*   
/*      Rev 1.173   29 Mar 2007 00:08:28   zf297a
/*   Implemented tmpA2APartInfoAddOk and tmpA2APartInfoAddYorN.
/*   
/*   Changed createPartInfo to use tmpA2APartInfoAddOk
/*   
/*      Rev 1.172   21 Mar 2007 18:40:52   zf297a
/*   Fixed deletePartInfo to check isPartSent instead of going against datasys_part_v since testing all parts going against datasys_part_v would take LOTS of time.
/*   
/*      Rev 1.171   21 Mar 2007 11:36:24   zf297a
/*   Implemented functions:
/*   partExistsInDataSystems
/*   partExistsInDataSystemsYorN
/*   isDataSysPartMarkedDelete
/*   isDataSysPartMarkedDeletedYorN
/*   
/*   
/*      Rev 1.170   13 Mar 2007 21:30:40   zf297a
/*   Fixed the opening of cursor repairInvInfoByDate for procedure initA2ARepairInvInfo to get the proper action_code and fixed the opening of cursors repairInvIno for the nested procedures getAllData and getTestData in the overloaded procedure initA2ARepairInvInfo to have the proper action_code.
/*   
/*      Rev 1.169   13 Mar 2007 12:57:22   zf297a
/*   Removed truncate of tmp_a2a_order_info
/*   
/*      Rev 1.168   13 Mar 2007 00:13:22   zf297a
/*   Add additional debug code for insertA2AOrderInfoLine and remove all commits for this procedure to allow it to be executed via a trigger.
/*   
/*      Rev 1.167   12 Mar 2007 16:06:04   zf297a
/*   fixed numbers for raise_application_error
/*   
/*      Rev 1.166   12 Mar 2007 15:38:06   zf297a
/*   use raise_applicaton_error to try to determine problem when the error does not get logged to amd_load_details.
/*   
/*      Rev 1.165   12 Mar 2007 13:52:56   zf297a
/*   For the following routines ignore commit or rollback exceptions when executed by a trigger:
/*   writemsg and insertTmpA2AOrderInfoLine. 
/*   By ignoring these errors, it will allow the routine to be executed from a trigger.
/*   
/*      Rev 1.164   07 Mar 2007 09:05:04   zf297a
/*   Removed all references to tmp_a2a_order_info table
/*   
/*      Rev 1.163   06 Mar 2007 09:44:34   zf297a
/*   Fixed initA2AOrderInfoLine and removed initA2AOrderInfo
/*   
/*      Rev 1.162   06 Mar 2007 08:19:10   zf297a
/*   removed tmp_a2a_order_info
/*   
/*      Rev 1.160   22 Feb 2007 15:28:12   zf297a
/*   For the loadAll and the PartInfo step 3, after loading all parts to tmp_a2a_part_info do the following:
/*   flag amd_sent_to_a2a parts that should b deleted
/*   create the a2a  part_info delete transaction
/*   load the rbl pairs
/*   update the spo_prime_part_no's
/*   create LocPartOverride delete's for all primes that have changed for all rsp bases
/*   for all non-prime parts in tmp_a2a_part_info update the resp_asset_mgr with the resp_asset_mgr for the prime_part.
/*   
/*      Rev 1.159   21 Feb 2007 20:23:58   zf297a
/*   Updated all PartInfo routines to use the mtbdr_computed field of the PartInfoRec
/*   
/*      Rev 1.158   26 Jan 2007 11:33:22   zf297a
/*   Fixed nested function getSchedReceiptDate of the includeOrder function to ignore DELETED orders and to get the max(line) number for the give gold_order_number and order_date.
/*   Fixed nested function getLIneNumber of the insertTmpA2AOrderInfo procedure to get the max line for the give gold_order_number and order_date since the order may have been deleted and then added back or added and then deleted.  This will only send the latest line number for the giver gold_order_number and order_date.  
/*   (The diff could be modified to incorporate the line as the key and then the getLIneNumber could probably be removed, but for now, this works)
/*   
/*      Rev 1.157   26 Jan 2007 10:03:58   zf297a
/*   In errorMsg made the handling of key5 more robust.  
/*   Changed all selects that create a onOrderCur type to have the Line as the third column.
/*   Modified getNextLine to just retrieve the Line from amd_on_order for the give gold_order_number and order_date.  
/*   Write more ifno to amd_load_details when there is an exception in insertTmpA2AOrderInfoLine.
/*   
/*      Rev 1.156   Dec 12 2006 12:25:04   zf297a
/*   Fixed getPartInfo's query by giving the action_code from the amd_sent_to_a2a priority over the action_code from amd_spare_parts.  Did an outer join against the amd_national_stock_items and the amd_sent_to_a2a since both tables may not have matching entries for the selected part.  Eliminated the action_code filter - not <> 'D'.
/*   Changed the query for getTestData in the same manner as was done for getPartInfo.
/*   Changed processParts to count the number inserts, updated, and delete transactions and to record those counts to amd_load_details.
/*   Changed the query for initA2APartInfo with the from date and to date arguments to be similar to the query of getPartInfo.
/*   
/*   The changes made to the queries should gaurantee that all deleted parts are collected and sent to the SPO.  Because some of these deleted parts may not have matching data in amd_national_stock_items, then the PartInfo_DEL.sql query will need to do a union with a query that is NOT using the amd_part_header_v5 view.
/*   
/*   
/*      Rev 1.155   Nov 29 2006 21:59:02   zf297a
/*   for insertRepairInvInfo, insertRepairInfo, insertTmpA2AOrderInfo, insertTmpA2AOrderInfoLine, and insertTmpA2AInTransits delete transactions make sure the site_location is not null.
/*   
/*   
/*      Rev 1.154   Nov 29 2006 21:20:14   zf297a
/*   for insertTmpA2AOrderInfo with delete_actions, make sure the site_location is not null.
/*   
/*      Rev 1.153   Nov 29 2006 13:24:56   zf297a
/*   For table amd_backorder_sum changed the column part_no to spo_prime_part_no.
/*   
/*      Rev 1.152   Nov 28 2006 14:26:50   zf297a
/*   fixed initA2ASpoUsers - use the action_code from amd_users
/*   
/*   fixed initSiteRespAssetMgr - use the action_code from amd_planner_logons
/*   
/*      Rev 1.151   Nov 28 2006 12:23:46   zf297a
/*   fixed processPartLeadTimes to check for the existance of the part_no in amd_sent_to_a2a with any action_code.
/*   
/*   fixed processPart to check for the existance of the part_no in amd_sent_to_a2a with any action_code.
/*   
/*   fixed deletePartInfo to check for the existance of the part_no in amd_sent_to_a2a with any action_code.
/*   
/*   fixed deletePartLeadTime to check for the existance of the part_no in amd_sent_to_a2a with any action_code.
/*   
/*   fixed deleteLocPartLeadTime to check for the existance of the part_no in amd_sent_to_a2a with any action_code.
/*   
/*   
/*   
/*   
/*   
/*   
/*   
/*   
/*   
/*   
/*      Rev 1.150   Nov 28 2006 11:57:46   zf297a
/*   Fixed insertInvInfo - for INSERT_ACTION or UPDATE_ACTION check to see if the part is in amd_sent_to_a2a with action_code <> DELETE_ACTION then insert it into tmp_a2a_inv_info.  For DELETE_ACTION's check to see if the part is in amd_sent_to_a2a with any action_code then insert it into tmp_a2a_inv_info
/*   
/*      Rev 1.149   Nov 28 2006 11:50:18   zf297a
/*   Fixed insertTmpA2AOrderInfo - for the INSERT_ACTION or UPDATE_ACTION check to see if the part exists in amd_sent_to_a2a with an action_code <> DELETE_ACTION and if it meets the include criteria then insert it into the tmp_a2a tables.  For the DELETE_ACTION check to see if the part exists in amd_sent_to_a2a with any action_code, if it does then insert it into the tmp_a2a table.
/*   
/*      Rev 1.148   Nov 28 2006 11:32:08   zf297a
/*   Fixed insertRepairInvInfo - for INSERT_ACTION or UPDATE_ACTION check to see if the part is in amd_sent_to_a2a with action_code <> DELETE_ACTION then insert it into tmp_a2a_repair_inv_info.  For DELETE_ACTION's check to see if the part is in amd_sent_to_a2a with any action_code then insert it into tmp_a2a_repair_inv_info.
/*   
/*   Fixed insertRepairInfo  - for INSERT_ACTION or UPDATE_ACTION check to see if the part is in amd_sent_to_a2a with action_code <> DELETE_ACTION then insert it into tmp_a2a_repair_info.  For DELETE_ACTION's check to see if the part is in amd_sent_to_a2a with any action_code then insert it into tmp_a2a_repair_info.
/*   
/*      Rev 1.147   Nov 28 2006 10:26:50   zf297a
/*   Fixed insertTmpA2AInTransits for deletes - only check that the part has been sent using isPartSent - which ignores the action_code and just looks for the part_no in amd_sent_to_a2a.
/*   
/*      Rev 1.146   Nov 22 2006 13:28:02   zf297a
/*   For initA2ABackorderInfo use spo_prime_part_no
/*   
/*      Rev 1.145   Nov 10 2006 10:50:22   zf297a
/*   Fixed generation of line for tmp_a2a_order_info_line
/*   
/*      Rev 1.144   Nov 01 2006 12:52:18   zf297a
/*   Resequenced pError_location values
/*   
/*      Rev 1.143   Nov 01 2006 09:30:50   zf297a
/*   Fixed initA2ABomDetails us use spo_prime_part_no's.  Moved the opening of "Test Data" and "All the Data" to separate procedure with writeMsg's to log the event.
/*   
/*      Rev 1.142   Oct 26 2006 12:07:38   zf297a
/*   implemented procedure deleteSentToA2AChildren.
/*   
/*      Rev 1.141   Oct 25 2006 10:38:46   zf297a
/*   start_dt is now a constant - so changed all variable names to upper case.  Implemented the get functions for the constants so these constants can be used in SQL queries in TOAD or sqlPlus.
/*   
/*      Rev 1.140   Oct 20 2006 12:21:34   zf297a
/*   Implemented interface isPartSent and isPartSentYorN
/*   
/*      Rev 1.140   Oct 20 2006 12:18:30   zf297a
/*   Implemented interface isPartSent and isPartSentYorN
/*   
/*      Rev 1.139   Oct 04 2006 15:42:40   zf297a
/*   Fixed isPartRepariable to use the preferred smr_code - ie smr_code_cleaned if it is not null and then smr_code.  Used amd_utils.isPartRepairable in repairables_Pkg.isPartValid so they use common code.
/*   
/*      Rev 1.138   Sep 12 2006 14:37:30   zf297a
/*   For all initA2A routines use the action_code of the amd data source whenever it has a value of DELETE_ACTION, otherwise the action_code from the amd_sent_to_a2a is used.  If a part has been deleted from SPO the A2A should always be deleted too - that's why amd_sent_to_a2a.action_code is sent for all other cases.  For INSERT's or UPDATE's the A2A only sends an INSERT - if the data is already there the system will update it.
/*   
/*      Rev 1.137   Sep 12 2006 11:11:06   zf297a
/*   Added defaults for all arguments to the errorMsg procedure.  Enhanced the errorMsg procedure by enabling dbms_output when this procedure has an error.
/*   For the insertTmpA2AOrderInfo made sure the delete_action was used for any deleted order and the delete_action was used for any part that has been deleted from the SPO otherwise use whatever is in amd_on_order for this order number and part_no.
/*   
/*      Rev 1.136   Sep 05 2006 12:40:12   zf297a
/*   Renumbered pError_location's values
/*   
/*      Rev 1.135   Sep 05 2006 10:27:52   zf297a
/*   Make sure part lead time and part pricing get deleted at the right time
/*   
/*      Rev 1.134   Aug 31 2006 11:57:52   zf297a
/*   removed errorMsg function
/*   implemented interface for initA2ADemands
/*   fixed format for minutes: MI
/*   changed initA2A routines to use the action_code from the amd_sent_to_a2a table for the corresponding spo_prime_part_no
/*   
/*      Rev 1.133   Aug 28 2006 21:44:18   zf297a
/*   Fixed getScheduledReceiptDate and patched errorMsg - was producing a numeric error.
/*   
/*      Rev 1.132   Aug 18 2006 15:42:54   zf297a
/*   Implemented interfaces processExtForececast and initA2AExtForecast.  Fixed processOnOrder: literal in writeMsg + added order by clause for both cursors.
/*   Fixed action_code for doInsert - always INSERT for included parts and always DELETE for excluded parts, which will make sure they do not exist in SPO.
/*   Changed loadAll to use initA2AExtForecast.
/*   
/*      Rev 1.131   Aug 11 2006 14:27:42   zf297a
/*   Fixed action_code for doInsert procedure
/*   
/*      Rev 1.130   Aug 10 2006 14:38:22   zf297a
/*   Fixed the errorMsg routines to use dbms_output when an exception occurs and then to raise the exception again.
/*   Implemented showReason for isPartValid and isPartValidYorN.  I elimitedn the check of debug, since the debugMsg already checks this boolean variable.  Also, if the part passes a test, there is nothing done, but if it fails the test, debugmsg will log the reason to amd_load_details.  debugMsg limits the number of messages recorded by the public variable debugThreshold .
/*   Renumbered the pError_location params for the entire package. 
/*   Record all excluded parts to the amd_load_details table.
/*   
/*      Rev 1.129   Aug 04 2006 12:56:56   zf297a
/*   Moved getDueDate to be a public function and added arguments part_no and order_date to its interface.
/*   
/*      Rev 1.128   Aug 04 2006 11:09:30   zf297a
/*   Fixed function includeOrder - retrieved the scheduled_receipt_date before doing compare.
/*   
/*      Rev 1.127   Jul 13 2006 11:48:10   zf297a
/*   Removed converting of part_no to spo_prime_part_no for tmp_a2a_backorder_info - the query that is used to create the xml will do the summation to spo_prime_part_no
/*   
/*      Rev 1.126   Jul 11 2006 14:29:58   c402417
/*   Added the SpoPrimePart function to load all for AmdBackorderSum. And modify the load all for amd_in_transit to amd_in_transit_sum.
/*   
/*      Rev 1.125   Jun 21 2006 09:55:34   zf297a
/*   When doing initA2AOrderInfo make sure the input is sorted by gold_order_number, part_no, and order_date.  By doing this, the genereated line number will be in sync with the order_date 1,2,......N where 1 is the oldest order_date and N is the most recent.
/*   
/*      Rev 1.124   Jun 21 2006 08:51:34   zf297a
/*   Added unique line number for every gold_order_number / part_no pair
/*   
/*      Rev 1.123   Jun 19 2006 10:44:32   zf297a
/*   fixed processOrder - removed erroneous if test. Added some diagnostic info for filters
/*   
/*      Rev 1.122   Jun 08 2006 13:22:34   zf297a
/*   added package name to key1 of amd_load_details for procedure version and moved revision to key2 of amd_load_details.
/*   
/*      Rev 1.121   Jun 08 2006 12:15:24   zf297a
/*   changed getSiteLocation to getSpoLocation in where clause of loadAll for tmp_a2a_demads
/*   
/*      Rev 1.120   Jun 07 2006 21:00:52   zf297a
/*   used getSpoLocation for tmp_a2a_backorder_info and tmp_a2a_demands.  switched to writeMsg instead of dbms_output.  Use mta_truncate_table instead of execute immediate.
/*   
/*      Rev 1.119   May 17 2006 15:00:08   zf297a
/*   removed start_date from on_order_filter
/*   
/*      Rev 1.118   May 17 2006 14:25:20   zf297a
/*   Using amd_on_order_date_filters_pkg routines for on_order date filtering
/*   
/*      Rev 1.117   May 16 2006 12:11:24   zf297a
/*   for initA2AInvInfo routines added the union of amd_rsp_sum to all the appropriate cursors.
/*   
/*      Rev 1.116   May 12 2006 13:58:36   zf297a
/*   Removed deletesOk from the wasPartSent interface.  Now using a global variable mblnSendAllData, which has its own getter and setter.
/*   Changed all init routines to include DELETED action codes and to use all part_no's contained in amd_sent_to_a2a that also have a spo_prime_part_no.
/*   
/*      Rev 1.115   May 12 2006 10:23:12   zf297a
/*   Allowed for A2A part delete transactions to be sent again
/*   
/*      Rev 1.114   May 12 2006 09:58:24   zf297a
/*   Changed processPart so that it sends "deleted" parts as A2A deletes.
/*   
/*      Rev 1.113   Apr 27 2006 12:27:04   zf297a
/*   processBackorder needed an EXIT when backOrder%NOTFOUND to terminate the LOOP otherwise Oracle would issue a ORA-00600 error with a 4454 parameter - meaning the PL/SQL had an infinite loop
/*   
/*      Rev 1.112   Apr 27 2006 08:15:06   zf297a
/*   added system_id to the procedure loadAll
/*   
/*      Rev 1.111   Apr 26 2006 10:05:24   zf297a
/*   Fixed check for an active job at the begining of procedure loadAll
/*   
/*      Rev 1.110   Apr 26 2006 09:28:42   zf297a
/*   Get theJob when the loadAll procedure is started or restarted.
/*   
/*      Rev 1.109   Apr 26 2006 09:23:14   zf297a
/*   Added batch_job and batch_job_steps tracking for the procedure loadAll
/*   
/*      Rev 1.108   Apr 24 2006 14:57:10   zf297a
/*   Fixed isNsnInRblPairs and isNsnInIsgPairs: used cursors since queries could return more than one row.
/*   
/*   Fixed errorMsg to ignore erros when a commit fails, which means an SQL select or DML statement was being executed and "commits" are not allowed then.  
/*   
/*      Rev 1.107   Apr 24 2006 13:28:50   zf297a
/*   Fixed isPartValid by changing the isNsnValid to allow for the nsn to be in amd_rbl_pairs OR  in bssm_isg_pairs.   Previous this was an AND condition.
/*   
/*   Also, started using amd amd_rlb_pairs instead of bssm_rlb_pairs.
/*   
/*      Rev 1.106   Mar 16 2006 23:15:20   zf297a
/*   Added additional filters to isPartValid
/*   
/*      Rev 1.105   Mar 03 2006 14:43:20   zf297a
/*   Implemented the loadAll procedure - this loads all the a2a data from amd
/*   
/*      Rev 1.104   Feb 15 2006 13:39:06   zf297a
/*   Added cur ref's for all init and byDate routines + a common process routine to make sure everything is done the same no matter what selection criteria is used.
/*   
/*      Rev 1.103   Feb 15 2006 10:12:30   zf297a
/*   Fixed InitPartInfo by date: If the part is NOT valid set the action_code to delete (valid parts were getting the action_code set to delete)
/*   
/*      Rev 1.102   Feb 13 2006 10:56:24   zf297a
/*   Added wasPartSent to InsertLocPartLeadTime and UpdateLocPartLeadTime
/*   
/*      Rev 1.101   Jan 06 2006 07:08:10   zf297a
/*   Fixed initA2APartInfo: added isPartValid test
/*   
/*      Rev 1.100   Jan 04 2006 09:14:32   zf297a
/*   For initA2ABomDetail and initA2ABackorderInfo made sure that the part has been sent - i.e. it exists in the amd_sent_to_a2a table and the action_code is not DELETE.
/*   
/*      Rev 1.99   Jan 04 2006 09:01:44   zf297a
/*   Added two overloaded procedures initA2ABackorderInfo which can accept a list of parts or a range of dates like the othe initA2A procedures.
/*   
/*      Rev 1.98   Jan 03 2006 12:44:14   zf297a
/*   Added date range to procedures 
/*   initA2AInvInfo
/*   initA2ARepairInvInfo
/*   initA2AInTransits
/*   initA2ARepairInfo
/*   initA2AOrderInfo
/*   initA2APartInfo
/*   initA2ABomDetail
/*   
/*   
/*      Rev 1.96   Dec 30 2005 01:32:08   zf297a
/*   added initA2ABomDetail by date
/*   
/*      Rev 1.95   Dec 29 2005 16:37:54   zf297a
/*   added initA2A by date procedures for PartInfo, OrderInfo, InvInfo, RepairInfo, InTransits, and RepairInvInfo
/*   
/*      Rev 1.94   Dec 16 2005 09:09:48   zf297a
/*   Removed erroneous reference to tmp_a2a_parts, which is not being used.
/*   
/*      Rev 1.93   Dec 14 2005 11:41:58   zf297a
/*   Fixed updateA2ApartInfo to use the correct rcm_ind.
/*   
/*      Rev 1.92   Dec 14 2005 10:39:08   zf297a
/*   Fixed isPlannerCodeValid - added check for a null planner code.
/*   
/*      Rev 1.91   Dec 07 2005 12:28:42   zf297a
/*   Now handle buffer overflow for dbms_output by disabling the output when this exception occurs.  Also, log the reason for isPartValid's criteria for returning a FALSE using debugMsg.
/*   
/*      Rev 1.90   Dec 07 2005 09:50:06   zf297a
/*   Fixed wasPartSent - checked to make sure the spo_prime_part_no is not null
/*   
/*      Rev 1.89   Dec 05 2005 13:40:54   zf297a
/*   Make sure the part_no is not null before trying to insert or update the tmp_a2a_bom_detail table.
/*   
/*      Rev 1.88   Dec 05 2005 13:29:26   zf297a
/*   Fixed retrieval of time_to_repair from amd_part_locs to allow for the no_data_found exception.
/*   
/*      Rev 1.87   Dec 01 2005 10:26:18   zf297a
/*   made sure spo_prime_part_no is not null before inserting into tmp_a2a_bom_detail
/*   
/*      Rev 1.86   Nov 30 2005 15:09:20   zf297a
/*   added type to errormsg of exception handler for insertTmpA2AInTransits.doUpdate 
/*   
/*      Rev 1.85   Nov 30 2005 15:03:46   zf297a
/*   added type qualifier for tmp_a2a_in_transits for doUpdate
/*   
/*      Rev 1.84   Nov 30 2005 11:32:16   zf297a
/*   added truncate of the tmp_a2a_bom_detail table to the initA2ABomDetail procedure.
/*   
/*      Rev 1.83   Nov 30 2005 10:54:08   zf297a
/*   added amd_test_parts to deletePartInfo.  implemented populateBomDetail.
/*   
/*      Rev 1.82   Nov 30 2005 09:11:50   zf297a
/*   Added isPartValid test when inserting tmp_a2a_repair_info.  Added exception handlers for duplicate keys for function insertTmpA2AInTransits
/*   
/*      Rev 1.81   Nov 15 2005 11:51:52   zf297a
/*   Use cleaned fields for smr_code and planner_code.  Add check for -14552
/*   
/*      Rev 1.80   Nov 10 2005 10:33:26   zf297a
/*   Implemented deleteInvalidParts.  Changed all literal of 'D' to amd_defaults.DELETE_ACTION.  Added "where action_code != amd_defaults.DELETE_ACTION" to all subqueries retrieving part_no's from amd_sent_to_a2a.
/*   
/*   Enhanced the debugMsg routine to ignore exception -14551, where a commit is not allowed during a query.  This exception could occur if some fo the YorN functions are used in a Select query and debug is turned on.
/*   
/*      Rev 1.79   Nov 09 2005 11:10:18   zf297a
/*   Implemented interfaces:  wasPartSentYorN, isPartValidYorN, isPlannerCodeAssign2UserIdYorN, and isNslYorN.
/*   
/*      Rev 1.78   Nov 09 2005 10:35:04   zf297a
/*   Added amd_test_parts table to make it easier to switch test parts.
/*   
/*      Rev 1.77   Oct 28 2005 08:39:36   zf297a
/*   In validateData routine, remove the to_char function for mtbf
/*   
/*      Rev 1.76   Oct 27 2005 15:45:10   c402417
/*   Changed expected_completion_date in tmp_a2a_repair_info to get date from amd_in_repair.repair_need_date.
/*   
/*      Rev 1.75   Oct 27 2005 10:23:10   zf297a
/*   Implemented deletePartInfo so all parts can be deleted or just a set of test cases can be deleted.
/*   
/*      Rev 1.74   Oct 21 2005 07:26:32   zf297a
/*   Added amd_partprime_pkg.DiffPartToPrime to initA2APartLeadTime
/*   
/*      Rev 1.73   Oct 20 2005 11:36:08   zf297a
/*   Removed converting of order_lead_time_cleaned from months to calendar days, since it is already being done by the amd_load.loadGold procedure.
/*   Removed converting of order_lead_time from business days to calendar days, since it is already being don by the amd_load.loadGold procedure.
/*   Removed converting time_to_repair_off_base_cleand from months to calendar days, since it is already being done by the amd_load.loadGold procedure.
/*   Added check that the part was sent before inserting any tmp_a2a_parts_lead_time rows.
/*   
/*      Rev 1.71   Oct 19 2005 11:46:08   zf297a
/*   Changed the arg list for insertTmpA2AOrderInfo and folded the procedure insertTmpA2AOrderInfoLine into insert                 OPEN onOrders FOR 
                 SELECT 
                      oo.PART_NO,  
                      LOC_SID,
                      LINE,          
                      ORDER_DATE,         
                      ORDER_QTY,          
                      GOLD_ORDER_NUMBER,  
                      case oo.ACTION_CODE
                             when amd_defaults.getDELETE_ACTION then
                                   oo.ACTION_CODE
                           else  
                                      sent.ACTION_CODE
                      end action_code,        
                      LAST_UPDATE_DT,     
                      SCHED_RECEIPT_DATE
                  FROM AMD_ON_ORDER OO, amd_sent_to_a2a sent 
                  WHERE oo.part_no = sent.part_no
                  and sent.SPO_PRIME_PART_NO is not null  
                  ORDER BY gold_order_number, part_no, order_date ;
Info.  Checked sched_receipt_date and if it is null compute a new due_date based on the order_lead_time (cleaned take precedence).
/*   
/*      Rev 1.70   Oct 18 2005 14:57:08   zf297a
/*   Enhanced debuging of isPartValid
/*   
/*      Rev 1.69   Oct 13 2005 10:18:36   zf297a
/*   Reinstated the in clause for the testParts.  Added additional counters for initA2AOrderInfo.  (include function still needs to be verified).
/*   
/*      Rev 1.68   Oct 11 2005 09:15:34   c402417
/*   changed the where clause in tmp_a2a_repair_info.
/*   
/*      Rev 1.67   Oct 10 2005 09:34:22   zf297a
/*   added price to tmp_a2a_part_info and all insert / update routines for tmp_a2a_part_info
/*   
/*      Rev 1.66   Oct 07 2005 12:18:22   zf297a
/*   Added cage_code to tmp_a2a_order_info and tmp_a2a_part_lead_time.  Created a separate procedure to init tmp_a2a_part_lead_time.
/*   
/*      Rev 1.65   Oct 06 2005 12:22:42   zf297a
/*   Changed set of part test cases.
/*   
/*      Rev 1.64   Oct 05 2005 16:08:22   c402417
/*   added condition to populate data into tmp_a2a_repair_info when ORDER_NO are not in 'RETAIL' or 'II%'.
/*   
/*      Rev 1.63   Sep 29 2005 12:47:20   zf297a
/*   Added check to exclude planner_code of AFD
/*   
/*      Rev 1.62   Sep 13 2005 12:54:48   zf297a
/*   For the includeOrder function removed the voucher test at the start.  If a param is not present for a given voucher, all param will be null, which will result in the order being "included"
/*   
/*      Rev 1.61   Sep 09 2005 13:33:30   zf297a
/*   Changed OrderInfo routines to use getSpoLocation instead of getSiteLocation per Laurie's directions.
/*   
/*      Rev 1.60   Sep 09 2005 11:11:20   zf297a
/*   Changed insertInvInfo to use spo_location, which comes from amd_spare_networks.spo_location.  However, the a2a transactions still refers to it as site_location so that name is left along for the tmp_a2a_inv_info table.
/*   
/*      Rev 1.59   Sep 08 2005 10:30:42   zf297a
/*   added date filter for tmp_a2a_order_info and tmp_a2a_order_info_line ;
/*   
/*      Rev 1.58   Aug 29 2005 14:43:52   zf297a
/*   modified insertA2AOrderInfo to filter by order_date and use the earliest date.
/*   
/*      Rev 1.57   Aug 26 2005 15:10:08   zf297a
/*   Qualified init routines with   and part_no in (select part_no from amd_sent_to_a2a) to make sure the part was sent.
/*   
/*      Rev 1.56   Aug 26 2005 14:51:34   zf297a
/*   Added function isNsnInIsgPairs
/*   
/*      Rev 1.56   Aug 19 2005 12:36:10   zf297a
/*   removed functions bizDays2CalendarDays, months2CalendarDays, and getSiteLocation and put them in amd_utils
/*   
/*      Rev 1.55   Aug 15 2005 14:45:48   zf297a
/*   added initA2ASpoUsers
/*   
/*      Rev 1.54   Aug 12 2005 13:06:44   zf297a
/*   Used getAssignedPlannerCode to determine the planner_code to be used for a2a_part_info - either the current planner or the default planner code.
/*   
/*      Rev 1.53   Aug 11 2005 12:41:54   zf297a
/*   Changed name of the routines that convert business days to calendar days and months to calendar days.  Used these conversion functions in the initA2APartInfo
/*   
/*      Rev 1.52   Aug 10 2005 13:48:04   zf297a
/*   Added commits for the init routines per every COMMIT_THRESHOLD times.  Added validateData to insertPartInfo.
/*      
/*      Rev 1.51   Aug 10 2005 10:00:18   zf297a
/*   Implemented functions convertCleanedOrderLeadTime and convertOrderLeadTime
/*   
/*      Rev 1.50   Aug 10 2005 09:27:04   zf297a
/*   Checked if a planner_code is assigned to a UserId and converted rcm_ind of T to R.
/*   
/*      Rev 1.49   Aug 09 2005 11:54:02   zf297a
/*   Fixed validateData for insertPartInfo: lineNo needed to be initialized and also coneverted to a character when an error is reported via amd_load_details.
/*   
/*      Rev 1.48   Aug 09 2005 10:05:08   zf297a
/*   Enhanced debugMsg by adding a lineNo argument to the interface  and a commit to the implementation.
/*   
/*      Rev 1.47   Aug 09 2005 09:46:54   zf297a
/*   Added validation of input for insertPartInfo, added doUpdate for insertRespSiteAssetMgr, and added substr for the email and name columns so they will not exceed 32 characters.
/*   
/*      Rev 1.46   Aug 04 2005 14:41:12   zf297a
/*   Implemented insertTmpA2ASpoUsers
/*   
/*      Rev 1.45   Aug 03 2005 14:53:56   zf297a
/*   Added sched_receipt_data for tmp_a2a_order_info_line
/*   
/*      Rev 1.44   Aug 02 2005 13:25:50   zf297a
/*   Added debug and dbms_output to isPartValid
/*   
/*      Rev 1.43   Jul 28 2005 10:52:40   zf297a
/*   Applied work around for the Oracle bug that caused this package not to compile with debug.  A view was created that was identical to the cursor partInfo used in initA2APartInfo.  This view is used as the "type" for the rec parameter used by the procedure processPart (partInfo_v%ROWTYPE).  Now the package will compile in "debug" without an error.
/*
/*      Rev 1.42   Jul 22 2005 14:34:34   zf297a
/*   Still getting the compiler error with Toad.  So, I tried eliminating all anonymous blocks in exception handlers, but the problem still persists: Toad displays this message: "Message Code Lang=Oracle was not found. Please verify and re-enter."
/*
/*      Rev 1.41   Jul 22 2005 14:20:36   zf297a
/*   Removed the anonymous block in processPart that declares the smr_code and moved the smr_code up so it belongs to the procedure.  This change enables Toad to compile the package with debug without an error.  For some reason Toad could not handle this syntax.
/*
/*      Rev 1.40   Jul 22 2005 12:24:52   zf297a
/*   Fixed wasPartSent - need paren's around the SQL OR condition otherwise more than one row would be returned.
/*
/*      Rev 1.39   Jul 20 2005 13:46:06   zf297a
/*   Delete the part from the spo via deletePartInfo when it no longer meets the criteria of a "spo part"
/*
/*   Make sure that the part was sent before trying to delete it from the spo. (deletePartInfo now uses wasPartSent)
/*
/*      Rev 1.38   Jul 20 2005 07:46:16   zf297a
/*   using only bems_id for a2a for spo users
/*
/*      Rev 1.37   Jul 19 2005 14:17:58   zf297a
/*   added spoUser procedure to create the a2a transactions for the spo_user
/*
/*      Rev 1.36   Jul 15 2005 10:53:00   zf297a
/*   do not insert into tmp_a2a tables if site_location is null
/*
/*      Rev 1.35   Jul 11 2005 12:38:44   zf297a
/*   added function initA2AInvInfo
/*
/*      Rev 1.34   Jul 11 2005 12:26:20   zf297a
/*   added function initA2AInTransits
/*
/*      Rev 1.33   Jul 11 2005 12:14:52   zf297a
/*   added function initA2ARepairInfo
/*
/*      Rev 1.32   Jul 11 2005 11:54:00   zf297a
/*   updated pError_location (10, 20, 30,...... 450)
/*
/*      Rev 1.31   Jul 11 2005 11:47:46   zf297a
/*   added procedure insertTmpA2AInTransits
/*
/*      Rev 1.30   Jul 11 2005 11:16:50   zf297a
/*   Made wasPartSent and isPartValid public functions
/*
/*      Rev 1.27   Jul 11 2005 10:37:36   zf297a
/*   added procedure to insertTmpA2AOrderInfo and insertTmpA2AOrderInfoLine
/*
/*      Rev 1.26   Jul 06 2005 12:52:58   zf297a
/*   Checked isPlannerCodeValid for all parts
/*
/*      Rev 1.25   Jun 22 2005 15:02:24   c970183
/*   Added flexibility to the Init routines so that the test case can be inserted, changed, or deleted.
/*
/*      Rev 1.24   Jun 10 2005 11:20:02   c970183
/*   Streamlined insertSiteRespAssetMgr, insertInvInfo, and insertRepairInfo.
/*
/*      Rev 1.23   Jun 09 2005 15:03:26   c970183
/*   implemented insert, update, and logical delete for tmp_a2a_site_resp_asset_mgr
/*
/*      Rev 1.22   Jun 08 2005 08:03:50   c970183
/*   Qualified the use of createPartInfo arguments to stop multiple rows from being selected by the getPartInfo routine.
/*
/*      Rev 1.21   May 18 2005 08:57:08   c970183
/*   Added getIndenture public method.  Modified inita2a to use getIndenture.
/*
/*      Rev 1.20   May 18 2005 08:25:50   c970183
/*   Fixed indenture.  Added function name to mArgs debug variable
/*
/*      Rev 1.19   May 13 2005 14:36:06   c970183
/*   Added procedure createPartInfo.  For a given part_no create an update transaction in tmp_a2a_part_info.  action_code may be overridden too.
/*
/*      Rev 1.18   May 02 2005 12:57:12   c970183
/*   Completed part validation routines.
/*
/*      Rev 1.17   Apr 28 2005 14:05:16   c970183
/*   Added part_no filter: if it is not an NSL send it as an A2A transaction.  If it is an NSL, validate that it meets the addional criteria to be sent.
/*
/*      Rev 1.16   Apr 27 2005 07:35:34   c970183
/*   For deletePartPricing - set price_type to AN_ORDER and price to zero.
/*
/*      Rev 1.15   Apr 22 2005 13:57:08   c970183
/*   added return success to all routines handling dup_val_on_index exceptions.
/*
/*      Rev 1.14   Apr 22 2005 10:49:44   c970183
/*   added update's to gaurantee function works.  However, if the unique keys are removed in the future, the update will never get executed and could be removed.
/*
/*      Rev 1.13   Apr 22 2005 08:06:50   c970183
/*   add mArgs to errorMsg
/*
/*      Rev 1.10   Mar 25 2005 11:46:28   c970183
/*   Fixed the update and delete routines to insert data into the tmp_a2a tables and to have the appropriate action_codes: update or delete.
/*
/*      Rev 1.9   03 Sep 2004 10:19:16   c970183
/*   Added check for SQL%ROWCOUNT = 0 after all updates.  This is an error situation that should not occurs.  Also. resequenced pError_location parameters
/*
/*      Rev 1.8   03 Sep 2004 09:59:56   c970183
/*   removed substr for pError_location - its a number not a string
/*
/*      Rev 1.6   03 Sep 2004 08:59:04   c970183
/*   Added substr's to error logging routine to make sure that it is never trying to insert strings longer that the columns that will contain the data: i.e. it should not cause an error when it is supposed to help find errors.
/*
/*      Rev 1.5   27 Aug 2004 14:33:06   c970183
/*   Added constants 'NEW BUY', 'REPAIR', and 'ORDER'.
/*
/*      Rev 1.4   12 Aug 2004 14:54:02   c970183
/*   implemented updatePartInfo function
/*
/*      Rev 1.3   12 Aug 2004 14:41:04   c970183
/*   removed initial prototypes
/*
/*      Rev 1.2   12 Aug 2004 14:30:46   c970183
/*   added insert, update, and delete functions for a2a tables.  implemented insert functions for part data.
/*
/*      Rev 1.1   Jul 20 2004 07:02:32   c970183
/*   Added functions to generate current year.
/*
/*      Rev 1.0   Jul 19 2004 14:10:48   c970183
/*   Initial revision.
    */

 THIS_PACKAGE CONSTANT CHAR(7) := 'a2a_pkg' ;
 mArgs VARCHAR2(2000) ;
 prime_ind VARCHAR2(1) ;
 prime_part AMD_SPARE_PARTS.part_no%TYPE ;
 mblnSendAllData BOOLEAN := FALSE ;
 debugThreshold number := 500 ;
 debugRepairInfoThreshold number := 500 ;
 debugDeleteThreshold number := 500 ;
 insertRowCnt number := 0 ;
 insertAddUpdRepairInfoCnt number := 0 ;
 deleteCnt number := 0 ;
 insertCnt number := 0 ;
 updateCnt number := 0 ;
 rejectCnt number := 0 ;
 debug boolean := false ;

 
 DEBUG_THRESHOLD      CONSTANT NUMBER := 5000 ;
 deleteChildrenThreshold number := 1 ;
  
 includeCnt NUMBER := 0 ;
 excludeCnt NUMBER := 0 ;
 
      


 CURSOR managers IS
 SELECT * FROM AMD_PLANNER_LOGONS ;


 CURSOR testParts IS
  SELECT sp.mfgr,
      sp.part_no,
      sp.NOMENCLATURE,
      sp.nsn,
      sp.order_lead_time,
      sp.order_lead_time_defaulted,
      sp.unit_cost,
      sp.unit_cost_defaulted,
      sp.unit_of_issue,
      nsi.unit_cost_cleaned,
      nsi.order_lead_time_cleaned,
      nsi.planner_code,
      nsi.planner_code_cleaned,
      nsi.mtbdr,
      nsi.mtbdr_cleaned,
      nsi.smr_code,
      nsi.smr_code_cleaned,
      nsi.smr_code_defaulted,
      nsi.nsi_sid,
      nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND
  FROM AMD_SPARE_PARTS sp,
    AMD_NATIONAL_STOCK_ITEMS nsi
  WHERE sp.nsn = nsi.nsn
     AND sp.action_code != Amd_Defaults.DELETE_ACTION
     AND sp.part_no IN (SELECT part_no FROM AMD_TEST_PARTS) ;


    PROCEDURE writeMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 IN VARCHAR2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'a2a_pkg',    
                pTableName  => pTableName,
                pError_location => pError_location,
                pKey1 => pKey1,
                pKey2 => pKey2,
                pKey3 => pKey3,
                pKey4 => pKey4,
                pData    => pData,
                pComments => pComments);
    exception when others then
        --  ignoretrying to rollback or commit from trigger
        if sqlcode <> -4092 then
            raise_application_error(-20010,
                substr('a2a_pkg ' 
                    || sqlcode || ' '
                    || pError_Location || ' ' 
                    || pTableName || ' ' 
                    || pKey1 || ' ' 
                    || pKey2 || ' ' 
                    || pKey3 || ' ' 
                    || pKey4 || ' '
                    || pData, 1,2000)) ;
        end if ;
    END writeMsg ;

    function isNumeric(p_string in varchar2) return boolean is
             l_number number ;
    begin
         l_number := p_string ;
         return true ;
    exception when others then
              return false ;
    end isNumeric ;

 -- do a forward declaration of ErrorMsg, since it will be wrapped by a procedure of the
 -- same name

     PROCEDURE ErrorMsg(
         pSqlfunction IN AMD_LOAD_STATUS.SOURCE%TYPE := 'errorMsg',
         pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE := 'noname',
         pError_location AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE := -100,
         pKey_1 IN AMD_LOAD_DETAILS.KEY_1%TYPE := '',
          pKey_2 IN AMD_LOAD_DETAILS.KEY_2%TYPE := '',
         pKey_3 IN AMD_LOAD_DETAILS.KEY_3%TYPE := '',
         pKey_4 IN AMD_LOAD_DETAILS.KEY_4%TYPE := '',
         pKeywordValuePairs IN VARCHAR2 := '') IS
         
         pragma autonomous_transaction ;
         
         key5 AMD_LOAD_DETAILS.KEY_5%TYPE := pKeywordValuePairs ;
         saveSqlCode number := sqlcode ;
         
     BEGIN
          IF key5 = '' or key5 is null THEN
             key5 := pSqlFunction || '/' || pTableName ;
          ELSE
            if key5 is not null then
                if length(key5) + length('' || pSqlFunction || '/' || pTablename) < 50  then           
                    key5 := key5 || ' ' || pSqlFunction || '/' || pTableName ;
                end if ;
            end if ;
          END IF ;
          -- use substr's to make sure that the input parameters for InsertErrorMsg and GetLoadNo
          -- do not exceed the length of the column's that the data gets inserted into
          -- This is for debugging and logging, so efforts to make it not be the source of more
          -- errors is VERY important
          
          dbms_output.put_line('insertError@' || pError_location) ;
          
          Amd_Utils.InsertErrorMsg (
            pLoad_no => Amd_Utils.GetLoadNo(
              pSourceName => SUBSTR(pSqlfunction,1,20),
              pTableName  => SUBSTR(pTableName,1,20)),
            pData_line_no => pError_location,
            pData_line    => 'repairables_Pkg.' || mArgs,
            pKey_1 => SUBSTR(pKey_1,1,50),
            pKey_2 => SUBSTR(pKey_2,1,50),
            pKey_3 => SUBSTR(pKey_3,1,50),
            pKey_4 => SUBSTR(pKey_4,1,50),
            pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS') ||
                 ' ' || substr(key5,1,50),
            pComments => SUBSTR('sqlcode('||saveSQLCODE||') sqlerrm('||SQLERRM||')',1,2000));
            
            if sqlcode <> -4092 then            
                COMMIT;
            end if ;
       
     EXCEPTION WHEN OTHERS THEN
       dbms_output.enable(10000) ;
       dbms_output.put_line('sql error=' || sqlcode || ' ' || sqlerrm) ;
       if pSqlFunction is not null then dbms_output.put_line('pSqlFunction=' || pSqlfunction) ; end if ;
       if pTableName is not null then dbms_output.put_line('pTableName=' || pTableName) ; end if ;
       if pError_location is not null then dbms_output.put_line('pError_location=' || pError_location) ; end if ;
       if pKey_1 is not null then dbms_output.put_line('key1=' || pKey_1) ; end if ;
       if pkey_2 is not null then dbms_output.put_line('key2=' || pKey_2) ; end if ;
       if pKey_3 is not null then dbms_output.put_line('key3=' || pKey_3) ; end if ;
       if pKey_4 is not null then dbms_output.put_line('key4=' || pKey_4) ; end if ;
       if pKeywordValuePairs is not null then dbms_output.put_line('pKeywordValuePairs=' || pKeywordValuePairs) ; end if ;
       if sqlcode <> -4092 then
           raise_application_error(-20030,
                substr('a2a_pkg ' 
                    || sqlcode || ' '
                    || pError_location || ' '
                    || pSqlFunction || ' ' 
                    || pTableName || ' ' 
                    || pKey_1 || ' ' 
                    || pKey_2 || ' ' 
                    || pKey_3 || ' ' 
                    || pKey_4 || ' '
                    || pKeywordValuePairs,1, 2000)) ;
        end if ;
     END ErrorMsg;
    
     PROCEDURE debugMsg(msg IN AMD_LOAD_DETAILS.DATA_LINE%TYPE, pError_Location IN NUMBER) IS
        pragma autonomous_transaction ;
     BEGIN
       IF debug THEN
           Amd_Utils.debugMsg(pMsg => msg,pPackage => 'a2a_pkg', pLocation => pError_location) ;
           COMMIT ; -- make sure the trace is kept
       END IF ;
     EXCEPTION WHEN OTHERS THEN
                IF SQLCODE = -14551 OR SQLCODE = -14552 THEN
                     NULL ; -- cannot do a commit inside a query, so ignore the error
               ELSE
                      RAISE ;
               END IF ;
     END debugMsg ;
     
     FUNCTION getSendAllData RETURN BOOLEAN IS
     BEGIN
           RETURN mblnSendAllData ;
     END getSendAllData ;
     
     PROCEDURE setSendAllData(theIndicator IN BOOLEAN) IS
     BEGIN
           mblnSendAllData := theIndicator ;
     END setSendAllData ; 
    
    
     PROCEDURE truncateA2Atables IS
     BEGIN
         Mta_Truncate_Table('tmp_a2a_part_info','reuse storage');
         Mta_Truncate_Table('tmp_a2a_part_lead_time','reuse storage');
         Mta_Truncate_Table('tmp_a2a_part_pricing','reuse storage');
     END truncateA2Atables ;
     
     FUNCTION getIndenture(smr_code_preferred IN AMD_NATIONAL_STOCK_ITEMS.SMR_CODE%TYPE) return varchar2 IS
     begin
       
       if substr(smr_code_preferred,1,3) in ('PBO','PAO') then
            return '1' ;
       end if ;
       
       return '2' ;
     end getIndenture ;
     
     FUNCTION isPlannerCodeValid(plannerCode in amd_national_stock_items.planner_code%type,
        showReason in boolean := false) RETURN BOOLEAN IS
         isValid BOOLEAN  := FALSE ;
     BEGIN
         IF plannerCode IS NOT NULL THEN
             IF LENGTH(plannerCode) >= 2 THEN
              isValid := UPPER(SUBSTR(plannerCode,1,2)) != 'KE' AND UPPER(SUBSTR(plannerCode,1,2)) != 'SE' ;
                IF isValid THEN
                    IF LENGTH(plannerCode) >= 3 THEN
                       isValid := UPPER(SUBSTR(plannerCode,1,3)) != 'AFD' ;
                    ELSE
                        isValid := TRUE ;
                    END IF ;
                END IF ;
            ELSE
               isValid := TRUE ;
            END IF ;
        END IF ;
        IF isValid THEN
             null ; -- do nothing
        else
            debugMsg(plannerCode || ' Planner code is NOT valid', 10) ;
             if showReason then 
                dbms_output.put_line(plannerCode || ' Planner code is NOT valid') ;
            end if ;              
        END IF ;
        
        RETURN isValid ;
        
    END isPlannerCodeValid ;
    
    function isPlannerCodeValidYorN(plannerCode in amd_national_stock_items.planner_code%type,
        showReason in boolean := false) return varchar2 is
    begin
        if isPlannerCodeValid(plannerCode, showReason) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isPlannerCodeValidYorN ;
    
    function getAcquisitionAdviceCode(part_no in amd_spare_parts.part_no%type) return varchar2 is
        theCode AMD_SPARE_PARTS.ACQUISITION_ADVICE_CODE%TYPE ;
    begin
           mArgs := 'getAcquisitionAdviceCode(' || part_no || ')' ;
              SELECT acquisition_advice_code INTO theCode
           FROM AMD_SPARE_PARTS WHERE part_no = getAcquisitionAdviceCode.part_No ;
           mArgs := 'theCode=' || theCode ;
           return UPPER(theCode) ;
           
    EXCEPTION
        when standard.no_data_found then
            mArgs := 'getAcquisitionAdviceCode: no data found for ' || part_no ;
            return null ; 
        WHEN OTHERS THEN
           ErrorMsg(pSqlfunction => 'select',
             pTableName => 'amd_spare_parts',
             pError_location => 10,
             pKey_1 => part_no ) ;
              RAISE ;
    end getAcquisitionAdviceCode ;

    function isNsnInRblPairs(nsn in amd_spare_parts.nsn%type, showReason in boolean := false) return boolean is
        result boolean := false ;
    begin
        <<tryOldNsn>>
        declare
            cursor old_nsns is
                select old_nsn
                from amd_rbl_pairs 
                where old_nsn = isNsnInRblPairs.nsn ;
        begin
            for rec in old_nsns loop 
                   result := true ;
                exit when true ;
            end loop ;
        
            if not result then
                <<tryNewNsn>>
                declare
                    cursor new_nsns is
                        select new_nsn
                        from amd_rbl_pairs 
                        where new_nsn = isNsnInRblPairs.nsn ;
                begin
                    for rec in new_nsns loop
                        result := true ;
                        exit when true ;
                    end loop ;
                exception
                    when others then
                        ErrorMsg(pSqlfunction => 'select',
                            pTableName => 'amd_rbl_pairs',
                            pError_location => 20,
                            pKey_1 => isNsnInRblPairs.nsn) ;
                        raise ;
                End tryNewNsn ;
        end  if ;
        exception when others then
                   ErrorMsg(pSqlfunction => 'select',
                  pTableName => 'amd_rbl_pairs',
                  pError_location => 30,
                  pKey_1 => isNsnInRblPairs.nsn) ;
            raise ;
        end tryOldNsn ;
             
        if result then
            null ; -- do nothing
        else
            debugMsg(isNsnInRblPairs.nsn || ' Nsn is NOT valid',40) ;
            if showReason then dbms_output.put_line(isNsnInRblPairs.nsn || ' Nsn is NOT in Rbl Pairs') ; end if ;
        end if ;
                    
        return result ;
    
    exception when others then
        ErrorMsg(pSqlfunction => 'isNsnInRblPairs',
            pTableName => 'amd_rbl_pairs',
            pError_location => 40,
            pKey_1 => isNsnInRblPairs.nsn) ;
        
        raise ;
    End isNsnInRblPairs ;
    
    function isNsnInRblPairsYorN(nsn in amd_spare_parts.nsn%type, showReason in boolean := false) return varchar2 is
    begin
        if isNsnInRblPairs(nsn, showReason) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isNsnInRblPairsYorN ;

    function isNsnInIsgPairs(nsn in amd_spare_parts.nsn%type, showReason in boolean := false) return boolean is
        result boolean := false ;
    begin
        <<tryOldNsn>>
        DECLARE
            CURSOR old_nsns IS
                select old_nsn  
                from bssm_isg_pairs 
                where old_nsn = isNsnInIsgPairs.nsn AND lock_sid = 0 ;
        begin
            for rec in old_nsns loop
                result := true ;
                exit when true ;
            end loop ;
            if not result then
                <<tryNewNsn>>
                declare
                    cursor new_nsns is
                        select new_nsn from bssm_isg_pairs 
                        where new_nsn = isnsninisgpairs.nsn and lock_sid = 0 ;
                begin
                for rec in new_nsns loop
                    result := true ;
                    exit when true ;
                    end loop ;
                exception
                    when others then
                        ErrorMsg(pSqlfunction => 'select',
                            pTableName => 'bssm_isg_pairs',
                            pError_location => 50,
                            pKey_1 => isNsnInIsgPairs.nsn) ;
                        raise ;
                end tryNewNsn ;
            end if ;
        exception
            when others then
                ErrorMsg(pSqlfunction => 'select',
                    pTableName => 'bssm_isg_pairs',
                    pError_location => 60,
                    pKey_1 => isNsnInIsgPairs.nsn) ;
                raise ;
                 
        end tryOldNsn ;
             
        if result then
            null ; -- do nothing
        else
            debugMsg('Nsn is NOT in ISG Pairs',50) ;
            if showReason then dbms_output.put_line('Nsn is NOT in ISG Pairs') ; end if ;
        end if ;
        return result ;
    
    end isNsnInIsgPairs ;

    function isNsnInIsgPairsYorN(nsn in amd_spare_parts.nsn%type, showReason in boolean := false) return varchar2 is
    begin
        if isNsnInIsgPairs(nsn, showReason) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isNsnInIsgPairsYorN ;

    function isNsnValid(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return boolean is
            
        nsn  amd_spare_parts.nsn%type ;
                       
    begin
        <<getNsn>>
        begin
            select parts.nsn into isNsnValid.nsn
            from amd_spare_parts parts
            where isNsnValid.part_no = parts.part_no ;
        exception when others then
            ErrorMsg(pSqlfunction => 'select',
                pTableName => 'amd_spare_parts',
                pError_location => 70,
                pKey_1 => isNsnValid.part_no,
                pKey_2 => nsn) ;
            raise ;
        end getNsn ;
        return isNsnInRblPairs(nsn, showReason) or isNsnInIsgPairs(nsn, showReason) ;
    exception
        when standard.no_data_found then
            return false ;
    end isNsnValid ;

    function isNsnValidYorN(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return varchar2 is
    begin
        if isNsnValid(part_no, showReason) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isNsnValidYorN ;
        
    function demandExists(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return boolean is
        result NUMBER := 0 ;
    begin
        select 1 into result
        from dual
        where exists
            (select *
            from amd_demands demands, amd_national_stock_items items, amd_spare_parts parts
            where demandexists.part_no = parts.part_no
            and parts.action_code != amd_defaults.delete_action
            and parts.nsn = items.nsn
            and items.action_code != amd_defaults.delete_action
            and items.nsi_sid = demands.nsi_sid
            and demands.quantity > 0
            and demands.action_code != amd_defaults.delete_action) ;
            
        if result > 0 then
            null ; -- do  nothing
        else
            debugMsg('Demand does NOT exist for ' || demandExists.part_no, 10) ;
            if showReason then dbms_output.put_line('Demand does NOT exist for ' || demandExists.part_no) ; end if ;
        end if ;
        
        return (result > 0) ;
        
    exception
        when standard.no_data_found then
            return false ;
        when others then
            ErrorMsg(pSqlfunction => 'select',
                pTableName => 'demands / items',
                pError_location => 80,
                pKey_1 => demandExists.part_no) ;
            raise ;
    end demandExists ;
    
    function demandExistsYorN(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return varchar2 is
    begin
        if demandExists(part_no, showReason) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end demandExistsYorN ;
        
    function inventoryExists(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return boolean is
        result NUMBER := 0 ;
        primePartNo AMD_NATIONAL_STOCK_ITEMS.prime_part_no%TYPE ;
    BEGIN
        <<getPrimePartNo>>
        BEGIN
            select items.prime_part_no into primePartNo
            from amd_national_stock_items items, amd_spare_parts parts
            where inventoryExists.part_no = parts.part_no
            and parts.nsn = items.nsn ;
        exception when others then
            ErrorMsg(pSqlfunction => 'select',
                pTableName => 'amd_spare_parts',
                pError_location => 90,
                pKey_1 => inventoryExists.part_no) ;
            raise ;
        end getPrimePartNo ;
    
        <<doesDataExist>>
        begin
            select 1 into result
            from dual
            where exists
                (select *
                from amd_on_hand_invs oh
                where primepartno = oh.part_no
                and oh.action_code != amd_defaults.delete_action
                and oh.inv_qty >0
                )
                or exists
                    (select *
                    from amd_in_repair ir
                    where primepartno = ir.part_no
                    and ir.action_code != amd_defaults.delete_action
                    and ir.repair_qty > 0
                    )
                or exists
                    (select *
                    from amd_on_order oo
                    where primepartno = oo.part_no
                    and oo.action_code != amd_defaults.delete_action
                    and oo.order_qty > 0
                    )
                or exists
                    (select *
                     from amd_in_transits it
                    where primepartno = it.part_no
                    and it.action_code != amd_defaults.delete_action
                    and it.quantity > 0
                    )  ;
        exception
            when standard.no_data_found then
                null ;
            when others then
                if sqlcode = -4091 then
                    raise_application_error(-20050,substr(1,2000,
                        '29 ' || inventoryExists.part_No )) ;
                else
                    ErrorMsg(pSqlfunction => 'select',
                        pTableName => 'exist',
                        pError_location => 100,
                        pKey_1 => inventoryExists.part_No) ;
                end if ;
                raise ;
    
        end doesDataExist ;
        if result > 0 then
            null ; -- do nothing
        else
            debugMsg('Inventory does NOT exist for ' || inventoryExists.part_No, 20) ;
            if showReason then dbms_output.put_line('Inventory does NOT exist for ' || inventoryExists.part_No) ; end if ;
        end if ;      
        return (result > 0) ;
    exception when others then
        ErrorMsg(pSqlfunction => 'selects',
            pTableName => 'inventoryExists',
            pError_location => 110,
            pKey_1 => part_no ) ;
        
        raise ;
    end inventoryExists ;

    function inventoryExistsYorN(part_no in amd_spare_parts.part_no%type, showReason in boolean := false) return varchar2 is
    begin
        if inventoryExists(part_no, showReason) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    exception when others then
        ErrorMsg(pSqlfunction => 'selects',
            pTableName => 'inventoryExistsYorN',
            pError_location => 120,
            pKey_1 => part_no) ;
        
        raise ;
    end inventoryExistsYorN ;

    function isPartValidYorN(partNo IN VARCHAR2, preferredSmrCode IN VARCHAR2, 
        preferredMtbdr IN NUMBER, preferredPlannerCode IN VARCHAR2, showReason in varchar2 := 'F') RETURN varchar2 is
    begin
        if isPartValid(partNo,preferredSmrCode,preferredMtbdr,preferredPlannerCode,upper(showReason) in ('T','Y','YES','TRUE')) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;                        
    end isPartValidYorN ; 
        
    function isPartValid(partNo IN VARCHAR2, preferredSmrCode IN VARCHAR2, 
        preferredMtbdr IN NUMBER, preferredPlannerCode IN VARCHAR2, showReason in boolean := false) RETURN BOOLEAN IS
    
        result boolean := false ;
        nsn amd_spare_parts.nsn%type ;
        lineNo number := 0 ;
    
    
     BEGIN
        lineNo := 10 ;
        if not amd_utils.isPartActive(partno) then
             if showReason then
                dbms_output.put_line(partNo || ' is not active') ;
             end if ;
             return false ;
        end if ;
       
        lineNo := 20 ;
        IF UPPER(partNo) = 'F117-PW-100' OR INSTR(UPPER(partNo),'17L8D') > 0 OR INSTR(UPPER(partNo),'17R9Y') > 0 OR INSTR(UPPER(preferredSmrCode),'PE') > 0 THEN
            if showReason then
                dbms_output.put_line(partNo || ' fails test: UPPER(partNo) = F117-PW-100 OR INSTR(UPPER(partNo),17L8D) > 0 OR INSTR(UPPER(partNo),17R9Y) > 0 OR INSTR(UPPER(preferredSmrCode),PE) > 0') ;
            end if ;
            return false ;
        END IF ;
       
        lineNo := 30 ;
       if getAcquisitionAdviceCode(partNo) = 'Y' then
            if showReason then
                dbms_output.put_line(partNo || ' has an acquisition advice code of Y') ;
            end if ;                
            return false ;
       end if ;
       
        lineNo := 40 ;
       result := amd_utils.isRepairableSmrCode(preferredSmrCode) ;
       
       if not result then
             debugmsg(preferredSmrCode || ' is NOT a repairable smr code', 70) ;
             if showreason then 
                dbms_output.put_line(preferredSmrCode || ' is NOT a repairable smr code') ; 
             end if ;
       end if ;
       
       lineNo := 50 ;
       result := result AND isPlannerCodeValid(preferredPlannerCode) ;
       if not result and showReason then
            dbms_output.put_line(partNo || ' does not have a valid planner code: ' || preferredPlannerCode) ;
       end if ;
                   
       IF result AND isNsl(partNo) THEN
       
         IF showReason AND (preferredMtbdr IS NOT NULL AND preferredMtbdr > 0) THEN
             dbms_output.put_line('mtbdr > 0 for part ' || partNo) ; 
         END IF ;
         
         lineNo := 60 ;
         result := result AND (demandExists(partNo, showReason) OR inventoryExists(partNo, showReason)
                    OR (preferredMtbdr IS NOT NULL AND preferredMtbdr > 0)
                    OR isNsnValid(partNo,showReason) ) ;
      END IF ;
      IF result THEN
           null ; -- do nothing
      ELSE
           debugMsg('part ' || partNo || ' is NOT valid.',80) ;
           if showReason then dbms_output.put_line('part ' || partNo || ' is NOT valid.') ; end if ;
      END IF ;
      lineNo := 70 ;
      return result ;
     exception when others then
        
        if sqlcode = -20000 then
            dbms_output.disable ; -- buffer overflow, disable
            return ispartvalid(partno) ; -- try validation again
        end if ;
        
        ErrorMsg(pSqlfunction => 'selects',
            pTableName => 'isPartValid',
            pError_location => 130,
            pKey_1 => lineNo) ;
        
        raise ;
           
     end isPartValid ;
    


     PROCEDURE insertPartInfo(
           part_no IN VARCHAR2,
           nomenclature IN VARCHAR2,
           action_code IN VARCHAR2,
            mfgr IN VARCHAR2 := NULL,
           unit_issue IN VARCHAR2 := NULL,
           smr_code IN VARCHAR2 := NULL,
           nsn IN VARCHAR2 := NULL,
           planner_code IN VARCHAR2 := NULL,
           third_party_flag IN VARCHAR2 := NULL,
           mtbdr      IN NUMBER := NULL,
           indenture IN VARCHAR2 := NULL,
           price IN NUMBER := NULL) IS
    
       result NUMBER := SUCCESS ;
      partInfoError EXCEPTION ;
     BEGIN
       if amd_utils.ispartConsumable(part_no) then
            debugMsg('InsertPartInfo: consumable', pError_location => 140) ;
            consumables_pkg.insertPartInfo(part_no, action_code) ;
            result := SUCCESS ;
       else
           CASE action_code
              WHEN Amd_Defaults.INSERT_ACTION THEN
            debugMsg('InsertPartInfo: insert', pError_location => 150) ;
                 result := insertPartInfo(
                mfgr,
               part_no,
               unit_issue,
               nomenclature,
               smr_code,
               nsn,
               planner_code,
               third_party_flag,
               mtbdr,
               indenture,
               price) ;
        
              WHEN Amd_Defaults.UPDATE_ACTION THEN
            debugMsg('InsertPartInfo: update', pError_location => 160) ;
                 result := updatePartInfo(
                mfgr,
               part_no,
               unit_issue,
               nomenclature,
               smr_code,
               nsn,
               planner_code,
               third_party_flag,
               mtbdr,
               indenture,
               price) ;
        
              WHEN Amd_Defaults.DELETE_ACTION THEN
            debugMsg('InsertPartInfo: delete', pError_location => 170) ;
                 if isPartSent(part_no) then
                    result := deletePartInfo(part_no, nomenclature) ;
                 end if ;
          END CASE ;
      end if ;           
      IF result != SUCCESS THEN
         RAISE partInfoError ;
      END IF ;
     END insertPartInfo ;
    
     procedure InsertPartInfo(part_no in varchar2, action_code in varchar2) is
     
           nomenclature     amd_spare_parts.NOMENCLATURE%type ;
           mfgr             amd_spare_parts.MFGR%type ;
           unit_issue       amd_spare_parts.UNIT_OF_ISSUE%type ;
           smr_code         amd_national_stock_items.smr_code%type ;
           nsn              amd_spare_parts.nsn%type ;
           planner_code     amd_national_stock_items.planner_code%type ;
           mtbdr            amd_national_stock_items.MTBDR%type ;
           indenture        varchar2(7) ;  
           price            amd_spare_parts.UNIT_COST%type ;       
           lineNo           number := 0 ;
           result           number ;    

     begin

        if amd_utils.ispartConsumable(part_no) then
            lineNo := 1 ;
            consumables_pkg.insertPartInfo(part_no, action_code) ;
        else        
            lineNo := 2 ;
            if action_code = amd_defaults.DELETE_ACTION then
                select nomenclature into nomenclature from amd_spare_parts where part_no = insertPartInfo.part_no ;
                result := deletePartInfo(part_no, nomenclature) ;
            else                
                lineNo := 3 ;
                select nomenclature, mfgr, unit_of_issue, parts.nsn, 
                    amd_preferred_pkg.GetPreferredValue(smr_code_cleaned, smr_code) smr_code,
                    amd_preferred_pkg.getPreferredValue(mtbdr_cleaned, mtbdr_computed, mtbdr) mtbdr,            
                    amd_preferred_pkg.getPreferredValue(planner_code_cleaned, planner_code) planner_code,
                    amd_preferred_pkg.getPreferredValue(unit_cost_cleaned, unit_cost) price
                into nomenclature, mfgr, unit_issue, nsn, smr_code, mtbdr, planner_code, price             
                from amd_spare_parts parts, amd_national_stock_items items
                where part_no = InsertPartInfo.part_no
                and parts.nsn = items.nsn ;
                
                lineNo := 4 ;
                insertPartInfo( part_no => part_no, nomenclature => nomenclature, action_code => action_code,
                    mfgr => mfgr, unit_issue => unit_issue, smr_code => smr_code, nsn => nsn, 
                    planner_code => planner_code, third_party_flag => repairables_Pkg.THIRD_PARTY_FLAG, 
                    mtbdr => mtbdr, indenture => getIndenture(smr_code), price => price) ;
            end if ;

        
        end if ;
        
     exception when others then
            
        ErrorMsg(pSqlfunction => 'select/insert',
              pTableName => 'insertPartInfo',
              pError_location => 180,
              pKey_1 => part_no,
              pKey_2 => lineNo ) ;
         RAISE ;
 end insertPartInfo ;
     
     procedure initA2ADemands is
        cnt number := 0 ;
        action_code amd_spare_parts.ACTION_CODE%type ;
        site varchar2(13) ;
        thePartNo amd_spare_parts.part_no%type ;
        cursor theDemands is
            SELECT a.NSI_SID,
                a.LOC_SID,
                a.DOC_NO docno,
                a.DOC_DATE demand_date,
                a.QUANTITY qty
            FROM amd_owner.AMD_DEMANDS a ;
     begin
        amd_owner.Mta_Truncate_Table('tmp_a2a_demands','reuse storage');
        for rec in theDemands loop
            thePartNo := Amd_Partprime_Pkg.getSuperPrimePartByNsiSid(rec.nsi_sid) ;
            site := Amd_Utils.getSpoLocation(rec.loc_sid) ;
            if site not in  ('FB4454', 'FB4455', 'FB4412', 'FB4490', 'FB4491') then
                begin
                    select action_code into action_code from amd_sent_to_a2a where part_no = thePartNo
                    and part_no = spo_prime_part_no ;
                    /*
                    INSERT INTO amd_owner.TMP_A2A_DEMANDS
                       (part_no, site, docno, demand_date, qty, demand_level, action_code, last_update_dt)
                       values (thePartNo, site, rec.docno, rec.demand_date, rec.qty, null, action_code, sysdate) ;
                       */
                    cnt := cnt + 1 ;
                exception when standard.no_data_found then
                    null ; -- do nothing
                end ;    
            end if ;
        end loop ;
        dbms_output.put_line('cnt=' || cnt) ;
        commit ;
     end initA2ADemands ;
     
     PROCEDURE processExtForecast(extForecast IN extForecastCur) IS
                rec AMD_part_loc_forecasts%ROWTYPE ;
               cnt NUMBER := 0 ;
               rc number ;
               extForecasts extForecastTab ;
     BEGIN
            writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 190,
                pKey1 => 'processExtForecast',
                pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
           
           fetch extForecast bulk collect into extForecasts ;
           close extForecast ;
           
           if extForecasts.first is not null then
               for indx in extForecasts.first .. extForecasts.last                
               LOOP
                /*
                  amd_part_loc_forecasts_pkg.InsertTmpA2A_EF_AllPeriods
                    (
                        extForecasts(indx).part_no, 
                        Amd_Utils.GetSpoLocation(extForecasts(indx).loc_sid) , 
                        amd_part_loc_forecasts_pkg.GetCurrentPeriod, 
                        extForecasts(indx).forecast_qty , 
                        extForecasts(indx).action_code, 
                        sysdate 
                    )  ; */
                   cnt := cnt + 1 ;
               END LOOP ;
            end if ;               
            writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 200,
                pKey1 => 'processExtForecast',
                pKey2 => 'cnt=' || TO_CHAR(cnt),
                pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;
     END processExtForecast ;
     
     PROCEDURE initA2AExtForecast(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE) IS
      extForecast extForecastCur ;
      
     BEGIN
          writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 210,
                    pKey1 => 'initA2AExtForecast',
                    pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                    pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                    pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          Mta_Truncate_Table('tmp_a2a_ext_forecast','reuse storage');
          mblnSendAllData := TRUE ;
          OPEN extForecast FOR
              SELECT * FROM AMD_part_loc_forecasts 
              WHERE
              TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
              and part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL)
              order by part_no, loc_sid, last_update_dt ;
          processExtForecast(extForecast) ;
          writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 220,
                    pKey1 => 'initA2AExtForecast',
                    pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                    pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                    pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;
     END initA2AExtForecast ;
     
      PROCEDURE initA2AExtForecast(useTestParts IN BOOLEAN := FALSE ) is
              extForecast extForecastCur ;
              procedure getTestData is
            begin
                writeMsg(pTableName => 'amd_part_loc_forcecast', pError_location => 230,
                    pKey1 => 'getTestData' ) ;
                commit ;
                OPEN extForecast FOR
                    SELECT *
                    FROM AMD_part_loc_forecasts WHERE
                    part_no IN (SELECT part_no FROM AMD_TEST_PARTS) 
                    AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL) 
                    order by part_no, loc_sid, last_update_dt ;
                        
            end getTestData ;
            
            procedure getAllData is
            begin
                 writeMsg(pTableName => 'amd_part_loc_forcecast', pError_location => 240,
                     pKey1 => 'getAllData' ) ;
                commit ;
                OPEN extForecast FOR
                    SELECT * FROM AMD_part_loc_forecasts WHERE
                    part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL)
                    order by part_no, loc_sid, last_update_dt ;
                  
            end getAllData ;
            
      begin
          writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 250,
                    pKey1 => 'initA2AExtForecast',
                    pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                    pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          mblnSendAllData := TRUE ;
          Mta_Truncate_Table('TMP_A2A_EXT_FORECAST','reuse storage');
          IF useTestParts THEN
               getTestData ;
          ELSE
               getAllData ;
          END IF ;
          processExtForecast(extForecast) ;
          writeMsg(pTableName => 'tmp_a2a_ext_forecast', pError_location => 260,
                    pKey1 => 'initA2AExtForecast',
                    pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                    pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;
      end initA2AExtForecast ;
    
    
     PROCEDURE processOnHandInvSum(onHandInvSum IN onHandInvSumCur) IS
               cnt NUMBER := 0 ;
               onHandInvSums onHandInvSumTab ;
     BEGIN
        writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 270,
            pKey1 => 'processOnHandInvSum',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
        fetch onHandInvSum bulk collect into onHandInvSums ;
        close onHandInvSum ;

        if onHandInvSums.first is not null then
            for indx in onHandInvSums.first .. onHandInvSums.last           
            LOOP
                repairables_Pkg.insertInvInfo(onHandInvSums(indx).part_no,onHandInvSums(indx).spo_location,onHandInvSums(indx).qty_on_hand, onHandInvSums(indx).action_code) ;
                cnt := cnt + 1 ;
            END LOOP ;
            COMMIT ;
        end if ;              
        writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 280,
            pKey1 => 'processOnHandInvSum',
            pKey2 => 'cnt=' || TO_CHAR(cnt),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
     END processOnHandInvSum ;
     
     PROCEDURE initA2AInvInfo(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE) IS
      invInfoByDate onHandInvSumCur ; 
       
     BEGIN
        writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 290,
                pKey1 => 'initA2AInvInfo',
                pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      mblnSendAllData := TRUE ;
      OPEN invInfoByDate FOR
        SELECT  
                    oh.PART_NO,       
                  SPO_LOCATION,    
                  QTY_ON_HAND,
                  case oh.ACTION_CODE
                         when amd_defaults.getDELETE_ACTION then
                               oh.ACTION_CODE
                       else     
                                 sent.ACTION_CODE
                  end action_code,     
                  LAST_UPDATE_DT,  
                  REORDER_POINT,   
                  STOCK_LEVEL     
        FROM AMD_ON_HAND_INVS_SUM oh, amd_sent_to_a2a sent 
        WHERE TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
        AND oh.part_no = sent.part_no
        and sent.SPO_PRIME_PART_NO is not null
        UNION ALL
        SELECT rsp.part_no, rsp_location, qty_on_hand, 
        case rsp.action_code
             when amd_defaults.getDELETE_ACTION then
                   rsp.action_code
             else
                  sent.action_code
        end action_code, last_update_dt, NULL reorder_point, NULL stock_level
        FROM AMD_RSP_SUM rsp, amd_sent_to_a2a sent 
        WHERE TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt)
        AND rsp.part_no = sent.part_no
        and sent.spo_prime_part_no is not null
        order by part_no, spo_location, last_update_dt ;
    
      Mta_Truncate_Table('TMP_A2A_INV_INFO','reuse storage');
      processOnHandInvSum(invInfoByDate) ;
      writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 300,
                pKey1 => 'initA2AInvInfo',
                pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
                
      COMMIT ;
     END initA2AInvInfo ;
    
     
     FUNCTION initA2AInvInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
         invInfo onHandInvSumCur ;
         result NUMBER := SUCCESS ;
         
         procedure getTestData is
         begin
            writeMsg(pTableName => 'amd_on_hand_invs_sum', pError_location => 310,
            pKey1 => 'getTestData' ) ;
            commit ;
            OPEN invInfo FOR
              SELECT 
                    oh.PART_NO,       
                  SPO_LOCATION,    
                  QTY_ON_HAND,
                  case oh.action_code
                         when amd_defaults.getDELETE_ACTION then
                               oh.action_code
                       else
                              sent.action_code
                  end action_code,     
                  LAST_UPDATE_DT,  
                  REORDER_POINT,   
                  STOCK_LEVEL     
              FROM AMD_ON_HAND_INVS_SUM oh, amd_sent_to_a2a sent, amd_test_parts testParts 
              WHERE oh.part_no = testParts.part_no 
              AND oh.part_no = sent.part_no
              and sent.SPO_PRIME_PART_NO is not null
              UNION ALL
              SELECT rsp.part_no, rsp_location, qty_on_hand, 
              case rsp.action_code
                     when amd_defaults.getDELETE_ACTION then
                           rsp.action_code
                   else
                          sent.action_code
              end action_code, last_update_dt, NULL reorder_point, NULL stock_level
              FROM AMD_RSP_SUM rsp, amd_sent_to_a2a sent, amd_test_parts testParts 
              WHERE rsp.part_no = testParts.part_no
              AND rsp.part_no = sent.part_no
              and sent.SPO_PRIME_PART_NO is not null
              order by part_no, spo_location, last_update_dt ;
         end getTestData ;
         
         procedure getAllData is
         begin
            writeMsg(pTableName => 'amd_on_hand_invs_sum', pError_location => 320,
            pKey1 => 'getAllData' ) ;
            commit ;
               OPEN invInfo FOR
                  SELECT  
                        oh.PART_NO,       
                      SPO_LOCATION,    
                      QTY_ON_HAND,
                      case oh.action_code
                             when amd_defaults.getDELETE_ACTION then
                                   oh.action_code
                           else                            
                                     sent.ACTION_CODE
                      end action_code,     
                      LAST_UPDATE_DT,  
                      REORDER_POINT,   
                      STOCK_LEVEL     
                    FROM AMD_ON_HAND_INVS_SUM oh, amd_sent_to_a2a sent 
                  WHERE oh.part_no = sent.part_no
                  and sent.SPO_PRIME_PART_NO is not null
                  UNION ALL
                  SELECT rsp.part_no, rsp_location, qty_on_hand, 
                  case rsp.action_code
                         when amd_defaults.getDELETE_ACTION then
                               rsp.action_code
                       else
                              sent.action_code
                  end action_code, last_update_dt, NULL reorder_point, NULL stock_level
                  FROM AMD_RSP_SUM rsp, amd_sent_to_a2a sent
                  WHERE rsp.part_no = sent.part_no
                  and sent.SPO_PRIME_PART_NO is not null
                  order by part_no, spo_location, last_update_dt ;

         end getAllData ;
      
    
     BEGIN
      writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 330,
                pKey1 => 'initA2AInvInfo',
                pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      mblnSendAllData := TRUE ;
      Mta_Truncate_Table('TMP_A2A_INV_INFO','reuse storage');
      IF useTestParts THEN
           getTestData ;
      ELSE
           getAllData ;
      END IF ;
      resetDebugCnts ;
      processOnHandInvSum(invInfo) ;
      writeMsg(pTableName => 'tmp_a2a_inv_info', pError_location => 340,
                pKey1 => 'initA2AInvInfo',
                pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                pKey3 => 'insertCnt=' || insertCnt || ' deleteCnt=' || deleteCnt || ' rejectCnt=' || rejectCnt,
                pData => 'updateCnt=' || updateCnt,
                pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
                
      COMMIT ;
      RETURN result ;
     END initA2AInvInfo ;
    
    function tmpA2AInvInfoAddOk(part_no in AMD_ON_HAND_INVS_SUM.PART_NO%type) return boolean is
         invInfo onHandInvSumCur ;
         result number := null ;
    begin
        processOnHandInvSum(invInfo) ;
        /*
        select 1 into result from dual
            where exists (select null
                          from tmp_a2a_inv_info
                          where part_no = tmpA2AInvInfoAddOk.part_no ) ;
                          */ 
        return result is not null ;
    exception when standard.no_data_found then
        return false ;
    end tmpA2AInvInfoAddOk ;
    
    function tmpA2AInvInfoAddOk(part_no in AMD_ON_HAND_INVS_SUM.PART_NO%type, spo_location in amd_on_hand_invs_sum.SPO_LOCATION%type ) return boolean is
         invInfo onHandInvSumCur ;
         result number := null ;
    begin
        if spo_location is null then
                    open invInfo for
                  SELECT  
                        oh.PART_NO,       
                      SPO_LOCATION,    
                      QTY_ON_HAND,
                      case oh.action_code
                             when amd_defaults.getDELETE_ACTION then
                                   oh.action_code
                           else                            
                                     sent.ACTION_CODE
                      end action_code,     
                      LAST_UPDATE_DT,  
                      REORDER_POINT,   
                      STOCK_LEVEL     
                    FROM AMD_ON_HAND_INVS_SUM oh, amd_sent_to_a2a sent 
                  WHERE oh.part_no = sent.part_no
                  and sent.SPO_PRIME_PART_NO is not null
                  and oh.part_no = tmpA2AInvInfoAddOk.part_no 
                  UNION ALL
                  SELECT rsp.part_no, rsp_location, qty_on_hand, 
                  case rsp.action_code
                         when amd_defaults.getDELETE_ACTION then
                               rsp.action_code
                       else
                              sent.action_code
                  end action_code, last_update_dt, NULL reorder_point, NULL stock_level
                  FROM AMD_RSP_SUM rsp, amd_sent_to_a2a sent
                  WHERE rsp.part_no = sent.part_no
                  and sent.SPO_PRIME_PART_NO is not null 
                  and rsp.part_no = tmpA2AInvInfoAddOk.part_no ;
        else
            open invInfo for
                      SELECT  
                            oh.PART_NO,       
                          SPO_LOCATION,    
                          QTY_ON_HAND,
                          case oh.action_code
                                 when amd_defaults.getDELETE_ACTION then
                                       oh.action_code
                               else                            
                                         sent.ACTION_CODE
                          end action_code,     
                          LAST_UPDATE_DT,  
                          REORDER_POINT,   
                          STOCK_LEVEL     
                        FROM AMD_ON_HAND_INVS_SUM oh, amd_sent_to_a2a sent 
                      WHERE oh.part_no = sent.part_no
                      and sent.SPO_PRIME_PART_NO is not null
                      and oh.part_no = tmpA2AInvInfoAddOk.part_no
                      and oh.spo_location =  tmpA2AInvInfoAddOk.spo_location
                      UNION ALL
                      SELECT rsp.part_no, rsp_location, qty_on_hand, 
                      case rsp.action_code
                             when amd_defaults.getDELETE_ACTION then
                                   rsp.action_code
                           else
                                  sent.action_code
                      end action_code, last_update_dt, NULL reorder_point, NULL stock_level
                      FROM AMD_RSP_SUM rsp, amd_sent_to_a2a sent
                      WHERE rsp.part_no = sent.part_no
                      and sent.SPO_PRIME_PART_NO is not null 
                      and rsp.part_no = tmpA2AInvInfoAddOk.part_no 
                      and rsp.rsp_location =  tmpA2AInvInfoAddOk.spo_location ;
        end if ;
        processOnHandInvSum(invInfo) ;
        
        return result is not null ;
        
    exception when standard.no_data_found then
        return false ;
    end tmpA2AInvInfoAddOk ;
    
 
    PROCEDURE processRepairInvInfo(repairInvInfo IN repairInvInfoCur) IS
              cnt NUMBER := 0 ;
              repairInvInfos repairInvInfoTab ;
    BEGIN
         writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 350,
                pKey1 => 'proecessRepairInvInfo',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
         fetch repairInvInfo bulk collect into repairInvInfos ;
         close repairInvInfo ;

        if repairInvInfos.first is not null then         
             for indx in repairInvInfos.first .. repairInvInfos.last
             LOOP
                 repairables_Pkg.insertRepairInvInfo(repairInvInfos(indx).part_no,repairInvInfos(indx).site_location,repairInvInfos(indx).qty_on_hand, repairInvInfos(indx).action_code) ;
                  cnt := cnt + 1 ;
             END LOOP ;
             COMMIT ;
        end if ;             
     writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 360,
            pKey1 => 'proecessRepairInvInfo',
            pKey2 => 'cnt=' || TO_CHAR(cnt),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
    END processRepairInvInfo ;
     
    PROCEDURE initA2ARepairInvInfo(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE) IS
      repairInvInfoByDate repairInvInfoCur ;
      
      cnt NUMBER := 0 ;
      
    BEGIN
      writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 370,
                pKey1 => 'initA2ARepairInvInfo',
                pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      Mta_Truncate_Table('TMP_A2A_REPAIR_INV_INFO','reuse storage');
      mblnSendAllData := TRUE ;
      OPEN repairInvInfoByDate FOR
              SELECT  rep.PART_NO,       
                      rep.SITE_LOCATION,    
                      QTY_ON_HAND,
                      case rep.action_code
                             when amd_defaults.getDELETE_ACTION then
                                   rep.action_code
                           else                            
                                     sent.ACTION_CODE
                      end action_code,     
                      LAST_UPDATE_DT  
              FROM AMD_REPAIR_INVS_SUM rep, amd_sent_to_a2a sent
              where rep.part_no = sent.part_no
              and sent.spo_prime_part_no is not null 
              and TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
              order by rep.part_no, rep.site_location, last_update_dt ;
      resetDebugCnts ;               
      processRepairInvInfo(repairInvInfoByDate) ;
      writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 380,
                pKey1 => 'initA2ARepairInvInfo',
                pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pData => 'insertCnt=' || insertCnt || ' deleteCnt=' || deleteCnt || ' rejectCnt=' || rejectCnt || ' updateCnt=' || updateCnt) ;
      COMMIT ;
    END initA2ARepairInvInfo ;
    
    function tmpA2ARepairInvInfoAddOk(part_no in amd_repair_invs_sum.part_no%type,
        site_location in amd_repair_invs_sum.site_location%type := null) return boolean is
      repairInvInfoByDate repairInvInfoCur ;
      result number := null ;
    begin
      if site_location is null then
          OPEN repairInvInfoByDate FOR
                  SELECT  rep.PART_NO,       
                          rep.SITE_LOCATION,    
                          QTY_ON_HAND,
                          case rep.action_code
                                 when amd_defaults.getDELETE_ACTION then
                                       rep.action_code
                               else                            
                                         sent.ACTION_CODE
                          end action_code,     
                          LAST_UPDATE_DT  
                  FROM AMD_REPAIR_INVS_SUM rep, amd_sent_to_a2a sent
                  where rep.part_no = sent.part_no
                  and sent.spo_prime_part_no is not null
                  and rep.part_no = tmpA2ARepairInvInfoAddOk.part_no ;
      else 
          OPEN repairInvInfoByDate FOR
                  SELECT  rep.PART_NO,       
                          rep.SITE_LOCATION,    
                          QTY_ON_HAND,
                          case rep.action_code
                                 when amd_defaults.getDELETE_ACTION then
                                       rep.action_code
                               else                            
                                         sent.ACTION_CODE
                          end action_code,     
                          LAST_UPDATE_DT  
                  FROM AMD_REPAIR_INVS_SUM rep, amd_sent_to_a2a sent
                  where rep.part_no = sent.part_no
                  and sent.spo_prime_part_no is not null
                  and rep.part_no = tmpA2ARepairInvInfoAddOk.part_no
                  and rep.site_location = tmpA2ARepairInvInfoAddOk.site_location ;
      end if ;
                  
      processRepairInvInfo(repairInvInfoByDate) ;
      
      return result is not null ;
    exception when standard.no_data_found then
        return false ;
    end tmpA2ARepairInvInfoAddOk ;
    
       
    FUNCTION initA2ARepairInvInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
        repairInvInfo repairInvInfoCur ;
        result NUMBER := SUCCESS ;
          
        procedure getTestData is
        begin
            writeMsg(pTableName => 'amd_repair_invs_sum', pError_location => 390,
            pKey1 => 'getTestData' ) ;
            commit ;
              OPEN repairInvInfo FOR
              SELECT  rep.PART_NO,       
                      rep.SITE_LOCATION,    
                      QTY_ON_HAND,
                      case rep.action_code
                             when amd_defaults.getDELETE_ACTION then
                                   rep.action_code             
                           else                            
                                     sent.ACTION_CODE
                      end action_code,     
                      LAST_UPDATE_DT  
              FROM AMD_REPAIR_INVS_SUM rep, amd_sent_to_a2a sent
              where rep.part_no = sent.part_no
              and sent.spo_prime_part_no is not null 
              and rep.part_no IN (SELECT part_no FROM AMD_TEST_PARTS) 
              order by rep.part_no, rep.site_location, last_update_dt ; 
        end getTestData ;
        
        procedure getAllData is
        begin
            writeMsg(pTableName => 'amd_repair_invs_sum', pError_location => 400,
            pKey1 => 'getAllData' ) ;
            commit ;
               OPEN repairInvInfo FOR
              SELECT  rep.PART_NO,       
                      rep.SITE_LOCATION,    
                      QTY_ON_HAND,
                      case rep.action_code
                             when amd_defaults.getDELETE_ACTION then
                                   rep.action_code
                           else                            
                                     sent.ACTION_CODE
                      end action_code,     
                      LAST_UPDATE_DT  
              FROM AMD_REPAIR_INVS_SUM rep, amd_sent_to_a2a sent
              where rep.part_no = sent.part_no
              and sent.spo_prime_part_no is not null
              order by rep.part_no, rep.site_location, last_update_dt ;
        end getAllData ;
    
    BEGIN
      writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 410,
                pKey1 => 'initA2ARepairInvInfo',
                pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      Mta_Truncate_Table('TMP_A2A_REPAIR_INV_INFO','reuse storage');
      mblnSendAllData := TRUE ;
      IF useTestParts THEN
           getTestData ;
      ELSE
           getAllData ;
      END IF ;
      resetDebugCnts ;
      processRepairInvInfo(repairInvInfo) ;
    
      writeMsg(pTableName => 'tmp_a2a_repair_inv_info', pError_location => 420,
                pKey1 => 'initA2ARepairInvInfo',
                pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                pKey3 => 'insertCnt=' || insertCnt || ' deleteCnt=' || deleteCnt || ' rejectCnt=' || rejectCnt,
                pData => 'updateCnt=' || updateCnt,
                pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      COMMIT ;
      RETURN result ;
     END initA2ARepairInvInfo ;
     
     PROCEDURE processInTransits(inTransit IN inTransitsCur) IS
                cnt NUMBER := 0 ;
               rec AMD_IN_TRANSITS_SUM%ROWTYPE ;
               inTransits inTransitsTab ;
     BEGIN
          writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 430,
                pKey1 => 'processInTransits',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
           fetch inTransit bulk collect into inTransits ;
           close inTransit ;
           
           if inTransits.first is not null then
               for indx in inTransits.first .. inTransits.last                
               LOOP 
                     cnt := cnt + 1 ;
              END LOOP ;
          end if ;              
          writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 440,
                pKey1 => 'processInTransits',
                pKey2 => 'cnt=' || TO_CHAR(cnt),
                pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;
     END processInTransits ;
     
     PROCEDURE initA2AInTransits(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE) IS
      inTransitsByDate inTransitsCur ;
      
     BEGIN
          writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 450,
                    pKey1 => 'initA2AInTransits',
                    pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                    pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                    pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          Mta_Truncate_Table('tmp_a2a_in_transits','reuse storage');
          mblnSendAllData := TRUE ;
          OPEN inTransitsByDate FOR
              SELECT * FROM AMD_IN_TRANSITS_SUM 
              WHERE
              TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
              AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL)
              order by part_no, site_location, serviceable_flag, last_update_dt ;
          processInTransits(inTransit => inTransitsByDate) ;
          writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 460,
                    pKey1 => 'initA2AInTransits',
                    pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                    pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                    pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;
     END initA2AInTransits ;
     
     FUNCTION initA2AInTransits(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
         inTransits inTransitsCur ;
        
         result NUMBER := SUCCESS ;
         
         procedure getTestData is
         begin
             writeMsg(pTableName => 'amd_in_transits_sum', pError_location => 470,
             pKey1 => 'getTestData' ) ;
             commit ;
               OPEN inTransits FOR
                  SELECT *
                  FROM AMD_IN_TRANSITS_SUM  WHERE
                  part_no IN (SELECT part_no FROM AMD_TEST_PARTS)
                  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL)
                  order by part_no, site_location, serviceable_flag, last_update_dt ;
         end getTestData ;
         
         procedure getAllData is
         begin
             writeMsg(pTableName => 'amd_in_transits_sum', pError_location => 480,
             pKey1 => 'getAllData' ) ;
             commit ;
               OPEN inTransits FOR
                  SELECT * FROM AMD_IN_TRANSITS_SUM  WHERE 
                  part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL)
                  order by part_no, site_location, serviceable_flag, last_update_dt ;
         end getAllData ;
    
     BEGIN
          writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 490,
                    pKey1 => 'initA2AInTransits',
                    pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                    pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
          Mta_Truncate_Table('tmp_a2a_in_transits','reuse storage');
          mblnSendAllData := TRUE ;
          IF useTestParts THEN
               getTestData ;
          ELSE
               getAllData ;
          END IF ;
          
          processInTransits(inTransits) ;
          writeMsg(pTableName => 'tmp_a2a_in_transits', pError_location => 500,
                    pKey1 => 'initA2AInTransits',
                    pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                    pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;  
          RETURN result ;
     END initA2AInTransits ;
    
     function tmpA2AInTransitsAddOk(part_no in amd_in_transits.part_no%type) return boolean is
         inTransits inTransitsCur ;
        
         result NUMBER := null ;
         
     begin
          
        open inTransits for
            select * from amd_in_transits_sum  where 
            part_no in (select part_no from amd_sent_to_a2a where spo_prime_part_no is not null)
            and part_no = tmpA2AInTransitsAddOk.part_no ;
             
          processintransits(intransits) ;
          /*
          select 1 into result from dual
          where exists (select null
                        from tmp_a2a_in_transits
                        where part_no = tmpA2AInTransitsAddOk.part_no ) ;
            */                  
          return result is not null ;
          
     exception when standard.no_data_found then
        return false ;
     end tmpA2AInTransitsAddOk ;
     
     PROCEDURE processInRepair(inRepair IN inRepairCur) IS
                cnt NUMBER := 0 ;
               inRepairs inRepairTab ;
     BEGIN
            writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 510,
                pKey1 => 'processInRepair',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
           fetch inRepair bulk collect into inRepairs ;
           close inRepair ;
           
           if inRepairs.first is not null then
               for indx in inRepairs.first .. inRepairs.last  
               LOOP
                   repairables_Pkg.insertRepairInfo(inRepairs(indx).part_no,inRepairs(indx).loc_sid,inRepairs(indx).order_no,inRepairs(indx).repair_date,repairables_Pkg.OPEN_STATUS,inRepairs(indx).repair_qty,
                        inRepairs(indx). repair_need_date, inRepairs(indx).action_code) ;
                   cnt := cnt + 1 ;
              END LOOP ;
           end if ;              
            writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 520,
                pKey1 => 'processInRepair',
                pKey2 => 'cnt=' || TO_CHAR(cnt),
                pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
          COMMIT ;
     END processInRepair ;
     
     PROCEDURE initA2ARepairInfo(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE) IS
      
      repairsByDate inRepairCur ;
      
     BEGIN
            writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 530,
                pKey1 => 'initA2ARepairInfo',
                pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
            Mta_Truncate_Table('tmp_a2a_repair_info','reuse storage');
          mblnSendAllData := TRUE ;
          OPEN repairsByDate FOR
              SELECT * FROM AMD_IN_REPAIR 
              WHERE
              TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
              AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL)
              order by order_no, part_no, loc_sid, last_update_dt ;
          resetDebugCnts ;              
          processInRepair(repairsByDate) ;
            writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 540,
                pKey1 => 'initA2ARepairInfo',
                pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;  
     END initA2ARepairInfo ;
     
     FUNCTION initA2ARepairInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
         repairs inRepairCur ;
         result NUMBER := SUCCESS ;
         
         procedure getTestData is
         begin
             writeMsg(pTableName => 'amd_in_repair', pError_location => 550,
             pKey1 => 'getTestData' ) ;
             commit ;
               OPEN repairs FOR
                  SELECT *
                  FROM AMD_IN_REPAIR WHERE
                  part_no IN (SELECT part_no FROM AMD_TEST_PARTS)
                  AND part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL)
                  order by order_no, part_no, loc_sid, last_update_dt ;
         end getTestData ;
         
         procedure getAllData is
         begin
             writeMsg(pTableName => 'amd_in_repair', pError_location => 560,
             pKey1 => 'getAllData' ) ;
             commit ;
               OPEN repairs FOR
                 SELECT * FROM AMD_IN_REPAIR WHERE 
                 part_no IN (SELECT part_no FROM AMD_SENT_TO_A2A WHERE spo_prime_part_no IS NOT NULL)
                 order by order_no, part_no, loc_sid, last_update_dt ;
         end getAllData ;
    
     BEGIN
      writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 570,
        pKey1 => 'initA2ARepairInfo',
        pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
        pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
      Mta_Truncate_Table('tmp_a2a_repair_info','reuse storage');
      mblnSendAllData := TRUE ;
      IF useTestParts THEN
           getTestData ;
      ELSE
           getAllData ;
      END IF ;
      resetDebugCnts ;
      processInRepair(repairs) ;
      writeMsg(pTableName => 'tmp_a2a_repair_info', pError_location => 580,
        pKey1 => 'initA2ARepairInfo',
        pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
        pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      COMMIT ;  
      RETURN result ;
     END initA2ARepairInfo ;
    
     PROCEDURE processOnOrder(onOrder IN onOrderCur) IS
                cnt NUMBER := 0 ;
               rec AMD_ON_ORDER%ROWTYPE ;
               onOrders onOrderTab ;
     BEGIN
          writeMsg(pTableName => 'tmp_a2a_order_info_line', pError_location => 590,
            pKey1 => 'processOnOrder',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
            
           fetch onOrder bulk collect into onOrders ;
           close onOrder ;
           
           if onOrders.first is not null then
               for indx in onOrders.first .. onOrders.last  
               LOOP
                    cnt := cnt + 1 ;
              END LOOP ;
          end if ;              
          writeMsg(pTableName => 'tmp_a2a_order_info_line', pError_location => 600,
            pKey1 => 'processOnOrder',
            pKey2 => 'cnt=' || TO_CHAR(cnt),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
          COMMIT ;
     END processOnOrder ;
     
     -- create a2a for a specific set of dates
     PROCEDURE initA2AOrderInfo(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE) IS
      ordersByDate onOrderCur ;
     BEGIN
          writeMsg(pTableName => 'tmp_a2a_order_info_line', pError_location => 610,
            pKey1 => 'initA2AOrderInfo',
            pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
            pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
            pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          includeCnt := 0 ;
          excludeCnt := 0 ;  
            Mta_Truncate_Table('tmp_a2a_order_info_line','reuse storage');
          mblnSendAllData := TRUE ;
          OPEN ordersByDate FOR
              SELECT  
                  oo.PART_NO,  
                  LOC_SID,
                  LINE,          
                  ORDER_DATE,         
                  ORDER_QTY,          
                  GOLD_ORDER_NUMBER, 
                  case oo.ACTION_CODE
                         when amd_defaults.getDELETE_ACTION then
                               oo.ACTION_CODE
                       else  
                                  sent.ACTION_CODE
                  end action_code,        
                  LAST_UPDATE_DT,     
                  SCHED_RECEIPT_DATE
                  FROM AMD_ON_ORDER OO, amd_sent_to_a2a sent 
              WHERE TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
              AND oo.part_no = sent.part_no
              and sent.SPO_PRIME_PART_NO is not null  
              ORDER BY gold_order_number, order_date, loc_sid, last_update_dt ;
          processOnOrder(ordersByDate) ;
            writeMsg(pTableName => 'tmp_a2a_order_info_line', pError_location => 620,
            pKey1 => 'initA2AOrderInfo',
            pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
            pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
            pKey4 => 'excludeCnt=' || TO_CHAR(excludeCnt),
            pData => 'includeCnt=' || includeCnt || ' ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
          COMMIT ;
     END initA2AOrderInfo ;
     
     FUNCTION initA2AOrderInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
         onOrders onOrderCur ;
         result NUMBER := SUCCESS ;
         orders NUMBER := 0 ;
         lines NUMBER := 0 ;
         
         procedure getTestData is
         begin
             writeMsg(pTableName => 'amd_on_order', pError_location => 630,
             pKey1 => 'getTestData' ) ;
             commit ;
               OPEN onOrders FOR
              SELECT 
                      oo.PART_NO,  
                      LOC_SID,
                      LINE,          
                      ORDER_DATE,         
                      ORDER_QTY,          
                      GOLD_ORDER_NUMBER,
                      case oo.ACTION_CODE
                             when amd_defaults.getDELETE_ACTION then
                                   oo.ACTION_CODE
                           else  
                                      sent.ACTION_CODE
                      end action_code,        
                      LAST_UPDATE_DT,     
                      SCHED_RECEIPT_DATE
              FROM AMD_ON_ORDER OO, amd_sent_to_a2a sent, amd_test_parts testParts 
              WHERE oo.part_no = testParts.PART_NO 
              AND oo.part_no = sent.part_no
              and sent.SPO_PRIME_PART_NO is not null     
              ORDER BY gold_order_number, order_date, loc_sid, last_update_dt ;
         end getTestData ;
         
         procedure getAllData is
         begin
             writeMsg(pTableName => 'amd_on_order', pError_location => 640,
             pKey1 => 'getAllData' ) ;
             commit ;
                 OPEN onOrders FOR 
                 SELECT 
                      oo.PART_NO,  
                      LOC_SID,
                      LINE,          
                      ORDER_DATE,         
                      ORDER_QTY,          
                      GOLD_ORDER_NUMBER,  
                      case oo.ACTION_CODE
                             when amd_defaults.getDELETE_ACTION then
                                   oo.ACTION_CODE
                           else  
                                      sent.ACTION_CODE
                      end action_code,        
                      LAST_UPDATE_DT,     
                      SCHED_RECEIPT_DATE
                  FROM AMD_ON_ORDER OO, amd_sent_to_a2a sent 
                  WHERE oo.part_no = sent.part_no
                  and sent.SPO_PRIME_PART_NO is not null  
                  ORDER BY gold_order_number, order_date, loc_sid, last_update_dt ;
         end getAllData ;
    
     BEGIN
      writeMsg(pTableName => 'tmp_a2a_order_info_line', pError_location => 650,
            pKey1 => 'initA2AOrderInfo',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
      Mta_Truncate_Table('tmp_a2a_order_info_line','reuse storage');
      mblnSendAllData := TRUE ;
      includeCnt := 0 ;
      excludeCnt := 0 ;
      IF useTestParts THEN
           getTestData ;
      ELSE
           getAllData ;
      END IF ;
      processOnOrder(onOrders) ;
    
      writeMsg(pTableName => 'tmp_a2a_order_info_line', pError_location => 660,
            pKey1 => 'initA2AOrderInfo',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'lines=' || TO_CHAR(lines),
            pData => 'includeCnt=' || includeCnt || ' excludeCnt=' || excludeCnt, 
            pComments => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
      RETURN result ;
     END initA2AOrderInfo ;

     function getActionCode(part_no in amd_sent_to_a2a.part_no%type) return amd_sent_to_a2a.action_code%type is
               theActionCode amd_sent_to_a2a.action_code%type ;
     begin
         select action_code into theActionCode from amd_sent_to_a2a where part_no = getActionCode.part_no ;
         return theActionCode ;
     end getActionCode ;
     
     PROCEDURE insertPartLeadTime(
            part_no IN amd_spare_parts.PART_NO%type,
            lead_time_type varchar2,
            lead_time IN number,
            action_code IN amd_spare_parts.action_code%TYPE) IS
           
      partLeadTimeError EXCEPTION ;
      result NUMBER := SUCCESS ;
     BEGIN
       CASE action_code
          WHEN Amd_Defaults.INSERT_ACTION THEN
             result := insertPartLeadTime(part_no, lead_time_type, lead_time) ;
         WHEN Amd_Defaults.UPDATE_ACTION THEN
             result := updatePartLeadTime(part_no, lead_time_type, lead_time) ;
         WHEN Amd_Defaults.DELETE_ACTION THEN
             result := deletePartLeadTime(part_no) ;
       END CASE ;
       IF result != SUCCESS THEN
        RAISE partLeadTimeError ;
       END IF ;
     END insertPartLeadTime ;
     
     PROCEDURE insertTmpA2APartLeadTime(part_no IN VARCHAR2, 
                order_lead_time IN number,
               order_lead_time_cleaned IN number,
               order_lead_time_defaulted IN number) IS
               
           lead_time number  ;
           result NUMBER ;
           
           action_code AMD_SPARE_PARTS.action_code%type := getActionCode(part_no) ; -- use whatever action_code is in amd_sent_to_a2a
              
           
     BEGIN
    
        IF order_lead_time_cleaned IS NOT NULL THEN
           lead_time := order_lead_time_cleaned ;
        ELSIF order_lead_time IS NOT NULL THEN
           lead_time := order_lead_time ;
        ELSE
         lead_time := order_lead_time_defaulted ;
        END IF ;
     
        IF lead_time IS not null or (lead_time is null and action_code = amd_defaults.DELETE_ACTION) THEN
             insertPartLeadTime(part_no => part_no, lead_time_type => NEW_BUY, lead_time => lead_time,
                                action_code => action_code) ;
        END IF ;
       
     END insertTmpA2APartLeadTime ;
     
     
     FUNCTION getPartInfo RETURN partCur IS
              parts partCur ;
     BEGIN
          writeMsg(pTableName => 'amd_spare_parts', pError_location => 670,
          pKey1 => 'getPartInfo' ) ;
          commit ;
           OPEN parts FOR
              SELECT sp.mfgr,
                  sp.part_no,
                  sp.NOMENCLATURE,
                  sp.nsn,
                  sp.order_lead_time,
                  sp.order_lead_time_defaulted,
                  sp.unit_cost,
                  sp.unit_cost_defaulted,
                  sp.unit_of_issue,
                  nsi.unit_cost_cleaned,
                  nsi.order_lead_time_cleaned,
                  nsi.planner_code,
                  nsi.planner_code_cleaned,
                  nsi.mtbdr,
                  nsi.mtbdr_cleaned,
                  nsi.mtbdr_computed,
                  nsi.smr_code,
                  nsi.smr_code_cleaned,
                  nsi.smr_code_defaulted,
                  nsi.nsi_sid,
                  nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND,
                  nsi.last_update_dt,
                  sp.action_code
              FROM AMD_SPARE_PARTS sp,
                AMD_NATIONAL_STOCK_ITEMS nsi,
                amd_sent_to_a2a sent
              WHERE sp.nsn = nsi.nsn (+)
              and sp.part_no = sent.part_no (+) ; 
                 
        RETURN parts ;
              
     END getPartInfo ;
     
     FUNCTION getTestData RETURN partCur IS
               parts partCur ;
     BEGIN
          writeMsg(pTableName => 'amd_spare_parts', pError_location => 680,
          pKey1 => 'getTestData' ) ;
          commit ;
           OPEN parts FOR 
              SELECT sp.mfgr,
                  sp.part_no,
                  sp.NOMENCLATURE,
                  sp.nsn,
                  sp.order_lead_time,
                  sp.order_lead_time_defaulted,
                  sp.unit_cost,
                  sp.unit_cost_defaulted,
                  sp.unit_of_issue,
                  nsi.unit_cost_cleaned,
                  nsi.order_lead_time_cleaned,
                  nsi.planner_code,
                  nsi.planner_code_cleaned,
                  nsi.mtbdr,
                  nsi.mtbdr_cleaned,
                  nsi.mtbdr_computed,
                  nsi.smr_code,
                  nsi.smr_code_cleaned,
                  nsi.smr_code_defaulted,
                  nsi.nsi_sid,
                  nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND,
                  nsi.last_update_dt,
                sp.action_code
              FROM AMD_SPARE_PARTS sp,
                AMD_NATIONAL_STOCK_ITEMS nsi,
                amd_sent_to_a2a sent
              WHERE sp.nsn = nsi.nsn (+)
                 and sp.part_no = sent.part_no (+)
                 AND sp.part_no IN (SELECT part_no FROM AMD_TEST_PARTS) ;
         
         RETURN parts ;
          
    END getTestData ;
     
    PROCEDURE processPartLeadTimes(parts IN partCur) IS
      rec partInfoRec ;
      cnt NUMBER := 0  ;
      theParts partTab ;
      
    BEGIN
         writeMsg(pTableName => 'tmp_a2a_part_lead_time', pError_location => 690,
            pKey1 => 'processPartLeadTimes',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;  
          fetch parts bulk collect into theParts ;
          close parts ;
          
         if theParts.first is not null then
             for indx in theParts.first .. theParts.last 
             LOOP
                
                IF isPartSent(theParts(indx).part_no) THEN -- part exists in amd_sent_to_a2a with any action_code
                       insertTmpA2APartLeadTime(part_no => theParts(indx).part_no,
                                         order_lead_time => theParts(indx).order_lead_time,
                                    order_lead_time_cleaned => theParts(indx).order_lead_time_cleaned,
                                    order_lead_time_defaulted => theParts(indx).order_lead_time_defaulted) ;
                        cnt := cnt + 1 ;
                        insertTimeToRepair (part_no => theParts(indx).part_no, nsi_sid => theParts(indx).nsi_sid,
                               time_to_repair_off_base_cleand => theParts(indx).time_to_repair_off_base_cleand ) ;
                        cnt := cnt + 1 ;                               
                END IF ;
                         
                
             END LOOP ;
         end if ;             
         writeMsg(pTableName => 'tmp_a2a_part_lead_time', pError_location => 700,
            pKey1 => 'processPartLeadTimes',
            pKey2 => 'cnt=' || TO_CHAR(cnt),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
         COMMIT ;       
    END processPartLeadTimes ;
               
     PROCEDURE initA2APartLeadTime(useTestParts IN BOOLEAN := FALSE) IS
                cnt NUMBER := 0 ;
               parts partCur ;
     BEGIN
      writeMsg(pTableName => 'tmp_a2a_part_lead_time', pError_location => 710,
            pKey1 => 'initA2APartLeadTime',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
      Mta_Truncate_Table('tmp_a2a_part_lead_time','reuse storage');
      IF useTestParts THEN
           parts := getTestData ;
      ELSE
        parts := getPartInfo ;
      END IF ;
      processPartLeadTimes(parts) ;
      writeMsg(pTableName => 'tmp_a2a_part_lead_time', pError_location => 720,
            pKey1 => 'initA2APartLeadTime',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      COMMIT ;       
     END initA2APartLeadTime ;
     
     FUNCTION getValidRcmInd(rcmInd IN VARCHAR2) RETURN VARCHAR2 IS
     BEGIN
           IF UPPER(rcmInd) = 'T' THEN
               RETURN RCM_REPAIRABLE ; -- repairable
          elsif upper(rcmInd) in ('N','P') then
            return RCM_CONSUMABLE ; -- consumable
          else
                RETURN UPPER(rcmInd) ;
          END IF ;
     END getValidRcmInd ;
    
    
    PROCEDURE insertTimeToRepair(part_no IN AMD_SPARE_PARTS.part_no%TYPE,
              nsi_sid IN AMD_NATIONAL_STOCK_ITEMS.nsi_sid%TYPE,
              time_to_repair_off_base_cleand IN AMD_NATIONAL_STOCK_ITEMS.time_to_repair_off_base_cleand%TYPE) IS
              
        time_to_repair NUMBER ;
        result NUMBER ;
        action_code amd_spare_parts.action_code%type := getActionCode(part_no) ; -- use whatever action_code is in amd_sent_to_a2a for this part
    BEGIN
        BEGIN
          SELECT ansi.time_to_repair_off_base
              INTO time_to_repair
              FROM amd_national_stock_items ansi 
              WHERE prime_part_no = insertTimeToRepair.part_no 
              and action_code <> amd_defaults.GETDELETE_ACTION ;
        EXCEPTION WHEN standard.NO_DATA_FOUND THEN
          NULL ; -- do nothing
          WHEN OTHERS THEN
               ErrorMsg(pSqlfunction => 'select',
                 pTableName => 'amd_part_locs',
                 pError_location => 740,
                 pKey_1 => TO_CHAR(insertTimeToRepair.part_no), pKey_2 => '23') ;
             RAISE ;
         END ;
         
        
    
         IF insertTimeToRepair.time_to_repair_off_base_cleand IS NOT NULL THEN
            time_to_repair := insertTimeToRepair.time_to_repair_off_base_cleand ;
         ELSIF time_to_repair IS NOT NULL THEN
            time_to_repair := time_to_repair ; 
                                                            
         END IF ;
    
         IF (time_to_repair IS not NULL or (time_to_repair is null and action_code = amd_defaults.DELETE_ACTION)) THEN
           -- and amd_utils.IsSpoPrimePart(part_no) THEN         
              insertPartLeadTime(part_no, REPAIR, time_to_repair, action_code) ;
            else
            null;        
         END IF ;
        
    END insertTimeToRepair ;

    procedure insertPartPricing( 
            part_no IN amd_spare_parts.PART_NO%type,
           price_type IN varchar2,
           unit_cost IN number ,
           action_code in amd_spare_parts.action_code%type)  IS
           
           result number ;
           
    begin
       CASE action_code
          WHEN Amd_Defaults.INSERT_ACTION THEN
             result := insertPartPricing(part_no, price_type, unit_cost) ;
         WHEN Amd_Defaults.UPDATE_ACTION THEN
             result := updatePartPricing(part_no, price_type, unit_cost) ;
         WHEN Amd_Defaults.DELETE_ACTION THEN
             result := deletePartPricing(part_no) ;
       END CASE ;
    end insertPartPricing ;
        
    PROCEDURE insertUnitCost (
              part_no IN AMD_SPARE_PARTS.part_no%TYPE,
              unit_cost_cleaned IN AMD_NATIONAL_STOCK_ITEMS.unit_cost_cleaned%TYPE,
              unit_cost IN AMD_SPARE_PARTS.unit_cost%TYPE, 
              unit_cost_defaulted IN AMD_SPARE_PARTS.unit_cost_defaulted%TYPE) IS
              
        unitCost NUMBER ;
        result      NUMBER ;
        action_code amd_spare_parts.action_code%type := getActionCode(part_no) ;
        
    BEGIN
        IF unit_cost_cleaned IS NOT NULL THEN
           unitCost := unit_cost_cleaned ;
        ELSIF insertUnitCost.unit_cost IS NOT NULL THEN
           unitCost := insertUnitCost.unit_cost ;
        ELSE
           unitCost := insertUnitCost.unit_cost_defaulted ;
        END IF;
    
        IF unitCost IS NOT NULL or (unitCost is null and action_code = amd_defaults.DELETE_ACTION) THEN
           InsertPartPricing(
              part_no,
             'ORDER',
             unitCost,
             action_code) ;
                 
        END IF ;
    END insertUnitCost ;
    
      PROCEDURE processPart(rec IN partInfoRec, action_code IN VARCHAR2 := NULL) IS
           smr_code_preferred AMD_NATIONAL_STOCK_ITEMS.SMR_CODE%TYPE :=
                  Amd_Preferred_Pkg.GetPreferredValue(rec.smr_code_cleaned, rec.smr_code, rec.smr_code_defaulted) ;
      BEGIN
       debugMsg('InsertPartInfo ' || rec.part_no, pError_location => 750) ;
       InsertPartInfo(
           rec.part_no,
           rec.nomenclature,
           NVL(action_code,rec.action_code),
            rec.mfgr,
           rec.unit_of_issue, -- unit_issue
           smr_code_preferred,
           rec.nsn,
           Amd_Preferred_Pkg.getPreferredValue(rec.planner_code_cleaned, rec.planner_code),
           NULL , -- third_party_flag
           Amd_Preferred_Pkg.getPreferredValue(rec.mtbdr_cleaned, rec.mtbdr_computed, rec.mtbdr),
           getIndenture(smr_code_preferred),
           Amd_Preferred_Pkg.getPreferredValue(rec.unit_cost_cleaned, rec.unit_cost)) ;
    
       IF isPartSent(rec.part_no) THEN  -- part exists in amd_sent_to_a2a with any action_code
           debugMsg('InsertPartInfo ' || rec.part_no, pError_location => 760) ;
           insertTmpA2APartLeadTime(part_no => rec.part_no, 
                                   order_lead_time => rec.order_lead_time, 
                                order_lead_time_cleaned => rec.order_lead_time_cleaned, 
                                order_lead_time_defaulted => rec.order_lead_time_defaulted) ;
        
            insertTimeToRepair (part_no => rec.part_no, nsi_sid => rec.nsi_sid,
                               time_to_repair_off_base_cleand => rec.time_to_repair_off_base_cleand ) ;
                            
            insertUnitCost (part_no => rec.part_no, unit_cost => rec.unit_cost,
                           unit_cost_cleaned => rec.unit_cost_cleaned,
                           unit_cost_defaulted => rec.unit_cost_defaulted) ;
        END IF ;
    debugMsg('end processPart' || rec.part_no, pError_location => 770) ;
      END processPart ;
      
    function tmpA2APartInfoAddOk(part_no in amd_spare_parts.part_no%type) return boolean is
        action_code amd_spare_parts.action_code%type ;  
        cursor thePart is
                SELECT sp.mfgr,
                  sp.part_no,
                  sp.NOMENCLATURE,
                  sp.nsn,
                  sp.order_lead_time,
                  sp.order_lead_time_defaulted,
                  sp.unit_cost,
                  sp.unit_cost_defaulted,
                  sp.unit_of_issue,
                  nsi.unit_cost_cleaned,
                  nsi.order_lead_time_cleaned,
                  nsi.planner_code,
                  nsi.planner_code_cleaned,
                  nsi.mtbdr,
                  nsi.mtbdr_cleaned,
                  nsi.mtbdr_computed,
                  nsi.smr_code,
                  nsi.smr_code_cleaned,
                  nsi.smr_code_defaulted,
                  nsi.nsi_sid,
                  nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND,
                  nsi.last_update_dt,
                  sp.action_code
              FROM AMD_SPARE_PARTS sp,
                AMD_NATIONAL_STOCK_ITEMS nsi,
                amd_sent_to_a2a sent
              WHERE sp.nsn = nsi.nsn (+)
              and sp.part_no = sent.part_no (+)
              and sp.part_no = tmpA2APartInfoAddOk.part_no ;    
    begin
        debugmsg('tmpA2APartInfoAddOk: ' || part_no, pError_location => 780) ;
        for rec in thePart loop
            processPart(rec) ;
        end loop ;
        
        
        return true ;
        
    exception when standard.no_data_found then
        return false ;
                 
    end tmpA2APartInfoAddOk ;
    
    function tmpA2AOrderInfoLineAddOk(gold_order_number in amd_on_order.gold_order_number%type, 
        from_dt in amd_on_order.order_date%type := START_DT,
        to_dt in amd_on_order.order_date%type := sysdate) return boolean is
         result number := null ;
         onOrders onOrderCur ;
    begin
        OPEN onOrders FOR 
        SELECT 
          oo.PART_NO,  
          LOC_SID,
                         LINE,          
          ORDER_DATE,         
          ORDER_QTY,          
          GOLD_ORDER_NUMBER,  
          case oo.ACTION_CODE
                 when amd_defaults.getDELETE_ACTION then
                       oo.ACTION_CODE
               else  
                          sent.ACTION_CODE
          end action_code,        
          LAST_UPDATE_DT,     
          SCHED_RECEIPT_DATE
         FROM AMD_ON_ORDER OO, amd_sent_to_a2a sent 
         WHERE oo.part_no = sent.part_no
         and sent.SPO_PRIME_PART_NO is not null
                     and oo.GOLD_ORDER_NUMBER = tmpA2AOrderInfoLineAddOk.gold_order_number
                     and trunc(oo.ORDER_DATE) between trunc(from_dt) and trunc(to_dt)  
         ORDER BY gold_order_number, part_no, order_date ;
         
        processOnOrder(onOrders) ;
        return (result is not null) ;
    exception when standard.no_data_found then
        return false ;
    end tmpA2AOrderInfoLineAddOk ;  

    
    function tmpA2APartInfoAddYorN(part_no in amd_spare_parts.part_no%type) return varchar2 is
    begin
        if tmpA2APartInfoAddOk(part_no) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end tmpA2APartInfoAddYorN ;
    
    function tmpA2ALocPartOverrideAddOk(part_no in amd_location_part_override.part_no%type) return boolean is
        result number null ;
        --overrides amd_location_part_override_pkg.locPartOverrideCur ;
    begin
        /*
             OPEN overrides FOR
                  SELECT alpo.part_no,
                         spo_location AS site_location,
                        amd_location_part_override_pkg.TSL_OVERRIDE_TYPE AS override_type,
                        case
                            when sent.action_code = amd_defaults.getDELETE_ACTION or alpo.action_code = amd_defaults.getDELETE_ACTION then
                                 0
                            else
                                tsl_override_qty
                        end AS override_quantity,
                        amd_location_part_override_pkg.OVERRIDE_REASON AS override_reason,
                        tsl_override_user,
                        SYSDATE AS begin_date,
                        NULL AS end_date,
                        case sent.action_code
                         when amd_defaults.getDELETE_ACTION then
                               amd_defaults.getDELETE_ACTION -- The part is not longer valid
                         else
                              case alpo.action_code
                                   when amd_defaults.getDELETE_ACTION then
                                         amd_defaults.getUPDATE_ACTION -- the part is still valid, update the current value to zero
                                  else
                                        alpo.action_code
                             end
                        end AS action_code,
                        SYSDATE AS last_update_dt
                 FROM AMD_LOCATION_PART_OVERRIDE alpo, AMD_SPARE_NETWORKS asn, amd_sent_to_a2a sent
                 WHERE alpo.loc_sid = asn.loc_sid
                       AND alpo.part_no = sent.part_no
                       and sent.SPO_PRIME_PART_NO is not null
                       and sent.PART_NO = sent.SPO_PRIME_PART_NO 
                       AND alpo.part_no = tmpA2ALocPartOverrideAddOk.part_no
                union
                select distinct rsp.part_no,
                rsp_location,
                amd_location_part_override_pkg.TSL_OVERRIDE_TYPE as override_type,
                case 
                     when rsp.action_code = amd_defaults.getDELETE_ACTION or sent.action_code = amd_defaults.getDELETE_ACTION then
                           0
                     else
                          rsp_level
                end override_quantity,
                amd_location_part_override_pkg.OVERRIDE_REASON as override_reason,
                Amd_Location_Part_Override_Pkg.GetFirstLogonIdForPart(Amd_Utils.GetNsiSidFromPartNo(rsp.part_no)),
                sysdate as begin_date,
                null as end_date,
                case sent.action_code
                     when amd_defaults.getDELETE_ACTION then
                           amd_defaults.getDELETE_ACTION -- The part is not longer valid
                     else
                          case rsp.action_code
                             when amd_defaults.getDELETE_ACTION then
                                   amd_defaults.getUPDATE_ACTION -- the part is still valid, update the current value to zero
                             else
                                    rsp.action_code
                        end                    
                end AS action_code,
                sysdate as last_update_dt
                from amd_rsp_sum rsp, amd_sent_to_a2a sent, amd_spare_networks nwks
                where rsp.part_no = sent.part_no
                and sent.part_no = sent.spo_prime_part_no
                and sent.SPO_PRIME_PART_NO is not null
                and rsp.part_no in (select part_no from amd_test_parts)
                and substr(rsp_location,1,length(rsp_location) - 4) = nwks.mob
                and nwks.mob is not null 
                and rsp.part_no = tmpA2ALocPartOverrideAddOk.part_no ;
                
        amd_location_part_override_pkg.processLocPartOverride(overrides) ;
        
                                                    
        select 1 into result from dual
        where exists (select null 
                      from tmp_a2a_loc_part_override 
                      where part_no = tmpA2ALocPartOverrideAddOk.part_no) ;
        */
        return result is not null ;
    exception when standard.no_data_found then
        return false ; 
    end tmpA2ALocPartOverrideAddOk ;
 
     
     PROCEDURE processParts(parts IN partCur) IS
                rec partInfoRec ;
               cnt NUMBER := 0 ;
               ins_cnt number := 0 ;
               upd_cnt number := 0 ;
               del_cnt number := 0 ;
               theParts partTab ;
     BEGIN
          writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 790,
            pKey1 => 'processParts',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
          
          fetch parts bulk collect into theParts ;
          close parts ;

          if theParts.first is not null then          
              for indx in theParts.first .. theParts.last 
              LOOP
                  case theParts(indx).action_code
                         when amd_defaults.INSERT_ACTION then
                               ins_cnt := ins_cnt + 1 ;
                       when amd_defaults.UPDATE_ACTION then
                               upd_cnt := upd_cnt + 1 ;
                       when amd_defaults.DELETE_ACTION then
                               del_cnt := del_cnt + 1 ;
                  end case ;        
                  processPart(theParts(indx)) ;
                  cnt := cnt + 1 ;
              END LOOP ;
          end if ;              
          writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 800,
            pKey1 => 'processParts',
            pKey2 => 'cnt=' || TO_CHAR(cnt),
            pKey3 => 'del_cnt=' || to_char(del_cnt),
            pKey4 => 'ins_cnt=' || to_char(ins_cnt),
            pData => 'upd_cnt=' || to_char(upd_cnt),
            pComments => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
          COMMIT ;
          
     END processParts ;
     
     -- allow for collecting data by last_update_dt
     PROCEDURE initA2APartInfo(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE) IS
     
                preferred_smr_code  AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE ;
               rcm_ind                varchar2(1) ;
               indenture            varchar2(7);
               preferred_unit_cost number ;
               nsn_fsc                varchar2(4) ;
               nsn_niin            varchar2(9) ;
               cnt                   NUMBER := 0 ;
               parts               partCur ;
               
     BEGIN
          writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 810,
            pKey1 => 'initA2APartInfo',
            pKey2 => 'start_dt=' || TO_CHAR(start_dt,'MM/DD/YYYY'),
            pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
            pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
           mblnSendAllData := TRUE ;
            truncateA2Atables ;
          OPEN parts FOR
            SELECT sp.mfgr,
                  sp.part_no,
                  sp.NOMENCLATURE,
                  sp.nsn,
                  sp.order_lead_time,
                  sp.order_lead_time_defaulted,
                  sp.unit_cost,
                  sp.unit_cost_defaulted,
                  sp.unit_of_issue,
                  nsi.unit_cost_cleaned,
                  nsi.order_lead_time_cleaned,
                  nsi.planner_code,
                  nsi.planner_code_cleaned,
                  nsi.mtbdr,
                  nsi.mtbdr_cleaned,
                  nsi.mtbdr_computed,
                  nsi.smr_code,
                  nsi.smr_code_cleaned,
                  nsi.smr_code_defaulted,
                  nsi.nsi_sid,
                  nsi.TIME_TO_REPAIR_OFF_BASE_CLEAND,
                  CASE 
                  WHEN TRUNC(sp.last_update_dt) >= TRUNC(nsi.last_update_dt) THEN 
                         sp.last_update_dt
                  ELSE
                      nsi.LAST_UPDATE_DT
                  END AS last_update_dt,
                  CASE 
                     when sent.action_code is not null then
                               sent.action_code
                     WHEN sp.action_code = nsi.action_code THEN 
                         sp.action_code
                     ELSE
                        CASE 
                            WHEN sp.action_code = amd_defaults.getDELETE_ACTION OR nsi.action_code = amd_defaults.getDELETE_ACTION then
                                 amd_defaults.getDELETE_ACTION
                            WHEN sp.action_code = amd_defaults.getUPDATE_ACTION OR nsi.action_code = amd_defaults.getUPDATE_ACTION then
                                 amd_defaults.getUPDATE_ACTION                        
                            ELSE
                                amd_defaults.getINSERT_ACTION
                        END
                END AS action_code
              FROM AMD_SPARE_PARTS sp,
                AMD_NATIONAL_STOCK_ITEMS nsi,
                amd_sent_to_a2a sent
              WHERE sp.nsn = nsi.nsn (+)
                   and sp.part_no = sent.part_no (+)  
                 AND (TRUNC(sp.last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
                      OR TRUNC(nsi.last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) ) ;
                       
          processParts(parts) ;
          
          writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 820,
            pKey1 => 'initA2APartInfo',
            pKey2 => 'start_dt=' || TO_CHAR(start_dt,'MM/DD/YYYY'),
            pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
            pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;       
     END initA2APartInfo ;
     
    
     FUNCTION initA2APartInfo(useTestParts IN BOOLEAN := FALSE) RETURN NUMBER IS
         result NUMBER := SUCCESS ;
          parts partCur ;
    
     BEGIN
      writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 830,
            pKey1 => 'initA2APartInfo',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
      mblnSendAllData := TRUE ;
      truncateA2Atables ;
      IF useTestParts THEN
           parts := getTestData ;
      ELSE
         parts := getPartInfo ;
      END IF ;
      processParts(parts) ;
    
      writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 840,
            pKey1 => 'initA2APartInfo',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      COMMIT ;       
      RETURN result ;
    
     END initA2APartInfo ;
     
     PROCEDURE deletePartInfo(partInfo IN part2DeleteCur) IS
                rec part2Delete ;
               cnt NUMBER := 0 ;           
               parts2Delete part2DeleteTab ; 
               
                PROCEDURE processPart(rec IN part2Delete) IS
                            result NUMBER ;
               BEGIN
                          result := repairables_Pkg.DeletePartInfo(rec.part_no, rec.nomenclature) ;
               END processPart ;
     BEGIN
            writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 850,
            pKey1 => 'deletePartInfo',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
           fetch partInfo bulk collect into parts2Delete ;
           close partInfo ;
           
           if parts2Delete is null then
               for indx in parts2Delete.first .. parts2Delete.last
               LOOP
                  processPart(parts2Delete(indx)) ;
                  cnt := cnt + 1 ;
              END LOOP ;
            end if ;              
            writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 860,
            pKey1 => 'deletePartInfo',
            pKey2 => 'cnt=' || TO_CHAR(cnt),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;
     END deletePartInfo ;
     
     PROCEDURE deletePartInfo(useTestParts IN BOOLEAN := FALSE) IS
         parts part2DeleteCur ;
        
        procedure getTestData is
        begin
          writeMsg(pTableName => 'amd_spare_parts', pError_location => 870,
          pKey1 => 'getTestData' ) ;
          commit ;
            OPEN parts FOR 
               SELECT part_no, nomenclature FROM AMD_SPARE_PARTS
               WHERE part_no IN (SELECT part_no FROM AMD_TEST_PARTS) 
               AND action_code != Amd_Defaults.DELETE_ACTION ;
        end getTestData ;
        
        procedure getAllData is
        begin
          writeMsg(pTableName => 'amd_spare_parts', pError_location => 880,
          pKey1 => 'getAllData' ) ;
          commit ;
          OPEN parts FOR     
               SELECT part_no, nomenclature FROM AMD_SPARE_PARTS WHERE action_code != Amd_Defaults.DELETE_ACTION ;
        end getAllData ;
            
     BEGIN
      writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 890,
            pKey1 => 'deletePartInfo',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
      truncateA2Atables ;
      IF useTestParts THEN
           getTestData ;
      ELSE
           getAllData ;
      END IF ;
      deletePartInfo(parts) ;
      writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 900,
            pKey1 => 'deletePartInfo',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
      COMMIT ;       
     END deletePartInfo ;
    
    
    
     FUNCTION isNsl(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN IS
        nsn AMD_SPARE_PARTS.nsn%TYPE ;
     BEGIN
    
       <<getNsn>>
       BEGIN
        SELECT nsn INTO isNsl.nsn
        FROM AMD_SPARE_PARTS
        WHERE partNo = part_no ;
       EXCEPTION WHEN OTHERS THEN
            ErrorMsg(pSqlfunction => 'select',
             pTableName => 'amd_spare_parts',
             pError_location => 920,
             pKey_1 => partNo) ;
          RAISE ;
       END getNsn ;
       IF UPPER(SUBSTR(nsn,1,3)) = 'NSL' AND debug THEN
             debugMsg(partNo || ' is an NSL part.', 90) ;
       END IF;
       RETURN UPPER(SUBSTR(nsn,1,3)) = 'NSL' ;
     END isNsl ;
     
     FUNCTION isNslYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 IS
     BEGIN
           IF isNsl(partNo) THEN
            RETURN 'Y' ;
          ELSE
            RETURN 'N' ;
          END IF ;
      END isNslYorN ;
    
     function isPartSent(part_no in amd_sent_to_a2a.part_no%type) return boolean is
        thePartNo amd_sent_to_a2a.part_no%type ;
     begin
        select part_no into thePartNo from amd_sent_to_a2a where part_no = isPartSent.part_no ;
        return true ;
     exception when standard.no_data_found then
        return false ;
     end isPartSent ;

     function isPartSentYorN(part_no in amd_sent_to_a2a.part_no%type) return varchar2 is
     begin
        if isPartSent(part_no) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
     end isPartSentYorN ;

     FUNCTION wasPartSent(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN BOOLEAN IS
          part_no AMD_SENT_TO_A2A.PART_NO%TYPE ;
     BEGIN
    
       IF mblnSendAllData THEN
           SELECT part_no INTO part_no FROM AMD_SENT_TO_A2A WHERE part_no = partNo
               AND spo_prime_part_no IS NOT NULL ;
       ELSE
           SELECT part_no INTO part_no FROM AMD_SENT_TO_A2A WHERE part_no = partNo
               AND (action_code = Amd_Defaults.INSERT_ACTION OR action_code = Amd_Defaults.UPDATE_ACTION)
               AND spo_prime_part_no IS NOT NULL ;
       END IF ;
       
       RETURN TRUE ;
    
     EXCEPTION WHEN standard.NO_DATA_FOUND THEN
         RETURN FALSE ;
     END wasPartSent ;
     
      -- added 4/12/2007 by dse
      function isPartActive(part_no in amd_sent_to_a2a.part_no%type) return boolean is
        action_code amd_sent_to_a2a.action_code%type ;
      begin
        select action_code into isPartActive.action_code 
        from amd_sent_to_a2a
        where part_no = isPartActive.part_no ;
        return (action_code <> amd_defaults.DELETE_ACTION) ;
      exception when standard.no_data_found then
        return false ; 
      end isPartActive ;
      -- added 4/12/2007 by dse
      function isPartActiveYorN(part_no in amd_sent_to_a2a.part_no%type) return varchar2 is
      begin
        if isPartActive(part_no) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
      end isPartActiveYorN ;
      
      -- added 4/12/2007 by dse
      function isSpoPrimePartActive(spo_prime_part_no in amd_sent_to_a2a.spo_prime_part_no%type) return boolean is
        action_code amd_sent_to_a2a.action_code%type ;
      begin
        select action_code into isSpoPrimePartActive.action_code
        from amd_sent_to_a2a
        where spo_prime_part_no = isSpoPrimePartActive.spo_prime_part_no
        and part_no = spo_prime_part_no
        and action_code <> amd_defaults.DELETE_ACTION ;
        
        return true ;
        
      exception when standard.no_data_found then
        return false ;
      end isSpoPrimePartActive ;
      -- added 4/12/2007 by dse
      function isSpoPrimePartActiveYorN(spo_prime_part_no in amd_sent_to_a2a.spo_prime_part_no%type) return varchar2 is
      begin
        if isSpoPrimePartActive(spo_prime_part_no) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
      end isSpoPrimePartActiveYorN ;
    
      -- added 4/12/2007 by dse
      function getSentToA2AActionCode(part_no in amd_sent_to_a2a.part_no%type) return varchar2 is
        action_code amd_sent_to_a2a.action_code%type ;
      begin
        select action_code into getSentToA2AActionCode.action_code
        from amd_sent_to_a2a
        where part_no = getSentToA2AActionCode.part_no ;
        return action_code ;
      exception when standard.no_data_found then
        return amd_defaults.DELETE_ACTION ; -- part and associated data should be deleted from SPO  
      end getSentToA2AActionCode ;

      
     FUNCTION isPlannerCodeAssigned2UserId(plannerCode IN VARCHAR2) RETURN BOOLEAN IS
               result NUMBER := 0 ;
     BEGIN
           <<isPlannerAssigned>>
           BEGIN
                  SELECT 1 INTO result FROM dual WHERE EXISTS  (SELECT planner_code FROM AMD_PLANNER_LOGONS WHERE planner_code = plannerCode) ;
          EXCEPTION 
              WHEN standard.NO_DATA_FOUND THEN
                 NULL ;
              WHEN OTHERS THEN
                ErrorMsg(pSqlfunction => 'select',
                 pTableName => 'amd_planner_logons',
                 pError_location => 930,
                 pKey_1 => plannerCode) ;
               RAISE ;
          END isPlannerAssigned ;
          
         RETURN result = 1;
         
     END isPlannerCodeAssigned2UserId ;
    
     
    
     FUNCTION isPartValid (partNo IN AMD_SPARE_PARTS.part_no%TYPE, showReason in boolean := false) RETURN BOOLEAN IS
        result BOOLEAN := FALSE ;
        nsn amd_national_stock_items.nsn%type ;
        smrCode AMD_NATIONAL_STOCK_ITEMS.smr_code%TYPE ;
        smrCodeCleaned AMD_NATIONAL_STOCK_ITEMS.smr_code_cleaned%TYPE ;
        mtbdr   AMD_NATIONAL_STOCK_ITEMS.mtbdr%TYPE ;
        mtbdr_cleaned AMD_NATIONAL_STOCK_ITEMS.mtbdr_cleaned%TYPE ;
        mtbdr_computed AMD_NATIONAL_STOCK_ITEMS.mtbdr_computed%TYPE ;        
        plannerCode AMD_NATIONAL_STOCK_ITEMS.planner_code%TYPE ;
        part_no AMD_SPARE_PARTS.part_no%TYPE ;
        plannerCodeCleaned AMD_NATIONAL_STOCK_ITEMS.planner_code_cleaned%TYPE ;
     BEGIN
       <<doesPartExist>>
       BEGIN
            SELECT part_no INTO isPartValid.part_no FROM AMD_SPARE_PARTS 
            WHERE partNo = part_no AND action_code != Amd_Defaults.DELETE_ACTION ;
       EXCEPTION
               WHEN standard.NO_DATA_FOUND THEN
                 IF debug THEN
                     debugMsg(partNo || ' does not exist in amd_spare_parts or has been logically deleted.', pError_location => 940) ; 
                 END IF ;
                 RETURN FALSE ;
       END doesPartExist ;
       
       if amd_utils.isPartConsumable(partNo) then
            return consumables_pkg.isPartValid(partNo) ;
       end if ;
                   
       <<getPrimePartData>>
       BEGIN
        SELECT nsn, smr_code, smr_code_cleaned, mtbdr, mtbdr_cleaned, mtbdr_computed, planner_code, planner_code_cleaned 
        INTO nsn, smrCode, smrCodeCleaned, mtbdr, mtbdr_cleaned, mtbdr_computed, plannerCode, plannerCodeCleaned
        FROM AMD_NATIONAL_STOCK_ITEMS items, AMD_NSI_PARTS parts
        WHERE isPartValid.partNo = parts.part_no
        AND parts.UNASSIGNMENT_DATE IS NULL
        AND parts.nsi_sid = items.nsi_sid ;
       EXCEPTION
         WHEN standard.NO_DATA_FOUND THEN
           IF debug THEN
                 debugMsg(partNo || ' is NOT valid amd_nsi_parts.UNASSIGNMENT_DATE is not be NULL', pError_location => 950) ;
           END IF ;
           RETURN FALSE ;
         WHEN OTHERS THEN
             ErrorMsg(pSqlfunction => 'select',
              pTableName => 'items / parts',
              pError_location => 960,
              pKey_1 => isPartValid.partNo) ;
             RAISE ;
       END getPrimePartData ;
       RETURN isPartValid(partNo => partNo, preferredSmrCode => Amd_Preferred_Pkg.getPreferredValue(smrCodeCleaned,smrCode), 
        preferredMtbdr => Amd_Preferred_Pkg.getPreferredValue(mtbdr_cleaned,mtbdr_computed, mtbdr), 
        preferredPlannerCode => Amd_Preferred_Pkg.GetPreferredValue(plannerCodeCleaned,plannerCode, amd_defaults.getPlannerCode(nsn)), showReason => showReason) ;
        
     END isPartValid ;
    
     FUNCTION createPartInfo(part_no IN VARCHAR2,
            action_code IN VARCHAR2 := Amd_Defaults.UPDATE_ACTION) RETURN NUMBER IS
     BEGIN
        debugMsg('creeatePartInfo: ' || part_no || ' ' || action_code,
            pError_location => 970) ;
        if tmpA2APartInfoAddOK(part_no) then
            return SUCCESS ;
        end if ;
        return FAILURE ; 
     END createPartInfo  ;
    
     
     
     FUNCTION InsertPartInfo(
           mfgr IN VARCHAR2,
           part_no IN VARCHAR2,
           unit_issue IN VARCHAR2,
           nomenclature IN VARCHAR2,
           smr_code IN VARCHAR2,
           nsn IN VARCHAR2,
           planner_code IN VARCHAR2,
           third_party_flag IN VARCHAR2,
           mtbdr      IN NUMBER,
           indenture IN VARCHAR2,
           price IN NUMBER) RETURN NUMBER IS
    
         result NUMBER ;
         rcm_ind varchar2(1);
         plannerCode amd_national_stock_items.planner_code%type := getAssignedPlannerCode(part_no) ;
         
    
     BEGIN
       mArgs := 'InsertPartInfo(' || mfgr || ', ' || part_no || ', ' || unit_issue || ', ' || nomenclature
           || ', ' || smr_code || ', ' || nsn || ', ' || plannerCode || ', ' || third_party_flag
          || ', ' || mtbdr || ', ' || indenture || ')' ;
       if amd_utils.isPartConsumable(part_no) then
             consumables_pkg.insertPartInfo(amd_defaults.INSERT_ACTION, part_no, nomenclature,
                mfgr,  unit_issue, smr_code, nsn, plannerCode, THIRD_PARTY_FLAG, mtbdr, price) ;
            return SUCCESS ;
       end if ;
       
           
      
      return SUCCESS ;
      
     exception
         when others then
           errorMsg(pSqlfunction => 'insert', pTableName => 'tmp_a2a_part_info', pError_location => 1000,
              pKey_1 => part_no, pKey_2 => mfgr, pKey_3 => nomenclature, pKey_4 => nsn) ;
              
           raise ;
    
     end insertPartInfo ;
    
    
     FUNCTION UpdatePartInfo(
           mfgr IN VARCHAR2,
           part_no IN VARCHAR2,
           unit_issue IN VARCHAR2,
           nomenclature IN VARCHAR2,
           smr_code IN VARCHAR2,
           nsn IN VARCHAR2,
           planner_code IN VARCHAR2,
           third_party_flag IN VARCHAR2,
           mtbdr      IN NUMBER,
           indenture IN VARCHAR2,
           price IN NUMBER) RETURN NUMBER IS
      
      result NUMBER ;
      rcm_ind varchar2(1) ;
      lineNo number := 0 ;
      
      plannerCode amd_national_stock_items.planner_code%type := getAssignedPlannerCode(part_no) ;
      
      
     begin
        mArgs := 'UpdatePartInfo(' || mfgr || ', ' || part_no || ', ' || unit_issue || ', '
        || nomenclature || ', ' || smr_code || ', ' || nsn || ', ' || plannerCode
        || ', ' || third_party_flag || ', ' || mtbdr || ', ' || indenture ||')' ;
        
        debugMsg(mArgs, pError_location => 1010) ;
        
        if amd_utils.ispartConsumable(part_no) then
                lineNo := 1 ;
            debugMsg('updatePartInfo: consumable', pError_location => 1020) ;
            consumables_pkg.insertPartInfo(amd_defaults.UPDATE_ACTION, part_no, nomenclature,
                mfgr, unit_issue, smr_code, nsn, plannerCode, THIRD_PARTY_FLAG, mtbdr, price) ;
                
            return SUCCESS ;
            
        end if ;
     
   
           
      return SUCCESS ;
      
     exception
         when others then
            errorMsg(pSqlfunction => 'update', pTableName => 'tmp_a2a_part_info', pError_location => 1030, 
                pKey_1 => part_no, pKey_2 => mfgr,  pKey_3 => nomenclature, pKey_4 => nsn) ;
                
            raise ;
                
     end updatePartInfo;
    
     function deletePartInfo(
           part_no IN VARCHAR2, nomenclature IN VARCHAR2) RETURN NUMBER IS
      result NUMBER ;
    
     BEGIN
       if amd_utils.isPartConsumable(part_no) then
            consumables_pkg.insertPartInfo(amd_defaults.DELETE_ACTION, part_no, nomenclature,
                mfgr => null,  unit_issue => null, smr_code => null, nsn => null, planner_code => null, 
                THIRD_PARTY_FLAG => null, mtbdr => null, price => null) ;
            return SUCCESS ;
       end if ;
       writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 1050,
        pKey1 => 'deletePartInfo',
        pKey2 => part_no,
        pKey3 => nomenclature,
        pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
       -- mblnSendAllData allows parts to be deleted even if they have been deleted previously.  This
       -- allows the system to send all types of A2A transactions when the initPartInfoA2A is executed
       
       writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 1060,
        pKey1 => 'deletePartInfo',
        pKey2 => part_no,
        pKey3 => nomenclature,
        pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
       RETURN SUCCESS ;
     EXCEPTION
      WHEN standard.DUP_VAL_ON_INDEX THEN
        RETURN SUCCESS ;
    
      WHEN OTHERS THEN
       ErrorMsg(pSqlfunction => 'delete',
          pTableName => 'tmp_a2a_part_info',
          pError_location => 1070,
          pKey_1 => part_no) ;
       RAISE ;
    
     END DeletePartInfo ;
    
    
         
     function insertPartLeadTime(
           part_no in varchar2,
           lead_time_type in varchar2,
           lead_time in number) return number is
           
          result number ;
          
          
     BEGIN
       debugMsg('insertPartLeadTime(' || part_no || ', ' || lead_time_type || ', ' || lead_time || ')',
        pError_location => 1120) ;
       
             
       return SUCCESS ;    
    
     End insertPartLeadTime ;
    
     function updatePartLeadTime(
            part_no in varchar2,
           lead_time_type in varchar2,
           lead_time in number) return number is
           
     begin
       debugMsg('UpdatePartLeadTime(' || part_no || ', ' || lead_time_type || ', ' || lead_time || ')' ,
          pError_location => 1130) ; 
            
       return SUCCESS ;
    
     end updatePartLeadTime ;
    
    
     FUNCTION deletePartLeadTime(
            part_no IN VARCHAR2) RETURN NUMBER IS
    
       rc NUMBER ;
       cage_code varchar2(5) := Amd_Utils.getCageCode(part_no) ;
    
    
     BEGIN
       debugMsg('DeletePartLeadTime(' || part_no || ')' ,
        pError_location => 1140) ;
        
       return SUCCESS ;
    
    
     end deletePartLeadTime ;
    
    
    
     FUNCTION InsertPartPricing(
            part_no IN VARCHAR2,
           price_type IN VARCHAR2,
           unit_cost IN NUMBER) RETURN NUMBER IS
      result NUMBER ;
      price NUMBER := unit_cost ;
     BEGIN
       debugMsg('InsertPartPricing(' || part_no || ', ' || price_type || ', ' || unit_cost || ')' ,
     pError_location => 1155) ;
       IF isPartValid(part_no) and wasPartSent(part_no) THEN
        IF price IS NULL THEN
         price := 4999.99 ;
        END IF ;
       END IF ;
    
       RETURN SUCCESS ;
    
     EXCEPTION
         WHEN standard.DUP_VAL_ON_INDEX THEN
        RETURN SUCCESS ;
    
      WHEN OTHERS THEN
       ErrorMsg(pSqlfunction => 'insert',
          pTableName => 'tmp_a2a_part_pricing',
          pError_location => 1160,
          pKey_1 => part_no,
          pKey_2 => price_type,
          pKey_3 => unit_cost,
          pKey_4 => TO_CHAR(SYSDATE, 'YYYY') );
       RAISE ;
    
     END InsertPartPricing ;
    
    
     FUNCTION UpdatePartPricing(
            part_no IN VARCHAR2,
           price_type IN VARCHAR2,
           unit_cost IN NUMBER) RETURN NUMBER IS
      result NUMBER ;
     BEGIN
       debugMsg('UpdatePartPricing(' || part_no || ', ' || price_type || ', ' || unit_cost || ')' ,
     pError_location => 1165) ;
       
       RETURN SUCCESS ;
    
    
    
     EXCEPTION
         WHEN standard.DUP_VAL_ON_INDEX THEN
            RETURN SUCCESS ;
    
      WHEN OTHERS THEN
       ErrorMsg(pSqlfunction => 'update',
          pTableName => 'tmp_a2a_part_pricing',
          pError_location => 1170,
          pKey_1 => part_no,
          pKey_2 => price_type,
          pKey_3 => unit_cost,
          pKey_4 => TO_CHAR(SYSDATE, 'YYYY') );
       RAISE ;
    
     END UpdatePartPricing ;
    
    
     FUNCTION DeletePartPricing(
            part_no IN VARCHAR2) RETURN NUMBER IS
      result NUMBER ;
    
    
     BEGIN
       debugMsg('DeletePartPricing(' || part_no || ')' ,
     pError_location => 1185) ;
    
       RETURN SUCCESS ;
    
     EXCEPTION
         WHEN standard.DUP_VAL_ON_INDEX THEN
        RETURN SUCCESS ;
    
      WHEN OTHERS THEN
       ErrorMsg(pSqlfunction => 'update',
          pTableName => 'tmp_a2a_part_pricing',
          pError_location => 1190,
          pKey_1 => part_no) ;
       RAISE ;
    
     END DeletePartPricing ;
    
     PROCEDURE updateA2AlocPartLeadTime(
            part_no IN VARCHAR2,
           location_name IN VARCHAR2,
           lead_time_type IN VARCHAR2,
           time_to_repair IN NUMBER,
           action_code IN VARCHAR2) IS
          result NUMBER ;
     BEGIN
       debugMsg('updateA2AlocPartLeadTime: ' || part_no,
    pError_location => 1195) ;
    
     EXCEPTION WHEN OTHERS THEN
       ErrorMsg(pSqlfunction => 'insert',
          pTableName => 'tmp_a2a_loc_part_lead_time',
          pError_location => 1200,
          pKey_1 => part_no,
          pKey_2 => lead_time_type,
          pKey_3 => time_to_repair );
      RAISE ;
     END updateA2AlocPartLeadTime ;
    
     FUNCTION InsertLocPartLeadTime(
            part_no IN VARCHAR2,
           loc_sid IN NUMBER,
           location_name IN VARCHAR2,
           lead_time_type IN VARCHAR2,
           time_to_repair IN NUMBER) RETURN NUMBER IS
      result NUMBER ;
     BEGIN
          debugMsg('InsertLocPartLeadTime(' || part_no || ', ' || loc_sid || ', ' || location_name || ', ' || lead_time_type || ', ' || time_to_repair || ')' ,
        pError_location => 1205) ;
       RETURN SUCCESS ;
    
     EXCEPTION
         WHEN standard.DUP_VAL_ON_INDEX THEN
        updateA2AlocPartLeadTime(part_no,location_name,lead_time_type,time_to_repair,Amd_Defaults.INSERT_ACTION) ;
        RETURN SUCCESS ;
    
      WHEN OTHERS THEN
       ErrorMsg(pSqlfunction => 'insert',
          pTableName => 'tmp_a2a_loc_part_lead_time',
          pError_location => 1210,
          pKey_1 => part_no,
          pKey_2 => loc_sid,
          pKey_3 => lead_time_type,
          pKey_4 => time_to_repair );
       RAISE ;
     END InsertLocPartLeadTime ;
    
    
     FUNCTION UpdateLocPartLeadTime(
            part_no IN VARCHAR2,
           loc_sid IN NUMBER,
           location_name IN VARCHAR2,
           lead_time_type IN VARCHAR2,
           time_to_repair IN NUMBER) RETURN NUMBER IS
      result NUMBER ;
     BEGIN
          debugMsg('UpdateLocPartLeadTime(' || part_no || ', ' || loc_sid || ', ' || location_name || ', ' || lead_time_type || ', ' || time_to_repair || ')' ,
        pError_location => 1215) ;
       RETURN SUCCESS ;
    
     EXCEPTION
         WHEN standard.DUP_VAL_ON_INDEX THEN
        updateA2AlocPartLeadTime(part_no,location_name,lead_time_type,time_to_repair,Amd_Defaults.UPDATE_ACTION) ;
        RETURN SUCCESS ;
    
      WHEN OTHERS THEN
       ErrorMsg(pSqlfunction => 'update',
          pTableName => 'tmp_a2a_loc_part_lead_time',
          pError_location => 1220,
          pKey_1 => part_no,
          pKey_2 => loc_sid,
          pKey_3 => lead_time_type,
          pKey_4 => time_to_repair );
    
       RAISE ;
    
     END UpdateLocPartLeadTime ;
    
    
     FUNCTION DeleteLocPartLeadTime(
            part_no IN VARCHAR2,
           loc_sid IN NUMBER,
           location_name IN NUMBER) RETURN NUMBER IS
      result NUMBER ;
     BEGIN
          debugMsg('DeleteLocPartLeadTime(' || part_no || ', ' || loc_sid || ', ' || location_name || ')' ,
        pError_location => 1235) ;
       RETURN SUCCESS ;
    
     EXCEPTION WHEN OTHERS THEN
         ErrorMsg(pSqlfunction => 'delete',
         pTableName => 'tmp_a2a_loc_part_lead_time',
         pError_location => 1240,
         pKey_1 => part_no,
         pKey_2 => loc_sid,
         pKey_3 => location_name );
    
      RAISE ;
    
     END DeleteLocPartLeadTime ;
    
     PROCEDURE initA2ASpoUsers IS
                CURSOR allUsers IS
               SELECT * FROM AMD_USERS ;
     BEGIN
            Mta_Truncate_Table('tmp_a2a_spo_users','reuse storage');
           FOR rec IN allUsers LOOP
              null ;
          END LOOP ;
     END initA2ASpoUsers ;
     
    
     
    
     PROCEDURE insertInvInfo(part_no IN amd_spare_parts.part_no%TYPE,
        spo_location IN varchar2 ,
        qty_on_hand IN number,
        action_code IN amd_spare_parts.action_code%TYPE)  IS
        

     BEGIN
        if insertInvInfo.action_code = amd_defaults.INSERT_ACTION
        or insertInvInfo.action_code = amd_defaults.UPDATE_ACTION then
              
            IF wasPartSent(insertInvInfo.part_no) -- does the part exist in amd_sent_to_a2a with an action_code <> DELETE_ACTION
            AND spo_location IS NOT NULL THEN                         
                insertCnt := insertCnt + 1 ;
            else
                rejectCnt := rejectCnt + 1 ;                                                                       
            END IF ;
        else
            if isPartSent(insertInvInfo.part_no) then -- does the part exist in amd_sent_to_a2a with any action_code
                      
                deleteCnt := deleteCnt + 1 ;
            else
                rejectCnt := rejectCnt + 1 ;                
                         
            end if ;
        end if ;
        
     END insertInvInfo ;
    
    
    PROCEDURE insertRepairInvInfo(part_no IN amd_spare_parts.part_no%TYPE,
        site_location IN varchar2,
        inv_qty IN number,
        action_code IN amd_spare_parts.action_code%TYPE)  IS
        
        
    
     BEGIN
        if action_code = amd_defaults.INSERT_ACTION 
        or action_code = amd_defaults.UPDATE_ACTION then
        
            IF wasPartSent(insertRepairInvInfo.part_no) -- must be in amd_sent_to_a2a with action_code <> D
            AND site_location IS NOT NULL THEN
                insertCnt := insertCnt + 1 ;                
            else
                rejectCnt := rejectCnt + 1 ;
                if debug then
                    begin
                        dbms_output.put_line('part ' || part_no 
                            || ' not inserted - wasPartSent=' 
                            || wasPartSentYorN(part_no) 
                            || ' site_location=' || nvl(site_location,'null')
                            || ' action_code=' || action_code) ;
                    exception when others then
                        debug := false ;                        
                    end ;                        
                end if ;                           
            END IF ;
            
        else
            if isPartSent(insertRepairInvInfo.part_no)
            and site_location is not null then -- must be in amd_sent_to_a2a - ignores action_code
                deleteCnt := deleteCnt + 1 ;
            else
                rejectCnt := rejectCnt + 1 ;
                if debug then
                    begin
                        dbms_output.put_line('part ' || part_no 
                            || ' not inserted - isPartSent=' 
                            || isPartSentYorN(part_no) 
                            || ' site_location=' || nvl(site_location,'null')
                            || ' action_code=' || action_code) ;
                    exception when others then
                        debug := false ;                        
                    end ;                        
                end if ;                                                  
            end if ;
        end if ;    
    
     END insertRepairInvInfo ;
     
    
     FUNCTION getNsiSid(part_no IN VARCHAR2) RETURN VARCHAR2 IS
        nsisid NUMBER ;
        result NUMBER ;
     BEGIN
       SELECT nsi.nsi_sid INTO nsisid
       FROM AMD_NATIONAL_STOCK_ITEMS nsi,
       AMD_SPARE_PARTS asp
       WHERE asp.part_no = getnsisid.part_no
       AND asp.nsn = nsi.nsn ;
    
       RETURN nsisid ;
    
     EXCEPTION WHEN OTHERS THEN
        errormsg( psqlfunction => 'select', ptablename => 'amd_national_stock_items', pError_location => 1340,
          pkey_1 => part_no) ;
        RAISE ;
    
     END getNsiSid ;
    
        FUNCTION getTimeToRepair(loc_sid  IN AMD_IN_REPAIR.loc_sid%TYPE,
                 part_no IN VARCHAR2)
    
        RETURN AMD_PART_LOCS.time_to_repair%TYPE IS
    
        result NUMBER ;
    
        time_to_repair AMD_PART_LOCS.time_to_repair%TYPE ;
        time_to_repair_defaulted AMD_PART_LOCS.time_to_repair_defaulted%TYPE ;
    
        no_time_to_repair    EXCEPTION ;
    
        nsisid NUMBER := getnsisid(part_no) ;
    
     BEGIN
      <<execSelectTimeToRepair>>
      BEGIN
       SELECT time_to_repair, time_to_repair_defaulted
       INTO time_to_repair, time_to_repair_defaulted
       FROM AMD_PART_LOCS
       WHERE nsi_sid = nsisid
       AND loc_sid = gettimetorepair.loc_sid ;
    
       IF time_to_repair IS NOT NULL THEN
        NULL ; -- do nothing use time_to_repair
       ELSIF time_to_repair_defaulted IS NOT NULL THEN
           time_to_repair := time_to_repair_defaulted ;
       ELSE
        time_to_repair := Amd_Defaults.time_to_repair_onbase ;
       END IF ;
    
      EXCEPTION
       WHEN NO_DATA_FOUND THEN
         time_to_repair := Amd_Defaults.time_to_repair_onbase ;
       WHEN OTHERS THEN
          errormsg( psqlfunction => 'select', ptablename => 'amd_part_locs', pError_location => 1350,
            pkey_1 => part_no, pkey_2 => loc_sid) ;
        RAISE ;
    
      END execSelectTimeToRepair ;
    
      RETURN time_to_repair ;
    
     END getTimeToRepair ;
     
     procedure setDebugRepairInfoThreshold(value in number) is
     begin
        debugRepairInfoThreshold := value ;
     end setDebugRepairInfoThreshold ;
    
     PROCEDURE insertRepairInfo(part_no IN amd_spare_parts.part_no%TYPE,
        loc_sid IN NUMBER,
        doc_no IN varchar2, 
        repair_date IN date,
        status IN varchar2,
        quantity IN number /* repair_qty */,
        expected_completion_date  IN date,
        action_code IN amd_spare_parts.action_code%TYPE)  IS
    
       site_location varchar2(20)  := Amd_Utils.getSpoLocation(loc_sid) ;
    
       /* Not needed in tmp_a2a_repair_info */
     -- expectedCompletionDate TMP_A2A_REPAIR_INFO.expected_completion_date%TYPE
           --  := repair_date + gettimetorepair(loc_sid,part_no) ;
    
      
    
      BEGIN
       insertCnt := insertCnt + 1 ;
       
       if debug and mod(insertCnt,debugRepairInfoThreshold) = 0 then
            dbms_output.put_line('2. insertRepairInfo ' || part_no || ' ' || action_code) ;
       end if ;
                   
       if insertRepairInfo.action_code = amd_defaults.INSERT_ACTION 
       or insertRepairInfo.action_code = amd_defaults.UPDATE_ACTION then       
           insertAddUpdRepairInfoCnt := insertAddUpdRepairInfoCnt + 1 ;
            if debug  then
                dbms_output.put_line('1.5. part_no=' || part_no || ' loc_sid=' || loc_sid || ' action_code = ' || action_code) ;
            end if ;                
           -- added isPartValid test DSE 11/30/05
     else
          deleteCnt := deleteCnt + 1 ;
          if debug and mod(deleteCnt,debugDeleteThreshold) = 0 then
            dbms_output.put_line('3. site_location = ' || site_location || ' loc_sid = ' || loc_sid) ;          
          end if ;
     end if ;
     END insertRepairInfo ;
    
     FUNCTION getDueDate(part_no in AMD_ON_ORDER.PART_NO%TYPE, order_date in AMD_ON_ORDER.ORDER_DATE%TYPE)  RETURN DATE IS
     
               order_lead_time AMD_SPARE_PARTS.ORDER_LEAD_TIME%TYPE ;
              order_lead_time_defaulted AMD_SPARE_PARTS.ORDER_LEAD_TIME_DEFAULTED%TYPE ;
              order_lead_time_cleaned AMD_NATIONAL_STOCK_ITEMS.order_lead_time_cleaned%TYPE ;
     BEGIN
          <<getOrderLeadTime>>
           BEGIN
                  SELECT order_lead_time, order_lead_time_defaulted INTO order_lead_time, order_lead_time_defaulted FROM AMD_SPARE_PARTS WHERE part_no = getDueDate.part_no ;
          EXCEPTION WHEN standard.NO_DATA_FOUND THEN
                 order_lead_time := NULL ;
          END getOrderLeadTime ;
          
          <<getOrderLeadTimeCleaned>>
          BEGIN
                 SELECT order_lead_time_cleaned INTO order_lead_time_cleaned FROM AMD_NATIONAL_STOCK_ITEMS items, AMD_SPARE_PARTS parts WHERE parts.part_no = getDueDate.part_no AND parts.nsn = items.nsn ;
          EXCEPTION WHEN standard.NO_DATA_FOUND THEN
                 order_lead_time_cleaned := NULL ;       
          END getOrderLeadTimeCleaned ;
          
          RETURN getDueDate.order_date + Amd_Preferred_Pkg.GetPreferredValue(order_lead_time_cleaned, order_lead_time, NVL(order_lead_time_defaulted,1)) ;
      
     END getDueDate ;
    
     FUNCTION includeOrderYorN(gold_order_number IN AMD_ON_ORDER.gold_order_number%TYPE, 
                             order_date IN AMD_ON_ORDER.order_date%TYPE,
                          part_no in amd_on_order.part_no%type) RETURN Varchar2 is
     begin
        if includeOrder(gold_order_number, order_date, part_no) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
     end includeOrderYorN ;
     
     FUNCTION includeOrder(gold_order_number IN AMD_ON_ORDER.gold_order_number%TYPE, 
                             order_date IN AMD_ON_ORDER.order_date%TYPE,
                          part_no in amd_on_order.part_no%type) RETURN BOOLEAN IS
     
           ON_ORDER_DATES_FILTER_NAME CONSTANT VARCHAR2(14) := 'on_order_dates' ;
           created_order_date DATE ;
          sched_receipt_date_from DATE ;
          sched_receipt_date_to DATE ;
          numberOfCalanderDays NUMBER ;
          sched_receipt_date AMD_ON_ORDER.SCHED_RECEIPT_DATE%TYPE ;
          lineOfCode number := 0 ;
          
          FUNCTION getSchedReceiptDate  RETURN DATE IS
                     sched_receipt_date AMD_ON_ORDER.SCHED_RECEIPT_DATE%TYPE ;
          BEGIN
                 SELECT sched_receipt_date INTO sched_receipt_date
               FROM AMD_ON_ORDER
               WHERE AMD_ON_ORDER.GOLD_ORDER_NUMBER =  includeOrder.gold_order_number
               and amd_on_order.ORDER_DATE = includeOrder.order_date
               and action_code <> amd_defaults.DELETE_ACTION
               and line = (select max(line) 
                           from amd_on_order 
                           where gold_order_number = includeOrder.gold_order_number
                           and order_date = includeOrder.order_date
                           and action_code <> amd_defaults.DELETE_ACTION) ;
               RETURN sched_receipt_date ;
          EXCEPTION 
                  WHEN standard.NO_DATA_FOUND THEN
                       return null ;
                when others then
                     if sqlcode = -4091 then
                        raise_application_error(-20060,
                            '1269 gold_order_number=' || gold_order_number || ' order_date=' || to_char(order_date,'MM/DD/YYYY')) ;
                     else
                         errormsg( psqlfunction => 'select', ptablename => 'amd_on_order', pError_location => 1380,
                                     pkey_1 => gold_order_number, pkey_2 => to_char(order_date,'MM/DD/YYYY') ) ;
                     end if ;
                     raise ; 
          END getSchedReceiptDate ;
          
          --function calculate
    
          PROCEDURE recordReason (theReason IN VARCHAR2) IS
          BEGIN     
               writeMsg(pTableName => 'tmp_a2a_order_info_line',pError_location => 1390,
                       pKey1 => 'gold_order_number=' || gold_order_number,
                    pKey2 => 'order_date=' || TO_CHAR(order_date,'MM/DD/YYYY HH:MI:SS AM'),
                    pKey3 => 'reason=' || theReason) ;
          exception when others then
            if sqlcode <> -4092 then
                errormsg( psqlfunction => 'recordReason', ptablename => 'amd_on_order', pError_location => 1400,
                             pkey_1 => gold_order_number, pkey_2 => to_char(order_date,'MM/DD/YYYY') ) ;
                raise ;
            else
                null ; -- do nothing
            end if ;
          END recordReason ;
          
          function iif(condition in boolean, truePart in varchar2, falsePart in varchar2) return varchar2 is
          begin
                 if condition then
                     return truePart ;
               else
                     return falsePart ;
               end if ;
          end iif ;
          
     BEGIN
           --IF SUBSTR(gold_order_number,1,2) IN ('AM', 'BA', 'BN', 'BR', 'LB', 'RS', 'SE') THEN
          --     RETURN TRUE ; -- include
          --END IF ;
          lineOfCode := 1 ;
          created_order_date := Amd_On_Order_Date_Filters_Pkg.getOrderCreateDate(ON_ORDER_DATES_FILTER_NAME,SUBSTR(gold_order_number,1,2)) ;
          sched_receipt_date_from := Amd_On_Order_Date_Filters_Pkg.getScheduledReceiptDateFrom(ON_ORDER_DATES_FILTER_NAME,SUBSTR(gold_order_number,1,2)) ;
          sched_receipt_date_to := Amd_On_Order_Date_Filters_Pkg.getScheduledReceiptDateTo(ON_ORDER_DATES_FILTER_NAME,SUBSTR(gold_order_number,1,2)) ;
          Amd_On_Order_Date_Filters_Pkg.getScheduledReceiptDateCalDays(ON_ORDER_DATES_FILTER_NAME,SUBSTR(gold_order_number,1,2), numberOfCalanderDays) ;
          lineOfCode := 2 ;
          IF created_order_date IS NOT NULL THEN
               IF order_date >= created_order_date THEN
                 recordReason('order_date >= created_order_date') ;
                 RETURN FALSE ; -- exclude
             END IF ;
          END IF ;
          lineOfCode := 3 ;
          IF numberOfCalanderDays IS NOT NULL THEN
               sched_receipt_date := getSchedReceiptDate ;
               IF sched_receipt_date IS NULL then
                 sched_receipt_date := getDueDate(part_no => part_no, order_date => order_date) ;
             end if ;
              IF sched_receipt_date > SYSDATE + numberOfCalanderDays THEN
                recordReason('sched_receipt_date > ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') || ' + ' || TO_CHAR(numberOfCalanderDays) ) ; 
               RETURN FALSE ; -- exclude
             END IF ;
         END IF ;
          lineOfCode := 4 ;
         IF sched_receipt_date_from IS NOT NULL THEN
             IF sched_receipt_date_to IS NOT NULL THEN
               IF sched_receipt_date_from <= sched_receipt_date_to THEN
                     sched_receipt_date := getSchedReceiptDate ;
                  if sched_receipt_date is null then
                       sched_receipt_date := getDueDate(part_no => part_no, order_date => order_date) ;
                  end if ;
                     IF sched_receipt_date >= sched_receipt_date_from AND sched_receipt_date <= sched_receipt_date_to THEN
                       RETURN TRUE ; -- include
                  ELSE
                      recordReason('sched_receipt_date NOT BETWEEN sched_receipt_date_from AND sched_receipt_date_to') ; 
                       RETURN FALSE ; -- exclude
                  END IF ;
               END IF ;
            END IF ;
         END IF ;
         
         RETURN TRUE ; -- include
     exception when others then
          dbms_output.put_line('includeOrder: lineOfCode=' || lineOfCode) ;
         errormsg( psqlfunction => 'select', ptablename => 'amd_on_order', pError_location => 1410,
                     pkey_1 => gold_order_number, pkey_2 => to_char(order_date,'MM/DD/YYYY'), 
                   pkey_3 => part_no,
                   pKey_4 => iif(sched_receipt_date is null,'NULL',to_char(sched_receipt_date,'MM/DD/YYYY')) || 'lineOfCode=' || lineOfCode, 
                   pKeywordValuePairs => 'numberOfCalanderDays=' || iif(numberOfCalanderDays is NULL,'NULL',to_char(numberOfCalanderDays)) ) ; /* 
                           || ' sched_receipt_date_from=' || iif(sched_receipt_date_from is NULL,'NULL',to_char(sched_receipt_date_from,'MM/DD/YYYY')) 
                        || ' sched_receipt_date_to=' || iif(sched_receipt_date_to is NULL,'NULL',to_char(sched_receipt_date_to,'MM/DD/YYYY'))
                        || ' created_order_date=' || iif(created_order_date is NULL,'NULL',to_char(created_order_date,'MM/DD/YYYY')) ) ; */
         RAISE ;
     
     END includeOrder ;
     
    
    
    
    
    
     PROCEDURE insertTmpA2AInTransits(part_no IN AMD_IN_TRANSITS_SUM.part_no%TYPE,
       site_location     IN AMD_IN_TRANSITS_SUM.site_location%TYPE,
       quantity      IN AMD_IN_TRANSITS_SUM.quantity%TYPE,
       serviceable_flag  IN AMD_IN_TRANSITS_SUM.serviceable_flag%TYPE,
       action_code   IN amd_in_transits.action_code%TYPE) IS
    
        
    
     BEGIN
      if action_code = amd_defaults.INSERT_ACTION 
      or action_code = amd_defaults.UPDATE_ACTION then
      
          IF quantity > 0 
          AND wasPartSent(insertTmpA2AInTransits.part_no)
          AND isPartValid(insertTmpA2AInTransits.part_no) -- added isPartValid DSE 11/30/05 
          AND site_location IS NOT NULL  THEN
                null ;
                --insertRow 
          
          END IF ;
      else
             if isPartSent(part_no) 
               and site_location is not null then
               null ;
                 --insertRow ;
          end if ;          
      end if ;
                     
     END insertTmpA2AInTransits ;
    
    
     PROCEDURE spoUser(bems_id IN varchar2,
      action_code IN amd_spare_parts.ACTION_CODE%TYPE) IS
    
      spoUserUpdateError EXCEPTION ;
    
    
    
     BEGIN
    
    
      <<insertA2A>>
      BEGIN
       null;
      END insertA2A ;
    
    
     END spoUser ;
    
    
    
      FUNCTION getAssignedPlannerCode(part_no IN amd_spare_parts.part_no%TYPE) RETURN AMD_PLANNERS.planner_code%TYPE  IS
              
              plannerCode AMD_PLANNERS.planner_code%TYPE := amd_preferred_pkg.getPlannerCodeByPart(part_no) ;
              
      BEGIN
        IF not isPlannerCodeAssigned2UserId(plannerCode) THEN
           plannerCode := null ;             
        END IF ;
        
        RETURN plannerCode ;
        
      END getAssignedPlannerCode ;
    
      FUNCTION wasPartSentYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE) RETURN VARCHAR2 IS 
      BEGIN
             IF wasPartSent(partNo) THEN
                RETURN 'Y' ;
           ELSE
             RETURN 'N' ;
           END IF ;
      END wasPartSentYorN ;
      
      FUNCTION isPartValidYorN(partNo IN AMD_SPARE_PARTS.part_no%TYPE, showReason in varchar2 := 'N') RETURN VARCHAR2 IS
                 showReasonBool boolean := false ;
      BEGIN
             if showReason <> 'N' then
                 if upper(substr(showReason,1,1)) = 'Y' then
                     showReasonBool := true ;
               end if ;
           end if ;
             IF isPartValid(partNo, showReason => showReasonBool) THEN
               RETURN 'Y' ;
           ELSE
               RETURN 'N' ;
           END IF ;
      END isPartValidYorN ;
      
      FUNCTION isPlannerCodeAssign2UserIdYorN(plannerCode IN VARCHAR2) RETURN VARCHAR2 IS
      BEGIN
             IF isPlannerCodeAssigned2UserId(plannerCode) THEN
             RETURN 'Y' ;
           ELSE
             RETURN 'N' ;
           END IF ;
      END isPlannerCodeAssign2UserIdYorN ;
      
      PROCEDURE deleteInvalidParts (testOnly IN BOOLEAN := FALSE) IS
          CURSOR invalidParts IS
          SELECT sent.part_no, nomenclature 
          FROM AMD_SENT_TO_A2A sent, amd_spare_parts parts
          WHERE sent.action_code != Amd_Defaults.DELETE_ACTION
          AND sent.spo_prime_part_no IS NOT NULL
          and (
                (amd_utils.isPartRepairableYorN(sent.part_no) = 'Y' and isPartValidYorN(sent.part_no) = 'N')
               or (amd_utils.isPartConsumableYorN(sent.part_no) = 'Y' and consumables_pkg.isPartValidYorN(sent.part_no) = 'N')
               or (amd_utils.isPartRepairableYorN(sent.part_no) = 'N' and amd_utils.isPartConsumableYorN(sent.part_no) = 'N')
              )                
          and sent.part_no = parts.part_no ;
          
          rc NUMBER ;
          cnt NUMBER := 0 ;
                  
      BEGIN
            writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 1540,
                pKey1 => 'deleteInvalidParts',
                pKey2 => 'testOnly=' || Amd_Utils.boolean2Varchar2(testOnly),
                pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
             FOR rec IN invalidParts LOOP
                  IF NOT testOnly THEN
                      rc := repairables_Pkg.DeletePartInfo(rec.part_no,rec.nomenclature) ;
                      UPDATE AMD_SENT_TO_A2A
                      SET action_code = Amd_Defaults.DELETE_ACTION,
                      transaction_date = SYSDATE
                      WHERE part_no = rec.part_no ; 
                  END IF ;
                  cnt := cnt + 1 ;
           END LOOP ;
           writeMsg(pTableName => 'tmp_a2a_part_info', pError_location => 1550,
                pKey1 => 'deleteInvalidParts',
                pKey2 => 'testOnly=' || Amd_Utils.boolean2Varchar2(testOnly),
                pKey3 => 'cnt=' || TO_CHAR(cnt),
                pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
           COMMIT ;       
      END deleteInvalidParts ;
    
    
      PROCEDURE processPart(rec IN AMD_SENT_TO_A2A%ROWTYPE) IS
      BEGIN
        null;
      END processPart ; 
    
     PROCEDURE processBomDetail(bomDetail IN bomDetailCur) IS
                cnt NUMBER := 0 ;
               rec AMD_SENT_TO_A2A%ROWTYPE ;
               bomDetails bomDetailTab ;
     BEGIN
            writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1580,
            pKey1 => 'processBomDetail',
            pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
            fetch bomDetail bulk collect into bomDetails ;
            close bomDetail ;
            
           if bomDetails.first is not null then
               for indx in bomDetails.first .. bomDetails.last        
               LOOP
                  IF bomDetails(indx).spo_prime_part_no IS NOT NULL THEN
                      processPart(bomDetails(indx)) ;
                      cnt := cnt + 1 ;
                  END IF ;
              END LOOP ;
            end if ;              
            writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1590,
            pKey1 => 'processBomDetail',
            pKey2 => 'cnt=' || TO_CHAR(cnt),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
          COMMIT ;
     END processBomDetail ;
     
     PROCEDURE initA2ABomDetail(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE ) IS
          partsByDate bomDetailCur ;
          cnt NUMBER := 0 ;
        BEGIN
            writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1600,
            pKey1 => 'initA2ABomDetail',
            pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
            pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
            pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
             Mta_Truncate_Table('tmp_a2a_bom_detail','reuse storage');
          mblnSendAllData := TRUE ;
          OPEN partsByDate FOR
              SELECT *
              FROM AMD_SENT_TO_A2A 
              WHERE 
              TRUNC(transaction_date) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
              AND part_no IN (SELECT spo_prime_part_no FROM AMD_SENT_TO_A2A WHERE part_no = spo_prime_part_no);
         processBomDetail(partsByDate) ;
            writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1610,
            pKey1 => 'initA2ABomDetail',
            pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
            pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
            pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;       
        END initA2ABomDetail ;
        
        PROCEDURE initA2ABomDetail(useTestParts IN BOOLEAN := FALSE) IS
          parts bomDetailCur ;
          procedure getTestData is
          begin
            writeMsg(pTableName => 'amd_sent_to_a2a', pError_location => 1620,
            pKey1 => 'getTestData' ) ;
            commit ;
            OPEN parts FOR
              SELECT *
              FROM AMD_SENT_TO_A2A 
              WHERE part_no IN (SELECT part_no FROM AMD_TEST_PARTS) 
              AND part_no IN (SELECT spo_prime_part_no FROM AMD_SENT_TO_A2A WHERE part_no = spo_prime_part_no);
          end getTestData ;
          
          procedure getAllData is
          begin
            writeMsg(pTableName => 'amd_sent_to_a2a', pError_location => 1630,
            pKey1 => 'getAllData' ) ;
            commit ;
            OPEN parts FOR
              SELECT *
              FROM AMD_SENT_TO_A2A WHERE
              part_no IN (SELECT spo_prime_part_no FROM AMD_SENT_TO_A2A WHERE part_no = spo_prime_part_no);
          end getAllData ;
           
        BEGIN
            writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1640,
            pKey1 => 'initA2ABomDetail',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
             Mta_Truncate_Table('tmp_a2a_bom_detail','reuse storage');
          mblnSendAllData := TRUE ;
          IF useTestParts THEN
               getTestData ;
          ELSE
            getAllData ;
          END IF ;
          processBomDetail(parts) ;
            writeMsg(pTableName => 'tmp_a2a_bom_detail', pError_location => 1650,
            pKey1 => 'initA2ABomDetail',
            pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
            pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;       
        END initA2ABomDetail ;
    
        PROCEDURE processBackOrder(backOrder IN backOrderCur) IS
                  cnt NUMBER := 0 ;
                  rec AMD_BACKORDER_SUM%ROWTYPE ;
                  site_location varchar2(20);
                  backOrders backOrderTab ;
        BEGIN
               writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1680,
                pKey1 => 'processBackOrder',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
             fetch backOrder bulk collect into backOrders ;
             close backOrder ;
             
             if backOrders.first is not null then
                 for indx in backOrders.first .. backOrders.last       
                 LOOP
                     site_location := backOrders(indx).spo_location ;
                     IF site_location IS NOT NULL THEN
                         cnt := cnt + 1 ;
                     END IF ;
                 END LOOP ;
              end if ;                 
               writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1690,
                pKey1 => 'processBackOrder',
                pKey2 => 'cnt=' || TO_CHAR(cnt),
                pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
             COMMIT ;
        END processBackOrder ;
        
         PROCEDURE initA2ABackorderInfo(from_dt IN DATE := START_DT, to_dt IN DATE := SYSDATE ) IS
          
          backOrdersByDate backOrderCur ;
          
        BEGIN
               writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1700,
                pKey1 => 'initA2ABackorderInfo',
                pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                pKey4 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
             Mta_Truncate_Table('tmp_a2a_backorder_info','reuse storage');
          mblnSendAllData := TRUE ;
          OPEN backOrdersByDate FOR
              SELECT
                  sent.spo_prime_part_no,         
                  bo.spo_location,         
                  QTY,
                  case bo.action_code
                         when amd_defaults.getDELETE_ACTION then
                               bo.action_code             
                         else
                              sent.ACTION_CODE
                  end action_code,    
                  LAST_UPDATE_DT           
              FROM AMD_BACKORDER_SUM bo, amd_sent_to_a2a sent 
              WHERE 
              TRUNC(last_update_dt) BETWEEN TRUNC(from_dt) AND TRUNC(to_dt) 
                AND bo.spo_prime_part_no = sent.part_no
              and sent.SPO_PRIME_PART_NO is not null 
              order by sent.spo_prime_part_no, last_update_dt ;
              
          processBackOrder(backOrdersByDate) ;
          writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1710,
                pKey1 => 'initA2ABackorderInfo',
                pKey2 => 'from_dt=' || TO_CHAR(from_dt,'MM/DD/YYYY'),
                pKey3 => 'to_dt=' || TO_CHAR(to_dt,'MM/DD/YYYY'),
                pKey4 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
          COMMIT ;
        END initA2ABackorderInfo ;
    
         PROCEDURE initA2ABackorderInfo(useTestParts IN BOOLEAN := FALSE ) IS
          parts backOrderCur ;
          useTestPartsString VARCHAR2(5) := 'False' ;
          procedure getTestData is
          begin
             writeMsg(pTableName => 'amd_backorder_sum', pError_location => 1720,
             pKey1 => 'getTestData' ) ;
             commit ;
               OPEN parts FOR
              SELECT 
                  sent.spo_prime_part_no,         
                  spo_location,         
                  QTY,             
                  case bo.action_code
                         when amd_defaults.getDELETE_ACTION then
                               bo.action_code
                       else    
                               sent.ACTION_CODE
                  end action_code,
                  LAST_UPDATE_DT           
              FROM AMD_BACKORDER_SUM bo, amd_sent_to_a2a sent, amd_test_parts testParts 
              WHERE 
              bo.spo_prime_part_no = testParts.part_no 
                AND bo.spo_prime_part_no = sent.part_no
              and sent.SPO_PRIME_PART_NO is not null 
              order by sent.spo_prime_part_no, last_update_dt ;
                useTestPartsString := 'True' ;
              
          end getTestData ;
          
          procedure getAllData is
          begin
             writeMsg(pTableName => 'amd_backorder_sum', pError_location => 1730,
             pKey1 => 'getAllData' ) ;
             commit ;
               OPEN parts FOR
              SELECT 
                  sent.spo_prime_part_no,         
                  spo_location,         
                  QTY,
                  case bo.action_code
                         when amd_defaults.getDELETE_ACTION then
                               bo.action_code
                       else             
                                 sent.ACTION_CODE
                  end action_code,    
                  LAST_UPDATE_DT           
              FROM AMD_BACKORDER_SUM bo, amd_sent_to_a2a sent
              WHERE bo.spo_prime_part_no = sent.part_no
              and sent.SPO_PRIME_PART_NO is not null 
              order by sent.spo_prime_part_no, last_update_dt ;
          end getAllData ;
          
        BEGIN
          writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1740,
                pKey1 => 'initA2ABackorderInfo',
                pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                pKey3 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;       
             Mta_Truncate_Table('tmp_a2a_backorder_info','reuse storage');
          mblnSendAllData := TRUE ;
          IF useTestParts THEN
               getTestData ;
          ELSE
               getAllData ;
          END IF ;
          processBackOrder(parts) ;
          writeMsg(pTableName => 'tmp_a2a_backorder_info', pError_location => 1750,
                pKey1 => 'initA2ABackorderInfo',
                pKey2 => 'useTestParts=' || Amd_Utils.boolean2Varchar2(useTestParts),
                pKey3 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
          COMMIT ;       
        END initA2ABackorderInfo ;
    
        
        PROCEDURE version IS
        BEGIN
             writeMsg(pTableName => 'a2a_pkg', 
                     pError_location => 1790, pKey1 => 'a2a_pkg', pKey2 => '$Revision:   1.236  $') ;
              dbms_output.put_line('a2a_pkg: $Revision:   1.236  $') ;
        END version ;

        function getVersion return varchar2 is
        begin
            return '$Revision:   1.236  $' ;
        end getVersion ;
        
        procedure setInsertAddUpdRepairInfoCnt (value in number) is
        begin
            insertAddUpdRepairInfoCnt := value ;
        end setInsertAddUpdRepairInfoCnt ;
        
        procedure resetDebugCnts is
        begin
             insertRowCnt  := 0 ;
             insertAddUpdRepairInfoCnt  := 0 ;
             deleteCnt  := 0 ;
             insertCnt  := 0 ;
             rejectCnt := 0 ;
        end resetDebugCnts ;
        
        function getInsertAddUpdRepairInfoCnt return number is
        begin
            return insertAddUpdRepairInfoCnt ;
        end getInsertAddUpdRepairInfoCnt ;
                            
        function getDebugYorN return varchar2 is
        begin
            if debug then
                return 'Y' ;
            else
                return 'N' ;
            end if ;            
        end getDebugYorN ;   
        
        procedure setDebug(switch in varchar2) is
        begin
            debug := upper(switch) in ('Y','T','YES','TRUE') ;
            if debug then
                dbms_output.ENABLE(100000) ;
            else
                dbms_output.DISABLE ;
            end if ;                    
        end setDebug ;
        
        function getDebugThreshold return number is
        begin
            return debugThreshold ;
        end getDebugThreshold ;
        
        procedure setDebugThreshold(value in number) is
        begin
            debugThreshold := value ;
        end setDebugThreshold ;
        
        procedure setAllThresholds(value in number) is
        begin
            debugThreshold := value ;
            debugRepairInfoThreshold := value ;
            debugDeleteThreshold := value ;
        end setAllThresholds ;
                                
                         
        procedure setDebugDeleteThreshold(value in number) is
        begin
            debugDeleteThreshold := value ;
        end setDebugDeleteThreshold ;            
                    
        function getStart_dt return date is
        begin
             return START_DT ;
        end getStart_dt ;

        function getNEW_BUY return varchar2 is
        begin
             return NEW_BUY ;
        end getNEW_BUY ;
         
        function getREPAIR  return varchar2 is
        begin
             return REPAIR ;
        end getREPAIR ;
        
        function getAN_ORDER return varchar2 is
        begin
             return AN_ORDER ;
        end getAN_ORDER ;
        
        function getOPEN_STATUS return varchar2 is
        begin
             return OPEN_STATUS ;
        end getOPEN_STATUS ;
        
        function getTHIRD_PARTY_FLAG return varchar2 is
        begin
             return THIRD_PARTY_FLAG ;
        end getTHIRD_PARTY_FLAG ;
        
        procedure deleteSentToA2AChildren is
                  cursor childrenToDelete is
                    select ch.part_no, nomenclature 
                    from 
                    amd_sent_to_a2a paren,
                    amd_sent_to_a2a ch, 
                    amd_spare_parts parts
                    where ch.part_no <> ch.spo_prime_part_no
                    and ch.SPO_PRIME_PART_NO = paren.part_no
                    and ch.action_code <> paren.action_code
                    and paren.action_code = amd_defaults.getDELETE_ACTION
                    and ch.part_no = parts.part_no ;
                cnt number := 0 ;
                result number ; 
        begin
            writeMsg(pTableName => 'amd_sent_to_a2a', pError_location => 1800,
                pKey1 => 'deleteSentToA2AChildren',
                pKey2 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM') ) ;
            commit ;
                            
             for rec in childrenToDelete loop
                  cnt := cnt + 1 ;
                 update amd_sent_to_a2a
                 set action_code = amd_defaults.DELETE_ACTION
                 where part_no = rec.part_no ;
                 
                 if mod(cnt,deleteChildrenThreshold) = 0 then
                    commit ;
                 end if ;                    
                 
                 result := deletePartInfo(rec.part_no, rec.nomenclature) ;
                 
                 if mod(cnt,deleteChildrenThreshold) = 0 then
                    commit ;
                 end if ;                    
                 
             end loop ;
            writeMsg(pTableName => 'amd_sent_to_a2a', pError_location => 1810,
                pKey1 => 'deleteSentToA2AChildren',
                pKey2 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey3 => 'cnt=' || to_char(cnt) ) ;
             commit ;
        
        end deleteSentToA2AChildren ;

        function lpOverrideExists(part_no in datasys_lp_override_v.PART%type, site_location in datasys_lp_override_v.SITE_LOCATION%type) return boolean is
            result number ;
        begin
            select 1 into result
            from dual
            where exists 
                    (select null
                    from datasys_lp_override_v
                    where part = lpOverrideExists.part_no
                    and site_location = lpOverrideExists.site_location ) ;
            
            return true ;
            
        exception when standard.no_data_found then
            return false ;
        end lpOverrideExists ;

        function lpOverrideExistsYorN(part_no in datasys_lp_override_v.PART%type, site_location in datasys_lp_override_v.SITE_LOCATION%type) return varchar2 is
        begin
            if lpOverrideExists(part_no, site_location) then
                return 'Y' ;
            else
                return 'N' ;
            end if ;            
        end lpOverrideExistsYorN ;
        
        function partExistsInDataSystems(pPartNo in datasys_part_v.part%type) return boolean is
            result varchar2(1) := 'N' ;
        begin
            select 'Y' into result from datasys_part_v where part = pPartNo ;
            return true  ;
        exception when standard.no_data_found then
            return false ;
        end partExistsInDataSystems ;

        function partExistsInDataSystemsYorN(pPartNo in datasys_part_v.part%type) return varchar2 is
        begin
            if partExistsInDataSystems(pPartNo) then
                return 'Y' ;
            end if ;
            return 'N' ;
        end partExistsInDataSystemsYorN ;
        

        function isDataSysPartMarkedDeleted(pPartNo in datasys_part_v.part%type) return boolean is
            result varchar2(1) := 'N' ;
        begin
            select 'Y' into result from datasys_part_v where part = pPartNo and end_date is not null ;
            return true ;
        exception when standard.no_data_found then 
            return false ;
        end isDataSysPartMarkedDeleted ;

        function isDataSysPartMarkedDeletedYorN(pPartNo in datasys_part_v.part%type) return varchar2 is
        begin
            if isDataSysPartMarkedDeleted(pPartNo) then
                return 'Y' ;
            end if ;
            return 'N' ;
        end isDataSysPartMarkedDeletedYorN ;
        
        -- added 9/27/07
        procedure initA2APartAlt is
            cursor sentParts is
            select * from amd_sent_to_a2a
            where part_no <> spo_prime_part_no ;
            cnt number := 0 ;
        begin
            writeMsg(pTableName => 'tmp_a2a_part_alt', pError_location => 1820,
                pKey1 => 'started at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM')) ;
            mta_truncate_table('tmp_a2a_part_alt','reuse storage') ;
            for rec in sentParts loop
                cnt := cnt + 1 ; 
            end loop ;
            writeMsg(pTableName => 'tmp_a2a_part_alt', pError_location => 1830,
                pKey1 => 'ended at ' || TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
                pKey2 => 'cnt=' || to_char(cnt) ) ;
            commit ;
        end initA2APartAlt ;
        
        procedure setDeleteChildrenThreshold(value in number) is
        begin
            deleteChildrenThreshold := value ;
        end setDeleteChildrenThreshold ;
        
        function getDeleteChildrenThreshold return number is
        begin
            return deleteChildrenThreshold ;
        end getDeleteChildrenThreshold ;
        
            
END repairables_Pkg ;
/


DROP PACKAGE BODY AMD_OWNER.USER_PLANNER_PKG;

CREATE OR REPLACE PACKAGE BODY AMD_OWNER.USER_PLANNER_PKG AS

 /*
      $Author:   zf297a  $
    $Revision:   1.1  $
        $Date:   01 Dec 2008 12:05:54  $
    $Workfile:   USER_PLANNER_PKG.pkb  $
         $Log:   I:\Program Files\Merant\vm\win32\bin\pds\archives\SDS-AMD\Database\Packages\USER_PLANNER_PKG.pkb.-arc  $
/*
/*      Rev 1.1   01 Dec 2008 12:05:54   zf297a
/*   Planner_code was removed from amd_site_asset_mgr.
/*
/*      Rev 1.0   02 Oct 2008 14:22:20   zf297a
/*   Initial revision.
*/
    PROCEDURE writeMsg(
                pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
                pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
                pKey1 IN VARCHAR2 := '',
                pKey2 IN VARCHAR2 := '',
                pKey3 IN VARCHAR2 := '',
                pKey4 IN VARCHAR2 := '',
                pData IN VARCHAR2 := '',
                pComments IN VARCHAR2 := '')  IS
    BEGIN
        Amd_Utils.writeMsg (
                pSourceName => 'user_planner_pkg',
                pTableName  => pTableName,
                pError_location => pError_location,
    			pKey1 => pKey1,
				pKey2 => pKey2,
				pKey3 => pKey3,
				pKey4 => pKey4,
				pData    => pData,
				pComments => pComments);
	END writeMsg ;

	PROCEDURE ErrorMsg(
				pTableName IN AMD_LOAD_STATUS.TABLE_NAME%TYPE,
				pError_location IN AMD_LOAD_DETAILS.DATA_LINE_NO%TYPE,
				pKey1 IN VARCHAR2 := '',
				pKey2 IN VARCHAR2 := '',
				pKey3 IN VARCHAR2 := '',
				pKey4 IN VARCHAR2 := '',
				pComments IN VARCHAR2 := '')  IS

                 pragma autonomous_transaction ;

	BEGIN
		Amd_Utils.InsertErrorMsg (
				pLoad_no => Amd_Utils.GetLoadNo(pSourceName => 'user_planner_pkg',	pTableName  => pTableName),
				pData_line_no => pError_location,
				pData_line    => 'user_planner_pkg',
				pKey_1 => SUBSTR(pKey1,1,50),
				pKey_2 => SUBSTR(pKey2,1,50),
				pKey_3 => SUBSTR(pKey3,1,50),
				pKey_4 => SUBSTR(pKey4,1,50),
				pKey_5 => TO_CHAR(SYSDATE,'MM/DD/YYYY HH:MI:SS AM'),
				pComments => 'sqlcode('||SQLCODE||') sqlerrm('||SQLERRM||') ' || pComments);
		COMMIT;
	END errorMsg ;


    function isValidPlannerCode(planner_code in amd_planners.planner_code%type) return boolean is
        wk_planner_code amd_planners.planner_code%type ;
    begin
        select planner_code into wk_planner_code
        from amd_planners
        where planner_code = isValidPlannerCode.planner_code;
        return true ;
    exception
        when standard.no_data_found then
            <<tryDefaults>>
            begin
                select planner_code into wk_planner_code
                from amd_default_planners_v
                where planner_code = isValidPlannerCode.planner_code ;
                return true ;
            exception
              when standard.no_data_found then
                return false ;
            end tryDefaults;
    end isValidPlannerCode ;

    function isValidPlannerCodeYorN(planner_code in amd_planners.planner_code%type) return varchar2 is
    begin
        if isValidPlannerCode(planner_code) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isValidPlannerCodeYorN ;

    function isValidBemsId(bems_id in amd_people_all_v.bems_id%type) return boolean is
        wk_bems_id amd_people_all_v.bems_id%type ;
    begin
        if length(bems_id) = 6 then
            wk_bems_id := '0' || bems_id ;
        elsif length(bems_id) = 7 then
            wk_bems_id := bems_id ;
        else
            writeMsg(pTableName => 'amd_people_all_v', pError_location => 10,
                pKey1 => 'isValidBemsId',
                pKey2 => 'Error: invalid bems_id(' || bems_id || ') must be at 6 or 7 characters long');
            dbms_output.put_line('Error: invalid bems_id(' || bems_id || ') must be at 6 or 7 characters long');
            return false ;
        end if ;
        select bems_id into wk_bems_id from amd_people_all_v where bems_id = wk_bems_id ;
        return true ;
        exception
            when standard.no_data_found then
                return false ;
        end isValidBemsId ;

    function isValidBemsIdYorN(bems_id in amd_people_all_v.bems_id%type) return varchar2 is
    begin
        if isValidBemsId(bems_id) then
            return 'Y' ;
        else
            return 'N' ;
        end if ;
    end isValidBemsIdYorN ;

    function insertAmdUse1Row(userid in amd_use1.userid%type,
                user_name in amd_use1.user_name%type,
                employee_no in amd_use1.employee_no%type,
                phone in amd_use1.phone%type,
                ims_designator_code in amd_use1.ims_designator_code%type,
                employee_status in amd_use1.employee_status%type) return number is

        inuse_userid amd_use1.USERID%type ;
        old_user_name amd_use1.user_name%type ;
        old_employee_no amd_use1.employee_no%type ;
        old_phone amd_use1.phone%type ;
        old_ims_designator_code amd_use1.ims_designator_code%type ;
        old_employee_status amd_use1.employee_status%type ;
        old_last_update_dt amd_use1.last_update_dt%type ;

        procedure dumpData(dumpId in number) is
        begin
            writeMsg(pTableName => 'amd_use1', pError_location => 20,
                pKey1 => 'insertAmdUse1Row:' || dumpId,
                pKey2 => insertAmdUse1Row.inuse_userid,
                pKey3 => nvl(old_user_name,'null'),
                pKey4 => nvl(old_employee_no,'null'),
                pComments => nvl(old_phone,'null') ) ;
            writeMsg(pTableName => 'amd_use1', pError_location => 30,
                pKey1 => 'insertAmdUse1Row:' || dumpId,
                pKey2 => nvl(old_ims_designator_code,'null'),
                pKey3 => nvl(old_employee_status,'null'),
                pKey4 => to_char(nvl(old_last_update_dt,sysdate),'MM/DD/YYYY HH:MI:SS AM') ) ;
            dbms_output.put_line('before: ' || insertAmdUse1Row.inuse_userid
            || ' user_name=' || nvl(old_user_name,'null')
            || ' employee_no=' || nvl(old_employee_no,'null')
            || ' phone=' || nvl(old_phone,'null') ) ;
            dbms_output.put_line('---- old_ims_designator_code=' || nvl(old_ims_designator_code,'null')
            || ' employee_status=' || nvl(old_employee_status,'null')
            || ' last_update_dt=' || to_char(nvl(old_last_update_dt,sysdate),'MM/DD/YYYY HH:MI:SS AM') ) ;
        end dumpData ;

    begin
       dbms_output.put_line('****** trying to insert: ' || insertAmdUse1Row.userid) ;
        if not isValidBemsId(employee_no) then
            writeMsg(pTableName => 'amd_use1', pError_location => 40,
                pKey1 => 'insertAmdUse1Row',
                pKey2 => 'Error: ' || employee_no || ' was not found in amd_people_all_v') ;
            dbms_output.put_line('Error: ' || employee_no || ' was not found in amd_people_all_v') ;
            return INVALID_BEMS_ID ;
        end if ;
        if not isValidPlannerCode(ims_designator_code) then
            dbms_output.put_line('Error: ' || ims_designator_code || ' was not found in amd_planners or amd_default_planners_v') ;
            return INVALID_PLANNER_CODE ;
        end if ;

        inuse_userid := insertAmdUse1Row.userid ;
        insert into amd_owner.amd_use1
        (userid,user_name,employee_no,phone,ims_designator_code,employee_status,last_update_dt)
        values(insertAmdUse1Row.userid,insertAmdUse1Row.user_name,insertAmdUse1Row.employee_no,insertAmdUse1Row.phone,
                insertAmdUse1Row.ims_designator_code,insertAmdUse1Row.employee_status,sysdate) ;

        dumpData(10) ;
        dbms_output.put_line('****** successful insert of: ' || insertAmdUse1Row.userid) ;
        return SUCCESS ;

    exception when standard.dup_val_on_index then

        <<tryagain>>
        begin
            if instr(sqlerrm,'AMD_USE1_UK01') > 0 then
                dbms_output.put_line(employee_no || ' in use.') ;
                select userid, user_name, nvl(employee_no,'null'),nvl(phone,'null'),nvl(ims_designator_code,'null'),employee_status,nvl(last_update_dt,sysdate) into
                    inuse_userid,  old_user_name,old_employee_no,old_phone,old_ims_designator_code,old_employee_status,old_last_update_dt
                from amd_owner.amd_use1
                where amd_use1.employee_no = insertAmdUse1Row.employee_no ;
                dbms_output.put_line(employee_no || ' is already in use by userid ' ||  inuse_userid) ;
                dumpData(20) ;
                update amd_owner.amd_use1
                set amd_use1.user_name =  insertAmdUse1Row.user_name,
                amd_use1.phone = insertAmdUse1Row.phone,
                amd_use1.ims_designator_code = insertAmdUse1Row.ims_designator_code,
                amd_use1.employee_status = insertAmdUse1Row.employee_status,
                amd_use1.last_update_dt =sysdate
                where amd_use1.employee_no = insertAmdUse1Row.employee_no ;
                dumpData(30) ;
            else
                inuse_userid := insertAmdUse1Row.userid ;
                dbms_output.put_line(insertAmdUse1Row.userid || ' already exists. ' || sqlcode || ' ' || sqlerrm) ;
                select user_name, nvl(employee_no,'null'),nvl(phone,'null'),nvl(ims_designator_code,'null'),employee_status,nvl(last_update_dt,sysdate) into
                    old_user_name,old_employee_no,old_phone,old_ims_designator_code,old_employee_status,old_last_update_dt
                from amd_owner.amd_use1
                where amd_use1.userid = insertAmdUse1Row.userid ;
                dumpData(40) ;
                update amd_owner.amd_use1
                set amd_use1.user_name =  insertAmdUse1Row.user_name,
                amd_use1.employee_no =  insertAmdUse1Row.employee_no,
                amd_use1.phone = insertAmdUse1Row.phone,
                amd_use1.ims_designator_code = insertAmdUse1Row.ims_designator_code,
                amd_use1.employee_status = insertAmdUse1Row.employee_status,
                amd_use1.last_update_dt =sysdate
                where amd_use1.userid = insertAmdUse1Row.userid ;
                dumpData(50) ;
            end if ;
        exception when others then
            return 10 ;
        end tryAgain;

        dbms_output.put_line('****** successful update of: ' || insertAmdUse1Row.userid) ;
        return SUCCESS ;

    end insertAmdUse1Row ;

    function insertUimsRow(userid in uims.userid%type,
                designator_code in uims.designator_code%type,
                alt_ims_des_code_b in uims.alt_ims_des_code_b%type,
                alt_es_des_code_b in uims.alt_es_des_code_b%type,
                alt_sup_des_code_b in uims.alt_sup_des_code_b%type) return number is

        inuse_userid uims.USERID%type ;
        old_designator_code uims.designator_code%type ;
        old_alt_ims_des_code_b uims.alt_ims_des_code_b%type ;
        old_alt_es_des_code_b uims.alt_es_des_code_b%type ;
        old_alt_sup_des_code_b uims.alt_sup_des_code_b%type ;
        old_last_update_dt uims.last_update_dt%type ;

        procedure beforeMsg is
        begin
            dbms_output.put_line('before: ' || insertUimsRow.inuse_userid
            || ' old_alt_ims_des_code_b=' || nvl(old_alt_ims_des_code_b,'null')
            || ' old_alt_es_des_code_b=' || nvl(old_alt_es_des_code_b,'null')
            || ' old_alt_sup_des_code_b=' || nvl(old_alt_sup_des_code_b,'null') ) ;
            dbms_output.put_line('---- old_designator_code=' || nvl(old_designator_code,'null')
            || ' old_last_update_dt=' || to_char(nvl(old_last_update_dt,sysdate),'MM/DD/YYYY HH:MI:SS AM') ) ;
        end beforeMsg ;

        procedure afterMsg is
        begin
            dbms_output.put_line('after: ' || insertUimsRow.inuse_userid ||
                ' alt_ims_des_code_b=' || insertUimsRow.alt_ims_des_code_b ||
                ' alt_es_des_code_b=' || insertUimsRow.alt_es_des_code_b ||
                ' alt_sup_des_code_b=' || insertUimsRow.alt_sup_des_code_b) ;
            dbms_output.put_line('---- ' ||
                ' designator_code=' || insertUimsRow.designator_code ||
                ' last_update_dt=' || to_char(sysdate,'MM/DD/YYYY HH:MI:SS AM') ) ;
        end afterMsg ;

    begin
        dbms_output.put_line('****** trying to insert: ' || insertUimsRow.userid) ;
        if not isValidBemsId(substr(userid,2)) then
            dbms_output.put_line('Error: ' || substr(userid,2) || ' was not found in amd_people_all_v') ;
            return INVALID_BEMS_ID ;
        end if ;
        if not isValidPlannerCode(designator_code) then
                dbms_output.put_line('Error: ' || designator_code || ' was not found in amd_planners or amd_default_planners_v') ;
                return INVALID_PLANNER_CODE ;
        end if ;
        inuse_userid := insertUimsRow.userid ;

        insert into amd_owner.uims
        (userid,alt_ims_des_code_b,alt_es_des_code_b,alt_sup_des_code_b,designator_code,last_update_dt)
        values(insertUimsRow.userid,insertUimsRow.alt_ims_des_code_b,insertUimsRow.alt_es_des_code_b,insertUimsRow.alt_sup_des_code_b,
                insertUimsRow.designator_code,sysdate) ;

        afterMsg ;
        dbms_output.put_line('****** successful insert of: ' || insertUimsRow.userid) ;
        return SUCCESS ;

    exception when standard.dup_val_on_index then
        <<tryAgain>>
        begin
            inuse_userid := insertUimsRow.userid ;
            dbms_output.put_line(insertUimsRow.userid || ' already exists. ' || sqlcode || ' ' || sqlerrm) ;

            select alt_ims_des_code_b, nvl(alt_es_des_code_b,'null'),nvl(alt_sup_des_code_b,'null'),nvl(designator_code,'null'),nvl(last_update_dt,sysdate) into
                old_alt_ims_des_code_b,old_alt_es_des_code_b,old_alt_sup_des_code_b,old_designator_code,old_last_update_dt
            from amd_owner.uims
            where uims.userid = insertUimsRow.userid
            and uims.designator_code = insertUimsRow.designator_code ;

            beforeMsg ;

            update amd_owner.uims
                set uims.alt_ims_des_code_b =  insertUimsRow.alt_ims_des_code_b,
                uims.alt_es_des_code_b =  insertUimsRow.alt_es_des_code_b,
                uims.alt_sup_des_code_b = insertUimsRow.alt_sup_des_code_b,
                uims.designator_code = insertUimsRow.designator_code,
                uims.last_update_dt =sysdate
            where uims.userid = insertUimsRow.userid
            and uims.designator_code = insertUimsRow.designator_code ;

            afterMsg ;
        exception when others then
            return 10 ;
        end tryAgain ;

        dbms_output.put_line('****** successful update of ' || insertUimsRow.userid) ;
        return SUCCESS ;

    end insertUimsRow ;

    function insertSiteAssetMgr(bems_id in amd_site_asset_mgr.bems_id%type) return number is
        user_exists number := 0 ; -- 1 = exists 0 = not exist
    begin
        if not isValidBemsId(bems_id) then
             ErrorMsg(pTableName => 'amd_site_asset_mgr',
				   pError_location => 50,
				   pKey1 => bems_id,
                   pKey2 => 'invalid_bems_id') ;
            dbms_output.put_line('bems_id:' || bems_id || ' is invalid.') ;
            return INVALID_BEMS_ID ;
        end if ;

        <<checkAmdUsers>>
        begin
            select 1 into user_exists
            from amd_users
            where bems_id = insertSiteAssetMgr.bems_id ;
            dbms_output.put_line('bems_id: ' || bems_id || ' already exists in amd_users.') ;
            dbms_output.put_line('amd_users will be used for x_user_v and spo_user') ;
            writeMsg(pTableName => 'amd_site_asset_mgr', pError_location => 55,
                pKey1 => bems_id,
                pKey2 => 'bems_id already exists in amd_users',
                pKey3 => 'amd_users will be sued for x_user_v and spo_user') ;
        exception when standard.no_data_found then
            user_exists := 0 ;
        end checkAmdUsers ;

        insert into amd_site_asset_mgr
        (bems_id)
        values(insertSiteAssetMgr.bems_id) ;
        return SUCCESS ;
    exception
        when standard.no_data_found then
            return sqlcode ;
        when standard.dup_val_on_index then
            return DUPLICATE ;
        when others then
            ErrorMsg(pTableName => 'amd_site_asset_mgr',
				   pError_location => 70,
				   pKey1 => bems_id) ;
            return sqlcode ;
    end insertSiteAssetMgr ;

    function deleteSiteAssetMgr(bems_id in amd_site_asset_mgr.bems_id%type) return number is
    begin
        update amd_site_asset_mgr
        set action_code = amd_defaults.DELETE_ACTION,
        last_update_dt = sysdate
        where bems_id = deleteSiteAssetMgr.bems_id ;
        return SUCCESS ;
    exception
        when standard.no_data_found then
            ErrorMsg(pTableName => 'amd_site_asset_mgr',
                   pError_location => 80,
                   pKey1 => bems_id,
                   pKey2 => 'no_data_found') ;
            return sqlcode ;
        when others then
            ErrorMsg(pTableName => 'amd_site_asset_mgr',
                   pError_location => 90,
                   pKey1 => bems_id,
                   pComments => sqlerrm) ;
            return sqlcode ;
    end deleteSiteAssetMgr ;

   procedure version is
    begin
         writeMsg(pTableName => 'user_planner_pkg',
                 pError_location => 410, pKey1 => 'user_planner_pkg', pKey2 => '$Revision:   1.1  $') ;
          dbms_output.put_line('user_planner_pkg: $Revision:   1.1  $') ;
    end version ;

    function getVersion return varchar2 is
    begin
        return '$Revision:   1.1  $' ;
    end getVersion ;

end user_planner_pkg ;
/


DROP PUBLIC SYNONYM AMD_BASIC_DEFAULT_PKG;

CREATE PUBLIC SYNONYM AMD_BASIC_DEFAULT_PKG FOR AMD_OWNER.AMD_BASIC_DEFAULT_PKG;


DROP PUBLIC SYNONYM AMD_BATCH_PKG;

CREATE PUBLIC SYNONYM AMD_BATCH_PKG FOR AMD_OWNER.AMD_BATCH_PKG;


DROP PUBLIC SYNONYM AMD_BEST_SPARES_INPUT_PKG;

CREATE PUBLIC SYNONYM AMD_BEST_SPARES_INPUT_PKG FOR AMD_OWNER.AMD_BEST_SPARES_INPUT_PKG;


DROP PUBLIC SYNONYM AMD_CLEANED_FROM_BSSM_PKG;

CREATE PUBLIC SYNONYM AMD_CLEANED_FROM_BSSM_PKG FOR AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG;


DROP PUBLIC SYNONYM AMD_CLEAN_DATA;

CREATE PUBLIC SYNONYM AMD_CLEAN_DATA FOR AMD_OWNER.AMD_CLEAN_DATA;


DROP PUBLIC SYNONYM AMD_DEFAULTS;

CREATE PUBLIC SYNONYM AMD_DEFAULTS FOR AMD_OWNER.AMD_DEFAULTS;


DROP PUBLIC SYNONYM AMD_DEFAULT_EFFECTIVITY_PKG;

CREATE PUBLIC SYNONYM AMD_DEFAULT_EFFECTIVITY_PKG FOR AMD_OWNER.AMD_DEFAULT_EFFECTIVITY_PKG;


DROP PUBLIC SYNONYM AMD_DEMAND;

CREATE PUBLIC SYNONYM AMD_DEMAND FOR AMD_OWNER.AMD_DEMAND;


DROP PUBLIC SYNONYM AMD_EFFECTIVITY_PKG;

CREATE PUBLIC SYNONYM AMD_EFFECTIVITY_PKG FOR AMD_OWNER.AMD_EFFECTIVITY_PKG;


DROP PUBLIC SYNONYM AMD_EFFECTIVITY_TCTO_PKG;

CREATE PUBLIC SYNONYM AMD_EFFECTIVITY_TCTO_PKG FOR AMD_OWNER.AMD_EFFECTIVITY_TCTO_PKG;


DROP PUBLIC SYNONYM AMD_FROM_BSSM_PKG;

CREATE PUBLIC SYNONYM AMD_FROM_BSSM_PKG FOR AMD_OWNER.AMD_FROM_BSSM_PKG;


DROP PUBLIC SYNONYM AMD_INVENTORY;

CREATE PUBLIC SYNONYM AMD_INVENTORY FOR AMD_OWNER.AMD_INVENTORY;


DROP PUBLIC SYNONYM AMD_LOAD;

CREATE PUBLIC SYNONYM AMD_LOAD FOR AMD_OWNER.AMD_LOAD;


DROP PUBLIC SYNONYM AMD_LOCATION_PART_LEADTIME_PKG;

CREATE PUBLIC SYNONYM AMD_LOCATION_PART_LEADTIME_PKG FOR AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG;


DROP PUBLIC SYNONYM AMD_LOCATION_PART_OVERRIDE_PKG;

CREATE PUBLIC SYNONYM AMD_LOCATION_PART_OVERRIDE_PKG FOR AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG;


DROP PUBLIC SYNONYM AMD_LP_OVERRIDE_CONSUMABL_PKG;

CREATE PUBLIC SYNONYM AMD_LP_OVERRIDE_CONSUMABL_PKG FOR AMD_OWNER.AMD_LP_OVERRIDE_CONSUMABL_PKG;


DROP PUBLIC SYNONYM AMD_MAINT_TASK_DISTRIBS_PKG;

CREATE PUBLIC SYNONYM AMD_MAINT_TASK_DISTRIBS_PKG FOR AMD_OWNER.AMD_MAINT_TASK_DISTRIBS_PKG;


DROP PUBLIC SYNONYM AMD_NSL_SEQUENCE_PKG;

CREATE PUBLIC SYNONYM AMD_NSL_SEQUENCE_PKG FOR AMD_OWNER.AMD_NSL_SEQUENCE_PKG;


DROP PUBLIC SYNONYM AMD_ON_ORDER_DATE_FILTERS_PKG;

CREATE PUBLIC SYNONYM AMD_ON_ORDER_DATE_FILTERS_PKG FOR AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG;


DROP PUBLIC SYNONYM AMD_PARTPRIME_PKG;

CREATE PUBLIC SYNONYM AMD_PARTPRIME_PKG FOR AMD_OWNER.AMD_PARTPRIME_PKG;


DROP PUBLIC SYNONYM AMD_PART_FACTORS_PKG;

CREATE PUBLIC SYNONYM AMD_PART_FACTORS_PKG FOR AMD_OWNER.AMD_PART_FACTORS_PKG;


DROP PUBLIC SYNONYM AMD_PART_LOCS_LOAD_PKG;

CREATE PUBLIC SYNONYM AMD_PART_LOCS_LOAD_PKG FOR AMD_OWNER.AMD_PART_LOCS_LOAD_PKG;


DROP PUBLIC SYNONYM AMD_PART_LOC_FORECASTS_PKG;

CREATE PUBLIC SYNONYM AMD_PART_LOC_FORECASTS_PKG FOR AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG;


DROP PUBLIC SYNONYM AMD_PREFERRED_PKG;

CREATE PUBLIC SYNONYM AMD_PREFERRED_PKG FOR AMD_OWNER.AMD_PREFERRED_PKG;


DROP PUBLIC SYNONYM AMD_REQS_PKG;

CREATE PUBLIC SYNONYM AMD_REQS_PKG FOR AMD_OWNER.AMD_REQS_PKG;


DROP PUBLIC SYNONYM AMD_RMADS_SOURCE_TMP_PKG;

CREATE PUBLIC SYNONYM AMD_RMADS_SOURCE_TMP_PKG FOR AMD_OWNER.AMD_RMADS_SOURCE_TMP_PKG;


DROP PUBLIC SYNONYM AMD_SPARE_NETWORKS_PKG;

CREATE PUBLIC SYNONYM AMD_SPARE_NETWORKS_PKG FOR AMD_OWNER.AMD_SPARE_NETWORKS_PKG;


DROP PUBLIC SYNONYM AMD_SPARE_PARTS_PKG;

CREATE PUBLIC SYNONYM AMD_SPARE_PARTS_PKG FOR AMD_OWNER.AMD_SPARE_PARTS_PKG;


DROP PUBLIC SYNONYM AMD_TEST_DATA;

CREATE PUBLIC SYNONYM AMD_TEST_DATA FOR AMD_OWNER.AMD_TEST_DATA;


DROP PUBLIC SYNONYM AMD_TMAPI_PKG;

CREATE PUBLIC SYNONYM AMD_TMAPI_PKG FOR AMD_OWNER.AMD_TMAPI_PKG;


DROP PUBLIC SYNONYM AMD_UTILS;

CREATE PUBLIC SYNONYM AMD_UTILS FOR AMD_OWNER.AMD_UTILS;


DROP PUBLIC SYNONYM AMD_VALIDATION_PKG;

CREATE PUBLIC SYNONYM AMD_VALIDATION_PKG FOR AMD_OWNER.AMD_VALIDATION_PKG;


DROP PUBLIC SYNONYM AMD_WARNINGS_PKG;

CREATE PUBLIC SYNONYM AMD_WARNINGS_PKG FOR AMD_OWNER.AMD_WARNINGS_PKG;


DROP PUBLIC SYNONYM CONSUMABLES_PKG;

CREATE PUBLIC SYNONYM CONSUMABLES_PKG FOR AMD_OWNER.CONSUMABLES_PKG;


DROP PUBLIC SYNONYM EMAIL_HANDLER_PKG;

CREATE PUBLIC SYNONYM EMAIL_HANDLER_PKG FOR AMD_OWNER.EMAIL_HANDLER_PKG;


DROP PUBLIC SYNONYM REPAIRABLES_PKG;

CREATE PUBLIC SYNONYM REPAIRABLES_PKG FOR AMD_OWNER.REPAIRABLES_PKG;


DROP PUBLIC SYNONYM USER_PLANNER_PKG;

CREATE PUBLIC SYNONYM USER_PLANNER_PKG FOR AMD_OWNER.USER_PLANNER_PKG;


GRANT EXECUTE ON AMD_OWNER.AMD_BASIC_DEFAULT_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BATCH_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BEST_SPARES_INPUT_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_CLEAN_DATA TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEFAULT_EFFECTIVITY_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEMAND TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_EFFECTIVITY_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_EFFECTIVITY_TCTO_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_FROM_BSSM_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_INVENTORY TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOAD TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LP_OVERRIDE_CONSUMABL_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_MAINT_TASK_DISTRIBS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_NSL_SEQUENCE_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PARTPRIME_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_FACTORS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_LOCS_LOAD_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_REQS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_RMADS_SOURCE_TMP_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_NETWORKS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_PARTS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_TEST_DATA TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_TMAPI_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_VALIDATION_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_WARNINGS_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.CONSUMABLES_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.EMAIL_HANDLER_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.REPAIRABLES_PKG TO AMD_READER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BASIC_DEFAULT_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BATCH_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_BEST_SPARES_INPUT_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_CLEAN_DATA TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEFAULTS TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEFAULT_EFFECTIVITY_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_DEMAND TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_EFFECTIVITY_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_EFFECTIVITY_TCTO_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_FROM_BSSM_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_INVENTORY TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOAD TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOCATION_PART_LEADTIME_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LOCATION_PART_OVERRIDE_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_LP_OVERRIDE_CONSUMABL_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_MAINT_TASK_DISTRIBS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_NSL_SEQUENCE_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_ON_ORDER_DATE_FILTERS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PARTPRIME_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_FACTORS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_LOCS_LOAD_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PART_LOC_FORECASTS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_PREFERRED_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_REQS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_RMADS_SOURCE_TMP_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_NETWORKS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_PARTS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_TEST_DATA TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_TMAPI_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_UTILS TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_VALIDATION_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_WARNINGS_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.CONSUMABLES_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.EMAIL_HANDLER_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.REPAIRABLES_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.USER_PLANNER_PKG TO AMD_WRITER_ROLE;

GRANT EXECUTE ON AMD_OWNER.AMD_INVENTORY TO BSRM_LOADER;

GRANT EXECUTE ON AMD_OWNER.AMD_SPARE_NETWORKS_PKG TO BSRM_LOADER;

GRANT EXECUTE ON AMD_OWNER.USER_PLANNER_PKG TO BSRM_LOADER;

GRANT EXECUTE ON AMD_OWNER.AMD_CLEANED_FROM_BSSM_PKG TO BSSM_OWNER WITH GRANT OPTION;

GRANT EXECUTE ON AMD_OWNER.AMD_UTILS TO BSSM_OWNER WITH GRANT OPTION;
